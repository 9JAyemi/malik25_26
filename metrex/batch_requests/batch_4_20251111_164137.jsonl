{"custom_id": "edgedetect_e6de9563", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule edgedetect (\n    input iCLK      ,\n    input iRST      ,\n    input iSIG      ,\n    output wire oRE ,\n    output wire oFE ,\n    output wire oRFE\n);\n\nparameter registered = \"FALSE\";\n\nreg delay;\n\nwire re;\nwire fe;\nwire rfe;\n\n\nalways @(posedge iCLK)\nbegin\n    if (iRST)\n    begin\n        delay <= 1'b0;\n    end\n    else\n    begin\n        delay <= iSIG;\n    end\nend\n\n\nassign re   = (iSIG && !delay) ? 1'b1 : 1'b0;\nassign fe   = (!iSIG && delay) ? 1'b1 : 1'b0;\nassign rfe  = ((iSIG && !delay) || (!iSIG && delay)) ? 1'b1 : 1'b0;\n\n\nreg re_reg, fe_reg, rfe_reg;\nalways @(posedge iCLK)\nbegin\n    if (iRST)\n    begin\n        re_reg     <= 1'b0;\n        fe_reg     <= 1'b0;\n        rfe_reg    <= 1'b0;\n    end\n    else\n    begin\n        re_reg     <= re;\n        fe_reg     <= fe;\n        rfe_reg    <= rfe;\n    end\nend\n\n\nassign oRE =    (registered == \"TRUE\") ? re_reg  : re ;\nassign oFE =    (registered == \"TRUE\") ? fe_reg  : fe ;\nassign oRFE =   (registered == \"TRUE\") ? rfe_reg : rfe;\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_65c2467a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n    input [15:0] D,\n    input SH,\n    input LD,\n    input clk,\n    output reg [15:0] Q\n);\n\nreg [15:0] Q1, Q2;\n\nalways @ (posedge clk) begin\n    if (LD) begin\n        Q1 <= D;\n    end else begin\n        Q1 <= Q2;\n    end\nend\n\nalways @ (posedge clk) begin\n    if (SH) begin\n        Q2 <= {Q1[14:0], 1'b0};\n    end else begin\n        Q2 <= {1'b0, Q1[15:1]};\n    end\nend\n\nalways @* begin\n    Q = Q2;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_generator_511a26fa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule memory_generator\n  #(parameter MEM_DEPTH = 1024,\n            INIT_VECTOR = 256'h0000000000000000000000000000000000000000000000000000000000000000)\n  (\n    output reg [35:0] douta,\n    input wire clka,\n    input wire [9:0] addra,\n    input wire en,\n    input wire [35:0] data_in\n  );\n\n  reg [35:0] mem [0:MEM_DEPTH-1];\n\n  // Initialize memory with INIT_VECTOR\n  integer i;\n  initial begin\n    for (i=0; i<MEM_DEPTH; i=i+1) begin\n      mem[i] = INIT_VECTOR;\n    end\n  end\n\n  always @(posedge clka) begin\n    douta <= mem[addra];\n    if (en) begin\n      mem[addra] <= data_in;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cpu_ctl_64d64e03", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule cpu_ctl(\n    input wire [5:0] op, func,\n    input wire equal_result,\n    output wire JR, J, JAL, LW, WREG, WMEM, RDorRT, SE, SA, IorR, BJ,\n    output reg [4:0] Aluc\n);\n\n    wire r_type = ~op[5] & ~op[4] & ~op[3] & ~op[2] & ~op[1] & ~op[0];\n    wire i_jr = r_type & ~func[5] & ~func[4] & func[3] & ~func[2] & ~func[1] & ~func[0];\n    wire i_sll = r_type & ~func[5] & ~func[4] & ~func[3] & ~func[2] & ~func[1] & ~func[0];\n    wire i_srl = r_type & ~func[5] & ~func[4] & ~func[3] & ~func[2] & func[1] & ~func[0];\n    wire i_sra = r_type & ~func[5] & ~func[4] & ~func[3] & ~func[2] & func[1] & func[0];\n\n    wire i_addi, i_addiu, i_andi, i_ori, i_xori, i_lui, i_lw, i_sw, i_slti, i_sltiu;\n    wire b_type, i_beq, i_bne;\n    wire i_j, i_jal;\n\n    wire i_type = i_addi | i_addiu | i_andi | i_ori | i_xori | i_lui | i_lw | i_sw | i_slti | i_sltiu;\n\n    assign i_addi = ~op[5] & ~op[4] & op[3] & ~op[2] & ~op[1] & ~op[0];\n    assign i_addiu = ~op[5] & ~op[4] & op[3] & ~op[2] & ~op[1] & op[0];\n    assign i_andi = ~op[5] & ~op[4] & op[3] & op[2] & ~op[1] & ~op[0];\n    assign i_ori = ~op[5] & ~op[4] & op[3] & op[2] & ~op[1] & op[0];\n    assign i_xori = ~op[5] & ~op[4] & op[3] & op[2] & op[1] & ~op[0];\n    assign i_lui = ~op[5] & ~op[4] & op[3] & op[2] & op[1] & op[0];\n    assign i_lw = op[5] & ~op[4] & ~op[3] & ~op[2] & op[1] & op[0];\n    assign i_sw = op[5] & ~op[4] & op[3] & ~op[2] & op[1] & op[0];\n    assign i_slti = ~op[5] & ~op[4] & op[3] & ~op[2] & op[1] & ~op[0];\n    assign i_sltiu = ~op[5] & ~op[4] & op[3] & ~op[2] & op[1] & op[0];\n\n    assign b_type = i_beq | i_bne;\n    assign i_beq = ~op[5] & ~op[4] & ~op[3] & op[2] & ~op[1] & ~op[0];\n    assign i_bne = ~op[5] & ~op[4] & ~op[3] & op[2] & ~op[1] & op[0];\n\n    assign i_j = ~op[5] & ~op[4] & ~op[3] & ~op[2] & op[1] & ~op[0];\n    assign i_jal = ~op[5] & ~op[4] & ~op[3] & ~op[2] & op[1] & op[0];\n\n    assign JR = i_jr;\n    assign J = i_j;\n    assign JAL = i_jal;\n    assign LW = i_lw;\n    assign WREG = i_jal | (IorR & ~i_sw) | (r_type & ~i_jr);\n    assign WMEM = i_sw;\n    assign RDorRT = r_type & ~i_jr;\n    assign SE = i_addi | i_addiu | i_lw | i_sw | i_slti;\n    assign SA = i_sll | i_srl | i_sra;\n    assign IorR = i_type & ~b_type;\n    assign BJ = (i_beq & equal_result) | (i_bne & ~equal_result);\n\n    always @(*) begin\n        case ({op, func})\n            6'b000000: Aluc = func[3:0]; // R-Type\n            6'b001000: Aluc = 4'b0010; // ADDI\n            6'b001001: Aluc = 4'b0011; // ADDIU\n            6'b001100: Aluc = 4'b0000; // ANDI\n            6'b001101: Aluc = 4'b0101; // ORI\n            6'b001110: Aluc = 4'b0110; // XORI\n            6'b001010: Aluc = 4'b0111; // SLTI\n            6'b001011: Aluc = 4'b1000; // SLTIU\n            6'b100011: Aluc = 4'b0001; // LW\n            6'b101011: Aluc = 4'b0001; // SW\n            default: Aluc = 4'b0000; // Default to 0\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "carry_lookahead_gen_69932ac3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule carry_lookahead_gen \n    (\n        input   wire[3:0]   g,\n        input   wire[3:0]   p,\n        input   wire        cin,\n        output  wire[3:0]   cout\n        );\n\n    wire    and_out_1;\n    wire    and_out_2;\n    wire    and_out_3;\n    wire    and_out_4;\n    wire    and_out_5;\n    wire    and_out_6;\n    wire    or_out_1;\n    wire    or_out_2;\n    wire    or_out_3;\n    assign  cout = {or_out_3, or_out_2, or_out_1, cin};\n    and     A1 (and_out_1, p[0], cin);\n    or      O1 (or_out_1, g[0], and_out_1);\n\n    and     A2 (and_out_2, p[1], g[0]);\n    and     A3 (and_out_3, p[1], p[0], cin);\n    or      O2 (or_out_2, g[1], and_out_3, and_out_2);\n\n    and     A4 (and_out_4, p[2], g[1]);\n    and     A5 (and_out_5, p[2], p[1], g[0]);\n    and     A6 (and_out_6, p[2], p[1], p[0], cin);\n    or      O3 (or_out_3, g[2], and_out_6, and_out_5, and_out_4);\n\n    endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dmac_2d_transfer_4d146544", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dmac_2d_transfer (\n\tinput req_aclk,\n\tinput req_aresetn,\n\n\tinput req_valid,\n\toutput reg req_ready,\n\n\tinput [31:C_BYTES_PER_BEAT_WIDTH_DEST] req_dest_address,\n\tinput [31:C_BYTES_PER_BEAT_WIDTH_SRC] req_src_address,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_x_length,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_y_length,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_dest_stride,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_src_stride,\n\tinput req_sync_transfer_start,\n\toutput reg req_eot,\n\t\n\toutput reg out_req_valid,\n\tinput out_req_ready,\n\toutput [31:C_BYTES_PER_BEAT_WIDTH_DEST] out_req_dest_address,\n\toutput [31:C_BYTES_PER_BEAT_WIDTH_SRC] out_req_src_address,\n\toutput [C_DMA_LENGTH_WIDTH-1:0] out_req_length,\n\toutput reg out_req_sync_transfer_start,\n\tinput out_eot\n);\n\nparameter C_DMA_LENGTH_WIDTH = 24;\nparameter C_BYTES_PER_BEAT_WIDTH_SRC = 3;\nparameter C_BYTES_PER_BEAT_WIDTH_DEST = 3;\n\nreg [31:C_BYTES_PER_BEAT_WIDTH_DEST] dest_address;\nreg [31:C_BYTES_PER_BEAT_WIDTH_SRC] src_address;\nreg [C_DMA_LENGTH_WIDTH-1:0] x_length;\nreg [C_DMA_LENGTH_WIDTH-1:0] y_length;\nreg [C_DMA_LENGTH_WIDTH-1:0] dest_stride;\nreg [C_DMA_LENGTH_WIDTH-1:0] src_stride;\n\nreg [1:0] req_id;\nreg [1:0] eot_id;\nreg [3:0] last_req;\n\nassign out_req_dest_address = dest_address;\nassign out_req_src_address = src_address;\nassign out_req_length = x_length;\n\nalways @(posedge req_aclk)\nbegin\n\tif (req_aresetn == 1'b0) begin\n\t\treq_id <= 2'b0;\n\t\teot_id <= 2'b0;\n\t\treq_eot <= 1'b0;\n\tend else begin\n\t\tif (out_req_valid && out_req_ready) begin\n\t\t\treq_id <= req_id + 1'b1;\n\t\t\tlast_req[req_id] <= y_length == 0;\n\t\tend\n\t\treq_eot <= 1'b0;\n\t\tif (out_eot) begin\n\t\t\teot_id <= eot_id + 1'b1;\n\t\t\treq_eot <= last_req[eot_id];\n\t\tend\n\tend\nend\n\nalways @(posedge req_aclk)\nbegin\n\tif (req_aresetn == 1'b0) begin\n\t\tdest_address <= 'h00;\n\t\tsrc_address <= 'h00;\n\t\tx_length <= 'h00;\n\t\ty_length <= 'h00;\n\t\tdest_stride <= 'h00;\n\t\tsrc_stride <= 'h00;\n\t\treq_ready <= 1'b1;\n\t\tout_req_valid <= 1'b0;\n\t\tout_req_sync_transfer_start <= 1'b0;\n\tend else begin\n\t\tif (req_ready) begin\n\t\t\tif (req_valid) begin\n\t\t\t\tdest_address <= req_dest_address;\n\t\t\t\tsrc_address <= req_src_address;\n\t\t\t\tx_length <= req_x_length;\n\t\t\t\ty_length <= req_y_length;\n\t\t\t\tdest_stride <= req_dest_stride;\n\t\t\t\tsrc_stride <= req_src_stride;\n\t\t\t\tout_req_sync_transfer_start <= req_sync_transfer_start;\n\t\t\t\treq_ready <= 1'b0;\n\t\t\t\tout_req_valid <= 1'b1;\n\t\t\tend\n\t\tend else begin\n\t\t\tif (out_req_valid && out_req_ready) begin\n\t\t\t\tdest_address <= dest_address + dest_stride[C_DMA_LENGTH_WIDTH-1:C_BYTES_PER_BEAT_WIDTH_DEST];\n\t\t\t\tsrc_address <= src_address + src_stride[C_DMA_LENGTH_WIDTH-1:C_BYTES_PER_BEAT_WIDTH_SRC];\n\t\t\t\ty_length <= y_length - 1'b1;\n\t\t\t\tout_req_sync_transfer_start <= 1'b0;\n\t\t\t\tif (y_length == 0) begin\n\t\t\t\t\tout_req_valid <= 1'b0;\n\t\t\t\t\treq_ready <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_8f4be089", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder(\n    input signed [3:0] a,\n    input signed [3:0] b,\n    input signed cin,\n    output signed [3:0] sum,\n    output signed cout\n);\n\nwire signed [4:0] temp_sum;\nwire signed temp_cout;\n\nassign temp_sum = a + b + cin;\nassign sum = temp_sum[3:0];\nassign temp_cout = (temp_sum[4] == 1) ? 1 : 0;\nassign cout = temp_cout;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "snoop_module_e662fdb6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule snoop_module(\n    input clk,\n    input reset,\n    input [7:0] snoopa,\n    input [7:0] snoopd,\n    input snoopp,\n    output reg snoopq,\n    output snoopm\n);\n\nreg [7:0] prgram [0:255];\n\ninteger i;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        snoopq <= 0;\n        i <= 0;\n    end else begin\n        snoopq <= prgram[snoopa];\n        if (snoopp) begin\n            prgram[snoopa] <= snoopd;\n        end\n        if (i == 255) begin\n            i <= 0;\n        end else begin\n            i <= i + 1;\n        end\n    end\nend\n\nassign snoopm = (i == 255);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_reg_463d2a93", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_reg (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= {q[6:0], d};\nend\n\nendmodule\n\nmodule d_ff (\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(negedge clk) begin\n    q <= d;\nend\n\nendmodule\n\nmodule concat_module (\n    input [7:0] shift_reg_out,\n    input [0:0] d_ff_out,\n    output [15:0] q\n);\n\nassign q = {shift_reg_out, d_ff_out};\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [15:0] q\n);\n\nwire [7:0] shift_reg_out;\nwire [0:0] d_ff_out;\n\nshift_reg shift_reg_inst (\n    .clk(clk),\n    .d(d),\n    .q(shift_reg_out)\n);\n\nd_ff d_ff_inst (\n    .clk(clk),\n    .d(shift_reg_out[7]),\n    .q(d_ff_out)\n);\n\nconcat_module concat_inst (\n    .shift_reg_out(shift_reg_out),\n    .d_ff_out(d_ff_out),\n    .q(q)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "traffic_light_7f1fdd70", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule traffic_light(\n    input clk,\n    input reset,\n    input car_sensor_road1_lane1,\n    input car_sensor_road1_lane2,\n    input car_sensor_road2_lane1,\n    input car_sensor_road2_lane2,\n    input pedestrian_sensor,\n    output reg [3:0] traffic_light_road1,\n    output reg [3:0] traffic_light_road2,\n    output reg pedestrian_light\n);\n\nparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\nparameter GREEN_TIME = 5, PEDESTRIAN_TIME = 10, YELLOW_TIME = 2;\n\nreg [1:0] state;\nreg [3:0] timer;\nreg [1:0] current_road1_lane;\nreg [1:0] current_road2_lane;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= S0;\n        timer <= 0;\n        current_road1_lane <= 2'b00;\n        current_road2_lane <= 2'b00;\n        traffic_light_road1 <= 4'b0100;\n        traffic_light_road2 <= 4'b0100;\n        pedestrian_light <= 1'b0;\n    end else begin\n        case (state)\n            S0: begin\n                if (timer == 0) begin\n                    if (pedestrian_sensor) begin\n                        state <= S1;\n                        timer <= PEDESTRIAN_TIME;\n                        pedestrian_light <= 1'b1;\n                        traffic_light_road1 <= {2'b10, 2'b01};\n                        traffic_light_road2 <= {2'b00, 2'b10};\n                    end else if (car_sensor_road1_lane1 || car_sensor_road1_lane2) begin\n                        state <= S1;\n                        timer <= GREEN_TIME;\n                        current_road1_lane <= 2'b01;\n                        traffic_light_road1 <= {2'b10, 2'b01};\n                        traffic_light_road2 <= {2'b00, 2'b10};\n                    end else if (car_sensor_road2_lane1 || car_sensor_road2_lane2) begin\n                        state <= S2;\n                        timer <= YELLOW_TIME;\n                        traffic_light_road1 <= {2'b10, 2'b00};\n                        traffic_light_road2 <= {2'b01, 2'b00};\n                    end\n                end else begin\n                    timer <= timer - 1;\n                end\n            end\n            S1: begin\n                if (timer == 0) begin\n                    state <= S2;\n                    timer <= YELLOW_TIME;\n                    traffic_light_road1 <= {2'b10, 2'b00};\n                    traffic_light_road2 <= {2'b01, 2'b00};\n                end else begin\n                    timer <= timer - 1;\n                end\n            end\n            S2: begin\n                if (timer == 0) begin\n                    if (pedestrian_sensor) begin\n                        state <= S3;\n                        timer <= PEDESTRIAN_TIME;\n                        pedestrian_light <= 1'b1;\n                        traffic_light_road1 <= {2'b00, 2'b10};\n                        traffic_light_road2 <= {2'b10, 2'b01};\n                    end else if (car_sensor_road2_lane1 || car_sensor_road2_lane2) begin\n                        state <= S3;\n                        timer <= GREEN_TIME;\n                        current_road2_lane <= 2'b01;\n                        traffic_light_road1 <= {2'b00, 2'b10};\n                        traffic_light_road2 <= {2'b10, 2'b01};\n                    end else if (car_sensor_road1_lane1 || car_sensor_road1_lane2) begin\n                        state <= S1;\n                        timer <= YELLOW_TIME;\n                        traffic_light_road1 <= {2'b10, 2'b01};\n                        traffic_light_road2 <= {2'b00, 2'b10};\n                    end\n                end else begin\n                    timer <= timer - 1;\n                end\n            end\n            S3: begin\n                if (timer == 0) begin\n                    state <= S0;\n                    timer <= YELLOW_TIME;\n                    traffic_light_road1 <= {2'b01, 2'b00};\n                    traffic_light_road2 <= {2'b01, 2'b00};\n                    pedestrian_light <= 1'b0;\n                end else begin\n                    timer <= timer - 1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_reg_mux_adder_88aaf3f0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_reg_mux_adder (\n    input         clk,\n    input         d,\n    input  [255:0] in,\n    input   [7:0] sel,\n    output reg out\n);\n\n    reg [2:0] shift_reg;\n    reg [7:0] shifted_in;\n    wire [7:0] mux_out;\n    wire       reg_out;\n    \n    // Shift register\n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[1:0], d};\n    end\n    \n    // Barrel shifter\n    always @(*) begin\n        case (sel)\n            8'h00: shifted_in = in[7:0];\n            8'h01: shifted_in = in[15:8];\n            8'h02: shifted_in = in[23:16];\n            8'h03: shifted_in = in[31:24];\n            8'h04: shifted_in = in[39:32];\n            8'h05: shifted_in = in[47:40];\n            8'h06: shifted_in = in[55:48];\n            8'h07: shifted_in = in[63:56];\n            8'h08: shifted_in = in[71:64];\n            8'h09: shifted_in = in[79:72];\n            8'h0A: shifted_in = in[87:80];\n            8'h0B: shifted_in = in[95:88];\n            8'h0C: shifted_in = in[103:96];\n            8'h0D: shifted_in = in[111:104];\n            8'h0E: shifted_in = in[119:112];\n            8'h0F: shifted_in = in[127:120];\n            8'h10: shifted_in = in[135:128];\n            8'h11: shifted_in = in[143:136];\n            8'h12: shifted_in = in[151:144];\n            8'h13: shifted_in = in[159:152];\n            8'h14: shifted_in = in[167:160];\n            8'h15: shifted_in = in[175:168];\n            8'h16: shifted_in = in[183:176];\n            8'h17: shifted_in = in[191:184];\n            8'h18: shifted_in = in[199:192];\n            8'h19: shifted_in = in[207:200];\n            8'h1A: shifted_in = in[215:208];\n            8'h1B: shifted_in = in[223:216];\n            8'h1C: shifted_in = in[231:224];\n            8'h1D: shifted_in = in[239:232];\n            8'h1E: shifted_in = in[247:240];\n            8'h1F: shifted_in = in[255:248];\n            default: shifted_in = 8'h00;\n        endcase\n    end\n    \n    // Multiplexer\n    assign mux_out = shifted_in;\n    \n    // 4-to-1 multiplexer\n    assign reg_out = mux_out[shift_reg[2:0]];\n    \n    // Adder\n    always @(*) begin\n        out = reg_out + shift_reg[2];\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Control_Register_Block #_8ce8468d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Control_Register_Block #(\n  parameter n = 4, // number of control signals\n  parameter m = 2 // number of enable signals\n\n) (\n  input [n-1:0] ctrl,\n  output [m-1:0] en\n);\n\n\n// Define subsets of control signals for each enable signal\nparameter [n-1:0] en1_ctrls = 4'b0001;\nparameter [n-1:0] en2_ctrls = 4'b0011;\n\n// Implement the functionality of the control register block\nassign en[0] = (ctrl & en1_ctrls) == en1_ctrls;\nassign en[1] = (ctrl & en2_ctrls) == en2_ctrls;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pg_5_fbb5890b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pg_5 ( g, p, g_prec, p_prec, g_out, p_out );\n  input g, p, g_prec, p_prec;\n  output g_out, p_out;\n  wire   n5, n6;\n\n  and U1 (p_out, p, p_prec);\n  not U2 (n6, g);\n  nand U3 (n5, p, g_prec);\n  nand U4 (g_out, n5, n6);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_82273001", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module( \n    input wire [15:0] in,\n    output wire [3:0] in1_hi, in1_lo,\n    output wire [3:0] in2_hi, in2_lo,\n    output wire [7:0] out );\n\n  wire [7:0] in1, in2;\n\n  // Split the 16-bit input into two 8-bit outputs\n  assign in1 = in[15:8];\n  assign in2 = in[7:0];\n\n  // Split each 8-bit input into two 4-bit inputs\n  assign in1_hi = in1[7:4];\n  assign in1_lo = in1[3:0];\n  assign in2_hi = in2[7:4];\n  assign in2_lo = in2[3:0];\n\n  // Compute the absolute difference between each pair of corresponding 4-bit inputs\n  wire [3:0] abs_diff_hi, abs_diff_lo;\n  assign abs_diff_hi = (in1_hi >= in2_hi) ? (in1_hi - in2_hi) : (in2_hi - in1_hi);\n  assign abs_diff_lo = (in1_lo >= in2_lo) ? (in1_lo - in2_lo) : (in2_lo - in1_lo);\n\n  // Output the sum of the absolute differences\n  assign out = abs_diff_hi + abs_diff_lo;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bridge_db1898f5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bridge (\n    input [7:0] RGA,\n    input [0:0] RGB,\n    input [7:0] OPT,\n    input [1:0] KEY,\n    input CLK,\n    input RST,\n    input ENA,\n    output reg [7:0] RGZ\n);\n\nreg [7:0] shift_reg;\nreg [7:0] not_reg;\nreg [7:0] zero_reg;\n\nalways @ (posedge CLK or negedge RST)\nbegin\n    if (!RST)\n    begin\n        shift_reg <= 8'b0;\n        not_reg <= 8'b0;\n        zero_reg <= 8'b0;\n    end\n    else if (ENA)\n    begin\n        case ({OPT, KEY})\n            8'b00000010: shift_reg <= {RGA[6:0], 1'b0};\n            8'b00000000: shift_reg <= {1'b0, RGA[7:1]};\n            8'b00000011: shift_reg <= {RGA[5:0], 2'b00};\n            8'b00000001: shift_reg <= {2'b00, RGA[7:2]};\n            8'b00000100: not_reg <= ~RGA;\n            8'b00000010: zero_reg <= 8'b0;\n            default: shift_reg <= RGA;\n        endcase\n    end\nend\n\nalways @*\nbegin\n    RGZ = RGB ? not_reg : (KEY == 2'b10 ? zero_reg : shift_reg);\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gating_b86631d2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_gating (\n  input CLK,\n  input EN,\n  input TE,\n  output reg ENCLK\n);\n\n  always @ (posedge CLK) begin\n    if (TE) begin\n      ENCLK <= CLK;\n    end else if (EN) begin\n      ENCLK <= CLK;\n    end else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_61d42292", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module(\n    input [254:0] in, // 255-bit input vector for population count circuit\n    input [31:0] in_swap, // 32-bit input vector for byte swapping module\n    output [7:0] count_out, // 8-bit output from population count circuit\n    output [31:0] swap_out, // 32-bit output from byte swapping module\n    output [7:0] sum_out, // 8-bit output from functional module\n    input clk // Clock signal\n);\n\n// Population count circuit\nreg [7:0] count_reg;\nreg [254:0] shift_reg;\nreg [7:0] adder_out;\n\nalways @(posedge clk) begin\n    shift_reg = {shift_reg[253:0], in};\n    adder_out = adder_out + shift_reg[254]; // \n    count_reg = adder_out;\nend\n\nassign count_out = count_reg;\n\n// Byte swapping module\nreg [7:0] swap_reg [3:0];\nreg [31:0] swap_out_reg;\n\nalways @(posedge clk) begin\n    swap_reg[0] = in_swap[31:24];\n    swap_reg[1] = in_swap[23:16];\n    swap_reg[2] = in_swap[15:8];\n    swap_reg[3] = in_swap[7:0];\n    swap_out_reg = {swap_reg[3], swap_reg[2], swap_reg[1], swap_reg[0]};\nend\n\nassign swap_out = swap_out_reg;\n\n// Functional module\nreg [7:0] sum_reg;\n\nalways @(posedge clk) begin\n    sum_reg = count_out + swap_out[31];\nend\n\nassign sum_out = sum_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Voter #_c80ef766", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Voter #(parameter WIDTH = 1)(\n    input  [(WIDTH-1):0] A, B, C,\n    output [(WIDTH-1):0] True\n    );\n\ngenvar i;\n\ngenerate\t\n\tfor (i = 0; i < WIDTH; i = i +1) begin : Vote_Bit\nassign True[i] =  (A[i] && B[i]) || (A[i] && C[i]) || (B[i] && C[i]);\nend\nendgenerate\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_b19a5e1f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter(\n  input clk,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else begin\n      if (count == 4'b1111) begin\n        count <= 4'b0000;\n      end else begin\n        count <= count + 4'b0001;\n      end\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__21e57853", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [3:0] a, b, // Two 4-bit inputs\n    input select,     // Select input to choose between adder and subtractor outputs\n    output [3:0] out  // 4-bit output from the selected module\n);\n\n    // Declare internal wires\n    wire [3:0] add_out_int, sub_out_int;\n\n    // Instantiate the adder and subtractor modules\n    four_bit_adder adder(.a(a), .b(b), .sum(add_out_int));\n    four_bit_subtractor subtractor(.a(a), .b(b), .diff(sub_out_int));\n\n    // Declare a flip-flop for the reset signal\n    reg reset_ff;\n\n    // Synchronous active-high reset\n    always @(posedge clk) begin\n        if (reset) begin\n            reset_ff <= 1;\n        end else begin\n            reset_ff <= 0;\n        end\n    end\n\n    // Instantiate the select module\n    select_module select_inst(.add_out(add_out_int), .sub_out(sub_out_int), .select(select), .out(out));\n\nendmodule\n\nmodule four_bit_adder (\n    input [3:0] a, b, // Two 4-bit inputs\n    output [3:0] sum  // 4-bit output from the adder\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule four_bit_subtractor (\n    input [3:0] a, b, // Two 4-bit inputs\n    output [3:0] diff // 4-bit output from the subtractor\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule select_module (\n    input [3:0] add_out, sub_out, // Outputs from the adder and subtractor modules\n    input select,                 // Select input to choose between adder and subtractor outputs\n    output [3:0] out              // Final output from the selected module\n);\n\n    assign out = select ? add_out : sub_out;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_rx_recv #_2b248ce5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule pcie_rx_recv # (\n\tparameter\tC_PCIE_DATA_WIDTH\t\t\t= 128\n)\n(\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_clk,\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_rst_n,\n\ninput\t[C_PCIE_DATA_WIDTH-1:0]\t\t\ts_axis_rx_tdata,\n\tinput\t[(C_PCIE_DATA_WIDTH/8)-1:0]\t\ts_axis_rx_tkeep,\n\tinput\t\t\t\t\t\t\t\t\ts_axis_rx_tlast,\n\tinput\t\t\t\t\t\t\t\t\ts_axis_rx_tvalid,\n\toutput\t\t\t\t\t\t\t\t\ts_axis_rx_tready,\n\tinput\t[21:0]\t\t\t\t\t\t\ts_axis_rx_tuser,\n\n\toutput\t\t\t\t\t\t\t\t\tpcie_mreq_err,\n\toutput\t\t\t\t\t\t\t\t\tpcie_cpld_err,\n\toutput\t\t\t\t\t\t\t\t\tpcie_cpld_len_err,\n\n\toutput\t\t\t\t\t\t\t\t\tmreq_fifo_wr_en,\n\toutput\t[C_PCIE_DATA_WIDTH-1:0]\t\t\tmreq_fifo_wr_data,\n\n\toutput\t[7:0]\t\t\t\t\t\t\tcpld_fifo_tag,\n\toutput\t[C_PCIE_DATA_WIDTH-1:0]\t\t\tcpld_fifo_wr_data,\n\toutput\t\t\t\t\t\t\t\t\tcpld_fifo_wr_en,\n\toutput\t\t\t\t\t\t\t\t\tcpld_fifo_tag_last\n);\n\n\nlocalparam\tS_RX_IDLE_SOF\t\t\t\t\t= 4'b0001;\nlocalparam\tS_RX_DATA\t\t\t\t\t\t= 4'b0010;\nlocalparam\tS_RX_STRADDLED\t\t\t\t\t= 4'b0100;\nlocalparam\tS_RX_STRADDLED_HOLD\t\t\t\t= 4'b1000;\n\nreg\t\t[3:0]\t\t\t\t\t\t\t\tcur_state;\nreg\t\t[3:0]\t\t\t\t\t\t\t\tnext_state;\n\n\nwire\t[4:0]\t\t\t\t\t\t\t\tw_rx_is_sof;\nwire\t[4:0]\t\t\t\t\t\t\t\tw_rx_is_eof;\n\nreg\t\t[31:0]\t\t\t\t\t\t\t\tr_pcie_head0;\nreg\t\t[31:0]\t\t\t\t\t\t\t\tr_pcie_head1;\nreg\t\t[31:0]\t\t\t\t\t\t\t\tr_pcie_head2;\n\nwire\t[2:0]\t\t\t\t\t\t\t\tw_mreq_head_fmt;\nwire\t[4:0]\t\t\t\t\t\t\t\tw_mreq_head_type;\nwire\t\t\t\t\t\t\t\t\t\tw_mreq_head_ep;\nwire\t[2:0]\t\t\t\t\t\t\t\tw_cpld_head_fmt;\nwire\t[4:0]\t\t\t\t\t\t\t\tw_cpld_head_type;\nwire\t\t\t\t\t\t\t\t\t\tw_cpld_head_ep;\nwire\t[9:0]\t\t\t\t\t\t\t\tw_cpld_head_len;\nwire\t[2:0]\t\t\t\t\t\t\t\tw_cpld_head_cs;\nwire\t[11:0]\t\t\t\t\t\t\t\tw_cpld_head_bc;\nwire\t[7:0]\t\t\t\t\t\t\t\tw_cpld_head_tag;\nwire\t\t\t\t\t\t\t\t\t\tw_pcie_mreq_type;\nwire\t\t\t\t\t\t\t\t\t\tw_pcie_cpld_type;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_mreq_type;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_cpld_type;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_mreq_err;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_cpld_err;\nreg\t\t\t\t\t\t\t\t\t\t\tr_pcie_cpld_len_err;\n\nreg\t\t[7:0]\t\t\t\t\t\t\t\tr_cpld_tag;\nreg\t\t[11:2]\t\t\t\t\t\t\t\tr_cpld_len;\nreg\t\t[11:2]\t\t\t\t\t\t\t\tr_cpld_bc;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_lhead;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_mem_req_en;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_data_en;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_tag_last;\nreg\t\t\t\t\t\t\t\t\t\t\tr_rx_straddled;\nreg\t\t\t\t\t\t\t\t\t\t\tr_rx_straddled_hold;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_rx_data_straddled;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_s_axis_rx_tdata;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_s_axis_rx_tdata_d1;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_mreq_fifo_wr_en;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_mreq_fifo_wr_data;\n\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_fifo_tag_en;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_fifo_wr_en;\nreg\t\t[127:0]\t\t\t\t\t\t\t\tr_cpld_fifo_wr_data;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cpld_fifo_tag_last;\n\nassign s_axis_rx_tready = ~r_rx_straddled_hold;\n\nassign pcie_mreq_err = r_pcie_mreq_err;\nassign pcie_cpld_err = r_pcie_cpld_err;\nassign pcie_cpld_len_err = r_pcie_cpld_len_err;\n\nassign mreq_fifo_wr_en = r_mreq_fifo_wr_en;\nassign mreq_fifo_wr_data = r_mreq_fifo_wr_data;\n\nassign cpld_fifo_tag = r_cpld_tag;\nassign cpld_fifo_wr_en = r_cpld_fifo_wr_en;\n\nassign cpld_fifo_wr_data[31:0] = {r_cpld_fifo_wr_data[7:0], r_cpld_fifo_wr_data[15:8], r_cpld_fifo_wr_data[23:16], r_cpld_fifo_wr_data[31:24]};\nassign cpld_fifo_wr_data[63:32] = {r_cpld_fifo_wr_data[39:32], r_cpld_fifo_wr_data[47:40], r_cpld_fifo_wr_data[55:48], r_cpld_fifo_wr_data[63:56]};\nassign cpld_fifo_wr_data[95:64] = {r_cpld_fifo_wr_data[71:64], r_cpld_fifo_wr_data[79:72], r_cpld_fifo_wr_data[87:80], r_cpld_fifo_wr_data[95:88]};\nassign cpld_fifo_wr_data[127:96] = {r_cpld_fifo_wr_data[103:96], r_cpld_fifo_wr_data[111:104], r_cpld_fifo_wr_data[119:112], r_cpld_fifo_wr_data[127:120]};\n\nassign cpld_fifo_tag_last = r_cpld_fifo_tag_last;\n\n\nassign w_rx_is_sof = s_axis_rx_tuser[14:10];\nassign w_rx_is_eof = s_axis_rx_tuser[21:17];\n\nalways @ (*)\nbegin\n\tif(w_rx_is_sof[3] == 1) begin\n\t\tr_pcie_head0 <= s_axis_rx_tdata[95:64];\n\t\tr_pcie_head1 <= s_axis_rx_tdata[127:96];\n\tend\n\telse begin\n\t\tr_pcie_head0 <= s_axis_rx_tdata[31:0];\n\t\tr_pcie_head1 <= s_axis_rx_tdata[63:32];\n\tend\n\n\tif(r_rx_straddled == 1)\n\t\tr_pcie_head2 <= s_axis_rx_tdata[31:0];\n\telse\n\t\tr_pcie_head2 <= s_axis_rx_tdata[95:64];\nend\n\n\n\nassign w_mreq_head_fmt = r_pcie_head0[31:29];\nassign w_mreq_head_type = r_pcie_head0[28:24];\nassign w_mreq_head_ep = r_pcie_head0[14];\nassign w_cpld_head_fmt = r_pcie_head0[31:29];\nassign w_cpld_head_type = r_pcie_head0[28:24];\nassign w_cpld_head_ep = r_pcie_head0[14];\nassign w_cpld_head_len = r_pcie_head0[9:0];\nassign w_cpld_head_cs = r_pcie_head1[15:13];\nassign w_cpld_head_bc = r_pcie_head1[11:0];\nassign w_cpld_head_tag = r_pcie_head2[15:8];\nassign w_pcie_mreq_type = ({w_mreq_head_fmt[2], w_mreq_head_type} == {1'b0, 5'b00000});\nassign w_pcie_cpld_type = ({w_cpld_head_fmt, w_cpld_head_type} == {3'b010, 5'b01010});\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0)\n\t\tcur_state <= S_RX_IDLE_SOF;\n\telse\n\t\tcur_state <= next_state;\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_RX_IDLE_SOF: begin\n\t\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_sof[4] == 1 && w_rx_is_eof[4] == 0 ) begin\n\t\t\t\tif(w_rx_is_sof[3] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= S_RX_DATA;\n\t\t\tend\n\t\t\telse\n\t\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\tend\n\t\tS_RX_DATA: begin\n\t\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_eof[4] == 1) begin\n\t\t\t\tif(w_rx_is_sof[4] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\t\tend\n\t\t\telse\n\t\t\t\tnext_state <= S_RX_DATA;\n\t\tend\n\t\tS_RX_STRADDLED: begin\n\t\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_eof[4] == 1) begin\n\t\t\t\tif(w_rx_is_sof[4] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\t\t\telse if(w_rx_is_eof[3] == 1)\n\t\t\t\t\tnext_state <= S_RX_STRADDLED_HOLD;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\t\tend\n\t\t\telse\n\t\t\t\tnext_state <= S_RX_STRADDLED;\n\t\tend\n\t\tS_RX_STRADDLED_HOLD: begin\n\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state <= S_RX_IDLE_SOF;\n\t\tend\n\tendcase\nend\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tif(s_axis_rx_tvalid == 1 && w_rx_is_sof[4] == 1) begin\n\t\tr_pcie_mreq_type <= w_pcie_mreq_type & ~w_mreq_head_ep;\n\t\tr_pcie_cpld_type <= w_pcie_cpld_type & ~w_cpld_head_ep & (w_cpld_head_cs == 0);\n\n\t\tr_cpld_len <= w_cpld_head_len;\n\t\tr_cpld_bc[11:2] <= w_cpld_head_bc[11:2];\n\tend\nend\n\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0) begin\n\t\tr_pcie_mreq_err <= 0;\n\t\tr_pcie_cpld_err <= 0;\n\t\tr_pcie_cpld_len_err <= 0;\n\tend\n\telse begin\n\t\tif(r_pcie_cpld_type == 1 && r_cpld_len < 2) begin\n\t\t\tr_pcie_cpld_len_err <= 1;\n\t\tend\n\n\t\tif(s_axis_rx_tvalid == 1 && w_rx_is_sof[4] == 1) begin\n\t\t\tr_pcie_mreq_err <= w_pcie_mreq_type & w_mreq_head_ep;\n\t\t\tr_pcie_cpld_err <= w_pcie_cpld_type & (w_cpld_head_ep | (w_cpld_head_cs != 0));\n\t\tend\n\tend\nend\n\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tcase(cur_state)\n\t\tS_RX_IDLE_SOF: begin\n\t\t\tr_cpld_tag <= w_cpld_head_tag;\n\t\t\tr_cpld_lhead <= 0;\n\t\tend\n\t\tS_RX_DATA: begin\n\n\t\tend\n\t\tS_RX_STRADDLED: begin\n\t\t\tif(s_axis_rx_tvalid == 1)\n\t\t\t\tr_cpld_lhead <= ~w_rx_is_sof[4];\n\n\t\t\tif(r_cpld_lhead == 0)\n\t\t\t\tr_cpld_tag <= w_cpld_head_tag;\n\t\tend\n\t\tS_RX_STRADDLED_HOLD: begin\n\n\t\tend\n\t\tdefault: begin\n\n\t\tend\n\tendcase\nend\n\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_RX_IDLE_SOF: begin\n\t\t\tr_mem_req_en <= (s_axis_rx_tvalid & w_rx_is_sof[4] & ~w_rx_is_sof[3]) & w_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= 0;\n\t\t\tr_cpld_tag_last <= 0;\n\t\t\tr_rx_straddled <= 0;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\t\tS_RX_DATA: begin\n\t\t\tr_mem_req_en <= s_axis_rx_tvalid & r_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= s_axis_rx_tvalid & r_pcie_cpld_type;\n\t\t\tr_cpld_tag_last <= (r_cpld_len == r_cpld_bc[11:2]) & (s_axis_rx_tvalid & r_pcie_cpld_type & w_rx_is_eof[4]);\n\t\t\tr_rx_straddled <= 0;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\t\tS_RX_STRADDLED: begin\n\t\t\tr_mem_req_en <= s_axis_rx_tvalid & r_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= s_axis_rx_tvalid & r_pcie_cpld_type & r_cpld_lhead;\n\t\t\tr_cpld_tag_last <= (r_cpld_len == r_cpld_bc[11:2]) & (s_axis_rx_tvalid & r_pcie_cpld_type & w_rx_is_eof[4] & ~w_rx_is_eof[3]);\n\t\t\tr_rx_straddled <= 1;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\t\tS_RX_STRADDLED_HOLD: begin\n\t\t\tr_mem_req_en <= r_pcie_mreq_type;\n\t\t\tr_cpld_data_en <= r_pcie_cpld_type;\n\t\t\tr_cpld_tag_last <= (r_cpld_len == r_cpld_bc[11:2]) & r_pcie_cpld_type;\n\t\t\tr_rx_straddled <= 1;\n\t\t\tr_rx_straddled_hold <= 1;\n\t\tend\n\t\tdefault: begin\n\t\t\tr_mem_req_en <= 0;\n\t\t\tr_cpld_data_en <= 0;\n\t\t\tr_cpld_tag_last <= 0;\n\t\t\tr_rx_straddled <= 0;\n\t\t\tr_rx_straddled_hold <= 0;\n\t\tend\n\tendcase\nend\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tr_mreq_fifo_wr_en <= r_mem_req_en;\n\tr_cpld_fifo_wr_en <= r_cpld_data_en;\n\tr_cpld_fifo_tag_last <= r_cpld_tag_last;\n\tr_rx_data_straddled <= r_rx_straddled;\n\n\tif(s_axis_rx_tvalid == 1 || r_rx_straddled_hold == 1) begin\n\t\tr_s_axis_rx_tdata <= s_axis_rx_tdata;\n\t\tr_s_axis_rx_tdata_d1 <= r_s_axis_rx_tdata;\n\tend\nend\n\nalways @ (*)\nbegin\n\tif(r_rx_data_straddled == 1)\n\t\tr_mreq_fifo_wr_data <= {r_s_axis_rx_tdata[63:0], r_s_axis_rx_tdata_d1[127:64]};\n\telse\n\t\tr_mreq_fifo_wr_data <= r_s_axis_rx_tdata;\n\n\tif(r_rx_data_straddled == 1)\n\t\tr_cpld_fifo_wr_data <= {r_s_axis_rx_tdata[31:0], r_s_axis_rx_tdata_d1[127:32]};\n\telse\n\t\tr_cpld_fifo_wr_data <= {r_s_axis_rx_tdata[95:0], r_s_axis_rx_tdata_d1[127:96]};\nend\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_36a9a4bc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] in,\n    output [7:0] q\n);\n\n    wire [99:0] rotated_data;\n    wire [2:0] comb_out;\n    wire [7:0] final_out;\n\n    rotator rotator_inst(\n        .clk(clk),\n        .load(load),\n        .ena(ena),\n        .data(in),\n        .rotated_data(rotated_data)\n    );\n\n    combinational combinational_inst(\n        .in(rotated_data),\n        .out(comb_out)\n    );\n\n    final_module final_inst(\n        .in1(rotated_data[7:0]),\n        .in2(comb_out),\n        .out(final_out)\n    );\n\n    assign q = final_out;\n\nendmodule\nmodule rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] rotated_data\n);\n\n    reg [99:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= data;\n        end else begin\n            if (ena[0]) begin\n                shift_reg <= {shift_reg[98:0], shift_reg[99]};\n            end else if (ena[1]) begin\n                shift_reg <= {shift_reg[1:99], shift_reg[0]};\n            end\n        end\n    end\n\n    assign rotated_data = shift_reg;\n\nendmodule\nmodule combinational(\n    input [99:0] in,\n    output [2:0] out\n);\n\n    assign out[0] = &in;\n    assign out[1] = |in;\n    assign out[2] = ^in;\n\nendmodule\nmodule final_module(\n    input [7:0] in1,\n    input [2:0] in2,\n    output [7:0] out\n);\n\n    reg [7:0] out;\n\n    always @(*) begin\n        case (in2)\n            3'b000: out = in1 & 8'hFF;\n            3'b001: out = in1 | 8'hFF;\n            3'b010: out = in1 ^ 8'hFF;\n            3'b011: out = in1 + 8'h01;\n            3'b100: out = in1 - 8'h01;\n            default: out = 8'h00;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spis_5ea0c3e2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule spis(\n    input clk,\n    input rst,\n    input SCLK,\n    input SSbar,\n    input MOSI,\n    output reg[7:0] dout,\n    output reg data_present,\n    input rd\n    );\n\t  \n\t reg clear;\n\t always @(posedge clk or posedge rst) begin\n\t\tif(rst) clear <= 1;\n\t\telse if(rd) clear <= 1;\n\t\t\t\telse clear <= 0;\n\t end\n\n\t always @(posedge rst or posedge SCLK) begin\n\t\tif(rst) dout <= 0;\n\t\telse if (SSbar==0 & ~data_present) dout <= { dout[6:0] , MOSI};\n\t end\n\t \n\t reg data_present_temp;\n\t always @(posedge SSbar or posedge clear) begin\n\t\tif(clear)\tdata_present_temp <= 0;\n\t\telse\tdata_present_temp <= 1;\n\t end\n\t \n\t always @(posedge clk or posedge rst) begin\n\t\tif(rst) data_present <= 0;\n\t\telse data_present <= data_present_temp;\n\t end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vga_67df3312", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule vga(input vclock,\n            output reg [9:0] hcount,  // pixel number on current line\n            output reg [9:0] vcount,  // line number\n            output reg vsync,hsync,blank);\n\n// VGA (640x480) @ 60 Hz\nparameter VGA_HBLANKON  =  10'd639;\nparameter VGA_HSYNCON   =  10'd655;\nparameter VGA_HSYNCOFF  =  10'd751;\nparameter VGA_HRESET    =  10'd799;\nparameter VGA_VBLANKON  =  10'd479;\nparameter VGA_VSYNCON   =  10'd490;\nparameter VGA_VSYNCOFF  =  10'd492;\nparameter VGA_VRESET    =  10'd523;\n\nreg hblank,vblank;\nwire hsyncon,hsyncoff,hreset,hblankon;\nassign hblankon = (hcount == VGA_HBLANKON);\nassign hsyncon = (hcount == VGA_HSYNCON);\nassign hsyncoff = (hcount == VGA_HSYNCOFF);\nassign hreset = (hcount == VGA_HRESET);\n\nwire vsyncon,vsyncoff,vreset,vblankon;\nassign vblankon = hreset & (vcount == VGA_VBLANKON);\nassign vsyncon = hreset & (vcount == VGA_VSYNCON);\nassign vsyncoff = hreset & (vcount == VGA_VSYNCOFF);\nassign vreset = hreset & (vcount == VGA_VRESET);\n\n// sync and blanking\nwire next_hblank,next_vblank;\nassign next_hblank = hreset ? 0 : hblankon ? 1 : hblank;\nassign next_vblank = vreset ? 0 : vblankon ? 1 : vblank;\n\n// VGA controller\nalways @(posedge vclock) begin\n    if (hcount == 799 && vcount == 523) begin\n        // End of frame, reset counters\n        hcount <= 0;\n        vcount <= 0;\n    end else if (hcount == 799) begin\n        // End of line, reset hcount\n        hcount <= 0;\n        vcount <= vcount + 1;\n    end else begin\n        // Increment hcount\n        hcount <= hcount + 1;\n    end\n\n    // Update sync and blanking signals\n    hblank <= next_hblank;\n    hsync <= hsyncon ? 0 : hsyncoff ? 1 : hsync;  // active low\n    vblank <= next_vblank;\n    vsync <= vsyncon ? 0 : vsyncoff ? 1 : vsync;  // active low\n    blank <= next_vblank | (next_hblank & ~hreset);\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_7914e129", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule decoder (\n    input [2:0] ABC,\n    input clk,  // Clock input added\n    output reg [7:0] Y\n);\n\nreg [2:0] A, B, C;\nreg [7:0] Y_temp;\n\nalways @ (posedge clk) begin\n    A <= ABC[0];\n    B <= ABC[1];\n    C <= ABC[2];\nend\n\nalways @ (posedge clk) begin\n    Y_temp <= 8'b00000000;\n    if (A == 0 && B == 0 && C == 0) Y_temp[0] <= 1;\n    else if (A == 0 && B == 0 && C == 1) Y_temp[1] <= 1;\n    else if (A == 0 && B == 1 && C == 0) Y_temp[2] <= 1;\n    else if (A == 0 && B == 1 && C == 1) Y_temp[3] <= 1;\n    else if (A == 1 && B == 0 && C == 0) Y_temp[4] <= 1;\n    else if (A == 1 && B == 0 && C == 1) Y_temp[5] <= 1;\n    else if (A == 1 && B == 1 && C == 0) Y_temp[6] <= 1;\n    else if (A == 1 && B == 1 && C == 1) Y_temp[7] <= 1;\nend\n\nalways @ (posedge clk) begin\n    Y <= Y_temp;\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "WcaDcOffset_ddaa2e2b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule WcaDcOffset (\n    input clock, \n    input reset, \n    input strobe,\t \n\t input  iqSel,\n\n    input  signed [11:0] sig_in,    output signed [11:0] dcoffset,  output signed [11:0] sigout \t );\n\n\n\t \n\n\treg  signed [25:0] integrator[1:0];\n\n\tassign dcoffset = integrator[iqSel][25:14];\n   assign sigout   = sig_in - dcoffset;\n\twire  signed [25:0] update = integrator[iqSel] + {{(14){sigout[11]}},sigout}; \n\t\t\n   always @(negedge clock)\n\t begin\n     if(reset)\n\t  begin \n\t\t integrator[0] <= #1 26'd0;\n\t\t integrator[1] <= #1 26'd0;\n\t  end\n     else if(strobe) \n\t\t integrator[iqSel] <= #1 update; \n\t end \n\n\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_49474d96", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n    input clk,\n    input rst,\n    input up_down,\n    output [3:0] count\n);\n\n    reg [3:0] count_reg;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count_reg <= 4'b0000;\n        end else begin\n            if (up_down == 1) begin\n                if (count_reg == 4'b0000) begin\n                    count_reg <= 4'b1111;\n                end else begin\n                    count_reg <= count_reg - 1;\n                end\n            end else begin\n                if (count_reg == 4'b1111) begin\n                    count_reg <= 4'b0000;\n                end else begin\n                    count_reg <= count_reg + 1;\n                end\n            end\n        end\n    end\n\n    assign count = count_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_144ffa03", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_register (\n    LOAD,\n    DATA_IN,\n    CLK,\n    RESET_B,\n    DATA_OUT,\n    Q_N\n);\n\n    input LOAD;\n    input [3:0] DATA_IN;\n    input CLK;\n    input RESET_B;\n    output [3:0] DATA_OUT;\n    output Q_N;\n\n    wire [3:0] Q;\n    wire DATAPATH_LOAD;\n\n    assign DATAPATH_LOAD = RESET_B && LOAD;\n\n    DFF flip_flop_0 (\n        .D(DATA_IN[0]),\n        .Q(Q[0]),\n        .CLK(CLK),\n        .RST_N(RESET_B),\n        .SET_N(DATAPATH_LOAD)\n    );\n\n    DFF flip_flop_1 (\n        .D(Q[0]),\n        .Q(Q[1]),\n        .CLK(CLK),\n        .RST_N(RESET_B),\n        .SET_N(DATAPATH_LOAD)\n    );\n\n    DFF flip_flop_2 (\n        .D(Q[1]),\n        .Q(Q[2]),\n        .CLK(CLK),\n        .RST_N(RESET_B),\n        .SET_N(DATAPATH_LOAD)\n    );\n\n    DFF flip_flop_3 (\n        .D(Q[2]),\n        .Q(Q[3]),\n        .CLK(CLK),\n        .RST_N(RESET_B),\n        .SET_N(DATAPATH_LOAD)\n    );\n\n    assign Q_N = ~Q[3];\n\n    assign DATA_OUT = Q;\n\nendmodule\nmodule DFF (\n    D,\n    Q,\n    CLK,\n    RST_N,\n    SET_N\n);\n\n    input D;\n    output Q;\n    input CLK;\n    input RST_N;\n    input SET_N;\n\n    wire D1, D2;\n\n    nand (D1, RST_N, SET_N);\n    nand (D2, D1, D, CLK);\n    nand (Q, RST_N, CLK, D2);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_edf5570d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_counter(input clk, rst, en, output reg [3:0] count);\n\n  reg [3:0] next_count;\n  reg carry_out;\n\n  always @(*) begin\n    if (rst) begin\n      next_count = 4'b0;\n    end\n    else if (en) begin\n      next_count = count + 1'b1;\n    end\n    else begin\n      next_count = count;\n    end\n  end\n\n  always @(posedge clk) begin\n    count <= next_count;\n  end\n\n  always @(*)\n  if (count == 4'b1111)\n      carry_out = 1'b1;\n  else\n      carry_out = 1'b0;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_15626ab9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module( \n    input [7:0] in,\n    input [1:0] sel,\n    output [3:0] out );\n    \n    wire [1:0] sel_inv;\n    assign sel_inv = ~sel;\n    \n    wire [1:0] sel_2to1;\n    assign sel_2to1[0] = sel[0];\n    assign sel_2to1[1] = sel[1];\n    \n    wire [1:0] sel_inv_2to1;\n    assign sel_inv_2to1[0] = sel_inv[0];\n    assign sel_inv_2to1[1] = sel_inv[1];\n    \n    wire [1:0] mux1_out;\n    wire [1:0] mux2_out;\n    wire [1:0] mux3_out;\n    wire [1:0] mux4_out;\n    \n    mux_2to1 mux1(.in0(in[1:0]), .in1(in[3:2]), .sel(sel_2to1[0]), .out(mux1_out));\n    mux_2to1 mux2(.in0(in[5:4]), .in1(in[7:6]), .sel(sel_2to1[1]), .out(mux2_out));\n    mux_2to1 mux3(.in0(mux1_out), .in1(mux2_out), .sel(sel_inv_2to1[0]), .out(mux3_out));\n    mux_2to1 mux4(.in0(mux3_out), .in1(mux3_out), .sel(sel_inv_2to1[1]), .out(mux4_out));\n    \n    assign out = mux4_out;\n    \nendmodule\n\nmodule mux_2to1(\n    input [1:0] in0,\n    input [1:0] in1,\n    input sel,\n    output [1:0] out );\n    \n    assign out = (sel == 1'b0) ? in0 : in1;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_empty_block_1535e5a4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fifo_empty_block (\n   rd_fifo_empty, rd_addr, rd_gray_pointer,\n   reset, rd_clk, rd_wr_gray_pointer, rd_read\n   );\n\n   parameter AW   = 2; input           reset;\n   input           rd_clk;\n   \n   input [AW:0]    rd_wr_gray_pointer;input           rd_read;\n   \n   output          rd_fifo_empty;\n   output [AW-1:0] rd_addr;\n   output [AW:0]   rd_gray_pointer;\n   \n   reg [AW:0]      rd_gray_pointer;\n   reg [AW:0]      rd_binary_pointer;\n   reg             rd_fifo_empty;\n\n   wire \t   rd_fifo_empty_next;\n   wire [AW:0]     rd_binary_next;\n   wire [AW:0]     rd_gray_next;\n   \n   \n   always @(posedge rd_clk or posedge reset)\n     if(reset)\n       begin\n\t  rd_binary_pointer[AW:0]     <= {(AW+1){1'b0}};\n\t  rd_gray_pointer[AW:0]       <= {(AW+1){1'b0}};\n       end\n     else if(rd_read)\n       begin\n\t  rd_binary_pointer[AW:0]     <= rd_binary_next[AW:0];\t  \n\t  rd_gray_pointer[AW:0]       <= rd_gray_next[AW:0];\t  \n       end\n\n   assign rd_addr[AW-1:0]        = rd_binary_pointer[AW-1:0];\n\n   assign rd_binary_next[AW:0]  = rd_binary_pointer[AW:0] + \n\t\t\t\t  {{(AW){1'b0}},rd_read};\n\n   assign rd_gray_next[AW:0] = {1'b0,rd_binary_next[AW:1]} ^ \n\t\t\t       rd_binary_next[AW:0];\n\n\n   assign rd_fifo_empty_next = (rd_gray_next[AW:0]==rd_wr_gray_pointer[AW:0]);\n\n   always @ (posedge rd_clk or posedge reset)\n     if(reset)\n       rd_fifo_empty <= 1'b1;\n     else \n       rd_fifo_empty <= rd_fifo_empty_next;\n \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "unknown_module_0ecf5a3b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define\tWBA_ALTERNATING\nmodule\twbarbiter(i_clk, i_rst, \n\ti_a_cyc, i_a_stb, i_a_we, i_a_adr, i_a_dat, i_a_sel, o_a_ack, o_a_stall, o_a_err,\n\ti_b_cyc, i_b_stb, i_b_we, i_b_adr, i_b_dat, i_b_sel, o_b_ack, o_b_stall, o_b_err,\n\to_cyc, o_stb, o_we, o_adr, o_dat, o_sel, i_ack, i_stall, i_err);\n\tparameter\t\t\tDW=32, AW=19;\n\tinput\twire\t\t\ti_clk, i_rst;\n\tinput\twire\t\t\ti_a_cyc, i_a_stb, i_a_we;\n\tinput\twire\t[(AW-1):0]\ti_a_adr;\n\tinput\twire\t[(DW-1):0]\ti_a_dat;\n\tinput\twire\t[(DW/8-1):0]\ti_a_sel;\n\toutput\twire\t\t\to_a_ack, o_a_stall, o_a_err;\n\tinput\twire\t\t\ti_b_cyc, i_b_stb, i_b_we;\n\tinput\twire\t[(AW-1):0]\ti_b_adr;\n\tinput\twire\t[(DW-1):0]\ti_b_dat;\n\tinput\twire\t[(DW/8-1):0]\ti_b_sel;\n\toutput\twire\t\t\to_b_ack, o_b_stall, o_b_err;\n\toutput\twire\t\t\to_cyc, o_stb, o_we;\n\toutput\twire\t[(AW-1):0]\to_adr;\n\toutput\twire\t[(DW-1):0]\to_dat;\n\toutput\twire\t[(DW/8-1):0]\to_sel;\n\tinput\twire\t\t\ti_ack, i_stall, i_err;\n\n\treg\tr_cyc;\n\talways @(posedge i_clk)\n\t\tif (i_rst)\n\t\t\tr_cyc <= 1'b0;\n\t\telse\n\t\t\tr_cyc <= o_cyc;\n\n\twire\tw_a_owner, w_b_owner;   \n\tassign o_cyc = ((~r_cyc)&&((i_a_cyc)||(i_b_cyc))) || ((r_cyc)&&((w_a_owner)||(w_b_owner)));\n\n\n\treg\tr_a_owner, r_b_owner;\n`ifdef\tWBA_ALTERNATING\n\treg\tr_a_last_owner;\n\n`endif\n\talways @(posedge i_clk)\n\t\tif (i_rst)\n\t\tbegin\n\t\t\tr_a_owner <= 1'b0;\n\t\t\tr_b_owner <= 1'b0;\n\t\tend else begin\n\t\t\tr_a_owner <= w_a_owner;\n\t\t\tr_b_owner <= w_b_owner;\n`ifdef\tWBA_ALTERNATING\n\t\t\tif (w_a_owner)\n\t\t\t\tr_a_last_owner <= 1'b1;\n\t\t\telse if (w_b_owner)\n\t\t\t\tr_a_last_owner <= 1'b0;\n`endif\n\t\tend\n\t`ifdef\tWBA_ALTERNATING\n\tassign w_a_owner = (i_a_cyc)\t&& ((r_a_owner) || ((~r_cyc) &&((~i_b_cyc) ||(~r_a_last_owner)) )); assign w_b_owner = (i_b_cyc)&& ((r_b_owner) || ((~r_cyc)&&((~i_a_cyc)||(r_a_last_owner)) ));\n`else\n\tassign w_a_owner = (i_a_cyc)&& ((r_a_owner) ||  (~r_cyc) );\n\tassign w_b_owner = (i_b_cyc)&& ((r_b_owner) || ((~r_cyc)&&(~i_a_cyc)) );\n`endif\n\n\tassign o_stb = (o_cyc) && ((w_a_owner) ? i_a_stb : i_b_stb);\n\tassign o_we  = (w_a_owner) ? i_a_we  : i_b_we;\n\tassign o_adr = (w_a_owner) ? i_a_adr : i_b_adr;\n\tassign o_dat = (w_a_owner) ? i_a_dat : i_b_dat;\n\tassign o_sel = (w_a_owner) ? i_a_sel : i_b_sel;\n\n\tassign\to_a_ack   = (w_a_owner) ? i_ack   : 1'b0;\n\tassign\to_b_ack   = (w_b_owner) ? i_ack   : 1'b0;\n\n\tassign\to_a_stall = (w_a_owner) ? i_stall : 1'b1;\n\tassign\to_b_stall = (w_b_owner) ? i_stall : 1'b1;\n\n\tassign\to_a_err = (w_a_owner) ? i_err : 1'b0;\n\tassign\to_b_err = (w_b_owner) ? i_err : 1'b0;\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__efaf92b0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input select,  // 1 to use adder, 0 to use shifter\n    input [31:0] a,  // input for carry select adder\n    input [31:0] b,  // input for carry select adder\n    input [3:0] data,  // input for barrel shifter\n    output reg [31:0] q  // output from selected module\n);\n\n    // Define internal signals\n    wire [31:0] adder_out;\n    wire [3:0] shifter_out;\n    reg [3:0] buffer [3:0];\n    reg [1:0] buffer_ptr;\n\n    // Define carry select adder\n    carry_select_adder adder_inst (\n        .a(a),\n        .b(b),\n        .cin(1'b0),\n        .s(adder_out),\n        .cout()\n    );\n\n    // Define barrel shifter\n    always @(posedge clk) begin\n        if (areset) begin\n            buffer_ptr <= 2'b0;\n        end else begin\n            if (load) begin\n                buffer[buffer_ptr] <= data;\n            end else if (ena) begin\n                buffer[buffer_ptr] <= {1'b0, buffer[buffer_ptr][3:1]};\n            end\n            buffer_ptr <= buffer_ptr + 1'b1;\n        end\n    end\n    assign shifter_out = buffer[buffer_ptr];\n\n    // Select output based on select input\n    always @(posedge clk) begin\n        if (areset) begin\n            q <= 32'b0;\n        end else begin\n            if (select) begin\n                q <= adder_out;\n            end else begin\n                q <= {28'b0, shifter_out};\n            end\n        end\n    end\n\nendmodule\nmodule carry_select_adder (\n    input [31:0] a,\n    input [31:0] b,\n    input cin,\n    output reg [31:0] s,\n    output reg cout\n);\n    reg [31:0] p, g;\n    reg [4:0] c;\n\n    always @(*) begin\n        p = a + b;\n        g = a & b;\n        c[0] = cin;\n        c[1] = g[0] | (p[0] & cin);\n        c[2] = g[1] | (p[1] & c[1]);\n        c[3] = g[2] | (p[2] & c[2]);\n        c[4] = g[3] | (p[3] & c[3]);\n        s = p + (c[4] << 4);\n        cout = c[4];\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "InputCell_f57bdd64", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\n\n\nmodule InputCell( InputPin, FromPreviousBSCell, CaptureDR, ShiftDR, TCK, ToNextBSCell);\ninput  InputPin;\ninput  FromPreviousBSCell;\ninput  CaptureDR;\ninput  ShiftDR; \ninput  TCK;     \n                \nreg Latch;      \n                \noutput ToNextBSCell;\nreg    ToNextBSCell;\n\nwire SelectedInput = CaptureDR? InputPin : FromPreviousBSCell;\n\nalways @ (posedge TCK)\nbegin\n\tif(CaptureDR | ShiftDR)\n\t\tLatch<=SelectedInput;\nend\n\nalways @ (negedge TCK)\nbegin\n\tToNextBSCell<=Latch;\nend\n\n\nendmodule\t// InputCell"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_fir_h3_f8d67901", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_fir_h3 (clk, new_data_rdy, output_data_ready, din, dout);\n\n    parameter WIDTH = 5'b10000;\n    parameter COEF0_3 = -9;\n    parameter COEF1_3 = -56;\n    parameter COEF2_3 = -109;\n    parameter COEF4_3 = 109;\n    parameter COEF5_3 = 56;\n    parameter COEF6_3 = 9;\n\n    input clk; \n    input[WIDTH - 1:0] din; \n    output[28 - 1:0] dout; \n    reg[28 - 1:0] dout;\n    input new_data_rdy;\n    output output_data_ready;\n    reg output_data_ready;\n\n    reg[WIDTH - 1:0]n_delay_reg1;\n    reg[WIDTH - 1:0]n_delay_reg2;\n    reg[WIDTH - 1:0]n_delay_reg3;\n    reg[WIDTH - 1:0]n_delay_reg4;\n    reg[WIDTH - 1:0]n_delay_reg5;\n    reg[WIDTH - 1:0]n_delay_reg6;\n\n    always @(posedge clk)\n    begin\n        if (new_data_rdy == 1'b1)\n        begin\n            n_delay_reg1 <= din;\n            n_delay_reg2 <= n_delay_reg1;\n            n_delay_reg3 <= n_delay_reg2;\n            n_delay_reg4 <= n_delay_reg3;\n            n_delay_reg5 <= n_delay_reg4;\n            n_delay_reg6 <= n_delay_reg5;\n        \n            output_data_ready <= 1'b1;\n            dout <= (din * COEF0_3) + \n                (n_delay_reg1 * COEF1_3) + \n                (n_delay_reg2 * COEF2_3) + \n                (n_delay_reg4 * COEF4_3) + \n                (n_delay_reg5 * COEF5_3) + \n                (n_delay_reg6 * COEF6_3);\n        end\n        else\n        begin\n            output_data_ready <= 1'b0;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_2bb9263e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder(input [3:0] a, input [3:0] b, output reg [4:0] sum);\n\n  always @(*) begin\n    sum = a + b;\n    if (sum > 15) sum = sum[3:0];\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__nand2_687d63aa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__nand2 (\n    Y,\n    A,\n    B\n);\n\n    output Y;\n    input  A;\n    input  B;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, B, A           );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clockdivider_1d0b0682", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule clockdivider(\n\t input clk,\n    input rst,\n\t input select,\n    output reg [31:0] OUT1,\n\t output reg [31:0] OUT2,\n    output clkdivided1hz,\n\t output clkdivided200hz,\n\t output clkselect\n    );\n\t \n\t always @ (posedge clk or posedge rst)\n\t\tbegin\n\t\tif (rst)\n\t\t\tOUT1<=32'd0;\n\t\telse\n\t\tif (OUT1 == 32'd50000000)\n\t\t\tOUT1<=32'd0;\n\t\telse\n\t\t\tOUT1 <= OUT1 + 1;\n\t\tend\n\t\t\n\t always @ (posedge clk or posedge rst)\n\t\tbegin\n\t\tif (rst)\n\t\t\tOUT2<=32'd0;\n\t\telse\n\t\tif (OUT2 == 32'd500000)\n\t\t\tOUT2<=32'd0;\n\t\telse\n\t\t\tOUT2 <= OUT2 + 1;\n\t\tend\nassign clkdivided1hz = (OUT1 == 32'd50000000);\nassign clkdivided200hz = (OUT2 == 32'd250000);\n\nassign clkselect  = clkdivided200hz;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "data_accumulation_f9707220", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule data_accumulation (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input valid_a,\n  input ready_b,\n  output reg ready_a,\n  output reg valid_b,\n  output reg [15:0] data_out\n);\n\n  parameter THRESHOLD = 256; // configurable threshold value\n  \n  reg [15:0] accumulator = 0;\n  reg [3:0] count = 0;\n  reg [15:0] temp_data = 0;\n  reg [15:0] next_accumulator;\n  \n  always @ (posedge clk) begin\n    if (reset) begin\n      accumulator <= 0;\n      count <= 0;\n      valid_b <= 0;\n    end\n    else if (valid_a) begin\n      temp_data <= data_in << (count * 8);\n      accumulator <= next_accumulator;\n      count <= count + 1;\n      if (count == 1) begin\n        ready_a <= 0;\n      end\n      else if (count == 2) begin\n        ready_a <= 1;\n      end\n      if (accumulator >= THRESHOLD) begin\n        valid_b <= 1;\n      end\n    end\n    else if (ready_b && valid_b) begin\n      accumulator <= 0;\n      count <= 0;\n      valid_b <= 0;\n      ready_a <= 1;\n    end\n  end\n  \n  always @*\n    next_accumulator = accumulator + temp_data;\n  \n  always @*\n    data_out = accumulator;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "complement_b6e8cde3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule complement(\n    input [3:0] A,\n    output reg [3:0] C\n);\n\n    always @(*) begin\n        C = ~A + 4'b1;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "srl8_to_64_3ff0998d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule srl8_to_64(clk, enable, reset, dataIn, ready, result); \n    input clk, enable, reset; \n    input [7:0] dataIn; \n    output ready; \n    output [63:0] result; \n\n    reg [7:0] regBank[7:0]; \n    reg [3:0] status_int;\n    integer i; \n\n    parameter s1=0, s2=1, s3=2, s4=3, s5=4, s6=5, s7=6, s8=7, s9=8; \n\n    always @(posedge clk)\n    begin\n        if (reset == 1)\n        begin\n            status_int <= s1;\n            for (i=0; i<8; i=i+1) begin \n                regBank[i] <= 8'h0; \n            end \n        end else \n        if (enable == 0)\n        begin\n            regBank[0] <= dataIn; \n            for (i=7; i>0; i=i-1) begin \n                regBank[i] <= regBank[i-1]; \n            end \n            if (status_int == s9) begin\n                status_int <= s1;\n            end else begin\n                status_int <= status_int + 1;\n            end\n        end else begin\n            status_int <= s1;\n        end\n    end\n\n    assign result = (status_int == s9) ? {regBank[7], regBank[6], regBank[5], regBank[4], regBank[3], regBank[2], regBank[1], regBank[0]} : 64'h0; \n    assign ready = (status_int == s9) ? 1'b1 : 1'b0;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bcd_converter_03979e56", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bcd_converter (\n    input [3:0] binary,\n    output reg [3:0] bcd_high,\n    output reg [3:0] bcd_low\n);\n\nalways @* begin\n    case (binary)\n        4'b0000: begin bcd_high = 4'b0000; bcd_low = 4'b0000; end\n        4'b0001: begin bcd_high = 4'b0000; bcd_low = 4'b0001; end\n        4'b0010: begin bcd_high = 4'b0000; bcd_low = 4'b0010; end\n        4'b0011: begin bcd_high = 4'b0000; bcd_low = 4'b0011; end\n        4'b0100: begin bcd_high = 4'b0000; bcd_low = 4'b0100; end\n        4'b0101: begin bcd_high = 4'b0000; bcd_low = 4'b0101; end\n        4'b0110: begin bcd_high = 4'b0000; bcd_low = 4'b0110; end\n        4'b0111: begin bcd_high = 4'b0000; bcd_low = 4'b0111; end\n        4'b1000: begin bcd_high = 4'b0001; bcd_low = 4'b0000; end\n        4'b1001: begin bcd_high = 4'b0001; bcd_low = 4'b0001; end\n        4'b1010: begin bcd_high = 4'b0001; bcd_low = 4'b0010; end\n        4'b1011: begin bcd_high = 4'b0001; bcd_low = 4'b0011; end\n        4'b1100: begin bcd_high = 4'b0001; bcd_low = 4'b0100; end\n        4'b1101: begin bcd_high = 4'b0001; bcd_low = 4'b0101; end\n        4'b1110: begin bcd_high = 4'b0001; bcd_low = 4'b0110; end\n        4'b1111: begin bcd_high = 4'b0001; bcd_low = 4'b0111; end\n        default: begin bcd_high = 4'b0000; bcd_low = 4'b0000; end\n    endcase\nend\n\nendmodule\n\nmodule absolute_value (\n    input [3:0] binary,\n    output reg [3:0] abs_val\n);\n\nalways @* begin\n    if (binary[3] == 1) begin\n        abs_val = ~binary + 1;\n    end else begin\n        abs_val = binary;\n    end\nend\n\nendmodule\n\nmodule abs_bcd_converter (\n    input [3:0] binary,\n    output reg [3:0] bcd_high,\n    output reg [3:0] bcd_low,\n    output reg [3:0] abs_val,\n    output reg [11:0] abs_bcd_val\n);\n\nbcd_converter bcd_converter_inst (\n    .binary(binary),\n    .bcd_high(bcd_high),\n    .bcd_low(bcd_low)\n);\n\nabsolute_value absolute_value_inst (\n    .binary(binary),\n    .abs_val(abs_val)\n);\n\nalways @* begin\n    if (abs_val[3] == 1) begin\n        abs_bcd_val = {4'b0001, ~bcd_high + 1, ~bcd_low + 1};\n    end else begin\n        abs_bcd_val = {4'b0000, bcd_high, bcd_low};\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] binary,\n    output [3:0] bcd_high,\n    output [3:0] bcd_low,\n    output reg [3:0] abs_val,\n    output reg [11:0] abs_bcd_val\n);\n\nabs_bcd_converter abs_bcd_converter_inst (\n    .binary(binary),\n    .bcd_high(bcd_high),\n    .bcd_low(bcd_low),\n    .abs_val(abs_val),\n    .abs_bcd_val(abs_bcd_val)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sequential_circuit_d7878243", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sequential_circuit (\n  input clk,\n  input a,\n  output reg q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n  q1 <= a;\n  q2 <= q1;\n  q <= q2;\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_3b7b07bd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0;\n    end else if (enable) begin\n        if (count == 4'b1111) begin\n            count <= 4'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "traffic_light_controller_17a881ef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule traffic_light_controller (\n  input clk,\n  input areset,\n  input pedestrian_button,\n  output reg red_light,\n  output reg yellow_light,\n  output reg green_light,\n  output reg walk_signal\n);\n\n  // Define the states\n  parameter STATE_0 = 3'b000;\n  parameter STATE_1 = 3'b001;\n  parameter STATE_2 = 3'b010;\n  parameter STATE_3 = 3'b011;\n  parameter STATE_4 = 3'b100;\n\n  // Define the current state\n  reg [2:0] current_state, next_state;\n\n  // State machine logic\n  always @(posedge clk) begin\n    if (areset == 1'b1) begin\n      current_state <= STATE_0;\n    end else begin\n      current_state <= next_state;\n    end\n  end\n\n  always @* begin\n    case (current_state)\n      STATE_0: begin\n        if (pedestrian_button == 1'b1) begin\n          next_state <= STATE_4;\n        end else begin\n          next_state <= STATE_1;\n        end\n      end\n      STATE_1: begin\n        next_state <= STATE_2;\n      end\n      STATE_2: begin\n        next_state <= STATE_3;\n      end\n      STATE_3: begin\n        next_state <= STATE_0;\n      end\n      STATE_4: begin\n        next_state <= STATE_0;\n      end\n    endcase\n  end\n\n  // Output logic\n  always @* begin\n    case (current_state)\n      STATE_0: begin\n        red_light <= 1'b1;\n        yellow_light <= 1'b0;\n        green_light <= 1'b0;\n        walk_signal <= 1'b0;\n      end\n      STATE_1: begin\n        red_light <= 1'b1;\n        yellow_light <= 1'b0;\n        green_light <= 1'b0;\n        walk_signal <= 1'b1;\n      end\n      STATE_2: begin\n        red_light <= 1'b0;\n        yellow_light <= 1'b1;\n        green_light <= 1'b0;\n        walk_signal <= 1'b0;\n      end\n      STATE_3: begin\n        red_light <= 1'b0;\n        yellow_light <= 1'b0;\n        green_light <= 1'b1;\n        walk_signal <= 1'b1;\n      end\n      STATE_4: begin\n        red_light <= 1'b0;\n        yellow_light <= 1'b1;\n        green_light <= 1'b0;\n        walk_signal <= 1'b1;\n      end\n    endcase\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_controller #_bf671a48", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule memory_controller #(\n  parameter n = 8, // number of address signals\n  parameter m = 32 // number of data signals\n) (\n  input [n-1:0] addr,\n  input we,\n  input [m-1:0] data,\n  output mem_we,\n  output mem_re,\n  output [m-1:0] mem_data\n);\n\nreg [n-1:0] state;\nreg [m-1:0] mem_data_reg;\nreg mem_we_reg;\nreg mem_re_reg;\n\nalways @(*) begin\n  case(state)\n    0: begin // idle state\n      mem_we_reg = 0;\n      mem_re_reg = 0;\n      if (we) begin\n        state = 1; // write state\n      end else begin\n        state = 2; // read state\n      end\n    end\n    1: begin // write state\n      mem_we_reg = 1;\n      mem_re_reg = 0;\n      mem_data_reg = data;\n      state = 0; // return to idle state\n    end\n    2: begin // read state\n      mem_we_reg = 0;\n      mem_re_reg = 1;\n      state = 3; // wait for memory read\n    end\n    3: begin // wait for memory read\n      mem_we_reg = 0;\n      mem_re_reg = 0;\n      mem_data_reg = mem_data;\n      state = 0; // return to idle state\n    end\n  endcase\nend\n\nassign mem_we = mem_we_reg;\nassign mem_re = mem_re_reg;\nassign mem_data = mem_data_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_6fdc2c07", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_register (\n    input CLK,\n    input RESET_N,\n    input LOAD,\n    input [7:0] DATA_IN,\n    output Q\n);\n\nreg [7:0] shift_reg;\n\nalways @ (posedge CLK, negedge RESET_N) begin\n    if (~RESET_N) begin\n        shift_reg <= 8'b0;\n    end else if (LOAD) begin\n        shift_reg <= DATA_IN;\n    end else begin\n        shift_reg <= {shift_reg[6:0], shift_reg[7]};\n    end\nend\n\nassign Q = shift_reg[0];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_xfer_status_fc7c3287", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule up_xfer_status (\n\n  up_rstn,\n  up_clk,\n  up_data_status,\n\n  d_rst,\n  d_clk,\n  d_data_status);\n\n  parameter     DATA_WIDTH = 8;\n  localparam    DW = DATA_WIDTH - 1;\n\n  input           up_rstn;\n  input           up_clk;\n  output  [DW:0]  up_data_status;\n\n  input           d_rst;\n  input           d_clk;\n  input   [DW:0]  d_data_status;\n\n  reg             d_xfer_state_m1 = 'd0;\n  reg             d_xfer_state_m2 = 'd0;\n  reg             d_xfer_state = 'd0;\n  reg     [ 5:0]  d_xfer_count = 'd0;\n  reg             d_xfer_toggle = 'd0;\n  reg     [DW:0]  d_xfer_data = 'd0;\n  reg     [DW:0]  d_acc_data = 'd0;\n  reg             up_xfer_toggle_m1 = 'd0;\n  reg             up_xfer_toggle_m2 = 'd0;\n  reg             up_xfer_toggle_m3 = 'd0;\n  reg             up_xfer_toggle = 'd0;\n  reg     [DW:0]  up_data_status = 'd0;\n\n  wire            d_xfer_enable_s;\n  wire            up_xfer_toggle_s;\n\n  assign d_xfer_enable_s = d_xfer_state ^ d_xfer_toggle;\n\n  always @(posedge d_clk or posedge d_rst) begin\n    if (d_rst == 1'b1) begin\n      d_xfer_state_m1 <= 'd0;\n      d_xfer_state_m2 <= 'd0;\n      d_xfer_state <= 'd0;\n      d_xfer_count <= 'd0;\n      d_xfer_toggle <= 'd0;\n      d_xfer_data <= 'd0;\n      d_acc_data <= 'd0;\n    end else begin\n      d_xfer_state_m1 <= up_xfer_toggle;\n      d_xfer_state_m2 <= d_xfer_state_m1;\n      d_xfer_state <= d_xfer_state_m2;\n      d_xfer_count <= d_xfer_count + 1'd1;\n      if ((d_xfer_count == 6'd1) && (d_xfer_enable_s == 1'b0)) begin\n        d_xfer_toggle <= ~d_xfer_toggle;\n        d_xfer_data <= d_acc_data;\n      end\n      if ((d_xfer_count == 6'd1) && (d_xfer_enable_s == 1'b0)) begin\n        d_acc_data <= d_data_status;\n      end else begin\n        d_acc_data <= d_acc_data | d_data_status;\n      end\n    end\n  end\n\n  assign up_xfer_toggle_s = up_xfer_toggle_m3 ^ up_xfer_toggle_m2;\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 1'b0) begin\n      up_xfer_toggle_m1 <= 'd0;\n      up_xfer_toggle_m2 <= 'd0;\n      up_xfer_toggle_m3 <= 'd0;\n      up_xfer_toggle <= 'd0;\n      up_data_status <= 'd0;\n    end else begin\n      up_xfer_toggle_m1 <= d_xfer_toggle;\n      up_xfer_toggle_m2 <= up_xfer_toggle_m1;\n      up_xfer_toggle_m3 <= up_xfer_toggle_m2;\n      up_xfer_toggle <= up_xfer_toggle_m3;\n      if (up_xfer_toggle_s == 1'b1) begin\n        up_data_status <= d_xfer_data;\n      end\n    end\n  end\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_carry_adder_3dc2a3f4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ripple_carry_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\nwire [3:0] sum;\nwire [3:0] carry;\n\nassign sum = A ^ B ^ Cin;\nassign carry[0] = (A & B) | (Cin & (A ^ B));\n\nassign S = sum;\nassign Cout = carry[3];\n\ngenvar i;\ngenerate\n    for(i=1; i<4; i=i+1) begin : carry_propagation\n        assign carry[i] = carry[i-1] & sum[i-1];\n    end\nendgenerate\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "KeyScanController_719c52bb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule KeyScanController(\n  input clk, rst, start, load, shift,\n  output reg [2:0] currentState,\n  output reg startTimer\n);\n\n  parameter DIVIDER = 3;\n  reg [DIVIDER-1:0] timer;\n  \n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      currentState <= 3'b000;\n      startTimer <= 0;\n      timer <= 0;\n    end else begin\n      case (currentState)\n        3'b000: begin\n          if (start) begin\n            currentState <= 3'b001;\n            startTimer <= 1;\n            timer <= 0;\n          end\n        end\n        3'b001: begin\n          startTimer <= 0;\n          if (timer == DIVIDER-1) begin\n            if (load) begin\n              currentState <= 3'b010;\n              timer <= 0;\n            end else if (shift) begin\n              currentState <= 3'b100;\n              timer <= 0;\n            end else begin\n              currentState <= 3'b000;\n              timer <= 0;\n            end\n          end else begin\n            timer <= timer + 1;\n          end\n        end\n        3'b010: begin\n          if (timer == DIVIDER-1) begin\n            currentState <= 3'b001;\n            timer <= 0;\n          end else begin\n            timer <= timer + 1;\n          end\n        end\n        3'b100: begin\n          if (timer == DIVIDER-1) begin\n            currentState <= 3'b001;\n            timer <= 0;\n          end else begin\n            timer <= timer + 1;\n          end\n        end\n      endcase\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_and_42252938", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_and (\n    clk,\n    input_a,\n    input_b,\n    output_result\n);\n\ninput clk;\ninput [7:0] input_a;\ninput [7:0] input_b;\noutput [7:0] output_result;\n\nwire [7:0] wire_and0;\nwire [7:0] wire_and1;\nwire [7:0] wire_and2;\nwire [7:0] wire_and3;\nwire [7:0] wire_and4;\nwire [7:0] wire_and5;\nwire [7:0] wire_and6;\nwire [7:0] wire_and7;\n\nassign wire_and0 = input_a[0] & input_b[0];\nassign wire_and1 = input_a[1] & input_b[1];\nassign wire_and2 = input_a[2] & input_b[2];\nassign wire_and3 = input_a[3] & input_b[3];\nassign wire_and4 = input_a[4] & input_b[4];\nassign wire_and5 = input_a[5] & input_b[5];\nassign wire_and6 = input_a[6] & input_b[6];\nassign wire_and7 = input_a[7] & input_b[7];\n\nassign output_result[0] = wire_and0;\nassign output_result[1] = wire_and1;\nassign output_result[2] = wire_and2;\nassign output_result[3] = wire_and3;\nassign output_result[4] = wire_and4;\nassign output_result[5] = wire_and5;\nassign output_result[6] = wire_and6;\nassign output_result[7] = wire_and7;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bcd_to_7seg_ef461ceb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule bcd_to_7seg (\n    input [3:0] BCD,\n    output reg [6:0] SEG,\n    input clk, // Added clock input\n    input reset // Added reset as an input\n);\n\nreg [3:0] bcd_reg;\nreg [2:0] stage;\n\nalways @(posedge clk) begin\n    if (reset) begin // Reset logic\n        SEG <= 7'b0000000;\n        stage <= 0;\n    end else begin\n        case (stage)\n            0: SEG <= 7'b0111111; // 0\n            1: SEG <= 7'b0000110; // 1\n            2: SEG <= 7'b1011011; // 2\n            3: SEG <= 7'b1001111; // 3\n            4: SEG <= 7'b1100110; // 4\n            5: SEG <= 7'b1101101; // 5\n            6: SEG <= 7'b1111101; // 6\n            7: SEG <= 7'b0000111; // 7\n        endcase\n        stage <= stage + 1;\n        if (stage == 7) begin\n            stage <= 0;\n        end\n    end\nend\n\nalways @(*) begin\n    case (stage)\n        0: bcd_reg <= BCD;\n        1: bcd_reg <= bcd_reg << 1;\n        2: bcd_reg <= bcd_reg << 1;\n        3: bcd_reg <= bcd_reg << 1;\n        4: bcd_reg <= bcd_reg << 1;\n        5: bcd_reg <= bcd_reg << 1;\n        6: bcd_reg <= bcd_reg << 1;\n        7: bcd_reg <= bcd_reg << 1;\n    endcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "reset_module_8a86ed87", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule reset_module(\n    input   rst,\n    input   clk,\n    output  reg rst_n\n);\n\nreg r;\n\nalways @(negedge clk)\n    if( rst ) begin\n        r     <= 1'b0;\n        rst_n <= 1'b0;\n    end else begin\n        { rst_n, r } <= { r, 1'b1 };\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_321e5817", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule priority_encoder (\n    input [7:0] a, b, c, d,\n    output reg [1:0] index\n);\n\n    always @* begin\n        if ({a,b,c,d} != 8'b00000000)\n            index = a ? 2'b00 : (b ? 2'b01 : (c ? 2'b10 : 2'b11));\n        else\n            index = 2'b11;\n    end\n\nendmodule\nmodule mux_4to1_priority_encoder (\n    input [7:0] a, b, c, d,\n    input [1:0] select,\n    output reg [7:0] out\n);\n\n    wire [1:0] index;\n    priority_encoder pe(a, b, c, d, index);\n\n    always @* begin\n        case (select)\n            2'b00: out = a;\n            2'b01: out = b;\n            2'b10: out = c;\n            2'b11: out = d;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vending_machine_9e3aa935", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule vending_machine (\n  input clk,\n  input reset,\n  input [3:0] data,\n  input purchase,\n  output reg [3:0] display,\n  output reg item_dispensed\n);\n\n  // Define state machine states\n  parameter IDLE = 2'b00;\n  parameter SELECTING = 2'b01;\n  parameter DISPENSING = 2'b10;\n  \n  // Define item prices\n  parameter ITEM_1_PRICE = 2;\n  parameter ITEM_2_PRICE = 3;\n  parameter ITEM_3_PRICE = 4;\n  \n  // Define state machine registers\n  reg [1:0] state;\n  reg [3:0] item_selected;\n  reg [3:0] item_price;\n  reg [3:0] item_dispensed_temp;\n  \n  // Define state machine outputs\n  always @* begin\n    display = (state == IDLE) ? 4'b0001 : (state == SELECTING) ? {4'b0010, item_price} : (state == DISPENSING) ? 4'b0100 : 4'b1111;\n  end\n  \n  // Define state machine logic\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      item_selected <= 4'b0000;\n      item_price <= 4'b0000;\n      item_dispensed_temp <= 4'b0000;\n      item_dispensed <= 1'b0;\n    end else begin\n      case (state)\n        IDLE: begin\n          if (purchase) begin\n            state <= SELECTING;\n          end\n        end\n        SELECTING: begin\n          item_price <= (data == 4'b0001) ? ITEM_1_PRICE : (data == 4'b0010) ? ITEM_2_PRICE : (data == 4'b0100) ? ITEM_3_PRICE : 4'b0000;\n          if (purchase && item_price > 0) begin\n            item_selected <= data;\n            item_dispensed_temp <= item_selected;\n            state <= DISPENSING;\n          end\n        end\n        DISPENSING: begin\n          item_dispensed <= 1'b1;\n          item_dispensed_temp <= 4'b0000;\n          state <= IDLE;\n        end\n      endcase\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hs__a31o_a53e0ca7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_hs__a31o (\n    VPWR,\n    VGND,\n    X,\n    A1,\n    A2,\n    A3,\n    B1\n);\n    // Module ports\n    input  VPWR;\n    input  VGND;\n    output X;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    // Internal logic\n    wire n1, n2, n3;\n\n    // Instantiate submodules\n    sky130_fd_sc_hs__and2_1 and2_1 (\n        .A(A1),\n        .B(A2),\n        .X(n1)\n    );\n\n    sky130_fd_sc_hs__and2_1 and2_2 (\n        .A(n1),\n        .B(A3),\n        .X(n2)\n    );\n\n    sky130_fd_sc_hs__and2_1 and2_3 (\n        .A(B1),\n        .B(n2),\n        .X(n3)\n    );\n\n    // Output assignment\n    assign X = n3;\n\nendmodule\n\nmodule sky130_fd_sc_hs__a31o_wrapper (\n    VPWR,\n    VGND,\n    Y,\n    A1,\n    A2,\n    A3,\n    B1,\n    SEL\n);\n\n    // Module ports\n    input  VPWR;\n    input  VGND;\n    output Y;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  SEL;\n\n    // Local signals\n    wire X;\n    wire not_X;\n\n    // Instantiate submodules\n    sky130_fd_sc_hs__a31o a31o_inst (\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .X(X),\n        .A1(A1),\n        .A2(A2),\n        .A3(A3),\n        .B1(B1)\n    );\n\n    // Output assignment\n    assign not_X = ~X;\n\n    assign Y = (SEL == 1'b0) ? X : not_X;\n\nendmodule\n\nmodule sky130_fd_sc_hs__and2_1 (\n    A,\n    B,\n    X\n);\n    // Module ports\n    input  A;\n    input  B;\n    output X;\n\n    // Internal logic\n    wire n1;\n\n    // Instantiate submodules\n    sky130_fd_sc_hs__nand2_1 nand2_1 (\n        .A(A),\n        .B(B),\n        .Y(n1)\n    );\n\n    // Output assignment\n    assign X = ~n1;\n\nendmodule\n\nmodule sky130_fd_sc_hs__nand2_1 (\n    A,\n    B,\n    Y\n);\n    // Module ports\n    input  A;\n    input  B;\n    output Y;\n\n    // Internal logic\n    wire n1;\n\n    // Instantiate submodules\n    sky130_fd_sc_hs__nor2_1 nor2_1 (\n        .A(A),\n        .B(B),\n        .Y(n1)\n    );\n\n    // Output assignment\n    assign Y = ~n1;\n\nendmodule\n\nmodule sky130_fd_sc_hs__nor2_1 (\n    A,\n    B,\n    Y\n);\n    // Module ports\n    input  A;\n    input  B;\n    output Y;\n\n    // Logic logic\n    assign Y = ~(A | B);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "signed_mag_multiplier_62683920", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule signed_mag_multiplier (\n    input signed [3:0] a,\n    input signed [3:0] b,\n    output signed [7:0] product,\n    output overflow\n);\n    \n    reg signed [7:0] temp_product;\n    reg signed [3:0] temp_a;\n    reg signed [3:0] temp_b;\n    reg overflow_flag;\n    \n    always @(*) begin\n        temp_a = (a < 0) ? (~a + 1) : a;\n        temp_b = (b < 0) ? (~b + 1) : b;\n        temp_product = temp_a * temp_b;\n        if (temp_product > 127 || temp_product < -128) begin\n            overflow_flag = 1;\n        end else begin\n            overflow_flag = 0;\n        end\n    end\n    \n    assign product = (a < 0) ^ (b < 0) ? (~temp_product + 1) : temp_product;\n    assign overflow = overflow_flag;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "address_4b609e42", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n`define SGB_HOOK\n\nmodule address(\n  input CLK,\n  input [15:0] featurebits, input [23:0] SNES_ADDR,   input [7:0] SNES_PA,      input SNES_ROMSEL,        output [23:0] ROM_ADDR,   output ROM_HIT,           output IS_SAVERAM,        output IS_ROM,            output IS_WRITABLE,       output msu_enable,\n  output sgb_enable,\n  output r213f_enable,\n  output r2100_hit,\n  output snescmd_enable,\n\n  output button_enable,\n  output button_addr\n);\n\n\nparameter [2:0]\n  FEAT_DSPX = 0,\n  FEAT_ST0010 = 1,\n  FEAT_SRTC = 2,\n  FEAT_MSU1 = 3,\n  FEAT_213F = 4,\n  FEAT_2100 = 6\n;\n\nwire [23:0] SRAM_SNES_ADDR;\n\n\n\nassign IS_ROM = ~SNES_ROMSEL;\n\nassign IS_SAVERAM = 0;\n\nassign IS_WRITABLE = IS_SAVERAM;\n\nassign SRAM_SNES_ADDR = {5'h00, SNES_ADDR[19:16], SNES_ADDR[14:0]};\n\nassign ROM_ADDR = SRAM_SNES_ADDR;\n\nassign ROM_HIT = IS_ROM | IS_WRITABLE;\n\nassign msu_enable = featurebits[FEAT_MSU1] & (!SNES_ADDR[22] && ((SNES_ADDR[15:0] & 16'hfff8) == 16'h2000));\nassign sgb_enable = !SNES_ADDR[22] && ((SNES_ADDR[15:0] & 16'hf808) == 16'h6000 || (SNES_ADDR[15:0] & 16'hf80F) == 16'h600F || (SNES_ADDR[15:0] & 16'hf000) == 16'h7000); assign r213f_enable = featurebits[FEAT_213F] & (SNES_PA == 8'h3f);\nassign r2100_hit = (SNES_PA == 8'h00);\n\nassign snescmd_enable = ({SNES_ADDR[22], SNES_ADDR[15:9]} == 8'b0_0010101);\n\nassign button_enable = {SNES_ADDR[23:2],2'b00} == {24'h010F10} && SNES_ADDR[1] != SNES_ADDR[0];\nassign button_addr   = ~SNES_ADDR[0];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "TOP_e1371f79", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule TOP(\n    input wire in0,\n    input wire in1,\n    output reg out\n);\n\nalways @(in0, in1) begin\n    out = in0 & in1;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "square_bc693e03", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule square(input clksamp, \n            input[31:0] freq, \n            input signed[16:0] amp, \n            input signed[16:0] offset, \n            input[9:0] duty,\n            output[11:0] sq);\nparameter SAMP_FREQ = 100_000_000;\n\nreg state = 1'b0;\nreg[15:0] period_counter = 16'b0;\nreg[15:0] duty_counter = 16'b0;\n\nwire[15:0] period_load = (SAMP_FREQ/freq);\nwire[15:0] duty_load = (period_load * duty) / 1000;\n\nreg[15:0] period_load_reg = 32'b0;\nreg[15:0] duty_load_reg = 32'b0;\n\nalways @(posedge clksamp) begin\n    period_load_reg <= period_load;\n    duty_load_reg <= duty_load;\n    period_counter <= (period_load_reg != period_load) ? period_load_reg - 1 : (period_counter > 0) ? period_counter - 1 : period_load_reg - 1;\n    duty_counter <= (duty_load_reg != duty_load) ? duty_load_reg - 1 : (duty_counter > 0) ? duty_counter - 1 : (period_counter > 0) ? 0 : duty_load_reg - 1;\n    state <= (duty_counter == 0 && period_counter > 0) ? 0 : 1;\nend\n\nwire signed[16:0] preclip = state ? offset + amp : offset - amp;\n\nassign sq = (freq == 0 || amp == 0) ? offset > 4095 ? 4095 : offset : duty == 0 ? 0 : preclip > 4095 ? 4095 : preclip < 0 ? 0 : preclip;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sm_timer_64_340ae035", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule sm_timer_64\n(\n  output wire             sCMD_tready   ,\n  input  wire             sCMD_tvalid   ,\n  input  wire  [31 : 0]   sCMD_tdata    ,\n\n  input  wire             mRet_tready   ,\n  output wire             mRet_tvalid   ,\n  output wire  [31 : 0]   mRet_tdata    ,\n\n  input  wire             ACLK          ,\n  input  wire             ARESETN\n);\n\nlocalparam Fetch           = 8'b00000001; localparam Decode          = 8'b00000010; localparam SMSTART         = 8'b00000100; localparam SMRESET         = 8'b00001000; localparam SMSTOP          = 8'b00010000; localparam SMLAP           = 8'b00100000; localparam SMSEND_Lo       = 8'b01000000; localparam SMSEND_Hi       = 8'b10000000; localparam OPSTART         = 16'h1;\nlocalparam OPSTOP          = 16'h2;\nlocalparam OPRESET         = 16'h3;\nlocalparam OPREAD          = 16'h4;\nlocalparam OPLAP           = 16'h5;\n\nreg [ 7:0] state       ;\nreg [31:0] instruction ;\nreg [31:0] rVal        ;\n\nassign mRet_tdata  = rVal;\nassign sCMD_tready = (state == Fetch);\nassign mRet_tvalid = (state == SMSEND_Lo || state == SMSEND_Hi);\nreg  [63 : 0]  counterR;\n\nreg            rRESET;\nreg            rEN;\n\nalways @(posedge ACLK) begin\n  if (rRESET) begin\n    counterR <= 64'd0;\n  end\n  else begin\n    if (rEN) begin\n      counterR <= counterR + 1;\n    end\n  end\nend\n\n\nalways @(posedge ACLK)\nbegin\n  if(!ARESETN) begin\n    state <= Fetch;\n    instruction <= 32'd0;\n    rVal  <= 32'd0;\n    rEN   <= 1'b0;\n    rRESET<= 1'b1;\n  end\n  else begin\n    case (state)\n\n      Fetch: begin\n        rRESET <= 1'b0;\n        if (sCMD_tvalid == 1) begin\n          instruction  <= sCMD_tdata;\n          state        <= Decode;\n        end\n        else begin\n          state        <= Fetch;\n        end\n      end\n\n      Decode: begin\n        case (instruction[31:16])\n          OPSTART: begin\n            rEN <= 1'b1;\n            state        <= Fetch;\n          end\n\n          OPSTOP: begin\n            rEN <= 1'b0;\n            state        <= Fetch;\n          end\n\n          OPRESET: begin\n            rRESET <= 1'b1;\n            state        <= Fetch;\n          end\n\n          OPREAD: begin\n            rVal         <= counterR[31:0];\n            state        <= SMSEND_Lo;\n          end\n\n          default: begin\n            state        <= Fetch;\n          end\n        endcase\n      end\n\n      SMSEND_Lo: begin\n        if (mRet_tready == 1) begin\n          rVal  <= counterR[63:32];\n          state <= SMSEND_Hi;\n        end\n        else begin\n          state <= SMSEND_Lo;\n        end\n      end\n\n      SMSEND_Hi: begin\n        if (mRet_tready == 1) begin\n          state <= Fetch;\n        end\n        else begin\n          state <= SMSEND_Hi;\n        end\n      end\n\n    endcase\n  end\nend\n\nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mult_gate_6c66ae82", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mult_gate (\n    output Y,\n    input J,\n    input I,\n    input H,\n    input G,\n    input F,\n    input E,\n    input D,\n    input C,\n    input B,\n    input A\n);\n\n    wire w3;\n    wire w2;\n    wire w1;\n\n    and gate3(w3, I, H, G);\n    and gate2(w2, F, E, D);\n    and gate1(w1, C, B, A);\n    or gate4(Y, w3, w2, w1, J);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_subtractor_4bit_40dc9543", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_subtractor_4bit (\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output [3:0] SUM\n);\n\nwire [3:0] CIN;\nwire [3:0] COUT;\n\nassign CIN[0] = SUB;\nassign CIN[1] = COUT[0];\nassign CIN[2] = COUT[1];\nassign CIN[3] = COUT[2];\n\nfa fa0 (\n    .A(A[0]),\n    .B(B[0]),\n    .CIN(CIN[0]),\n    .SUM(SUM[0]),\n    .COUT(COUT[0])\n);\nfa fa1 (\n    .A(A[1]),\n    .B(B[1]),\n    .CIN(CIN[1]),\n    .SUM(SUM[1]),\n    .COUT(COUT[1])\n);\nfa fa2 (\n    .A(A[2]),\n    .B(B[2]),\n    .CIN(CIN[2]),\n    .SUM(SUM[2]),\n    .COUT(COUT[2])\n);\nfa fa3 (\n    .A(A[3]),\n    .B(B[3]),\n    .CIN(CIN[3]),\n    .SUM(SUM[3]),\n    .COUT(COUT[3])\n);\n\nendmodule\n\nmodule fa (\n    input A,\n    input B,\n    input CIN,\n    output SUM,\n    output COUT\n);\n\nassign {COUT, SUM} = A + B + CIN;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_e60d231c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder (\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    assign {cout, sum} = cin + A + B;\n\nendmodule\n\nmodule ripple_addsub (\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    input select,\n    output [3:0] sum,\n    output cout\n);\n\n    assign {cout, sum} = select ? (cin + A - B) : (cin + A + B);\n\nendmodule\n\nmodule top_module (\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    input select,\n    output reg [3:0] sum,\n    output reg cout\n);\n\n    wire [3:0] adder_out;\n    wire adder_cout;\n    wire [3:0] ripple_addsub_out;\n    wire ripple_addsub_cout;\n\n    adder adder_inst (\n        .A(A),\n        .B(B),\n        .cin(cin),\n        .sum(adder_out),\n        .cout(adder_cout)\n    );\n\n    ripple_addsub ripple_addsub_inst (\n        .A(A),\n        .B(B),\n        .cin(cin),\n        .select(select),\n        .sum(ripple_addsub_out),\n        .cout(ripple_addsub_cout)\n    );\n\n    always @(*) begin\n        if (select) begin\n            if (adder_cout) begin\n                sum <= ripple_addsub_out + 4'b0001;\n            end else begin\n                sum <= ripple_addsub_out;\n            end\n        end else begin\n            sum <= adder_out;\n        end\n    end\n\n    always @(*) begin\n        if (select) begin\n            cout <= ripple_addsub_cout;\n        end else begin\n            cout <= adder_cout;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "selector_mode_3472fbd8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule selector_mode\n#(parameter LO = 2, HI = 5, CLK_CH = 25)\n(\n    input [31:0]clk,\n    input switch_power,\n    input switch_en,\n    input sig_change,\n    input [1:0]washing_machine_running,\n    output reg push,\n    output reg [2:0] sel_value\n);\n\n    reg init_flag;\n    wire real_clk;\n\n    initial begin\n        init_flag <= 1;\n        sel_value <= LO;\n        push <= 1'b0;\n    end\n\n    always @(posedge clk[CLK_CH]) begin\n        if (switch_power) begin\n            if (!switch_en) begin   \n                if(washing_machine_running[1]) begin\n                    push = 1'b1;\n                    sel_value = LO;\n                end else begin\n                    if(init_flag) begin\n                        sel_value = LO;\n                        init_flag = 0;\n                        push = 1'b0;\n                    end\n                    if (sig_change) begin\n                        sel_value = (sel_value + 1) % (HI+1) ? (sel_value + 1) % (HI+1) : LO;\n                        push = 1'b1;\n                    end else begin\n                        sel_value = sel_value;\n                        push = push;\n                    end\n                end\n            end else begin\n                push = 1'b0;\n                sel_value = sel_value;\n            end\n        end else begin\n            init_flag = 1;\n            sel_value = LO;\n            push = 1'b0;\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "KeyEncoder_f5d2fec6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule KeyEncoder(Columns, Rows, Clock, Reset, OnesDigit, TensDigit, Found);\n\tinput [3:0] Columns;\n\tinput [3:0] Rows;\n\tinput Clock, Reset;\n\toutput reg [3:0] OnesDigit;\n\toutput reg [3:0] TensDigit;\n\toutput reg Found;\n\tparameter NoKey = 9'd0;\n\tparameter key1 = 9'b100000001;\n\tparameter key2 = 9'b100000010;\n\tparameter key3 = 9'b100000011;\n\tparameter key4 = 9'b100000100;\n\tparameter key5 = 9'b100000101;\n\tparameter key6 = 9'b100000110;\n\tparameter key7 = 9'b100000111;\n\tparameter key8 = 9'b100001000;\n\tparameter key9 = 9'b100001001;\n\tparameter keyA = 9'b100010000;\n\tparameter keyB = 9'b100010001;\n\tparameter keyC = 9'b100010010;\n\tparameter keyD = 9'b100010011;\n\tparameter keyStar = 9'b100010100;\n\tparameter key0 = 9'b100010101;\n\tparameter keyPound = 9'b100010110;\n\talways@(posedge Clock or posedge Reset)\n\tif (Reset == 1) {Found, TensDigit, OnesDigit} <= NoKey;\n\telse case ({ Columns, Rows })\n\t\t8'b01110111: {Found, TensDigit, OnesDigit} <= key1;\n\t\t8'b10110111: {Found, TensDigit, OnesDigit} <= key2;\n\t\t8'b11010111: {Found, TensDigit, OnesDigit} <= key3;\n\t\t8'b01111011: {Found, TensDigit, OnesDigit} <= key4;\n\t\t8'b10111011: {Found, TensDigit, OnesDigit} <= key5;\n\t\t8'b11011011: {Found, TensDigit, OnesDigit} <= key6;\n\t\t8'b01111101: {Found, TensDigit, OnesDigit} <= key7;\n\t\t8'b10111101: {Found, TensDigit, OnesDigit} <= key8;\n\t\t8'b11011101: {Found, TensDigit, OnesDigit} <= key9;\n\t\t8'b11100111: {Found, TensDigit, OnesDigit} <= keyA;\n\t\t8'b11101011: {Found, TensDigit, OnesDigit} <= keyB;\n\t\t8'b11101101: {Found, TensDigit, OnesDigit} <= keyC;\n\t\t8'b11101110: {Found, TensDigit, OnesDigit} <= keyD;\n\t\t8'b01111110: {Found, TensDigit, OnesDigit} <= keyStar;\n\t\t8'b10111110: {Found, TensDigit, OnesDigit} <= key0;\n\t\t8'b11011110: {Found, TensDigit, OnesDigit} <= keyPound;\n\t\tdefault: {Found, TensDigit, OnesDigit} <= NoKey;\n\tendcase\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__1809b38e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    input [7:0] d,  // 8-bit input for the register\n    input select,  // Select input to choose between register and counter\n    output [7:0] q  // 8-bit output from the addition operation\n);\n\n    // Declare internal wires\n    wire [7:0] reg_out;\n    wire [3:0] counter_out;\n\n    // Instantiate the register module\n    reg_module reg_inst (\n        .clk(clk),\n        .reset(reset),\n        .d(d),\n        .q(reg_out)\n    );\n\n    // Instantiate the counter module\n    counter_module counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .q(counter_out)\n    );\n\n    // Instantiate the adder module\n    adder_module adder_inst (\n        .a(select ? reg_out : counter_out),\n        .b(select ? counter_out : reg_out),\n        .sum(q)\n    );\n\nendmodule\n\n// 8-bit register with active high synchronous reset\nmodule reg_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    input [7:0] d,  // 8-bit input\n    output reg [7:0] q  // 8-bit output\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'h34;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\n\n// 4-bit binary counter that counts from 0 through 15, with synchronous reset to 0\nmodule counter_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    output reg [3:0] q  // 4-bit output\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule\n\n// Functional module that adds two 8-bit inputs\nmodule adder_module (\n    input [7:0] a,  // 8-bit input a\n    input [7:0] b,  // 8-bit input b\n    output reg [7:0] sum  // 8-bit output sum\n);\n\n    always @(*) begin\n        sum = a + b;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sd_clock_divider_07df698d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sd_clock_divider (\n           input CLK,\n           input [7:0] DIVIDER,\n           input RST,\n           output SD_CLK\n       );\n\nreg [7:0] ClockDiv;\nreg SD_CLK_O;\n\nassign SD_CLK = SD_CLK_O;\n\nalways @(posedge CLK or posedge RST)\nbegin\n    if (RST) begin\n        ClockDiv <= 8'b0000_0000;\n        SD_CLK_O <= 0;\n    end\n    else if (ClockDiv == DIVIDER) begin\n        ClockDiv <= 0;\n        SD_CLK_O <= ~SD_CLK_O;\n    end else begin\n        ClockDiv <= ClockDiv + 8'h1;\n        SD_CLK_O <= SD_CLK_O;\n    end\nend\n\nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_display_879b0d1d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule counter_display(\n    input CLOCK_50, // 50 MHz FPGA Clock\n    input [1:0] KEY, // Pushbutton Keys\n    input [5:0] SW, // DIP Switches\n    output [6:0] HEX0, HEX1, HEX2, HEX3 // Seven-Segment Displays\n);\n\n    wire enable;\n    wire [15:0] hexDigits;\n    wire [3:0] countValue;\n\n    // Instantiate keyPressed module\n    keyPressed K1 ( // Module instantiation with correct module name.\n        .clock(CLOCK_50),\n        .reset(KEY[0]),\n        .enable_in(KEY[1]),\n        .enable_out(enable)\n    );\n\n    // Instantiate counter16bit module\n    counter16bit C1 ( // Module instantiation with correct module name.\n        .clock(CLOCK_50),\n        .enable(enable),\n        .clear(KEY[0]),\n        .disp(SW[5]),\n        .dir(SW[4]),\n        .countValue(countValue),\n        .outputValue(hexDigits)\n    );\n\n    // Instantiate seven-segment display drivers\n    sevenSegmentDecoder S0 (// Module instantiation with correct module name.\n        .digit(hexDigits[3:0]),\n        .drivers(HEX0)\n    );\n    sevenSegmentDecoder S1 ( // Module instantiation with correct module name.\n        .digit(hexDigits[7:4]),\n        .drivers(HEX1)\n    );\n    sevenSegmentDecoder S2 ( // Module instantiation with correct module name.\n        .digit(hexDigits[11:8]),\n        .drivers(HEX2)\n    );\n    sevenSegmentDecoder S3 ( // Module instantiation with correct module name.\n        .digit(hexDigits[15:12]),\n        .drivers(HEX3)\n    );\n\nendmodule\n\nmodule keyPressed(\n    input clock,\n    input reset,\n    input enable_in,\n    output reg enable_out\n);\n\n    always @ (posedge clock) begin\n        if (reset) begin\n            enable_out <= 0;\n        end else if (enable_in) begin\n            enable_out <= 1;\n        end else begin\n            enable_out <= 0;\n        end\n    end\n\nendmodule\n\nmodule counter16bit(\n    input clock,\n    input enable,\n    input clear,\n    input disp,\n    input dir, // Corrected typo\n    output reg [3:0] countValue,\n    output reg [15:0] outputValue\n);\n\n    always @ (posedge clock) begin\n        if (clear) begin\n            countValue <= 0;\n            outputValue <= 0;\n        end else if (enable) begin\n            if (dir) begin\n                countValue <= countValue - 1;\n            end else begin\n                countValue <= countValue + 1;\n            end\n            outputValue <= {disp, countValue};\n        end\n    end\n\nendmodule\n\nmodule sevenSegmentDecoder(\n    input [3:0] digit,\n    output reg [6:0] drivers\n);\n\n    always @ (digit) begin\n        case (digit)\n            4'b0000: drivers = 7'b1000000; // 0\n            4'b0001: drivers = 7'b1111001; // 1\n            4'b0010: drivers = 7'b0100100; // 2\n            4'b0011: drivers = 7'b0110000; // 3\n            4'b0100: drivers = 7'b0011001; // 4\n            4'b0101: drivers = 7'b0010010; // 5\n            4'b0110: drivers = 7'b0000010; // 6\n            4'b0111: drivers = 7'b1111000; // 7\n            4'b1000: drivers = 7'b0000000; // 8\n            4'b1001: drivers = 7'b0010000; // 9\n            default: drivers = 7'b1111111; // Error\n        endcase\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_c9759237", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule\n\nmodule ripple_carry_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire c0, c1, c2, c3;\n\n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c0));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(c0), .sum(sum[1]), .cout(c1));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(c1), .sum(sum[2]), .cout(c2));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(c2), .sum(sum[3]), .cout(c3));\n\n    assign cout = c3;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "byte_reversal_03dca645", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule byte_reversal (\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nalways @(*) begin\n    out[7:0] = in[31:24];\n    out[15:8] = in[23:16];\n    out[23:16] = in[15:8];\n    out[31:24] = in[7:0];\nend\n\nendmodule\n\nmodule priority_encoder (\n    input [31:0] in,\n    output reg [4:0] pos // Position of the first high bit in the input\n);\n\nalways @(*) begin\n    case(in)\n        32'b00000000000000000000000000000000: pos = 5'b00000;\n        32'b00000000000000000000000000000001: pos = 5'b00001;\n        32'b00000000000000000000000000000011: pos = 5'b00010;\n        32'b00000000000000000000000000000111: pos = 5'b00011;\n        32'b00000000000000000000000000001111: pos = 5'b00100;\n        32'b00000000000000000000000000011111: pos = 5'b00101;\n        32'b00000000000000000000000000111111: pos = 5'b00110;\n        32'b00000000000000000000000001111111: pos = 5'b00111;\n        32'b00000000000000000000000011111111: pos = 5'b01000;\n        32'b00000000000000000000000111111111: pos = 5'b01001;\n        32'b00000000000000000000001111111111: pos = 5'b01010;\n        32'b00000000000000000000011111111111: pos = 5'b01011;\n        default: pos = 5'b01111;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_with_sync_reset_4d529226", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_counter_with_sync_reset (\n    input clk,\n    input reset,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            Q <= 4'b0000;\n        end else begin\n            if (Q == 4'b1111) begin\n                Q <= 4'b0000;\n            end else begin\n                Q <= Q + 1;\n            end\n        end\n    end\n\nendmodule\nmodule shift_register_with_serial_in_out (\n    input clk,\n    input reset,\n    input SI,\n    output reg SO,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= {Q[2:0], SI};\n            SO <= Q[0];\n        end\n    end\n\nendmodule\nmodule bitwise_OR_module (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] Y\n);\n\n    always @(*) begin\n        Y = A | B;\n    end\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input SI,\n    input select,\n    output reg [3:0] Q\n);\n\n    reg [3:0] counter_out;\n    reg [3:0] shift_reg_out;\n    reg [3:0] bitwise_OR_out;\n\n    binary_counter_with_sync_reset counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .Q(counter_out)\n    );\n\n    shift_register_with_serial_in_out shift_reg_inst (\n        .clk(clk),\n        .reset(reset),\n        .SI(SI),\n        .Q(shift_reg_out)\n    );\n\n    bitwise_OR_module bitwise_OR_inst (\n        .A(counter_out),\n        .B(shift_reg_out),\n        .Y(bitwise_OR_out)\n    );\n\n    always @(posedge clk) begin\n        if (reset) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= bitwise_OR_out;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "square_wave_gen_55ccaa2d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule square_wave_gen (\n  input clk,\n  input freq,\n  output reg square_wave\n);\n\n  reg [31:0] counter, half_period, clk_period;\n\n  always @(posedge clk) begin\n    if (counter == half_period) begin\n      square_wave <= ~square_wave;\n      counter <= 0;\n    end else begin\n      counter <= counter + 1'b1;\n    end\n  end\n\n  always @(posedge clk) begin\n    clk_period <= (clk_period / freq) ? (clk_period / freq) : 1'b0;\n    half_period <= clk_period / 2;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gray_to_binary_9e913ef0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule gray_to_binary (\n    input clk,\n    input rst,\n    input ena,\n    input [3:0] gray,\n    output [3:0] binary\n);\n\nreg [3:0] gray_reg1, gray_reg2;\nreg [3:0] binary_reg1, binary_reg2;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        gray_reg1 <= 4'b0000;\n        gray_reg2 <= 4'b0000;\n        binary_reg1 <= 4'b0000;\n        binary_reg2 <= 4'b0000;\n    end else if (ena) begin\n        gray_reg1 <= gray;\n        gray_reg2 <= gray_reg1;\n        binary_reg1 <= binary_reg2;\n        binary_reg2 <= binary_reg1 ^ gray_reg2;\n    end\nend\n\nassign binary = binary_reg2;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fsm_bit_pattern_detection_cfeb4f39", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fsm_bit_pattern_detection (\n  input clk,\n  input reset,\n  input [7:0] data,\n  output reg pulse\n);\n\n  parameter S0 = 2'b00; // Idle state\n  parameter S1 = 2'b01; // First bit of pattern detected\n  parameter S2 = 2'b10; // Second bit of pattern detected\n  parameter S3 = 2'b11; // Pattern detected\n  \n  reg [1:0] state; // FSM state register\n  reg [7:0] shift_reg; // Shift register for input data\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state <= S0;\n      shift_reg <= 8'h00;\n      pulse <= 1'b0;\n    end\n    else begin\n      case (state)\n        S0: begin // Idle state\n          shift_reg <= {shift_reg[6:0], data}; // Shift in new data\n          if (shift_reg == 8'b10110101) begin // Detect pattern\n            state <= S3;\n            pulse <= 1'b1; // Output pulse\n          end\n          else if (shift_reg[7] == 1'b1) begin // First bit detected\n            state <= S1;\n          end\n        end\n        S1: begin // First bit detected\n          shift_reg <= {shift_reg[6:0], data}; // Shift in new data\n          if (shift_reg[7:6] == 2'b10) begin // Second bit detected\n            state <= S2;\n          end\n          else if (shift_reg[7] == 1'b0) begin // Reset if pattern not found\n            state <= S0;\n          end\n        end\n        S2: begin // Second bit detected\n          shift_reg <= {shift_reg[6:0], data}; // Shift in new data\n          if (shift_reg[7:5] == 3'b101) begin // Pattern detected\n            state <= S3;\n            pulse <= 1'b1; // Output pulse\n          end\n          else if (shift_reg[7:6] != 2'b10) begin // Reset if pattern not found\n            state <= S0;\n          end\n        end\n        S3: begin // Pattern detected\n          shift_reg <= {shift_reg[6:0], data}; // Shift in new data\n          if (shift_reg[7:0] != 8'b10110101) begin // Reset if pattern not found\n            state <= S0;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Multiplexer_AC__parameterized61_fb8f84e1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Multiplexer_AC__parameterized61\n   (ctrl,\n    D0,\n    D1,\n    S);\n  input ctrl;\n  input [0:0]D0;\n  input [0:0]D1;\n  output [0:0]S;\n\n  wire [0:0]S;\n\n  assign S = ctrl ? D1 : D0;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "NOR3X1_74c0ceb4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule NOR3X1 (\n\tA, \n\tB, \n\tC, \n\tY);\n   input A;\n   input B;\n   input C;\n   output Y;\n   \n   wire AB_nor;\n   wire AB_nor_C_nor;\n   \n   nor(AB_nor, A, B);\n   nor(AB_nor_C_nor, AB_nor, C);\n   assign Y = AB_nor_C_nor;\n   \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__o311a_7434c429", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__o311a (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  C1;\n\n    wire or0_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1, A3     );\n    and and0 (and0_out_X, or0_out, B1, C1);\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_operators #_984d93ae", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_operators #(\n  parameter n = 4\n) (\n  input [n-1:0] A,\n  input [n-1:0] B,\n  output [n-1:0] C1,\n  output [n-1:0] C2,\n  output [n-1:0] C3,\n  output [n-1:0] C4\n\n);\n\n// Bitwise AND\nassign C1 = A & B;\n\n// Bitwise OR\nassign C2 = A | B;\n\n// Bitwise XOR\nassign C3 = A ^ B;\n\n// Bitwise NOT\nassign C4 = ~A;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mouse_painter_36a97d42", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mouse_painter(\n    input [4:0] line_number,\n    output reg [7:0] line_code\n);\n\nparameter [7:0] line00 = 8'h01;\nparameter [7:0] line01 = 8'h03;\nparameter [7:0] line02 = 8'h07;\nparameter [7:0] line03 = 8'h0F;\nparameter [7:0] line04 = 8'h1F;\nparameter [7:0] line05 = 8'h3F;\nparameter [7:0] line06 = 8'h7F;\nparameter [7:0] line07 = 8'hFF;\nparameter [7:0] line08 = 8'h07;\nparameter [7:0] line09 = 8'h03;\nparameter [7:0] line10 = 8'h01;\n\nalways @(*) begin\n    case(line_number)\n        5'b00000 : line_code = line00;\n        5'b00001 : line_code = line01;\n        5'b00010 : line_code = line02;\n        5'b00011 : line_code = line03;\n        5'b00100 : line_code = line04;\n        5'b00101 : line_code = line05;\n        5'b00110 : line_code = line06;\n        5'b00111 : line_code = line07;\n        5'b01000 : line_code = line08;\n        5'b01001 : line_code = line09;\n        5'b01010 : line_code = line10;\n        default : line_code = 8'b00000000;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "max_value_9592a13e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule max_value (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] max,\n    output reg equal_flag\n);\n\nalways @(*) begin\n    if (a > b) begin\n        max = a;\n        equal_flag = 0;\n    end\n    else if (b > a) begin\n        max = b;\n        equal_flag = 0;\n    end\n    else begin\n        max = a;\n        equal_flag = 1;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_4bit_8319eb3f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule comparator_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  input [3:0] C,\n  input [3:0] D,\n  output reg eq,\n  output reg gt,\n  output reg lt\n);\n\n  always @(*) begin\n    eq = (A==B) && (B==C) && (C==D);\n    gt = (A>B) && (B>C) && (C>D);\n    lt = (A<B) && (B<C) && (C<D);\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "CLK_GATE_MODULE_66129a73", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule CLK_GATE_MODULE (\n  input CLK, EN, TE,\n  output ENCLK\n);\n\n  assign ENCLK = (EN & ~TE) ? CLK & EN : 1'b0;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "processor_reset_71ae9ec1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule processor_reset(\n  input  input_sync_clk,\n  input  ext_reset_in,\n  input  aux_reset_in,\n  input  mb_debug_sys_rst,\n  input  dcm_locked,\n  output reg mb_reset,\n  output reg bus_struct_reset,\n  output reg peripheral_reset,\n  output reg interconnect_aresetn,\n  output reg peripheral_aresetn\n);\n\n  parameter C_EXT_RST_WIDTH = 4;\n  parameter C_AUX_RST_WIDTH = 4;\n  parameter C_NUM_BUS_RST = 1;\n  parameter C_NUM_INTERCONNECT_ARESETN = 1;\n  parameter C_NUM_PERP_ARESETN = 1;\n  parameter C_AUX_RESET_HIGH = 1'b0;\n  parameter C_EXT_RESET_HIGH = 1'b1;\n  parameter C_FAMILY = \"artix7\";\n\n  reg [C_EXT_RST_WIDTH-1:0] ext_rst_count;\n  reg [C_AUX_RST_WIDTH-1:0] aux_rst_count;\n  reg [1:0] debug_rst_count;\n  reg dcm_locked_1;\n  \n  always @(posedge input_sync_clk) begin\n    ext_rst_count <= (ext_reset_in == C_EXT_RESET_HIGH) ? ext_rst_count + 1 : 0;\n    aux_rst_count <= (aux_reset_in == C_AUX_RESET_HIGH) ? aux_rst_count + 1 : 0;\n    debug_rst_count <= (mb_debug_sys_rst == 1'b1) ? debug_rst_count + 1 : 0;\n    dcm_locked_1 <= dcm_locked;\n  end\n\n  always @(ext_rst_count or aux_rst_count or debug_rst_count) begin\n    if (ext_rst_count == C_EXT_RST_WIDTH || aux_rst_count == C_AUX_RST_WIDTH || debug_rst_count == 2'd1) begin\n      mb_reset <= 1'b1;\n      bus_struct_reset <= 1'b1;\n      peripheral_reset <= 1'b1;\n    end\n\n    else if (dcm_locked_1 == 1'b0) begin\n      mb_reset <= 1'b0;\n      bus_struct_reset <= 1'b0;\n      peripheral_reset <= 1'b0;\n    end\n  end\n\n  always @* begin\n    interconnect_aresetn = (dcm_locked_1 == 1'b1) ? 1'b1 : 1'b0;\n    peripheral_aresetn = (dcm_locked_1 == 1'b1) ? 1'b1 : 1'b0;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mix_columns_ecf4b6c1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mix_columns\n(\n\toutput [31:0] mix_out_enc,\n\toutput [31:0] mix_out_dec,\n\tinput  [31:0] mix_in\n);\n\nlocalparam integer SIZE      = 32;\nlocalparam integer WORD_SIZE = 8;\nlocalparam integer NUM_WORDS = 4;\n\nwire [WORD_SIZE - 1 : 0] col  [0 : NUM_WORDS - 1];\nwire [WORD_SIZE - 1 : 0] sum_p[0 : NUM_WORDS - 1];\nwire [WORD_SIZE - 1 : 0] y    [0 : NUM_WORDS - 2];\n\nfunction [7:0] aes_mult_02;\n  input [7:0] data_in;\n  begin\n    aes_mult_02 = (data_in << 1) ^ {8{data_in[7]}} & 8'h1b;\n  end\nendfunction\n\nfunction [7:0] aes_mult_04;\n  input [7:0] data_in;\n  begin\n    aes_mult_04 = ((data_in << 2) ^ {8{data_in[6]}} & 8'h1b) ^ {8{data_in[7]}} & 8'h36;\n  end\nendfunction\n\ngenerate\n\tgenvar i;\n\tfor(i = 0 ; i < NUM_WORDS; i = i + 1)\n\tbegin:WBT\n\t\tassign col[i] = mix_in[WORD_SIZE*(i + 1) - 1: WORD_SIZE*i];\n\tend\nendgenerate\n\ngenerate\n\tgenvar j;\n\tfor(j = 0; j < NUM_WORDS; j = j + 1)\n\t\tbegin:DMCO\n\t\t\tassign sum_p[j] = col[(j + 1)%NUM_WORDS] ^ col[(j + 2)%NUM_WORDS] ^ col[(j + 3)%NUM_WORDS];\n\t\t\tassign mix_out_enc[ WORD_SIZE*(j + 1) - 1 : WORD_SIZE*j] = aes_mult_02(col[j] ^ col[(j + NUM_WORDS - 1)%NUM_WORDS]) ^ sum_p[j];\n\t\tend\nendgenerate\n\nassign y[0] = aes_mult_04(col[2] ^ col[0]); \nassign y[1] = aes_mult_04(col[3] ^ col[1]);\nassign y[2] = aes_mult_02(  y[1] ^   y[0]);  \nassign mix_out_dec = mix_out_enc ^ {2{y[2] ^ y[1], y[2] ^ y[0]}};\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_2c7d777e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_counter (\n    input clk,\n    input reset,\n    input count_en,\n    input [31:0] max_count,\n    input [31:0] load_val,\n    input load,\n    input count_dir,\n    output reg [31:0] count_out\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count_out <= 32'b0;\n    end\n    else if (load) begin\n        count_out <= load_val;\n    end\n    else if (count_en) begin\n        if (count_dir) begin\n            if (count_out == max_count) begin\n                count_out <= 32'b0;\n            end\n            else begin\n                count_out <= count_out + 1;\n            end\n        end\n        else begin\n            if (count_out == 0) begin\n                count_out <= max_count;\n            end\n            else begin\n                count_out <= count_out - 1;\n            end\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__791ff194", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [3:0] a,    // 4-bit input for ALU\n    input [3:0] b,    // 4-bit input for ALU\n    input [2:0] op,   // 3-bit control signal for ALU\n    output [3:0] q // 4-bit output of the functional module\n);\n\nwire [3:0] alu_output;\n\nalu alu_inst (\n    .a(a),\n    .b(b),\n    .op(op),\n    .result(alu_output)\n);\n\ntwos_complement twos_complement_inst (\n    .input_value(alu_output),\n    .output_value(q)\n);\n\nendmodule\n\nmodule alu (\n    input [3:0] a,\n    input [3:0] b,\n    input [2:0] op,\n    output reg [3:0] result\n);\n\nalways @(*) begin\n    case (op)\n        3'b000: result = a + b;\n        3'b001: result = a - b;\n        3'b010: result = a & b;\n        3'b011: result = a | b;\n        3'b100: result = a ^ b;\n        3'b101: result = a << 1;\n        default: result = 4'b0;\n    endcase\nend\n\nendmodule\n\nmodule twos_complement (\n    input [3:0] input_value,\n    output reg [3:0] output_value\n);\n\nalways @(*) begin\n    output_value = ~input_value + 4'b0001;\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "HallwayRight_4a8d3845", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule HallwayRight(clk_vga, CurrentX, CurrentY, mapData, wall);\n\n\tinput clk_vga;\n\tinput [9:0]CurrentX;\n\tinput [8:0]CurrentY;\n\tinput [7:0]wall;\n\t\n\toutput [7:0]mapData;\n\t\n\treg [7:0]mColor;\n\t\n\talways @(posedge clk_vga) begin\n\t\t//Top walls\n\t\tif((CurrentY < 40) && ~(CurrentX < 0)) begin\n\t\t\tmColor[7:0] <= wall;\n\t\tend \n\t\t//Right side wall\n\t\telse if(~(CurrentX < 600)) begin\n\t\t\tmColor[7:0] <= wall;\n\t\tend\n\t\t//Bottom wall\n\t\telse if((~(CurrentY < 440) && (CurrentX < 260)) || (~(CurrentY < 440) && ~(CurrentX < 380))) begin\n\t\t\tmColor[7:0] <= wall;\n\t\t//floor area - grey\n\t\tend else\n\t\t\tmColor[7:0] <= 8'b10110110;\n\t\t\t\n\tend\n\t\n\tassign mapData = mColor;\n\t\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "usb_crc5_7417fc84", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule usb_crc5(\n  input [10:0] data_in,\n  input crc_en,\n  output [4:0] crc_out,\n  input rst,\n  input clk);\n\n  reg [4:0] lfsr_q,lfsr_c;\n\n  assign crc_out = ~lfsr_q;\n\n  always @(*) begin\n    lfsr_c[0] = lfsr_q[0] ^ lfsr_q[3] ^ lfsr_q[4] ^ data_in[0] ^ data_in[3] ^ data_in[5] ^ data_in[6] ^ data_in[9] ^ data_in[10];\n    lfsr_c[1] = lfsr_q[0] ^ lfsr_q[1] ^ lfsr_q[4] ^ data_in[1] ^ data_in[4] ^ data_in[6] ^ data_in[7] ^ data_in[10];\n    lfsr_c[2] = lfsr_q[0] ^ lfsr_q[1] ^ lfsr_q[2] ^ lfsr_q[3] ^ lfsr_q[4] ^ data_in[0] ^ data_in[2] ^ data_in[3] ^ data_in[6] ^ data_in[7] ^ data_in[8] ^ data_in[9] ^ data_in[10];\n    lfsr_c[3] = lfsr_q[1] ^ lfsr_q[2] ^ lfsr_q[3] ^ lfsr_q[4] ^ data_in[1] ^ data_in[3] ^ data_in[4] ^ data_in[7] ^ data_in[8] ^ data_in[9] ^ data_in[10];\n    lfsr_c[4] = lfsr_q[2] ^ lfsr_q[3] ^ lfsr_q[4] ^ data_in[2] ^ data_in[4] ^ data_in[5] ^ data_in[8] ^ data_in[9] ^ data_in[10];\n\n  end always @(posedge clk, posedge rst) begin\n    if(rst) begin\n      lfsr_q <= {5{1'b1}};\n    end\n    else begin\n      lfsr_q <= crc_en ? lfsr_c : lfsr_q;\n    end\n  end endmodule `ifdef TEST_USB_CRC5\nmodule tb();\nreg [10:0] data_in;\nreg crc_en;\nwire [4:0] crc_out;\nreg rst;\nwire clk;\nsim_clk #(125) clk_125_r(.clk(clk));\nusb_crc5 dut(.*);\nwire [4:0] to_wire = ~crc_out; initial begin\n  $dumpfile(\"crc5.lxt\");\n  $dumpvars();\n  rst <= 1'b0;\n  crc_en <= 1'b0;\n  wait(clk);\n  wait(~clk);\n  rst <= 1'b1;\n  wait(clk);\n  wait(~clk);\n  rst <= 1'b0;\n  wait(clk);\n  wait(~clk);\n  data_in <= 11'b10000000000;\n  crc_en <= 1'b1;\n  wait(clk);\n  wait(~clk);\n  rst <= 1'b1;\n  crc_en <= 1'b0;\n  wait(clk);\n  wait(~clk);\n  rst <= 1'b0;\n  crc_en <= 1'b1;\n  data_in <= 11'b01000000000;\n  #1000;\n  $finish();\nend\nendmodule\n`endif\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "altera_up_av_config_auto_init_ltm_3988eba4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule altera_up_av_config_auto_init_ltm (\n    // Inputs\n    clk,\n    rom_address,\n\n    // Outputs\n    rom_data\n);\n\n\n\n\n// Inputs\ninput           clk;\ninput           [4:0]   rom_address;\n\n// Outputs\noutput      [23:0]  rom_data;\n\n\n\n// States\nlocalparam [4:0] STATE_0 = 5'h0;\nlocalparam [4:0] STATE_1 = 5'h1;\nlocalparam [4:0] STATE_2 = 5'h2;\nlocalparam [4:0] STATE_3 = 5'h3;\nlocalparam [4:0] STATE_4 = 5'h4;\nlocalparam [4:0] STATE_5 = 5'h5;\nlocalparam [4:0] STATE_6 = 5'h6;\nlocalparam [4:0] STATE_7 = 5'h7;\nlocalparam [4:0] STATE_8 = 5'h8;\nlocalparam [4:0] STATE_9 = 5'h9;\nlocalparam [4:0] STATE_10 = 5'hA;\nlocalparam [4:0] STATE_11 = 5'hB;\nlocalparam [4:0] STATE_12 = 5'hC;\nlocalparam [4:0] STATE_13 = 5'hD;\nlocalparam [4:0] STATE_14 = 5'hE;\nlocalparam [4:0] STATE_15 = 5'hF;\nlocalparam [4:0] STATE_16 = 5'h10;\nlocalparam [4:0] STATE_17 = 5'h11;\nlocalparam [4:0] STATE_18 = 5'h12;\nlocalparam [4:0] STATE_19 = 5'h13;\n\n\n// Internal Wires\nreg         [23:0] data;\n\n// State Machine Registers\nreg         [4:0]   state_reg;\nreg         [4:0]   next_state;\n\n\n\nalways @(*) begin\n    case (state_reg)\n        STATE_0 : next_state = (rom_address == 5'h0) ? STATE_0 : STATE_1;\n        STATE_1 : next_state = (rom_address == 5'h1) ? STATE_1 : STATE_2;\n        STATE_2 : next_state = (rom_address == 5'h2) ? STATE_2 : STATE_3;\n        STATE_3 : next_state = (rom_address == 5'h3) ? STATE_3 : STATE_4;\n        STATE_4 : next_state = (rom_address == 5'h4) ? STATE_4 : STATE_5;\n        STATE_5 : next_state = (rom_address == 5'h5) ? STATE_5 : STATE_6;\n        STATE_6 : next_state = (rom_address == 5'h6) ? STATE_6 : STATE_7;\n        STATE_7 : next_state = (rom_address == 5'h7) ? STATE_7 : STATE_8;\n        STATE_8 : next_state = (rom_address == 5'h8) ? STATE_8 : STATE_9;\n        STATE_9 : next_state = (rom_address == 5'h9) ? STATE_9 : STATE_10;\n        STATE_10 : next_state = (rom_address == 5'hA) ? STATE_10 : STATE_11;\n        STATE_11 : next_state = (rom_address == 5'hB) ? STATE_11 : STATE_12;\n        STATE_12 : next_state = (rom_address == 5'hC) ? STATE_12 : STATE_13;\n        STATE_13 : next_state = (rom_address == 5'hD) ? STATE_13 : STATE_14;\n        STATE_14 : next_state = (rom_address == 5'hE) ? STATE_14 : STATE_15;\n        STATE_15 : next_state = (rom_address == 5'hF) ? STATE_15 : STATE_16;\n        STATE_16 : next_state = (rom_address == 5'h10) ? STATE_16 : STATE_17;\n        STATE_17 : next_state = (rom_address == 5'h11) ? STATE_17 : STATE_18;\n        STATE_18 : next_state = (rom_address == 5'h12) ? STATE_18 : STATE_19;\n        STATE_19 : next_state = (rom_address == 5'h13) ? STATE_19 : STATE_0;\n        default : next_state = STATE_0;\n    endcase\nend\n\n\n\n// State machine\nalways @(posedge clk) begin\n    state_reg <= next_state;\nend\n\n\n\n// Output Assignments\nassign rom_data = {data[13:8], 2'h0, data[7:0]};\n\n// Internal Assignments\nalways @(*) begin\n    case (state_reg)\n        STATE_0 : data <= {6'h02, 8'h07};\n        STATE_1 : data <= {6'h03, 8'hDF};\n        STATE_2 : data <= {6'h04, 8'h17};\n        STATE_3 : data <= {6'h11, 8'h00};\n        STATE_4 : data <= {6'h12, 8'h5B};\n        STATE_5 : data <= {6'h13, 8'hFF};\n        STATE_6 : data <= {6'h14, 8'h00};\n        STATE_7 : data <= {6'h15, 8'h20};\n        STATE_8 : data <= {6'h16, 8'h40};\n        STATE_9 : data <= {6'h17, 8'h80};\n        STATE_10 : data <= {6'h18, 8'h00};\n        STATE_11 : data <= {6'h19, 8'h80};\n        STATE_12 : data <= {6'h1A, 8'h00};\n        STATE_13 : data <= {6'h1B, 8'h00};\n        STATE_14 : data <= {6'h1C, 8'h80};\n        STATE_15 : data <= {6'h1D, 8'hC0};\n        STATE_16 : data <= {6'h1E, 8'hE0};\n        STATE_17 : data <= {6'h1F, 8'hFF};\n        STATE_18 : data <= {6'h20, 8'hD2};\n        STATE_19 : data <= {6'h21, 8'hD2};\n        default : data <= 24'h000000;\n    endcase\nend\n\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fmlarb_dack_b01bc0c9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule fmlarb_dack(\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\tinput stb,\n\tinput eack,\n\tinput we,\n\n\toutput stbm,\n\toutput reg ack\n);\n\nwire read = eack & ~we;\nwire write = eack & we;\n\nreg ack_read2;\nreg ack_read1;\nreg ack_read0;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tack_read2 <= 1'b0;\n\t\tack_read1 <= 1'b0;\n\t\tack_read0 <= 1'b0;\n\tend else begin\n\t\tack_read2 <= read;\n\t\tack_read1 <= ack_read2;\n\t\tack_read0 <= ack_read1;\n\tend\nend\n\nreg ack0;\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tack0 <= 1'b0;\n\t\tack <= 1'b0;\n\tend else begin\n\t\tack0 <= ack_read0|write;\n\t\tack <= ack0;\n\tend\nend\n\nreg mask;\nassign stbm = stb & ~mask;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tmask <= 1'b0;\n\telse begin\n\t\tif(eack)\n\t\t\tmask <= 1'b1;\n\t\tif(ack)\n\t\t\tmask <= 1'b0;\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_behavioral_cef3b88a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1_behavioral (\n  input [3:0] a,\n  input [3:0] b,\n  input s,\n  output reg [3:0] mux_out\n);\n\n  always @(*) begin\n    if (s == 1'b0) begin\n      mux_out = a;\n    end else begin\n      mux_out = b;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "control_enable_options_7f6aa6a5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule control_enable_options(\n    input wire clk,\n    input wire rst_n,\n    input wire [7:0] zxuno_addr,\n    input wire zxuno_regrd,\n    input wire zxuno_regwr,\n    input wire [7:0] din,\n    output reg [7:0] dout,\n    output reg oe_n,\n    output wire disable_ay,\n    output wire disable_turboay,\n    output wire disable_7ffd,\n    output wire disable_1ffd,\n    output wire disable_romsel7f,\n    output wire disable_romsel1f,\n    output wire enable_timexmmu,\n    output wire disable_spisd,\n    output wire disable_timexscr,\n    output wire disable_ulaplus,\n    output wire disable_radas\n    );\n\n    parameter DEVOPTIONS = 8'h0E;\n    parameter DEVOPTS2   = 8'h0F;\n    \n    reg [7:0] devoptions = 8'h00;  reg [7:0] devopts2 = 8'h00;    assign disable_ay = devoptions[0];\n    assign disable_turboay = devoptions[1];\n    assign disable_7ffd = devoptions[2];\n    assign disable_1ffd = devoptions[3];\n    assign disable_romsel7f = devoptions[4];\n    assign disable_romsel1f = devoptions[5];\n    assign enable_timexmmu = devoptions[6];\n    assign disable_spisd = devoptions[7];\n    assign disable_timexscr = devopts2[0];\n    assign disable_ulaplus = devopts2[1];\n    assign disable_radas = devopts2[2];\n    \n    always @(posedge clk) begin\n        if (rst_n == 1'b0) begin\n            devoptions <= 8'h00;  devopts2 <= 8'h00;\n        end\n        else if (zxuno_addr == DEVOPTIONS && zxuno_regwr == 1'b1)\n            devoptions <= din;\n        else if (zxuno_addr == DEVOPTS2 && zxuno_regwr == 1'b1)\n            devopts2 <= din;\n    end\n    \n    always @* begin\n        oe_n = 1'b1;\n        dout = 8'hFF;\n        if (zxuno_regrd == 1'b1)            \n            if (zxuno_addr == DEVOPTIONS) begin\n                oe_n = 1'b0;\n                dout = devoptions;\n            end\n            else if (zxuno_addr == DEVOPTS2) begin\n                oe_n = 1'b0;\n                dout = devopts2;\n            end\n        end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_module_b480f87c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule memory_module\n  (\n    clk_i,\n    rst_i,\n    we_i,  \n    stb_i,\n    ack_o,\n    dat_i,\n    dat_o,\n    adr_i,\n    a11,\n    a12,\n    b10,\n    b11,\n    b12\n  );\n\n  input clk_i;\n  input rst_i;\n  input we_i;\n  input stb_i;\n  output ack_o;\n  input [15:0] dat_i;\n  output [15:0] dat_o;\n  input [2:0] adr_i;\n  output [15:0] a11;\n  output [15:0] a12;\n  output [15:0] b10;\n  output [15:0] b11;\n  output [15:0] b12;\n\n  reg [15:0] a11;\n  reg [15:0] a12;\n  reg [15:0] b10;\n  reg [15:0] b11;\n  reg [15:0] b12;\n\n  wire ack_o;\n  wire sel_a11;\n  wire sel_a12;\n  wire sel_b10;\n  wire sel_b11;\n  wire sel_b12;\n\n  assign sel_a11 = (adr_i == 3'b000);\n  assign sel_a12 = (adr_i == 3'b001);\n  assign sel_b10 = (adr_i == 3'b010);\n  assign sel_b11 = (adr_i == 3'b011);\n  assign sel_b12 = (adr_i == 3'b100);\n\n  assign ack_o = stb_i;\n\n  always @(posedge clk_i or posedge rst_i)\n    if (rst_i) begin\n      a11 <= 16'hFF;\n      a12 <= 16'h1F;\n      b10 <= 16'h7F;\n      b11 <= 16'h3;\n      b12 <= 16'hFF;\n    end\n    else begin\n      a11 <= (stb_i & we_i & sel_a11) ? dat_i : a11;\n      a12 <= (stb_i & we_i & sel_a12) ? dat_i : a12;\n      b10 <= (stb_i & we_i & sel_b10) ? dat_i : b10;\n      b11 <= (stb_i & we_i & sel_b11) ? dat_i : b11;\n      b12 <= (stb_i & we_i & sel_b12) ? dat_i : b12;\n    end\n\n  assign dat_o = sel_a11 ? a11 :\n    (sel_a12 ? a12 :\n    (sel_b10 ? b10 :\n    (sel_b11 ? b11 :\n    (sel_b12 ? b12 : 16'h0000))));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "parity_sum_292fad87", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule parity_sum (\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] parity_sum\n);\n\nendmodule\nmodule parity_checker #(\n    parameter DATAWIDTH = 8\n) (\n    input [DATAWIDTH-1:0] data,\n    output parity\n);\n\n    wire [DATAWIDTH-1:0] sum;\n    genvar i;\n    \n    for (i = 0; i < DATAWIDTH; i = i + 1) begin : adder_tree\n        assign sum[i] = data[i] ^ (i == 0 ? 0 : sum[i-1]);\n    end\n    \n    assign parity = sum[DATAWIDTH-1];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_8775e333", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ddr_ctrl_wrapper #_aaad6b8b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule ddr_ctrl_wrapper #(\n\tparameter ADDR_WIDTH\t= 25\t)\n(\n\toutput\t\t\trdy_o,\n\toutput\t\t\tidle_o,\n\tinput  [31:0]\t\tadr_i,\n\toutput [31:0]\t\tadr_o,\n\tinput  [31:0]\t\tdat_i,\n\toutput [31:0]\t\tdat_o,\n\tinput  [3:0]\t\tsel_i,\n\tinput\t\t\tacc_i,\n\toutput\t\t\tack_o,\n\tinput\t\t\twe_i,\n\tinput  [3:0]\t\tbuf_width_i,\n\n\toutput [ADDR_WIDTH-3:0]\tlocal_address_o,\n\toutput\t\t\tlocal_write_req_o,\n\toutput\t\t\tlocal_read_req_o,\n\toutput\t\t\tlocal_burstbegin_o,\n\toutput [31:0]\t\tlocal_wdata_o,\n\toutput [3:0]\t\tlocal_be_o,\n\toutput [6:0]\t\tlocal_size_o,\n\tinput  [31:0]\t\tlocal_rdata_i,\n\tinput\t\t\tlocal_rdata_valid_i,\n\tinput\t\t\tlocal_reset_n_i,\n\tinput\t\t\tlocal_clk_i,\n\tinput\t\t\tlocal_ready_i\n);\n\n\tlocalparam LOCAL_ADR_WIDTH = ADDR_WIDTH-2;\n\n\tfunction [31:0] get_mask;\n\tinput [3:0] width;\n\t\tbegin\n\t\t\tget_mask = ((1 << (width)) - 1);\n\t\tend\n\tendfunction\n\n\tassign local_be_o\t= sel_i;\n\tassign dat_o\t\t= local_rdata_i;\n\tassign local_address_o\t= we_i ? adr_i[LOCAL_ADR_WIDTH+1:2] : adr_i[LOCAL_ADR_WIDTH+1:2] & ~get_mask(buf_width_i);\n\tassign local_wdata_o\t= dat_i;\n\n\treg [22:0]\tlocal_address;\n\treg\t\tlocal_write_req;\n\treg\t\tlocal_read_req;\n\treg\t\tlocal_burstbegin;\n\treg [31:0]\tlocal_wdata;\n\treg [6:0]\tlocal_size;\n\n\tassign local_write_req_o\t= local_write_req;\n\tassign local_read_req_o\t\t= local_read_req;\n\tassign local_burstbegin_o\t= local_burstbegin;\n\tassign local_size_o\t\t= local_size;\n\n\treg [3:0]\tstate;\n\treg [31:0]\tcount;\n\treg\t\tack_w;\n\treg [31:0]\tadr;\n\n\tlocalparam [3:0]\n\t\tWAIT_READY    = 4'h0,\n\t\tIDLE          = 4'h1,\n\t\tWRITE         = 4'h2,\n\t\tREAD          = 4'h3;\n\n\tassign rdy_o = local_ready_i;\n\tassign idle_o = (state == IDLE);\n\tassign adr_o = adr;\n\n\tassign ack_o = acc_i ? (we_i ? ack_w : local_rdata_valid_i) : 1'b0;\n\n\talways @(posedge local_clk_i) begin\n\t\tif (local_reset_n_i == 1'b0) begin\n\t\t\tlocal_write_req\t\t<= 1'b0;\n\t\t\tlocal_read_req\t\t<= 1'b0;\n\t\t\tlocal_burstbegin\t<= 1'b0;\n\t\t\tlocal_size\t\t<= 6'b1;\n\t\t\tcount\t\t\t<= 0;\n\t\t\tadr\t\t\t<= 32'b0;\n\t\t\tstate\t\t\t<= WAIT_READY;\n\t\tend else begin\n\n\t\t\tack_w\t\t\t<= 1'b0;\n\t\t\tlocal_burstbegin\t<= 1'b0;\n\t\t\tlocal_write_req\t\t<= 1'b0;\n\t\t\tlocal_burstbegin\t<= 1'b0;\n\t\t\tlocal_read_req\t\t<= 1'b0;\n\n\t\t\tcase (state)\n\n\t\t\tWAIT_READY: begin\n\t\t\t\tif (local_ready_i)\n\t\t\t\t\tstate <= IDLE;\n\t\t\tend\n\n\t\t\tIDLE: begin\n\t\t\t\tif (acc_i) begin\n\t\t\t\t\tif (we_i & local_ready_i) begin\n\t\t\t\t\t\tack_w\t\t\t<= 1'b1;\n\t\t\t\t\t\tlocal_burstbegin\t<= 1'b1;\n\t\t\t\t\t\tlocal_write_req\t\t<= 1'b1;\n\t\t\t\t\t\tlocal_size\t\t<= 1;\n\t\t\t\t\t\tstate\t\t\t<= WRITE;\n\t\t\t\t\tend\n\t\t\t\t\tif (!we_i & local_ready_i) begin\n\t\t\t\t\t\tlocal_burstbegin\t<= 1'b1;\n\t\t\t\t\t\tlocal_read_req\t\t<= 1'b1;\n\t\t\t\t\t\tstate\t\t\t<= READ;\n\t\t\t\t\t\tlocal_size\t\t<= (1<<buf_width_i);\n\t\t\t\t\t\tadr\t\t\t<= adr_i & ~get_mask(buf_width_i+2);\n\t\t\t\t\t\tcount\t\t\t<= 0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tWRITE : begin\n\t\t\t\tstate <= IDLE;\n\t\t\tend\n\n\t\t\tREAD : begin\n\t\t\t\tif (local_rdata_valid_i) begin\n\t\t\t\t\tcount <= count + 1'b1;\n\t\t\t\t\tadr <= (adr & ~get_mask(buf_width_i+2)) | ((((adr >> 2) + 1) & get_mask(buf_width_i)) << 2);\n\t\t\t\tend\n\n\t\t\t\tif (count == (1<<buf_width_i)) begin\n\t\t\t\t\tcount <= 0;\n\t\t\t\t\tstate <= IDLE;\n\t\t\t\tend\n\t\t\tend\n\n\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "count_ones_82f4207b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule count_ones (\n    input [31:0] in,\n    input clk,\n    output reg [5:0] out\n);\n\nreg [31:0] in_reg;\nreg [31:0] in_reg_pipe1;\nreg [31:0] in_reg_pipe32;\n\nreg [31:0] sum_reg;\nreg [31:0] sum_reg_pipe31;\nreg [31:0] sum_reg_pipe32;\n\nalways @(posedge clk) begin\n    in_reg_pipe1 <= in_reg;\n    in_reg_pipe32 <= in_reg_pipe1;\n    \n    sum_reg_pipe31 <= sum_reg;\n    sum_reg_pipe32 <= sum_reg_pipe31;\nend\n\nalways @(posedge clk) begin\n    in_reg <= in;\n    sum_reg <= sum_reg_pipe31 + in_reg_pipe32;\nend\n\nalways @(*) begin\n    out = sum_reg_pipe32[5:0];\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adapter_axi_stream_2_ppfifo_wl #_7bdd5501", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adapter_axi_stream_2_ppfifo_wl #(\n  parameter                         DATA_WIDTH    = 32,\n  parameter                         STROBE_WIDTH  = DATA_WIDTH / 8,\n  parameter                         USE_KEEP      = 0\n)(\n  input                             rst,\n\n  input                             i_tear_effect,\n  input                             i_fsync,\n  input       [31:0]                i_pixel_count,\n\n  //AXI Stream Input\n  input                             i_axi_clk,\n  output                            o_axi_ready,\n  input       [DATA_WIDTH - 1:0]    i_axi_data,\n  input       [STROBE_WIDTH - 1:0]  i_axi_keep,\n  input                             i_axi_last,\n  input                             i_axi_valid,\n\n  //Ping Pong FIFO Write Controller\n  output                            o_ppfifo_clk,\n  input       [1:0]                 i_ppfifo_rdy,\n  output  reg [1:0]                 o_ppfifo_act,\n  input       [23:0]                i_ppfifo_size,\n  output  reg                       o_ppfifo_stb,\n  output  reg [DATA_WIDTH:0]        o_ppfifo_data\n);\n//local parameters\nlocalparam      WAIT_FOR_TEAR_EFFECT  = 0;\nlocalparam      WAIT_FOR_FRAME        = 1;\nlocalparam      READ_FRAME            = 2;\nlocalparam      WAIT_FOR_END_TEAR     = 3;\n\nlocalparam      TEAR_WINDOW_COUNT     = 100;\n\n//registes/wires\nwire                        clk;  //Convenience Signal\nreg           [3:0]         state;\nreg           [23:0]        r_count;\nreg                         r_last;\nreg           [31:0]        r_pixel_count;\nreg                         r_prev_tear;\nreg                         r_pos_edge_tear;\n\nassign  o_ppfifo_clk    = i_axi_clk;\nassign  clk             = i_axi_clk;\nassign  o_axi_ready     = (o_ppfifo_act > 0) &&\n                          (r_count < i_ppfifo_size) &&\n                          !r_last &&\n                          (state == READ_FRAME);\n//synchronous logic\n\nalways @ (posedge clk) begin\n  o_ppfifo_stb                                <=  0;\n  r_last                                      <=  0;\n\n  if (rst) begin\n    r_count                                   <=  0;\n    o_ppfifo_act                              <=  0;\n    o_ppfifo_data                             <=  0;\n    r_pos_edge_tear                           <=  0;\n    r_pixel_count                             <=  0;\n    state                                     <=  WAIT_FOR_TEAR_EFFECT;\n  end\n  else begin\n    if ((i_ppfifo_rdy > 0) && (o_ppfifo_act == 0)) begin\n      r_count                                 <=  0;\n      if (i_ppfifo_rdy[0]) begin\n        o_ppfifo_act[0]                       <=  1;\n      end\n      else begin\n        o_ppfifo_act[1]                       <=  1;\n      end\n    end\n\n    case (state)\n      WAIT_FOR_TEAR_EFFECT: begin\n        if (r_pos_edge_tear) begin\n          r_pos_edge_tear                     <=  0;\n          r_pixel_count                       <=  0;\n          state                               <=  WAIT_FOR_FRAME;\n        end\n      end\n      WAIT_FOR_FRAME: begin\n        r_pixel_count                         <=  0;\n        if (i_fsync) begin\n          state                               <= READ_FRAME;\n          r_pixel_count                       <= 0;\n        end\n        else if (r_pixel_count < TEAR_WINDOW_COUNT) begin\n          r_pixel_count                       <= r_pixel_count + 1;\n        end\n        else begin\n          state                               <= WAIT_FOR_TEAR_EFFECT;  \n        end\n      end\n      READ_FRAME: begin\n        if (o_ppfifo_act) begin\n          if (r_last) begin\n            o_ppfifo_act                      <=  0;\n            if (r_pixel_count >= i_pixel_count) begin\n              state                           <=  WAIT_FOR_END_TEAR;\n            end\n          end\n          else if (r_count < i_ppfifo_size) begin\n            if (i_axi_valid && o_axi_ready) begin\n              o_ppfifo_stb                      <=  1;\n              r_pixel_count                     <=  r_pixel_count + 1;\n              o_ppfifo_data[DATA_WIDTH - 1: 0]  <=  i_axi_data;\n              o_ppfifo_data[DATA_WIDTH]         <=  i_axi_last;\n              r_last                            <=  i_axi_last;\n              r_count                           <=  r_count + 1;\n            end\n          end\n          else begin\n            o_ppfifo_act                        <=  0;\n          end\n        end\n      end\n      WAIT_FOR_END_TEAR: begin\n        if (!i_tear_effect) begin\n          state                                 <=  WAIT_FOR_TEAR_EFFECT;\n        end\n      end\n    endcase\n\n    //Detect the positive edge of a tear effect\n    if (!r_prev_tear && i_tear_effect) begin\n      r_pos_edge_tear                           <=  1;\n    end\n    r_prev_tear                                 <=  i_tear_effect;\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "I2C_d70d7d27", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule I2C (\n  input SDA,\n  input SCL,\n  input rst,\n  output [2:0] state,\n  output ack\n);\n\n  // Define the states\n  parameter IDLE = 3'b000;\n  parameter START = 3'b001;\n  parameter WRITE = 3'b010;\n  parameter READ = 3'b011;\n  parameter ACK = 3'b100;\n  parameter NACK = 3'b101;\n  \n  // Define the state register\n  reg [2:0] current_state;\n  \n  // Define the acknowledge register\n  reg ack_reg;\n  \n  // Define the slave address and R/W bit\n  reg [6:0] slave_address;\n  reg rw_bit;\n  \n  // Define the data buffer\n  reg [7:0] data_buffer;\n  reg [2:0] data_index;\n  \n  // Define the start condition flag\n  reg start_condition;\n  \n  // Define the SDA and SCL signals\n  reg sda_signal;\n  reg scl_signal;\n  \n  // Define the SDA and SCL signal delays\n  parameter DELAY = 10;\n  reg [3:0] delay_counter;\n  \n  // Define the state machine\n  always @(posedge SCL or posedge rst) begin\n    if (rst) begin\n      current_state <= IDLE;\n      ack_reg <= 1'b0;\n      slave_address <= 7'b0000000;\n      rw_bit <= 1'b0;\n      data_buffer <= 8'b0;\n      data_index <= 3'b000;\n      start_condition <= 1'b0;\n      sda_signal <= 1'b1;\n      scl_signal <= 1'b1;\n      delay_counter <= 4'b0000;\n    end else begin\n      case (current_state)\n        IDLE: begin\n          if (start_condition) begin\n            current_state <= START;\n          end\n        end\n        START: begin\n          if (delay_counter < DELAY) begin\n            delay_counter <= delay_counter + 1;\n          end else begin\n            delay_counter <= 4'b0000;\n            sda_signal <= 1'b0;\n            scl_signal <= 1'b0;\n            current_state <= WRITE;\n          end\n        end\n        WRITE: begin\n          if (delay_counter < DELAY) begin\n            delay_counter <= delay_counter + 1;\n          end else begin\n            delay_counter <= 4'b0000;\n            if (data_index == 3'b000) begin\n              slave_address <= {1'b0, SDA};\n              data_index <= data_index + 1;\n            end else if (data_index == 3'b001) begin\n              slave_address <= {slave_address[5:0], SDA};\n              data_index <= data_index + 1;\n            end else if (data_index == 3'b010) begin\n              slave_address <= {slave_address[5:0], SDA};\n              data_index <= data_index + 1;\n            end else if (data_index == 3'b011) begin\n              rw_bit <= SDA;\n              data_index <= data_index + 1;\n            end else if (data_index == 3'b100) begin\n              ack_reg <= ~SDA;\n              if (ack_reg) begin\n                current_state <= ACK;\n              end else begin\n                current_state <= NACK;\n              end\n              data_index <= 3'b000;\n            end\n          end\n        end\n        READ: begin\n          // Not implemented\n        end\n        ACK: begin\n          if (delay_counter < DELAY) begin\n            delay_counter <= delay_counter + 1;\n          end else begin\n            delay_counter <= 4'b0000;\n            sda_signal <= 1'b1;\n            scl_signal <= 1'b1;\n            current_state <= IDLE;\n          end\n        end\n        NACK: begin\n          if (delay_counter < DELAY) begin\n            delay_counter <= delay_counter + 1;\n          end else begin\n            delay_counter <= 4'b0000;\n            sda_signal <= 1'b1;\n            scl_signal <= 1'b1;\n            current_state <= IDLE;\n          end\n        end\n      endcase\n    end\n  end\n  \n  // Generate the SDA and SCL signals\n  always @(posedge SCL or posedge rst) begin\n    if (rst) begin\n      sda_signal <= 1'b1;\n      scl_signal <= 1'b1;\n    end else begin\n      case (current_state)\n        IDLE: begin\n          sda_signal <= 1'b1;\n          scl_signal <= 1'b1;\n        end\n        START: begin\n          sda_signal <= sda_signal;\n          scl_signal <= scl_signal;\n        end\n        WRITE: begin\n          sda_signal <= data_buffer[data_index];\n          scl_signal <= scl_signal;\n        end\n        READ: begin\n          // Not implemented\n        end\n        ACK: begin\n          sda_signal <= sda_signal;\n          scl_signal <= scl_signal;\n        end\n        NACK: begin\n          sda_signal <= sda_signal;\n          scl_signal <= scl_signal;\n        end\n      endcase\n    end\n  end\n  \n  // Assign the state and acknowledge signals\n  assign state = current_state;\n  assign ack = ack_reg;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DATA_PHYSICAL_df175320", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule DATA_PHYSICAL(\n    input wire SD_CLK,\n    input wire RESET_L,\n    input wire strobe_IN_DATA_Phy,\n    input wire ack_IN_DATA_Phy,\n    input wire [15:0] timeout_Reg_DATA_Phy,\n    input wire [3:0] blocks_DATA_Phy,\n    input wire writeRead_DATA_Phy,\n    input wire multiple_DATA_Phy,\n    input wire idle_in_DATA_Phy,\n    input wire transmission_complete_PS_Phy,\n    input wire reception_complete_SP_Phy,\n    input wire [31:0] data_read_SP_Phy,\n    input wire [31:0] dataFromFIFO_FIFO_Phy,\n    output reg serial_Ready_Phy_DATA,\n    output reg complete_Phy_DATA,\n    output reg ack_OUT_Phy_DATA,\n    output reg data_timeout_Phy_DATA,\n    output reg reset_Wrapper_Phy_PS,\n    output reg enable_pts_Wrapper_Phy_PS,\n    output reg enable_stp_Wrapper_Phy_SP,\n    output reg [31:0] dataParallel_Phy_PS,\n    output reg pad_state_Phy_PAD,\n    output reg pad_enable_Phy_PAD,\n    output reg writeFIFO_enable_Phy_FIFO,\n    output reg readFIFO_enable_Phy_FIFO,\n    output reg [31:0] dataReadToFIFO_Phy_FIFO,\n    output reg IO_enable_Phy_SD_CARD\n);\n\nparameter RESET                  = 11'b00000000001;\nparameter IDLE                   = 11'b00000000010;\nparameter FIFO_READ              = 11'b00000000100;\nparameter LOAD_WRITE             = 11'b00000001000;\nparameter SEND                   = 11'b00000010000;\nparameter WAIT_RESPONSE          = 11'b00000100000;\nparameter READ                   = 11'b00001000000;\nparameter READ_FIFO_WRITE        = 11'b00010000000;\nparameter READ_WRAPPER_RESET     = 11'b00100000000;\nparameter WAIT_ACK               = 11'b01000000000;\nparameter SEND_ACK               = 11'b10000000000;\n\nreg [15:0] timeout_input;\nreg [3:0] blocks;\nreg [10:0] STATE;\nreg [10:0] NEXT_STATE;\n\n\nalways @ (posedge SD_CLK)\nbegin\n    if (!RESET_L)\n        begin\n        STATE <= RESET;\n        end\n    else\n        begin\n            STATE <= NEXT_STATE;\n        end\nend\nalways @ (*)\nbegin\n    case (STATE)\n        RESET:\n            begin\n            serial_Ready_Phy_DATA       = 0;\n            complete_Phy_DATA           = 0;\n            ack_OUT_Phy_DATA            = 0;\n            data_timeout_Phy_DATA       = 0;\n            reset_Wrapper_Phy_PS        = 1;                 enable_pts_Wrapper_Phy_PS   = 0;\n            enable_stp_Wrapper_Phy_SP   = 0;\n            dataParallel_Phy_PS         = 32'b0;\n            pad_state_Phy_PAD           = 0;\n            pad_enable_Phy_PAD          = 0;\n            writeFIFO_enable_Phy_FIFO   = 0;\n            readFIFO_enable_Phy_FIFO    = 0;\n            dataReadToFIFO_Phy_FIFO     = 32'b0;\n            IO_enable_Phy_SD_CARD        = 0;                NEXT_STATE = IDLE;\n            end\n        IDLE:\n            begin\n            serial_Ready_Phy_DATA = 1;\n            blocks = 4'b0;\n            timeout_input = 16'b0;\n\n            if (strobe_IN_DATA_Phy && writeRead_DATA_Phy)\n                begin\n                    NEXT_STATE = FIFO_READ;\n                end\n            else\n                begin\n                    NEXT_STATE = READ;\n                end\n            end\n        FIFO_READ:\n            begin\n            writeFIFO_enable_Phy_FIFO = 1;\n            dataParallel_Phy_PS = dataFromFIFO_FIFO_Phy;\n\n            NEXT_STATE = LOAD_WRITE;\n            end\n        LOAD_WRITE:\n            begin\n            enable_pts_Wrapper_Phy_PS = 1;\n            IO_enable_Phy_SD_CARD = 0;\n            pad_state_Phy_PAD = 1;\n            pad_enable_Phy_PAD = 1;\n\n            NEXT_STATE = SEND;\n            end\n        SEND:\n            begin\n            IO_enable_Phy_SD_CARD = 1;\n            NEXT_STATE = WAIT_RESPONSE;\n            end\n        WAIT_RESPONSE:\n            begin\n            enable_pts_Wrapper_Phy_PS = 0;\n            enable_stp_Wrapper_Phy_SP = 1;\n            pad_state_Phy_PAD = 0;\n            timeout_input = timeout_input + 1;\n            if (timeout_input == timeout_Reg_DATA_Phy)\n                begin\n                    data_timeout_Phy_DATA = 1;\n                end\n            else\n                begin\n                    data_timeout_Phy_DATA = 0;\n                end\n\n            if (reception_complete_SP_Phy)\n                begin\n                    blocks = blocks + 1;\n                    if (!multiple_DATA_Phy || (blocks==blocks_DATA_Phy))\n                        begin\n                            NEXT_STATE = WAIT_ACK;\n                        end\n                    else\n                        begin\n                            NEXT_STATE = FIFO_READ;\n                        end\n                end\n            else\n                begin\n                    NEXT_STATE = WAIT_RESPONSE;\n                end\n            end\n        READ:\n            begin\n            pad_enable_Phy_PAD = 1;\n            pad_state_Phy_PAD = 0;\n            enable_stp_Wrapper_Phy_SP = 1;\n            timeout_input = timeout_input + 1;\n            if (timeout_input == timeout_Reg_DATA_Phy)\n                begin\n                    data_timeout_Phy_DATA = 1;\n                end\n            else\n                begin\n                    data_timeout_Phy_DATA = 0;\n                end\n\n            if (reception_complete_SP_Phy)\n                begin\n                    blocks = blocks + 1;\n                    NEXT_STATE = READ_FIFO_WRITE;\n                end\n            else\n                begin\n                    NEXT_STATE = READ;\n                end\n            end\n        READ_FIFO_WRITE:\n            begin\n            readFIFO_enable_Phy_FIFO = 1;\n            dataReadToFIFO_Phy_FIFO = data_read_SP_Phy;\n            enable_stp_Wrapper_Phy_SP = 0;\n            if ((blocks == blocks_DATA_Phy) || !multiple_DATA_Phy)\n                begin\n                    NEXT_STATE = WAIT_ACK;\n                end\n            else\n                begin\n                    NEXT_STATE = READ_WRAPPER_RESET;\n                end\n            end\n        READ_WRAPPER_RESET:\n            begin\n            reset_Wrapper_Phy_PS = 1;\n            NEXT_STATE = READ;\n            end\n        WAIT_ACK:\n            begin\n            complete_Phy_DATA = 1;\n            if (ack_IN_DATA_Phy)\n                begin\n                    NEXT_STATE = SEND_ACK;\n                end\n            else\n                begin\n                    NEXT_STATE = WAIT_ACK;\n                end\n            end\n        SEND_ACK:\n            begin\n                ack_OUT_Phy_DATA = 1;\n                NEXT_STATE = IDLE;\n            end\n        default:\n            begin\n            NEXT_STATE = IDLE;  end\n    endcase\nend endmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nor_buf_0bc39cea", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nor_buf (\n    Y,\n    A,\n    B,\n    C\n);\n\n    // Module ports\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    // Local signals\n    wire nor_out_Y;\n\n    //  Name  Output      Other arguments\n    nor nor_gate (nor_out_Y, A, B, C);\n    buf buffer (Y, nor_out_Y);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__lpflow_inputiso1n_8357da96", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__lpflow_inputiso1n (\n    X      ,\n    A      ,\n    SLEEP_B\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire SLEEP;\n\n    not not0 (SLEEP , SLEEP_B        );\n    or  or0  (X     , A, SLEEP       );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2_to_1_en_df1c290b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2_to_1_en(\n  input a,\n  input b,\n  input en,\n  output out\n);\n\n  assign out = en ? b : a;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "digital_circuit_d346cda3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule digital_circuit (\n    input input_1,\n    input input_2,    \n    input input_3,    \n    input input_4,    \n    output output_1,    \n    output output_2    \n);\n\n    // Implement output_1 as the AND of input_1 and input_2\n    assign output_1 = input_1 & input_2;\n    \n    // Implement output_2 as the OR of input_3 and input_4\n    assign output_2 = input_3 | input_4;\n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "opc6cpu_e29e6186", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule opc6cpu(input[15:0] din,input clk,input reset_b,input[1:0] int_b,input clken,output vpa,output vda,output vio,output[15:0] dout,output[15:0] address,output rnw);\n    parameter MOV=5'h0,AND=5'h1,OR=5'h2,XOR=5'h3,ADD=5'h4,ADC=5'h5,STO=5'h6,LD=5'h7,ROR=5'h8,JSR=5'h9,SUB=5'hA,SBC=5'hB,INC=5'hC,LSR=5'hD,DEC=5'hE,ASR=5'hF;\n    parameter HLT=5'h10,BSWP=5'h11,PPSR=5'h12,GPSR=5'h13,RTI=5'h14,NOT=5'h15,OUT=5'h16,IN=5'h17,PUSH=5'h18,POP=5'h19,CMP=5'h1A,CMPC=5'h1B;    \n    parameter FET0=3'h0,FET1=3'h1,EAD=3'h2,RDM=3'h3,EXEC=3'h4,WRM=3'h5,INT=3'h6;\n    parameter EI=3,S=2,C=1,Z=0,P0=15,P1=14,P2=13,IRLEN=12,IRLD=16,IRSTO=17,IRNPRED=18,IRWBK=19,INT_VECTOR0=16'h0002,INT_VECTOR1=16'h0004;\n    reg [15:0] OR_q,PC_q,PCI_q,result;\n    reg [19:0] IR_q; \n    reg [15:0] RF_q[15:0];\n    reg [2:0]  FSM_q;\n    reg [3:0]  swiid,PSRI_q;\n    reg [7:0]  PSR_q ;\n    reg        zero,carry,sign,enable_int,reset_s0_b,reset_s1_b,pred_q;\n    wire [4:0]  op            = {IR_q[IRNPRED],IR_q[11:8]};\n    wire [4:0]  op_d          = { (din[15:13]==3'b001),din[11:8] };\n    wire        pred_d        = (din[15:13]==3'b001) || (din[P2] ^ (din[P1] ? (din[P0] ? sign : zero): (din[P0] ? carry : 1))); wire        pred_din      = (din[15:13]==3'b001) || (din[P2] ^ (din[P1]?(din[P0]?PSR_q[S]:PSR_q[Z]):(din[P0]?PSR_q[C]:1))); wire [15:0] RF_w_p2       = (IR_q[7:4]==4'hF) ? PC_q: {16{(IR_q[7:4]!=4'h0)}} & RF_q[IR_q[7:4]];                          wire [15:0] RF_dout       = (IR_q[3:0]==4'hF) ? PC_q: {16{(IR_q[3:0]!=4'h0)}} & RF_q[IR_q[3:0]];                          wire [15:0] operand       = (IR_q[IRLEN]||IR_q[IRLD]||(op==INC)||(op==DEC)||(IR_q[IRWBK]))?OR_q:RF_w_p2;     assign {rnw,dout,address} = {!(FSM_q==WRM), RF_w_p2,(FSM_q==WRM||FSM_q==RDM)? ((op==POP)? RF_dout: OR_q)  : PC_q};\n    assign {vpa,vda,vio}      = {((FSM_q==FET0)||(FSM_q==FET1)||(FSM_q==EXEC)),({2{(FSM_q==RDM)||(FSM_q==WRM)}} & {!((op==IN)||(op==OUT)),(op==IN)||(op==OUT)})};\n    always @( * ) begin\n        case (op)\n            AND,OR               :{carry,result} = {PSR_q[C],(IR_q[8])?(RF_dout & operand):(RF_dout | operand)};\n            ADD,ADC,INC          :{carry,result} = RF_dout + operand + (IR_q[8] & PSR_q[C]);\n            SUB,SBC,CMP,CMPC,DEC :{carry,result} = RF_dout + (operand ^ 16'hFFFF) + ((IR_q[8])?PSR_q[C]:1);\n            XOR,GPSR             :{carry,result} = (IR_q[IRNPRED])?{PSR_q[C],8'b0,PSR_q}:{PSR_q[C],RF_dout ^ operand};\n            NOT,BSWP             :{result,carry} = (IR_q[10])? {~operand,PSR_q[C]} : {operand[7:0],operand[15:8],PSR_q[C]};\n            ROR,ASR,LSR          :{result,carry} = {(IR_q[10]==0)?PSR_q[C]:(IR_q[8]==1)?operand[15]:1'b0,operand};\n            default              :{carry,result} = {PSR_q[C],operand} ; endcase {swiid,enable_int,sign,carry,zero} = (op==PPSR)?operand[7:0]:(IR_q[3:0]!=4'hF)?{PSR_q[7:3],result[15],carry,!(|result)}:PSR_q;\n    end always @(posedge clk)\n        if (clken) begin\n            {reset_s0_b,reset_s1_b,pred_q} <= {reset_b,reset_s0_b,(FSM_q==FET0)?pred_din:pred_d};\n            if (!reset_s1_b)\n                {PC_q,PCI_q,PSRI_q,PSR_q,FSM_q} <= 0;\n            else begin\n                case (FSM_q)\n                    FET0   : FSM_q <= (din[IRLEN]) ? FET1 : (!pred_din) ? FET0 : ((din[11:8]==LD)||(din[11:8]==STO)||(op_d==PUSH)||(op_d==POP)) ? EAD : EXEC;\n                    FET1   : FSM_q <= (!pred_q )? FET0: ((IR_q[3:0]!=0) || (IR_q[IRLD])||IR_q[IRSTO])?EAD:EXEC;\n                    EAD    : FSM_q <= (IR_q[IRLD]) ? RDM : (IR_q[IRSTO]) ? WRM : EXEC;\n                    EXEC   : FSM_q <= ((!(&int_b) & PSR_q[EI])||((op==PPSR) && (|swiid)))?INT:((IR_q[3:0]==4'hF)||(op==JSR))?FET0:\n                                      (din[IRLEN]) ? FET1 : ((din[11:8]==LD)||(din[11:8]==STO)||(op_d==POP)||(op_d==PUSH))?EAD:(pred_d)?EXEC:FET0;\n                    WRM    : FSM_q <= (!(&int_b) & PSR_q[EI])?INT:FET0;\n                    default: FSM_q <= (FSM_q==RDM)? EXEC : FET0;  endcase \n                OR_q <= ((FSM_q==FET0)||(FSM_q==EXEC))?({16{op_d==PUSH}}^({12'b0,(op_d==DEC)||(op_d==INC)?din[7:4]:{3'b0,(op_d==POP)}})):(FSM_q==EAD)?RF_w_p2+OR_q:din;\n                if ( FSM_q == INT )\n                    {PC_q,PCI_q,PSRI_q,PSR_q[EI]} <= {(!int_b[1])?INT_VECTOR1:INT_VECTOR0,PC_q,PSR_q[3:0],1'b0} ; else if ((FSM_q==FET0)||(FSM_q==FET1)) \n                    PC_q  <= PC_q + 1;\n                else if ( FSM_q == EXEC) begin\n                    PC_q <= (op==RTI)?PCI_q: ((IR_q[3:0]==4'hF)||(op==JSR))?result:(((!(&int_b)) && PSR_q[EI])||((op==PPSR)&&(|swiid)))?PC_q:PC_q + 1;\n                    PSR_q <= (op==RTI)?{4'b0,PSRI_q}:{swiid,enable_int,sign,carry,zero}; end\n                if (((FSM_q==EXEC) && !((op==CMP)||(op==CMPC)))|| (((FSM_q==WRM)||(FSM_q==RDM)) && IR_q[IRWBK]))\n                    RF_q[IR_q[3:0]] <= (op==JSR)? PC_q : result ;\n                if ((FSM_q==FET0)||(FSM_q==EXEC))\n                    IR_q <= {(op_d==PUSH)||(op_d==POP),(din[15:13]==3'b001),(din[11:8]==STO)||(op_d==PUSH),(din[11:8]==LD)||(op_d==POP),din};\n                else if (((FSM_q==EAD && (IR_q[IRLD]||IR_q[IRSTO]))||(FSM_q==RDM)))\n                  IR_q[7:0] <= {IR_q[3:0],IR_q[7:4]}; end \n        end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pll_lock_lookup_61d04cc7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule pll_lock_lookup(\n    input clk,\n    input [6:0] divider,\n    output reg [39:0] value\n    );\n     reg [39:0] lookup [0:64];\n    wire [5:0] addr;\n   initial\n   begin\n            lookup[00]=40'b00110_00110_1111101000_1111101001_0000000001;\n            lookup[01]=40'b00110_00110_1111101000_1111101001_0000000001;\n            lookup[02]=40'b01000_01000_1111101000_1111101001_0000000001;\n            lookup[03]=40'b01011_01011_1111101000_1111101001_0000000001;\n            lookup[04]=40'b01110_01110_1111101000_1111101001_0000000001;\n            lookup[05]=40'b10001_10001_1111101000_1111101001_0000000001;\n            lookup[06]=40'b10011_10011_1111101000_1111101001_0000000001;\n            lookup[07]=40'b10110_10110_1111101000_1111101001_0000000001;\n            lookup[08]=40'b11001_11001_1111101000_1111101001_0000000001;\n            lookup[09]=40'b11100_11100_1111101000_1111101001_0000000001;\n            lookup[10]=40'b11111_11111_1110000100_1111101001_0000000001;\n            lookup[11]=40'b11111_11111_1100111001_1111101001_0000000001;\n            lookup[12]=40'b11111_11111_1011101110_1111101001_0000000001;\n            lookup[13]=40'b11111_11111_1010111100_1111101001_0000000001;\n            lookup[14]=40'b11111_11111_1010001010_1111101001_0000000001;\n            lookup[15]=40'b11111_11111_1001110001_1111101001_0000000001;\n            lookup[16]=40'b11111_11111_1000111111_1111101001_0000000001;\n            lookup[17]=40'b11111_11111_1000100110_1111101001_0000000001;\n            lookup[18]=40'b11111_11111_1000001101_1111101001_0000000001;\n            lookup[19]=40'b11111_11111_0111110100_1111101001_0000000001;\n            lookup[20]=40'b11111_11111_0111011011_1111101001_0000000001;\n            lookup[21]=40'b11111_11111_0111000010_1111101001_0000000001;\n            lookup[22]=40'b11111_11111_0110101001_1111101001_0000000001;\n            lookup[23]=40'b11111_11111_0110010000_1111101001_0000000001;\n            lookup[24]=40'b11111_11111_0110010000_1111101001_0000000001;\n            lookup[25]=40'b11111_11111_0101110111_1111101001_0000000001;\n            lookup[26]=40'b11111_11111_0101011110_1111101001_0000000001;\n            lookup[27]=40'b11111_11111_0101011110_1111101001_0000000001;\n            lookup[28]=40'b11111_11111_0101000101_1111101001_0000000001;\n            lookup[29]=40'b11111_11111_0101000101_1111101001_0000000001;\n            lookup[30]=40'b11111_11111_0100101100_1111101001_0000000001;\n            lookup[31]=40'b11111_11111_0100101100_1111101001_0000000001;\n            lookup[32]=40'b11111_11111_0100101100_1111101001_0000000001;\n            lookup[33]=40'b11111_11111_0100010011_1111101001_0000000001;\n            lookup[34]=40'b11111_11111_0100010011_1111101001_0000000001;\n            lookup[35]=40'b11111_11111_0100010011_1111101001_0000000001;\n            lookup[36]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[37]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[38]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[39]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[40]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[41]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[42]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[43]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[44]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[45]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[46]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[47]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[48]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[49]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[50]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[51]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[52]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[53]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[54]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[55]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[56]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[57]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[58]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[59]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[60]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[6]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[00]=40'b11111_11111_0011111010_1111101001_0000000001;\n            lookup[00]=40'b11111_11111_0011111010_1111101001_0000000001;\n   end\n   \n   assign addr = divider - 1;\n   always @(posedge clk)\n   begin\n       value = lookup[addr];\n   end \n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "intern_sync_604f1288", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule intern_sync\n(\n\tinput       clk       ,\n\tinput       rstn      ,\n\n\tinput       rc_is_idle,\n\n\tinput       rc_reqn,\n\toutput reg  rc_ackn\n);\n\n\n\treg [1:0] state_c, state_n;\n\nlocalparam [1:0]\n\t\tRC_Idle    = 4'd0,\n\t\tRC_ReqAck  = 4'd1;\n\n\talways @(posedge clk or negedge rstn) begin\n\t\tif (~rstn)\n\t\t\tstate_c <= RC_Idle;\n\t\telse\n\t\t\tstate_c <= state_n;\n\tend\n\n\talways @(*) begin\n\t\t{rc_ackn} = {1'b1};\n\n\t\t\n\t\tcase (state_c)\n\t\t\tRC_Idle: begin state_n = (~rc_reqn)? RC_ReqAck:RC_Idle; end\n\t\t\tRC_ReqAck:begin\n\t\t\t\tif(rc_is_idle) begin\n\t\t\t\t\tstate_n = RC_Idle;\n\t\t\t\t\trc_ackn = 1'b0;\n\t\t\t\tend else begin\n\t\t\t\t\tstate_n = RC_ReqAck;\n\t\t\t\tend\n\t\t\tend\n\t\t\tdefault: begin state_n = RC_Idle; end\n\t\tendcase\n\tend\n\nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "address_counter #_79965bf6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule address_counter #\n(\n  parameter integer COUNT_WIDTH = 13\n)\n(\n  input  wire clken, input  wire trig, input  wire clk,\n  output wire [31:0] address,\n  output wire [3:0] wen );\n\n  localparam count_max = (1 << COUNT_WIDTH) - 1;\n  reg trig_reg;\n  reg trig_detected;\n\n  reg wen_reg;\n\n  reg [COUNT_WIDTH-1:0] count;\n\n  initial count = 0;\n  initial trig_detected = 0;\n  initial wen_reg = 0;\n\n  always @(posedge clk) begin\n    trig_reg <= trig;\n    if (trig & ~trig_reg) begin\n        trig_detected <= 1;\n    end else if (count == count_max) begin\n        trig_detected <= 0;\n    end\n  end\n\n  always @(posedge clk) begin\n    if (clken) begin\n      count <= count + 1;\n      if (count == count_max) begin\n        wen_reg <= trig_detected;\n      end\n    end\n  end\n\n  assign address = count << 2;\n  assign wen = {4{wen_reg}};\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_34c5888e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register(clk, rst, load, shift_left, shift_right, serial_in, shift_reg);\n\tinput clk, rst, load, shift_left, shift_right, serial_in;\n\toutput reg [3:0] shift_reg;\n\n\talways @(posedge clk) begin\n\t\tif (rst) begin\n\t\t\tshift_reg <= 0;\n\t\tend else if (load) begin\n\t\t\tshift_reg <= serial_in;\n\t\tend else if (shift_left) begin\n\t\t\tshift_reg <= {shift_reg[2:0], shift_reg[3]};\n\t\tend else if (shift_right) begin\n\t\t\tshift_reg <= {shift_reg[1], shift_reg[3:1]};\n\t\tend\n\tend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__nand3_246fff1f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__nand3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, B, A, C        );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "servo_control_0f64a51b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule servo_control (\n  input clk,\n  input rst,\n  input [15:0] pwm_in,\n  output reg [15:0] pwm_out\n);\n\nparameter min_pulse_width = 1000; // in microseconds\nparameter max_pulse_width = 2000; // in microseconds\nparameter frequency = 50; // in Hz\nparameter resolution = 16; // in bits\n\nreg [15:0] counter = 0;\nreg [15:0] threshold = 0;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    pwm_out <= min_pulse_width;\n    counter <= 0;\n    threshold <= 0;\n  end else begin\n    counter <= counter + 1;\n    if (counter == resolution) begin\n      counter <= 0;\n      threshold <= pwm_in;\n    end\n    if (threshold > counter) begin\n      pwm_out <= max_pulse_width;\n    end else begin\n      pwm_out <= min_pulse_width;\n    end\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "alu_min_c730b6bf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule alu_min( RST, CLK, ENA, RGA, RGB, RGZ, KEY, OPT);\n\tinput RST, CLK, ENA;\n\tinput [7:0]OPT,RGA,RGB;\n\toutput [7:0]RGZ;\n\tinput [1:0]KEY;\n\treg [7:0]RGZ;\n\n\talways@(posedge CLK)begin\n\t\tif(RST) RGZ = 0;\n\t\telse begin\n\t\tcase(OPT)\n\t\t\t8'b00000001: RGZ = 0; \n\t\t\t8'b00000010: RGZ = RGA + RGB;\n\t\t\t8'b00000011: RGZ = RGA - RGB;\n\t\t\t8'b00000011: RGZ = RGA^RGB;\n\t\t\t8'b00000100: RGZ = RGA&RGB;\n\t\t\t8'b00000101: RGZ = RGA|RGB;\n\t\t\t8'b00000110: RGZ = RGA&&RGB;\n\t\t\t8'b00000111: RGZ = RGA||RGB;\n\n\t\t\t8'b00001000: RGZ = RGA+1;\n\t\t\t8'b00001001: RGZ = RGA-1;\n\t\t\t8'b00001010: RGZ = RGA<<1;\n\t\t\t8'b00001011: RGZ = RGA>>1;\n\t\t\t8'b00001100: RGZ = !RGA;\n\t\t\t8'b00001101: RGZ = ~RGA;\n\t\t\t8'b00001110: RGZ = RGA+RGA;\n\t\t\t8'b00001111: RGZ = RGA-RGA;\n\n\t\t\t8'b00010000: RGZ = RGB+RGZ;\n\t\t\t8'b00010001: RGZ = RGB-RGZ;\n\t\t\t\n\t\t\t8'b00010011: RGZ = RGB^RGZ;\n\t\t\t8'b00010100: RGZ = RGB&RGZ;\n\t\t\t8'b00010101: RGZ = RGB|RGZ;\n\t\t\t8'b00010110: RGZ = RGB&&RGZ;\n\t\t\t8'b00010111: RGZ = RGB||RGZ;\n\n\t\t\t8'b00111000: RGZ = RGZ+1;\n\t\t\t8'b00111001: RGZ = RGZ-1;\n\t\t\t8'b00111010: RGZ = RGZ<<1;\n\t\t\t8'b00111011: RGZ = RGZ>>1;\n\t\t\t8'b00111100: RGZ = !RGZ;\n\t\t\t8'b00111101: RGZ = ~RGZ;\n\t\t\t8'b00111110: RGZ = RGB+RGZ;\n\t\t\t8'b00111111: RGZ = RGB-RGZ;\n\n\t\t\t8'b00100000: RGZ = RGA+RGB;\n\t\t\t8'b00100001: RGZ = RGA-RGB;\n\t\t\t\n\t\t\t8'b00100011: RGZ = RGA^RGB;\n\t\t\t8'b00100100: RGZ = RGA&RGB;\n\t\t\t8'b00100101: RGZ = RGA|RGB;\n\t\t\t8'b00100110: RGZ = RGA&&RGB;\n\t\t\t8'b00100111: RGZ = RGA||RGB;\n\n\t\t\t8'b00101000: RGZ = RGA+1;\n\t\t\t8'b00101001: RGZ = RGA-1;\n\t\t\t8'b00101010: RGZ = RGA<<1;\n\t\t\t8'b00101011: RGZ = RGA>>1;\n\t\t\t8'b00101100: RGZ = !RGA;\n\t\t\t8'b00101101: RGZ = ~RGA;\n\t\t\t8'b00101110: RGZ = RGA+RGA;\n\t\t\t8'b00101111: RGZ = RGA-RGA;\n\n\t\t\t8'b00110000: RGZ = RGZ+RGA;\n\t\t\t8'b00110001: RGZ = RGZ-RGA;\n\t\t\t\n\t\t\t8'b00111000: RGZ = RGZ+1;\n\t\t\t8'b00111001: RGZ = RGZ-1;\n\t\t\t8'b00111010: RGZ = RGZ<<1;\n\t\t\t8'b00111011: RGZ = RGZ>>1;\n\t\t\t8'b00111100: RGZ = !RGZ;\n\t\t\t8'b00111101: RGZ = ~RGZ;\n\t\t\t8'b00111110: RGZ = RGZ+RGB;\n\t\t\t8'b00111111: RGZ = RGZ-RGB;\n\t\t\t8'b01000000: RGZ=RGA+RGB;\n\t\t\t8'b01000001: RGZ=RGA-RGB;\n\t\t\t8'b01000010: RGZ=RGB-1;\n\n\t\t\t8'b01000100: RGZ=RGA&&RGB;\n\t\t\t8'b01000101: RGZ=RGA||RGB;\n\t\t\t8'b01000110: RGZ=!RGA;\n\t\t\t8'b01000111: RGZ=~RGA;\n\n\t\t\t8'b01001000: RGZ=RGA&RGB;\n\t\t\t8'b01001001: RGZ=RGA|RGB;\n\t\t\t8'b01001010: RGZ=RGA^RGB;\n\t\t\t8'b01001011: RGZ=RGA<<1;\n\t\t\t8'b01001100: RGZ=RGA>>1;\n\t\t\t8'b01001101: RGZ=RGA+1;\n\t\t\t8'b01001110: RGZ=RGA-1;\n\t\t\t8'b01001111: RGZ=RGA-1;\n\n\t\t\t8'b01010000: RGZ=RGA+RGB;\n\t\t\t8'b01010001: RGZ=RGA-RGB;\n\t\t\t8'b01010010: RGZ=RGB-1;\n\t\t\t8'b01010011: RGZ=RGA*RGB;\n\t\t\t8'b01010100: RGZ=RGA&&RGB;\n\t\t\t8'b01010101: RGZ=RGA||RGB;\n\t\t\t8'b01010110: RGZ=!RGA;\n\t\t\t8'b01010111: RGZ=~RGA;\n\n\t\t\t8'b01011000: RGZ=RGA&RGB;\n\t\t\t8'b01011001: RGZ=RGA|RGB;\n\t\t\t8'b01011010: RGZ=RGA^RGB;\n\t\t\t8'b01011011: RGZ=RGA<<1;\n\t\t\t8'b01011100: RGZ=RGA>>1;\n\t\t\t8'b01011101: RGZ=RGA+1;\n\t\t\t8'b01011110: RGZ=RGA-1;\n\t\t\t8'b01011111: RGZ=RGA-1;\n\n\t\t\t8'b01100000: RGZ=RGA+RGB;\n\t\t\t8'b01100001: RGZ=RGA-RGB;\n\t\t\t8'b01100010: RGZ=RGB-1;\n\t\t\t\n\t\t\t8'b01100100: RGZ=RGA&&RGB;\n\t\t\t8'b01100101: RGZ=RGA||RGB;\n\t\t\t8'b01100110: RGZ=!RGA;\n\t\t\t8'b01100111: RGZ=~RGA;\n\n\t\t\t8'b01101000: RGZ=RGA&RGB;\n\t\t\t8'b01101001: RGZ=RGA|RGB;\n\t\t\t8'b01101010: RGZ=RGA^RGB;\n\t\t\t8'b01101011: RGZ=RGA<<1;\n\t\t\t8'b01101100: RGZ=RGA>>1;\n\t\t\t8'b01101101: RGZ=RGA+1;\n\t\t\t8'b01101110: RGZ=RGA-1;\n\t\t\t8'b01101111: RGZ=RGA-1;\n\n\t\t\t8'b01110000: RGZ=RGA+RGB;\n\t\t\t8'b01110001: RGZ=RGA-RGB;\n\t\t\t8'b01110010: RGZ=RGB-1;\n\t\t\t8'b01110011: RGZ=RGA*RGB;\n\t\t\t8'b01110100: RGZ=RGA&&RGB;\n\t\t\t8'b01110101: RGZ=RGA||RGB;\n\t\t\t8'b01110110: RGZ=!RGA;\n\t\t\t8'b01110111: RGZ=~RGA;\n\n\t\t\t8'b01111000: RGZ=RGA&RGB;\n\t\t\t8'b01111001: RGZ=RGA|RGB;\n\t\t\t8'b01111010: RGZ=RGA^RGB;\n\t\t\t8'b01111011: RGZ=RGA<<1;\n\t\t\t8'b01111100: RGZ=RGA>>1;\n\t\t\t8'b01111101: RGZ=RGA+1;\n\t\t\t8'b01111110: RGZ=RGA-1;\n\t\t\t8'b01111111: RGZ=RGA-1;\n\n\t\t\t8'b10000000: RGZ=RGA+RGB;\n\t\t\t8'b10000001: RGZ=RGA-RGB;\n\t\t\t8'b10000010: RGZ=RGB-1;\n\t\t\t\n\t\t\t8'b10000100: RGZ=RGA&&RGB;\n\t\t\t8'b10000101: RGZ=RGA||RGB;\n\t\t\t8'b10000110: RGZ=!RGA;\n\t\t\t8'b10000111: RGZ=~RGA;\n\n\t\t\t8'b10001000: RGZ=RGA&RGB;\n\t\t\t8'b10001001: RGZ=RGA|RGB;\n\t\t\t8'b10001010: RGZ=RGA^RGB;\n\t\t\t8'b10001011: RGZ=RGA<<1;\n\t\t\t8'b10001100: RGZ=RGA>>1;\n\t\t\t8'b10001101: RGZ=RGA+1;\n\t\t\t8'b10001110: RGZ=RGA-1;\n\t\t\t8'b10001111: RGZ=RGA-1;\n\n\t\t\t8'b10010000: RGZ=RGA+RGB;\n\t\t\t8'b10010001: RGZ=RGA-RGB;\n\t\t\t8'b10010010: RGZ=RGB-1;\n\n\t\t\t8'b10010100: RGZ=RGA&&RGB;\n\t\t\t8'b10010101: RGZ=RGA||RGB;\n\t\t\t8'b10010110: RGZ=!RGA;\n\t\t\t8'b10010111: RGZ=~RGA;\n\n\t\t\t8'b10011000: RGZ=RGA&RGB;\n\t\t\t8'b10011001: RGZ=RGA|RGB;\n\t\t\t8'b10011010: RGZ=RGA^RGB;\n\t\t\t8'b10011011: RGZ=RGA<<1;\n\t\t\t8'b10011100: RGZ=RGA>>1;\n\t\t\t8'b10011101: RGZ=RGA+1;\n\t\t\t8'b10011110: RGZ=RGA-1;\n\t\t\t8'b10011111: RGZ=RGA-1;\n\n\t\t\t8'b10100000: RGZ=RGA+RGB;\n\t\t\t8'b10100001: RGZ=RGA-RGB;\n\t\t\t8'b10100010: RGZ=RGB-1;\n\t\t\t8'b10100011: RGZ=RGA*RGB;\n\t\t\t8'b10100100: RGZ=RGA&&RGB;\n\t\t\t8'b10100101: RGZ=RGA||RGB;\n\t\t\t8'b10100110: RGZ=!RGA;\n\t\t\t8'b10100111: RGZ=~RGA;\n\n\t\t\t8'b10101000: RGZ=RGA&RGB;\n\t\t\t8'b10101001: RGZ=RGA|RGB;\n\t\t\t8'b10101010: RGZ=RGA^RGB;\n\t\t\t8'b10101011: RGZ=RGA<<1;\n\t\t\t8'b10101100: RGZ=RGA>>1;\n\t\t\t8'b10101101: RGZ=RGA+1;\n\t\t\t8'b10101110: RGZ=RGA-1;\n\t\t\t8'b10101111: RGZ=RGA-1;\n\n\t\t\t8'b10110000: RGZ=RGA+RGB;\n\t\t\t8'b10110001: RGZ=RGA-RGB;\n\t\t\t8'b10110010: RGZ=RGB-1;\n\t\t\t8'b10110011: RGZ=RGA*RGB;\n\t\t\t8'b10110100: RGZ=RGA&&RGB;\n\t\t\t8'b10110101: RGZ=RGA||RGB;\n\t\t\t8'b10110110: RGZ=!RGA;\n\t\t\t8'b10110111: RGZ=~RGA;\n\n\t\t\t8'b10111000: RGZ=RGA&RGB;\n\t\t\t8'b10111001: RGZ=RGA|RGB;\n\t\t\t8'b10111010: RGZ=RGA^RGB;\n\t\t\t8'b10111011: RGZ=RGA<<1;\n\t\t\t8'b10111100: RGZ=RGA>>1;\n\t\t\t8'b10111101: RGZ=RGA+1;\n\t\t\t8'b10111110: RGZ=RGA-1;\n\t\t\t8'b10111111: RGZ=RGA-1;\n\n\t\t\t8'b11000000: RGZ=RGA+RGB;\n\t\t\t8'b11000001: RGZ=RGA-RGB;\n\t\t\t8'b11000010: RGZ=RGB-1;\n\t\t\t8'b11000011: RGZ=RGA*RGB;\n\t\t\t8'b11000100: RGZ=RGA&&RGB;\n\t\t\t8'b11000101: RGZ=RGA||RGB;\n\t\t\t8'b11000110: RGZ=!RGA;\n\t\t\t8'b11000111: RGZ=~RGA;\n\n\t\t\t8'b11001000: RGZ=RGA&RGB;\n\t\t\t8'b11001001: RGZ=RGA|RGB;\n\t\t\t8'b11001010: RGZ=RGA^RGB;\n\t\t\t8'b11001011: RGZ=RGA<<1;\n\t\t\t8'b11001100: RGZ=RGA>>1;\n\t\t\t8'b11001101: RGZ=RGA+1;\n\t\t\t8'b11001110: RGZ=RGA-1;\n\t\t\t8'b11001111: RGZ=RGA-1;\n\n\t\t\t8'b11010000: RGZ=RGA+RGB;\n\t\t\t8'b11010001: RGZ=RGA-RGB;\n\t\t\t8'b11010010: RGZ=RGB-1;\n\t\t\t8'b11010011: RGZ=RGA*RGB;\n\t\t\t8'b11010100: RGZ=RGA&&RGB;\n\t\t\t8'b11010101: RGZ=RGA||RGB;\n\t\t\t8'b11010110: RGZ=!RGA;\n\t\t\t8'b11010111: RGZ=~RGA;\n\n\t\t\t8'b11011000: RGZ=RGA&RGB;\n\t\t\t8'b11011001: RGZ=RGA|RGB;\n\t\t\t8'b11011010: RGZ=RGA^RGB;\n\t\t\t8'b11011011: RGZ=RGA<<1;\n\t\t\t8'b11011100: RGZ=RGA>>1;\n\t\t\t8'b11011101: RGZ=RGA+1;\n\t\t\t8'b11011110: RGZ=RGA-1;\n\t\t\t8'b11011111: RGZ=RGA-1;\n\n\t\t\t8'b11100000: RGZ=RGA+RGB;\n\t\t\t8'b11100001: RGZ=RGA-RGB;\n\t\t\t8'b11100010: RGZ=RGB-1;\n\t\t\t8'b11100011: RGZ=RGA*RGB;\n\t\t\t8'b11100100: RGZ=RGA&&RGB;\n\t\t\t8'b11100101: RGZ=RGA||RGB;\n\t\t\t8'b11100110: RGZ=!RGA;\n\t\t\t8'b11100111: RGZ=~RGA;\n\n\t\t\t8'b11101000: RGZ=RGA&RGB;\n\t\t\t8'b11101001: RGZ=RGA|RGB;\n\t\t\t8'b11101010: RGZ=RGA^RGB;\n\t\t\t8'b11101011: RGZ=RGA<<1;\n\t\t\t8'b11101100: RGZ=RGA>>1;\n\t\t\t8'b11101101: RGZ=RGA+1;\n\t\t\t8'b11101110: RGZ=RGA-1;\n\t\t\t8'b11101111: RGZ=RGA-1;\n\n\t\t\t8'b11110000: RGZ=RGA+RGB;\n\t\t\t8'b11110001: RGZ=RGA-RGB;\n\t\t\t8'b11110010: RGZ=RGB-1;\n\t\t\t8'b11110011: RGZ=RGA*RGB;\n\t\t\t8'b11110100: RGZ=RGA&&RGB;\n\t\t\t8'b11110101: RGZ=RGA||RGB;\n\t\t\t8'b11110110: RGZ=!RGA;\n\t\t\t8'b11110111: RGZ=~RGA;\n\n\t\t\t8'b11111000: RGZ=RGA&RGB;\n\t\t\t8'b11111001: RGZ=RGA|RGB;\n\t\t\t8'b11111010: RGZ=RGA^RGB;\n\t\t\t8'b11111011: RGZ=RGA<<1;\n\t\t\t8'b11111100: RGZ=RGA>>1;\n\t\t\t8'b11111101: RGZ=RGA+1;\n\t\t\t8'b11111110: RGZ=RGA-1;\n\t\t\t8'b11111111: RGZ=RGA-1;\n\t\tendcase\n\t\tend\n\tend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "AdlerChecksum #_a2386f97", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule AdlerChecksum #(\n  parameter n = 16 // number of input bytes\n)(\n  input [n*8-1:0] in,\n  input [15:0] check,\n  output reg error,\n  output reg [15:0] out\n);\n\n\nreg [15:0] A = 1;\nreg [15:0] B = 1;\n\ninteger i;\n\nalways @(*) begin\n  A = 1;\n  B = 1;\n  for (i = 0; i < n; i = i + 1) begin\n    A = (A + in[i*8 +: 8]) % 65521;\n    B = (B + A) % 65521;\n  end\n  out = (B << 16) | A;\nend\n\nalways @(*) begin\n  error = (out == check) ? 0 : 1;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_4151a2d7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder(a, b, sum, carry_out);\n  \n  input [3:0] a;\n  input [3:0] b;\n  output [3:0] sum;\n  output carry_out;\n\n  assign {carry_out, sum} = a + b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "afifo_sram #_1b583428", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule afifo_sram #(\n    parameter DEPTH =256,\n    parameter ADDRESS_WIDTH = 8, \n    parameter WIDTH=8\n)(\n    input CLK,\n    input REN,\n    input WEN,\n    input RESET,\n    input valid_in,\n    input [WIDTH-1:0] Data_in,\n    output [WIDTH-1:0] Data_out,\n    output Full_out,\n    output Empty_out\n);\n\n\nreg [ADDRESS_WIDTH-1:0] read_ptr;\nreg [ADDRESS_WIDTH-1:0] write_ptr;\nwire [ADDRESS_WIDTH-1:0] next_write_ptr;\nwire [ADDRESS_WIDTH-1:0] next_read_ptr;\nwire [ADDRESS_WIDTH-1:0] mem_addr;\nreg [WIDTH-1:0] mem [DEPTH-1:0];\n\nassign mem_addr = REN ? read_ptr : write_ptr;\nassign Data_out = mem[mem_addr];\n\nassign Full_out = (next_write_ptr == read_ptr) & (REN==1'b0);\nassign Empty_out = (write_ptr == read_ptr) & (WEN==1'b0);\n\nalways @(posedge CLK) begin\n    if (RESET) begin\n        read_ptr <= 0;\n        write_ptr <= 0;\n    end else begin\n        if (WEN && !Full_out) begin\n            mem[write_ptr] <= Data_in;\n            write_ptr <= next_write_ptr;\n        end\n        if (REN && !Empty_out && valid_in) begin\n            read_ptr <= next_read_ptr;\n        end\n    end\nend\n\nassign next_write_ptr = (write_ptr == DEPTH-1) ? 0 : write_ptr + 1;\nassign next_read_ptr = (read_ptr == DEPTH-1) ? 0 : read_ptr + 1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "encryption_module_432be79e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule encryption_module(\n  input aclk,\n  input reset,\n  input [15:0] data_in,\n  output reg [15:0] data_out\n);\n\n  reg [7:0] A;\n  reg [7:0] B;\n  reg [7:0] rotated_A;\n  reg [15:0] result;\n\n  always @(posedge aclk) begin\n    if (reset) begin\n      A <= 8'd0;\n      B <= 8'd0;\n      rotated_A <= 8'd0;\n      result <= 16'd0;\n      data_out <= 16'd0;\n    end else begin\n      A <= data_in[15:8];\n      B <= data_in[7:0];\n\n      rotated_A <= {A[5:0], A[7:6]};\n      result <= rotated_A + B;\n      data_out <= {result[15:8], result[7:0]};\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fourbitmuxcase_6a998ba9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fourbitmuxcase(in, s, out);\n\tinput wire[3: 0] in;\n\tinput wire[1: 0] s;\n\toutput wire out;\n\treg _out;\n\talways @(in or s)\n\t\tcase (s)\n\t\t\t2'b00: _out = in[0];\n\t\t\t2'b01: _out = in[1];\n\t\t\t2'b10: _out = in[2];\n\t\t\t2'b11: _out = in[3];\n\t\t\tdefault: _out = 1'b0;\n\t\tendcase\n\tassign out = _out;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "acc_e87633a5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule acc (input clock, input reset, input clear, input enable_in, output reg enable_out,\n            input signed [30:0] addend, output reg signed [33:0] sum );\n\n   always @(posedge clock)\n     if(reset)\n       sum <= #1 34'd0;\n     else if(clear)\n       sum <= #1 addend;\n     else if(enable_in)\n       sum <= #1 sum + addend;\n\n   always @(posedge clock)\n     enable_out <= #1 enable_in;\n   \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "CRC_16_d7bbea6e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule CRC_16(BITVAL, Enable, CLK, RST, CRC);\n input        BITVAL;input Enable;\n   input        CLK;                           input        RST;                             output reg [15:0] CRC;                               wire         inv;\n   \n   assign inv = BITVAL ^ CRC[15];                   always @(posedge CLK or posedge RST) begin\n\t\tif (RST) begin\n\t\t\tCRC = 0;   \n\t\t\n        end\n      else begin\n        if (Enable==1) begin\n         CRC[15] = CRC[14];\n         CRC[14] = CRC[13];\n         CRC[13] = CRC[12];\n         CRC[12] = CRC[11] ^ inv;\n         CRC[11] = CRC[10];\n         CRC[10] = CRC[9];\n         CRC[9] = CRC[8];\n         CRC[8] = CRC[7];\n         CRC[7] = CRC[6];\n         CRC[6] = CRC[5];\n         CRC[5] = CRC[4] ^ inv;\n         CRC[4] = CRC[3];\n         CRC[3] = CRC[2];\n         CRC[2] = CRC[1];\n         CRC[1] = CRC[0];\n         CRC[0] = inv;\n        end\n         end\n      end\n   \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SensorFSM #_96c6f568", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule SensorFSM #(\n  parameter DataWidth = 8\n) (\n  input                        Reset_n_i,\n  input                        Clk_i,\n  input                        Enable_i,\n  output reg                   CpuIntr_o,\n  output     [2*DataWidth-1:0] SensorValueL_o,\n  output     [2*DataWidth-1:0] SensorValueR_o,\n  output reg                   MeasureFSM_QueryLocal_o,\n  output reg                   MeasureFSM_QueryRemote_o,\n  input                        MeasureFSM_Done_i,\n  input                        MeasureFSM_Error_i,\n  input     [DataWidth-1:0]    MeasureFSM_Byte0_i,\n  input     [DataWidth-1:0]    MeasureFSM_Byte1_i,\n  input [2*DataWidth-1:0]      ParamCounterPresetH_i,\n  input [2*DataWidth-1:0]      ParamCounterPresetL_i\n);\n\n  localparam stDisabled    = 3'd0;\n  localparam stIdle        = 3'd1;\n  localparam stQueryLocal  = 3'd2;\n  localparam stWait1       = 3'd3;\n  localparam stQueryRemote = 3'd4;\n  localparam stNotify      = 3'd5;\n  localparam stError       = 3'd6;\n  reg  [2:0]             SensorFSM_State;\n  reg  [2:0]             SensorFSM_NextState;\n  wire                   SensorFSM_TimerOvfl;\n  reg                    SensorFSM_TimerPreset;\n  reg                    SensorFSM_TimerEnable;\n  reg                    SensorFSM_StoreLocal;\n  reg                    SensorFSM_StoreRemote;\n  wire [2*DataWidth-1:0] SensorValue;\n  reg  [2*DataWidth-1:0] WordL;\n  reg  [2*DataWidth-1:0] WordR;\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      SensorFSM_State <= stDisabled;\n    end\n    else\n    begin\n      SensorFSM_State <= SensorFSM_NextState;\n    end  \n  end\n\n  always @(SensorFSM_State, Enable_i, SensorFSM_TimerOvfl, MeasureFSM_Done_i, MeasureFSM_Error_i)\n  begin  SensorFSM_NextState      = SensorFSM_State;\n    SensorFSM_TimerPreset    = 1'b0;\n    SensorFSM_TimerEnable    = 1'b0;\n    MeasureFSM_QueryLocal_o  = 1'b0;\n    MeasureFSM_QueryRemote_o = 1'b0;\n    SensorFSM_StoreLocal     = 1'b0;\n    SensorFSM_StoreRemote    = 1'b0;\n    CpuIntr_o                = 1'b0;\n    case (SensorFSM_State)\n      stDisabled: begin\n        if (Enable_i == 1'b1)\n        begin\n          SensorFSM_NextState     = stIdle;\n          SensorFSM_TimerPreset   = 1'b1;  SensorFSM_TimerEnable   = 1'b0;\n        end\n      end\n      stIdle: begin\n        if (Enable_i == 1'b0)\n        begin\n          SensorFSM_NextState     = stDisabled;\n        end\n        else\n        if (SensorFSM_TimerOvfl == 1'b1)\n        begin\n          SensorFSM_NextState     = stQueryLocal;\n          MeasureFSM_QueryLocal_o = 1'b1;\n        end\n        else\n        begin\n          SensorFSM_TimerEnable   = 1'b1;  end\n      end\n      stQueryLocal: begin\n        if (MeasureFSM_Error_i == 1'b1)\n        begin\n          SensorFSM_NextState     = stError;\n          CpuIntr_o               = 1'b1;  end\n        else if (MeasureFSM_Done_i == 1'b1)\n        begin\n          SensorFSM_StoreLocal     = 1'b1;  SensorFSM_NextState      = stWait1;\n        end\n      end\n      stWait1: begin\n        MeasureFSM_QueryRemote_o = 1'b1;\n        SensorFSM_NextState      = stQueryRemote;\n      end\n      stQueryRemote: begin\n        if (MeasureFSM_Error_i == 1'b1)\n        begin\n          SensorFSM_NextState     = stError;\n          CpuIntr_o               = 1'b1;  end\n        else if (MeasureFSM_Done_i == 1'b1)\n        begin\n          SensorFSM_StoreRemote   = 1'b1;  SensorFSM_NextState     = stNotify;\n        end\n      end\n      stNotify: begin\n        SensorFSM_TimerPreset   = 1'b1;  CpuIntr_o               = 1'b1;  SensorFSM_NextState     = stIdle;\n      end\n      stError: begin\n        if (Enable_i == 1'b0)\n        begin\n          SensorFSM_NextState     = stDisabled;\n        end\n      end\n      default: begin\n      end\n    endcase\n  end \n\n  reg [31:0] SensorFSM_Timer;\n  \n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      SensorFSM_Timer <= 32'd0;\n    end\n    else\n    begin\n      if (SensorFSM_TimerPreset)\n      begin\n        SensorFSM_Timer <= {ParamCounterPresetH_i, ParamCounterPresetL_i};\n      end\n      else if (SensorFSM_TimerEnable)\n      begin\n        SensorFSM_Timer <= SensorFSM_Timer - 1'b1;\n      end\n    end  \n  end\n\n  assign SensorFSM_TimerOvfl = (SensorFSM_Timer == 0) ? 1'b1 : 1'b0;\n\n  assign SensorValue = {MeasureFSM_Byte1_i, MeasureFSM_Byte0_i};\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      WordL <= 16'd0;\n      WordR <= 16'd0;\n    end\n    else\n    begin\n      if (SensorFSM_StoreLocal)\n      begin\n        WordL <= SensorValue;\n      end\n      if (SensorFSM_StoreRemote)\n      begin\n        WordR <= SensorValue;\n      end\n    end  \n  end\n\n  assign SensorValueL_o = WordL;\n  assign SensorValueR_o = WordR;\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ExtADCSimple_4a143165", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ExtADCSimple (\n  input Reset_n_i,\n  input Clk_i,\n  input Enable_i,\n  output reg CpuIntr_o,\n  output reg SensorPower_o,\n  output reg SensorStart_o,\n  input SensorReady_i,\n  output reg AdcStart_o,\n  input AdcDone_i,\n  input [15:0] AdcValue_i,\n  input [15:0] PeriodCounterPreset_i,\n  output [15:0] SensorValue_o\n);\n\n  // Sensor FSM\n  localparam stDisabled     = 3'b000;\n  localparam stIdle         = 3'b001;\n  localparam stSensorPower  = 3'b010;\n  localparam stSensorSettle = 3'b011;\n  localparam stMeasure      = 3'b100;\n  reg  [2:0]             State;\n  reg  [2:0]             NextState;\n  wire                   TimerOvfl;\n  reg                    TimerPreset;\n  reg                    TimerEnable;\n  wire                   DiffTooLarge;\n  reg                    StoreNewValue;\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      State <= stDisabled;\n    end\n    else\n    begin // rising clock edge\n      // state register\n      State <= NextState;\n    end  \n  end\n\n  always @(State, Enable_i, TimerOvfl, SensorReady_i, AdcDone_i, DiffTooLarge)\n  begin  // process CombProc\n    NextState     = State;\n    // control signal default values\n    TimerPreset   = 1'b1;\n    TimerEnable   = 1'b0;\n    SensorPower_o = 1'b0;\n    SensorStart_o = 1'b0;\n    AdcStart_o    = 1'b0;\n    StoreNewValue = 1'b0;\n    CpuIntr_o     = 1'b0;\n    // next state and output logic\n    case (State)\n      stDisabled: begin\n        if (Enable_i == 1'b1)\n        begin\n          NextState     = stIdle;\n          TimerPreset   = 1'b0;\n          TimerEnable   = 1'b1;\n        end\n      end\n      stIdle: begin\n        if (Enable_i == 1'b0)\n        begin\n          NextState     = stDisabled;\n        end\n        else\n        if (TimerOvfl == 1'b1)\n        begin\n          NextState     = stSensorPower;\n          SensorPower_o = 1'b1;\n        end\n        else\n        begin\n          TimerPreset   = 1'b0;\n          TimerEnable   = 1'b1;\n        end\n      end\n      stSensorPower: begin\n        SensorPower_o = 1'b1;\n        SensorStart_o = 1'b1;\n        NextState     = stSensorSettle;\n      end\n      stSensorSettle: begin\n        SensorPower_o = 1'b1;\n        SensorStart_o = 1'b1;\n        if (SensorReady_i == 1'b1) \n        begin\n          NextState     = stMeasure;\n          AdcStart_o    = 1'b1;\n        end\n      end\n      stMeasure: begin\n        SensorPower_o = 1'b1;\n        SensorStart_o = 1'b1;\n        AdcStart_o    = 1'b1;\n        if (AdcDone_i == 1'b1)\n        begin\n          NextState     = stIdle;\n          StoreNewValue = 1'b1;  // store new value\n          CpuIntr_o     = 1'b1;  // notify CPU\n        end\n      end\n      default: begin\n      end\n    endcase\n  end \n\n  /////////////////////////////////////////////////////////////////////////////\n  // Word Arithmetic //////////////////////////////////////////////////////////\n  /////////////////////////////////////////////////////////////////////////////\n\n  reg [15:0] Timer;\n  \n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      Timer <= 16'd0;\n    end\n    else\n    begin\n      if (TimerPreset)\n      begin\n        Timer <= PeriodCounterPreset_i;\n      end\n      else if (TimerEnable)\n      begin\n        Timer <= Timer - 1'b1;\n      end\n    end  \n  end\n\n  assign TimerOvfl = (Timer == 0) ? 1'b1 : 1'b0;\n\n  /////////////////////////////////////////////////////////////////////////////\n  // Word Arithmetic\n  // interconnecting signals\n  reg  [15:0] Word0;\n  wire [15:0] AbsDiffResult;\n\n  always @(negedge Reset_n_i or posedge Clk_i)\n  begin\n    if (!Reset_n_i)\n    begin\n      Word0 <= 16'd0;\n    end\n    else\n    begin\n      if (StoreNewValue)\n      begin\n        Word0 <= AdcValue_i;\n      end\n    end  \n  end\n\n  assign SensorValue_o = Word0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rs_fe1_pre_dec_bc67e86d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule rs_fe1_pre_dec\n(\n\t\tinput\twire\t[13:0]\taddr_i,\n\t\toutput\twire\t\tpre_dec_o,\n\t\toutput\twire\t\tpre_dec_err_o\n\t);\n\n\tparameter N_DOMAINS = 2;\n\n    reg pre_dec;\n    reg pre_dec_err;\n    assign pre_dec_o = pre_dec;\n    assign pre_dec_err_o = pre_dec_err;\n\n    always @(addr_i) begin\n        pre_dec     = 0;\n        pre_dec_err = 0;\n        case (addr_i[5:2])\n            'h0, 'h8, 'ha: pre_dec = 0;\n            'h1, 'h2, 'h3, 'h4, 'h5, 'h6, 'h7: pre_dec = 1;\n            default: begin \n                pre_dec     = 0;\n                pre_dec_err = 1;\n            end\n        endcase\n    end\n\n\tendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "amiq_mux2_1_8382f2fc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule amiq_mux2_1(input clk, input sel, input in0, input in1, output reg out);\n\tinitial out=0;\n\t\n\talways@(posedge clk) begin\n\t\tout<=sel?in1:in0;\t\n\tend\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FSM #_6342a00b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2 // number of output signals\n)(\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk\n);\n\n\nparameter s = 8; // number of states in the FSM\n\nreg [s-1:0] state;\nreg [m-1:0] output_reg;\n\nalways @ (posedge clk) begin\n  case(state)\n    3'b000: begin // state 0\n      if (in[0] && !in[1]) begin\n        state <= 3'b001;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b000;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b001: begin // state 1\n      if (in[0] && !in[1]) begin\n        state <= 3'b011;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b000;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b001;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b010: begin // state 2\n      if (in[0] && !in[1]) begin\n        state <= 3'b000;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b110;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b010;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b011: begin // state 3\n      if (in[0] && !in[1]) begin\n        state <= 3'b111;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b100;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b011;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b100: begin // state 4\n      if (in[0] && !in[1]) begin\n        state <= 3'b101;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b100;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b101: begin // state 5\n      if (in[0] && !in[1]) begin\n        state <= 3'b110;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b001;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b101;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b110: begin // state 6\n      if (in[0] && !in[1]) begin\n        state <= 3'b100;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b011;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b110;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b111: begin // state 7\n      if (in[0] && !in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b101;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b111;\n        output_reg <= 2'b00;\n      end\n    end\n  endcase\nend\n\nassign out = output_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_3956c6be", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1(\n    input A,\n    input B,\n    input sel,\n    output Y\n);\n\nassign Y = sel ? B : A;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rising_edge_detector_c9792474", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rising_edge_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] pipeline_reg [2:0];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        pipeline_reg[0] <= 0;\n        pipeline_reg[1] <= 0;\n        pipeline_reg[2] <= 0;\n        out <= 0;\n    end else begin\n        pipeline_reg[0] <= in;\n        pipeline_reg[1] <= pipeline_reg[0];\n        pipeline_reg[2] <= pipeline_reg[1];\n        \n        out[0] <= pipeline_reg[2][0] & ~pipeline_reg[1][0] & pipeline_reg[0][0];\n        out[1] <= pipeline_reg[2][1] & ~pipeline_reg[1][1] & pipeline_reg[0][1];\n        out[2] <= pipeline_reg[2][2] & ~pipeline_reg[1][2] & pipeline_reg[0][2];\n        out[3] <= pipeline_reg[2][3] & ~pipeline_reg[1][3] & pipeline_reg[0][3];\n        out[4] <= pipeline_reg[2][4] & ~pipeline_reg[1][4] & pipeline_reg[0][4];\n        out[5] <= pipeline_reg[2][5] & ~pipeline_reg[1][5] & pipeline_reg[0][5];\n        out[6] <= pipeline_reg[2][6] & ~pipeline_reg[1][6] & pipeline_reg[0][6];\n        out[7] <= pipeline_reg[2][7] & ~pipeline_reg[1][7] & pipeline_reg[0][7];\n        out[8] <= pipeline_reg[2][8] & ~pipeline_reg[1][8] & pipeline_reg[0][8];\n        out[9] <= pipeline_reg[2][9] & ~pipeline_reg[1][9] & pipeline_reg[0][9];\n        out[10] <= pipeline_reg[2][10] & ~pipeline_reg[1][10] & pipeline_reg[0][10];\n        out[11] <= pipeline_reg[2][11] & ~pipeline_reg[1][11] & pipeline_reg[0][11];\n        out[12] <= pipeline_reg[2][12] & ~pipeline_reg[1][12] & pipeline_reg[0][12];\n        out[13] <= pipeline_reg[2][13] & ~pipeline_reg[1][13] & pipeline_reg[0][13];\n        out[14] <= pipeline_reg[2][14] & ~pipeline_reg[1][14] & pipeline_reg[0][14];\n        out[15] <= pipeline_reg[2][15] & ~pipeline_reg[1][15] & pipeline_reg[0][15];\n        out[16] <= pipeline_reg[2][16] & ~pipeline_reg[1][16] & pipeline_reg[0][16];\n        out[17] <= pipeline_reg[2][17] & ~pipeline_reg[1][17] & pipeline_reg[0][17];\n        out[18] <= pipeline_reg[2][18] & ~pipeline_reg[1][18] & pipeline_reg[0][18];\n        out[19] <= pipeline_reg[2][19] & ~pipeline_reg[1][19] & pipeline_reg[0][19];\n        out[20] <= pipeline_reg[2][20] & ~pipeline_reg[1][20] & pipeline_reg[0][20];\n        out[21] <= pipeline_reg[2][21] & ~pipeline_reg[1][21] & pipeline_reg[0][21];\n        out[22] <= pipeline_reg[2][22] & ~pipeline_reg[1][22] & pipeline_reg[0][22];\n        out[23] <= pipeline_reg[2][23] & ~pipeline_reg[1][23] & pipeline_reg[0][23];\n        out[24] <= pipeline_reg[2][24] & ~pipeline_reg[1][24] & pipeline_reg[0][24];\n        out[25] <= pipeline_reg[2][25] & ~pipeline_reg[1][25] & pipeline_reg[0][25];\n        out[26] <= pipeline_reg[2][26] & ~pipeline_reg[1][26] & pipeline_reg[0][26];\n        out[27] <= pipeline_reg[2][27] & ~pipeline_reg[1][27] & pipeline_reg[0][27];\n        out[28] <= pipeline_reg[2][28] & ~pipeline_reg[1][28] & pipeline_reg[0][28];\n        out[29] <= pipeline_reg[2][29] & ~pipeline_reg[1][29] & pipeline_reg[0][29];\n        out[30] <= pipeline_reg[2][30] & ~pipeline_reg[1][30] & pipeline_reg[0][30];\n        out[31] <= pipeline_reg[2][31] & ~pipeline_reg[1][31] & pipeline_reg[0][31];\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nrising_edge_detector detector (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(out)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clk_1_khz_3c9360b8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule clk_1_khz(\n    input clk_50mhz,\n    output reg clk_1khz\n);\n\nreg [3:0] count;\n\nalways @(posedge clk_50mhz)\nbegin\n    count <= count + 1;\n    if(count == 7) begin // 7 is chosen because 7*143 = 1001\n        count <= 0;\n        clk_1khz <= ~clk_1khz;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ResetInverter_a360c34d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n`ifdef BSV_ASSIGNMENT_DELAY\n`else\n`define BSV_ASSIGNMENT_DELAY\n`endif\n\nmodule ResetInverter(RESET_IN, RESET_OUT);\n\n   input     RESET_IN;            output    RESET_OUT;           wire      RESET_OUT;\n   \n   assign    RESET_OUT = ! RESET_IN ;\n   \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter #_728384c7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter #(parameter N = 4) (\n    input clk,\n    input rst,\n    output reg [N-1:0] count\n);\n\nalways @(posedge clk or negedge rst) begin\n    if (rst == 0) begin\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "image_processor_dbg_142cdce2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule image_processor_dbg (\n        input                   iClk,\n        input                   iLineValid,\n        input                   iFrameValid,\n        input                   iSW,\n        \n        output          [23:0]  oDebug\n    );\n\n    assign oDebug = (iSW == 1) ? rDebugFPS : rDebugRes;\n    \n    \n    reg     [23:0]  rDebugFPS       = 0;\n    reg     [23:0]  rDebugRes       = 0;\n    reg     [23:0]  rFPS            = 0;\n    reg     [32:0]  rTime           = 0;\n    reg     [23:0]  rWidth          = 0;\n    reg     [23:0]  rHeight         = 0;\n    reg             rLineValidL     = 0;\n    reg             rFrameValidL    = 0;\n    \n    always@(posedge iClk)\n    begin\n        rTime <= rTime + 1;\n        if({rFrameValidL,iFrameValid} == 2'b10)  rFPS <= rFPS + 1;\n        case({rLineValidL,iLineValid})\n            2'b10:  rDebugRes[23:12] <= rWidth[11:0];\n            2'b00:  rWidth <= 0;\n            2'b01:  rWidth <= 0;\n            2'b11:  rWidth <= rWidth + 1;\n        endcase\n        rLineValidL <= iLineValid;\n        case({rFrameValidL,iFrameValid})\n            2'b10:  rDebugRes[11:0] <= rHeight[11:0];\n            2'b00:  rHeight <= 0;\n            2'b01:  rHeight <= 0;\n            2'b11:  if({rLineValidL,iLineValid} == 2'b10) rHeight <= rHeight + 1;\n        endcase\n        rFrameValidL    <=  iFrameValid;\n        if(rTime == 25000000)\n        begin\n            rTime       <=  0;\n            rDebugFPS   <=  rFPS;\n            rFPS        <=  0;\n        end\n    end\n    \nendmodule\n    \n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder32_9cfac13c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder32 ( \n    a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15,\n    b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15,\n    s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15,\n    cout  );\n  input  a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, \nb0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15;\n  output s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, cout;\n  wire n50, n51, n53, n54, n55, n56, n57, n58, n60, n61, n62, n63, n64, n65,    n66, n67, n68, n69, n71, n72, n73, n74, n75, n76, n77, n78, n79, n80,    n82, n83, n84, n85, n86, n87, n88, n89, n90, n91, n93, n94, n95, n96,    n97, n98, n99, n100, n101, n102, n104, n105, n106, n107, n108, n109,    n110, n111, n112, n113, n115, n116, n117, n118, n119, n120, n121, n122,    n123, n124, n126, n127, n128, n129, n130, n131, n132, n133, n134, n135,    n137, n138, n139, n140, n141, n142, n143, n144, n145, n146, n148, n149,    n150, n151, n152, n153, n154, n155, n156, n157, n159, n160, n161, n162,    n163, n164, n165, n166, n167, n168, n170, n171, n172, n173, n174, n175,    n176, n177, n178, n179, n181, n182, n183, n184, n185, n186, n187, n188,    n189, n190, n192, n193, n194, n195, n196, n197, n198, n199, n200, n201,    n203, n204, n205, n206, n207, n208, n209, n210, n211, n212, n214, n215,   n216, n217;\n  assign n50 = ~a0 & b0;\n  assign n51 = a0 & ~b0;\n  assign s0 = n50 | n51;\n  assign n53 = a0 & b0;\n  assign n54 = ~a1 & b1;\n  assign n55 = a1 & ~b1;\n  assign n56 = ~n54 & ~n55;\n  assign n57 = n53 & n56;\n  assign n58 = ~n53 & ~n56;\n  assign s1 = n57 | n58;\n  assign n60 = a1 & b1;\n  assign n61 = a1 & n53;\n  assign n62 = ~n60 & ~n61;\n  assign n63 = b1 & n53;\n  assign n64 = n62 & ~n63;\n  assign n65 = ~a2 & b2;\n  assign n66 = a2 & ~b2;\n  assign n67 = ~n65 & ~n66;\n  assign n68 = ~n64 & n67;\n  assign n69 = n64 & ~n67;\n  assign s2 = n68 | n69;\n  assign n71 = a2 & b2;\n  assign n72 = a2 & ~n64;\n  assign n73 = ~n71 & ~n72;\n  assign n74 = b2 & ~n64;\n  assign n75 = n73 & ~n74;\n  assign n76 = ~a3 & b3;\n  assign n77 = a3 & ~b3;\n  assign n78 = ~n76 & ~n77;\n  assign n79 = ~n75 & n78;\n  assign n80 = n75 & ~n78;\n  assign s3 = n79 | n80;\n  assign n82 = a3 & b3;\n  assign n83 = a3 & ~n75;\n  assign n84 = ~n82 & ~n83;\n  assign n85 = b3 & ~n75;\n  assign n86 = n84 & ~n85;\n  assign n87 = ~a4 & b4;\n  assign n88 = a4 & ~b4;\n  assign n89 = ~n87 & ~n88;\n  assign n90 = ~n86 & n89;\n  assign n91 = n86 & ~n89;\n  assign s4 = n90 | n91;\n  assign n93 = a4 & b4;\n  assign n94 = a4 & ~n86;\n  assign n95 = ~n93 & ~n94;\n  assign n96 = b4 & ~n86;\n  assign n97 = n95 & ~n96;\n  assign n98 = ~a5 & b5;\n  assign n99 = a5 & ~b5;\n  assign n100 = ~n98 & ~n99;\n  assign n101 = ~n97 & n100;\n  assign n102 = n97 & ~n100;\n  assign s5 = n101 | n102;\n  assign n104 = a5 & b5;\n  assign n105 = a5 & ~n97;\n  assign n106 = ~n104 & ~n105;\n  assign n107 = b5 & ~n97;\n  assign n108 = n106 & ~n107;\n  assign n109 = ~a6 & b6;\n  assign n110 = a6 & ~b6;\n  assign n111 = ~n109 & ~n110;\n  assign n112 = ~n108 & n111;\n  assign n113 = n108 & ~n111;\n  assign s6 = n112 | n113;\n  assign n115 = a6 & b6;\n  assign n116 = a6 & ~n108;\n  assign n117 = ~n115 & ~n116;\n  assign n118 = b6 & ~n108;\n  assign n119 = n117 & ~n118;\n  assign n120 = ~a7 & b7;\n  assign n121 = a7 & ~b7;\n  assign n122 = ~n120 & ~n121;\n  assign n123 = ~n119 & n122;\n  assign n124 = n119 & ~n122;\n  assign s7 = n123 | n124;\n  assign n126 = a7 & b7;\n  assign n127 = a7 & ~n119;\n  assign n128 = ~n126 & ~n127;\n  assign n129 = b7 & ~n119;\n  assign n130 = n128 & ~n129;\n  assign n131 = ~a8 & b8;\n  assign n132 = a8 & ~b8;\n  assign n133 = ~n131 & ~n132;\n  assign n134 = ~n130 & n133;\n  assign n135 = n130 & ~n133;\n  assign s8 = n134 | n135;\n  assign n137 = a8 & b8;\n  assign n138 = a8 & ~n130;\n  assign n139 = ~n137 & ~n138;\n  assign n140 = b8 & ~n130;\n  assign n141 = n139 & ~n140;\n  assign n142 = ~a9 & b9;\n  assign n143 = a9 & ~b9;\n  assign n144 = ~n142 & ~n143;\n  assign n145 = ~n141 & n144;\n  assign n146 = n141 & ~n144;\n  assign s9 = n145 | n146;\n  assign n148 = a9 & b9;\n  assign n149 = a9 & ~n141;\n  assign n150 = ~n148 & ~n149;\n  assign n151 = b9 & ~n141;\n  assign n152 = n150 & ~n151;\n  assign n153 = ~a10 & b10;\n  assign n154 = a10 & ~b10;\n  assign n155 = ~n153 & ~n154;\n  assign n156 = ~n152 & n155;\n  assign n157 = n152 & ~n155;\n  assign s10 = n156 | n157;\n  assign n159 = a10 & b10;\n  assign n160 = a10 & ~n152;\n  assign n161 = ~n159 & ~n160;\n  assign n162 = b10 & ~n152;\n  assign n163 = n161 & ~n162;\n  assign n164 = ~a11 & b11;\n  assign n165 = a11 & ~b11;\n  assign n166 = ~n164 & ~n165;\n  assign n167 = ~n163 & n166;\n  assign n168 = n163 & ~n166;\n  assign s11 = n167 | n168;\n  assign n170 = a11 & b11;\n  assign n171 = a11 & ~n163;\n  assign n172 = ~n170 & ~n171;\n  assign n173 = b11 & ~n163;\n  assign n174 = n172 & ~n173;\n  assign n175 = ~a12 & b12;\n  assign n176 = a12 & ~b12;\n  assign n177 = ~n175 & ~n176;\n  assign n178 = ~n174 & n177;\n  assign n179 = n174 & ~n177;\n  assign s12 = n178 | n179;\n  assign n181 = a12 & b12;\n  assign n182 = a12 & ~n174;\n  assign n183 = ~n181 & ~n182;\n  assign n184 = b12 & ~n174;\n  assign n185 = n183 & ~n184;\n  assign n186 = ~a13 & b13;\n  assign n187 = a13 & ~b13;\n  assign n188 = ~n186 & ~n187;\n  assign n189 = ~n185 & n188;\n  assign n190 = n185 & ~n188;\n  assign s13 = n189 | n190;\n  assign n192 = a13 & b13;\n  assign n193 = a13 & ~n185;\n  assign n194 = ~n192 & ~n193;\n  assign n195 = b13 & ~n185;\n  assign n196 = n194 & ~n195;\n  assign n197 = ~a14 & b14;\n  assign n198 = a14 & ~b14;\n  assign n199 = ~n197 & ~n198;\n  assign n200 = ~n196 & n199;\n  assign n201 = n196 & ~n199;\n  assign s14 = n200 | n201;\n  assign n203 = a14 & b14;\n  assign n204 = a14 & ~n196;\n  assign n205 = ~n203 & ~n204;\n  assign n206 = b14 & ~n196;\n  assign n207 = n205 & ~n206;\n  assign n208 = ~a15 & b15;\n  assign n209 = a15 & ~b15;\n  assign n210 = ~n208 & ~n209;\n  assign n211 = ~n207 & n210;\n  assign n212 = n207 & ~n210;\n  assign s15 = n211 | n212;\n  assign n214 = a15 & b15;\n  assign n215 = a15 & ~n207;\n  assign n216 = ~n214 & ~n215;\n  assign n217 = b15 & ~n207;\n  assign cout = ~n216 | n217;\nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_55494cf4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter(\n    input clk,\n    input rst,\n    input up_down,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            count <= 4'b0000;\n        end\n        else if (up_down) begin\n            count <= count + 1;\n        end\n        else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_8_reset_73c6b564", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_8_reset (clk, d, rst, q);\n    input clk, rst;\n    input [7:0] d;\n    output [7:0] q;\n    reg [7:0] q;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bus_manager #_34fb4c72", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule bus_manager #(parameter RAM_MSB=10)(\ninput [7:0] ROM_data_out,\n\tinput [7:0]\tRAM_data,\n\tinput [7:0] jt_data_out,\n\tinput\t\tgame_sel,\n\tinput [7:0]\tsound_latch,\n\toutput\t\tclear_irq,\n\toutput reg [7:0] cpu_data_in,\t\n\tinput [15:0]addr,\n\tinput\t\tcpu_vma,\n\tinput\t\tcpu_rw,\n\toutput\treg\tRAM_cs,\n\toutput\treg\topm_cs_n\n\t\n);\n\nwire ROM_cs = addr[15];\n\nparameter RAM_START = 16'h6000;\nparameter RAM_END = RAM_START+(2**(RAM_MSB+1));\nparameter ROM_START=16'h8000;\n\nwire [15:0] ram_start_contra\t= 16'h6000;\nwire [15:0] ram_end_contra\t\t= 16'h7FFF;\nwire [15:0] ram_start_ddragon\t= 16'h0000;\nwire [15:0] ram_end_ddragon\t\t= 16'h0FFF;\n\nreg [15:0] irq_clear_addr;\n\nreg LATCH_rd;\n\nalways @(*) begin\n\tif( cpu_rw && cpu_vma)\n\t\tcasex( {~opm_cs_n, RAM_cs, ROM_cs, LATCH_rd } )\n\t\t\t4'b1XXX: cpu_data_in = jt_data_out;\n\t\t\t4'b01XX: cpu_data_in = RAM_data;\n\t\t\t4'b001X: cpu_data_in = ROM_data_out;\n\t\t\t4'b0001: cpu_data_in = sound_latch;\n\t\t\tdefault: cpu_data_in = 8'h0;\n\t\tendcase\n\telse\n\t\tcpu_data_in = 8'h0;\nend\n\nwire opm_cs_contra = !addr[15] && !addr[14] && addr[13]; \nwire opm_cs_ddragon= addr>=16'h2800 && addr<=16'h2801;\n\nalways @(*)\n\tif( game_sel ) begin\n\t\tRAM_cs\t= cpu_vma && (addr>=ram_start_ddragon && addr<=ram_end_ddragon);\n\t\topm_cs_n= !(cpu_vma && opm_cs_ddragon);\n\t\tLATCH_rd= cpu_vma && addr==16'h1000; irq_clear_addr = 16'h1000;\n\tend\n\telse begin\n\t\tRAM_cs \t= cpu_vma && (addr>=ram_start_contra && addr<=ram_end_contra);\n\t\topm_cs_n= !(cpu_vma && opm_cs_contra);\n\t\tLATCH_rd= cpu_vma && addr==16'h0; irq_clear_addr = 16'h4000;\n\tend\n\t\nassign clear_irq = (addr==irq_clear_addr) && cpu_vma ? 1'b1 : 1'b0;\n\t\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fsm_traffic_light_control_234f2e99", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fsm_traffic_light_control (\n  input clk,\n  input reset,\n  input ped,\n  output reg red,\n  output reg green,\n  output reg yellow\n);\n\n  parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n  reg [1:0] state, next_state;\n\n  localparam red_time = 4;\n  localparam green_time = 6;\n  localparam yellow_time = 2;\n\n  reg [2:0] counter;\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      state <= S0;\n      counter <= 0;\n    end\n    else begin\n      state <= next_state;\n      case (state)\n        S0: begin\n          counter <= red_time;\n        end\n        S1: begin\n          if (ped) begin\n            counter <= yellow_time;\n          end\n          else begin\n            counter <= green_time;\n          end\n        end\n        S2: begin\n          counter <= yellow_time;\n        end\n        default: begin\n          counter <= 0;\n        end\n      endcase\n    end\n  end\n\n  always @(posedge clk) begin\n    if (reset) begin\n      red <= 1'b1;\n      green <= 1'b0;\n      yellow <= 1'b0;\n    end\n    else begin\n      case (state)\n        S0: begin\n          red <= 1'b1;\n          green <= 1'b0;\n          yellow <= 1'b0;\n        end\n        S1: begin\n          if (ped) begin\n            red <= 1'b0;\n            green <= 1'b0;\n            yellow <= 1'b1;\n          end\n          else begin\n            red <= 1'b0;\n            green <= 1'b1;\n            yellow <= 1'b0;\n          end\n        end\n        S2: begin\n          red <= 1'b0;\n          green <= 1'b0;\n          yellow <= 1'b1;\n        end\n        default: begin\n          red <= 1'b0;\n          green <= 1'b0;\n          yellow <= 1'b0;\n        end\n      endcase\n    end\n  end\n\n  always @(*) begin\n    case (state)\n      S0: begin\n        next_state = S1;\n      end\n      S1: begin\n        if (counter == 0) begin\n          next_state = S2;\n        end\n        else begin\n          next_state = S1;\n        end\n      end\n      S2: begin\n        if (counter == 0) begin\n          next_state = S0;\n        end\n        else begin\n          next_state = S2;\n        end\n      end\n      default: begin\n        next_state = S0;\n      end\n    endcase\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "byte_reverser_158ee812", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule byte_reverser (\n  input [31:0] in,\n  output [31:0] out\n);\n  assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\nendmodule\nmodule full_adder (\n  input a, b, cin,\n  output reg sum, carry_out\n);\n  always @ (a, b, cin) begin\n    sum = a ^ b ^ cin;\n    carry_out = (a & b) | (a & cin) | (b & cin);\n  end\nendmodule\nmodule functional_module (\n  input [31:0] in1,\n  input [2:0] in2,\n  output [31:0] out\n);\n  assign out = in1 ^ {in2[2], in2[2], in2[1:0]};\nendmodule\nmodule control_logic (\n  input select,\n  input [31:0] in1,\n  input a, b, cin,\n  output reg [31:0] out\n);\n  wire [31:0] in2;\n  assign in2 = select ? {a, b, cin} : in1;\n\n  byte_reverser byte_reverser_inst (\n    .in(in2),\n    .out(out)\n  );\nendmodule\nmodule top_module (\n  input clk,\n  input reset,\n  input [31:0] in,\n  input a, b, cin,\n  input select,\n  output [31:0] out\n);\n  wire [31:0] in1;\n  control_logic control_logic_inst (\n    .select(select),\n    .in1(in),\n    .a(a),\n    .b(b),\n    .cin(cin),\n    .out(in1)\n  );\n\n  assign out = in1;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "minimac2_sync_7543b2d3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule minimac2_sync(\n    input sys_clk,\n    input phy_rx_clk,\n    input phy_tx_clk,\n    \n    input [1:0] sys_rx_ready,\n    output [1:0] sys_rx_done,\n    output reg [10:0] sys_rx_count_0,\n    output reg [10:0] sys_rx_count_1,\n    \n    input sys_tx_start,\n    output sys_tx_done,\n    input [10:0] sys_tx_count,\n    \n    output [1:0] phy_rx_ready,\n    input [1:0] phy_rx_done,\n    input [10:0] phy_rx_count_0,\n    input [10:0] phy_rx_count_1,\n    \n    output phy_tx_start,\n    input phy_tx_done,\n    output reg [10:0] phy_tx_count\n);\n\nminimac2_psync rx_ready_0(\n    .clk1(sys_clk),\n    .i(sys_rx_ready[0]),\n    .clk2(phy_rx_clk),\n    .o(phy_rx_ready[0])\n);\nminimac2_psync rx_ready_1(\n    .clk1(sys_clk),\n    .i(sys_rx_ready[1]),\n    .clk2(phy_rx_clk),\n    .o(phy_rx_ready[1])\n);\nminimac2_psync rx_done_0(\n    .clk1(phy_rx_clk),\n    .i(phy_rx_done[0]),\n    .clk2(sys_clk),\n    .o(sys_rx_done[0])\n);\nminimac2_psync rx_done_1(\n    .clk1(phy_rx_clk),\n    .i(phy_rx_done[1]),\n    .clk2(sys_clk),\n    .o(sys_rx_done[1])\n);\nreg [10:0] sys_rx_count_0_r;\nreg [10:0] sys_rx_count_1_r;\nalways @(posedge sys_clk) begin\n    sys_rx_count_0_r <= phy_rx_count_0;\n    sys_rx_count_0 <= sys_rx_count_0_r;\n    sys_rx_count_1_r <= phy_rx_count_1;\n    sys_rx_count_1 <= sys_rx_count_1_r;\nend\n\nminimac2_psync tx_start(\n    .clk1(sys_clk),\n    .i(sys_tx_start),\n    .clk2(phy_tx_clk),\n    .o(phy_tx_start)\n);\nminimac2_psync tx_done(\n    .clk1(phy_tx_clk),\n    .i(phy_tx_done),\n    .clk2(sys_clk),\n    .o(sys_tx_done)\n);\nreg [10:0] phy_tx_count_r;\nalways @(posedge phy_tx_clk) begin\n    phy_tx_count_r <= sys_tx_count;\n    phy_tx_count <= phy_tx_count_r;\nend\n\nendmodule\n\nmodule minimac2_psync(\n    input clk1,       // Source clock\n    input i,          // Input signal in the source clock domain\n    input clk2,       // Destination clock\n    output reg o      // Output signal in the destination clock domain\n);\n\n    // Synchronization from clk1 to clk2 domain\n    reg intermediate;\n    reg [1:0] sync_reg; // Double flip-flop for synchronizing the signal\n\n    // Pulse detection in clk1 domain\n    reg i_reg;\n    wire pulse; // Detected pulse\n\n    always @(posedge clk1) begin\n        i_reg <= i;\n    end\n    assign pulse = i & ~i_reg; // Detecting rising edge\n\n    // Transfer the pulse to the clk2 domain\n    always @(posedge clk2) begin\n        if (pulse)\n            intermediate <= 1'b1; // Set intermediate high if a pulse is detected\n        else if (sync_reg[1])\n            intermediate <= 1'b0; // Reset intermediate when the pulse has been acknowledged\n\n        sync_reg <= {sync_reg[0], intermediate}; // Synchronize the intermediate signal\n    end\n\n    always @(posedge clk2) begin\n        o <= sync_reg[1]; // Output the synchronized signal\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clk_generator_9b9ed134", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clk_generator(\n    input       clk_i,      output  reg clk_core,   output      clk_bus     );\n\n    assign clk_bus = clk_i;\n\n    initial begin\n        clk_core <= 1'b0;\n    end\n\n    always @(posedge clk_i ) begin\n        clk_core <= !clk_core;\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Shift_Register_e582c9a7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Shift_Register (\n  input CLK,\n  input EN,\n  input TE,\n  input [6:0] DATA_IN,\n  output reg [6:0] DATA_OUT,\n  output reg ENCLK\n);\n\n  reg [6:0] data_out_reg;\n  reg [6:0] data_out;\n\n  always @ (posedge CLK) begin\n    if (EN) begin\n      data_out_reg <= {DATA_IN[6], data_out_reg[6:1]};\n    end\n  end\n\n  always @ (*) begin\n    if (TE) begin\n      data_out <= data_out_reg;\n    end\n  end\n\n  always @ (*) begin\n    DATA_OUT = data_out;\n    ENCLK = data_out[0];\n  end\n\nendmodule\n\nmodule TLATNTSCAX2TS (\n  input E,\n  input SE,\n  input CK,\n  output reg ECK\n);\n\n  // Define behavior here\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_634c0bd4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo(clk, rst, din, wr_en, rd_en, dout, full, empty, data_count);\n  parameter DEPTH = 4096;\n  parameter WIDTH = 24;\n  parameter ADDR_WIDTH = $clog2(DEPTH);\n  \n  input clk, rst, wr_en, rd_en;\n  input [WIDTH-1:0] din;\n  output [WIDTH-1:0] dout;\n  output full, empty;\n  output reg [ADDR_WIDTH-1:0] data_count;\n  \n  reg [WIDTH-1:0] mem [0:DEPTH-1];\n  reg [ADDR_WIDTH-1:0] wr_ptr, rd_ptr;\n  wire [ADDR_WIDTH-1:0] next_wr_ptr = wr_ptr + 1'b1;\n  wire [ADDR_WIDTH-1:0] next_rd_ptr = rd_ptr + 1'b1;\n  \n  assign dout = mem[rd_ptr];\n  assign full = (wr_ptr == next_rd_ptr);\n  assign empty = (wr_ptr == rd_ptr);\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      wr_ptr <= 0;\n      rd_ptr <= 0;\n      data_count <= 0;\n    end else begin\n      if (wr_en && !full) begin\n        mem[wr_ptr] <= din;\n        wr_ptr <= next_wr_ptr;\n        data_count <= data_count + 1'b1;\n      end\n      if (rd_en && !empty) begin\n        rd_ptr <= next_rd_ptr;\n        data_count <= data_count - 1'b1;\n      end\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rbo_test_1f121256", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule rbo_test\n(\n  input clk,\n  output reg CAL,\n  output reg CS,\n  output reg IS1,\n  output reg IS2,\n  output reg LE,\n  output reg R12,\n  output reg RBI,\n  output reg RESET,\n  output reg RPHI1,\n  output reg RPHI2,\n  output reg SBI,\n  output reg SEB,\n  output reg SPHI1,\n  output reg SPHI2,\n  output reg SR,\n  output [15:0]Aref,\n  output [15:0]RG,\n  output [15:0]Vana,\n  output [15:0]Vthr,\n  input reset_gen\n);\n\nreg [31:0]counter;\nreg [7:0]stage;\nreg [15:0]stage_iter;\nassign Vthr=16'H0025;\nassign Aref=16'H0033;\nassign Vana=16'H0066;\nassign RG=16'H0033;\nalways @(posedge clk) begin\n  if(reset_gen == 1) begin\n    counter <= 0;\n    stage <= 0;\n    stage_iter <= 0;\n    CAL <= 0;\n    SBI <= 0;\n    SPHI1 <= 0;\n    SPHI2 <= 0;\n    SEB <= 1;\n    IS1 <= 1;\n    IS2 <= 0;\n    SR <= 1;\n    RESET <= 1;\n    R12 <= 1;\n    RBI <= 0;\n    RPHI1 <= 1;\n    RPHI2 <= 1;\n    LE <= 0;\n    CS<=0;\n  end\n  else begin\n    if(stage == 0) begin\n      if(counter == 7) begin\n        RBI <= 1;\n      end\n      if(counter == 16) begin\n        RBI <= 0;\n      end\n      if(counter == 22) begin\n        RPHI1 <= 0;\n        RPHI2 <= 0;\n      end\n      if(counter == 24) begin\n        RBI <= 1;\n      end\n      if(counter == 25) begin\n        RPHI1 <= 1;\n      end\n      if(counter == 26) begin\n        RPHI1 <= 0;\n      end\n      if(counter == 27) begin\n        RBI <= 0;\n      end\n      if(counter == 28) begin\n        RPHI2 <= 1;\n      end\n      if(counter == 29) begin\n        RPHI2 <= 0;\n      end\n      if(counter == 29) begin\n        if(stage_iter == 0) begin\n          stage <= (stage + 1) % 2;\n          stage_iter <= 0;\n        end\n        else begin\n          stage_iter <= stage_iter + 1;\n        end\n        counter <= 0;\n      end\n      else begin\n        counter <= counter + 1;\n      end\n    end\n    if(stage == 1) begin\n      if(counter == 1) begin\n        RPHI1 <= 0;\n        CS<=1;\n      end\n      if(counter == 2) begin\n        RPHI2 <= 1;\n      end\n      if(counter == 3) begin\n        RPHI2 <= 0;\n      end\n      if(counter == 3) begin\n        if(stage_iter == 128) begin\n          stage <= (stage + 1) % 2;\n          stage_iter <= 0;\n        end\n        else begin\n          stage_iter <= stage_iter + 1;\n        end\n        counter <= 0;\n      end\n      else begin\n        counter <= counter + 1;\n      end\n    end\n  end\nend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_flip_flop_mux_latch_cf8f5a2b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule d_flip_flop_mux_latch (\n    input clk,\n    input d,\n    output reg q );\n\n    reg mux_out;\n    reg latch_out;\n\n    always @ (posedge clk) begin\n        mux_out <= d;\n    end\n\n    always @ (mux_out) begin\n        if (mux_out) begin\n            latch_out <= 1'b1;\n        end else begin\n            latch_out <= 1'b0;\n        end\n    end\n\n    always @ (posedge clk) begin\n        q <= latch_out;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter #_46d8f7a9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule counter #(\n  parameter M = 0\n) (\n  input clk,\n  input rst,\n  input cnt,\n  output reg [31:0] q,\n  output reg ov\n);\n\n  localparam N = M < 32 ? M : 32;\n\n  always @(posedge clk) begin\n    if (rst || ov) begin\n      q <= 0;\n      ov <= 0;\n    end else begin\n      if (cnt) begin\n        q <= q + 1;\n        if (q == M-1) begin\n          ov <= 1;\n        end\n      end\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplicadorPuntoFijo  #_a25a5896", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule multiplicadorPuntoFijo  #(parameter Width = 24, Magnitud = 4, Precision = 19, Signo = 1)\n\t\t(EnableMul,In,Coeff,OutMul,Error);\n\t \n\t input EnableMul;\n\t input signed [Width-1:0] In,Coeff;\n\t output reg signed [Width-1:0] OutMul = 0; \n\t output Error;\n\t reg signed [2*Width-1:0]  AuxMul = 0; \n\t reg Overflow = 0;\n\t reg Underflow = 0;\n\t \n\t \n\t \n\t\talways @* begin if (EnableMul) begin\n\t\t\t\tAuxMul <= In * Coeff; end\n\t\t\telse begin\n\t\t\t\tAuxMul <= 0;\n\t\t\tend\n\t\tend\n\t\t\n\t\talways @* begin if (~In[Width-1] && ~Coeff[Width-1] && AuxMul[2*Width -1 - Magnitud - Signo]) begin\n\t\t\t\tOverflow <= 1;\n\t\t\t\tUnderflow <= 0;\n\t\t\tend\n\t\t\telse if(In[Width-1] && Coeff[Width-1] && AuxMul[2*Width -1 - Magnitud - Signo]) begin\n\t\t\t\tOverflow <= 1;\n\t\t\t\tUnderflow <= 0;\n\t\t\tend\n\t\t\telse if(~In[Width-1] && Coeff[Width-1] && ~AuxMul[2*Width -1 - Magnitud - Signo]) begin\n\t\t\t\tOverflow <= 0;\n\t\t\t\tUnderflow <= 1;\n\t\t\tend\n\t\t\telse if(In[Width-1] && ~Coeff[Width-1] && ~AuxMul[2*Width -1 - Magnitud - Signo]) begin\n\t\t\t\tOverflow <= 0;\n\t\t\t\tUnderflow <= 1;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tOverflow <= 0;\n\t\t\t\tUnderflow <= 0;\n\t\t\tend\n\t\tend\n\t\t\n\t\talways @* begin if (In == 0 || Coeff==0) begin\n\t\t\t\t\tOutMul <= 0;\n\t\t\tend \n\t\t\telse begin\n\t\t\t\tif (Overflow) begin\n\t\t\t\t\tOutMul <= 2**(Width-1) -1;  end\n\t\t\t\telse begin\n\t\t\t\t\tif (Underflow) begin\n\t\t\t\t\t\tOutMul <= -2**(Width-1);    end\n\t\t\t\t\telse begin\n\t\t\t\t\t\tOutMul <= AuxMul[2*Width -1 - Magnitud - Signo : Precision];      end\n\t\t\t\tend\t\n\t\t\tend\n\t\tend\n\t\t\n\t\tassign Error =  Overflow | Underflow;\n\t\t\n\t\n\t endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sync_counter_5225359f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sync_counter(\n    input clk,\n    input rst,\n    output reg [2:0] count_out\n);\n\n    always @ (posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 3'b0;\n        end\n        else begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__ha_72ddc35d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__ha (\n    COUT,\n    SUM ,\n    A   ,\n    B\n);\n\n    output COUT;\n    output SUM ;\n    input  A   ;\n    input  B   ;\n\n    wire and0_out_COUT;\n    wire xor0_out_SUM ;\n\n    and and0 (and0_out_COUT, A, B           );\n    buf buf0 (COUT         , and0_out_COUT  );\n    xor xor0 (xor0_out_SUM , B, A           );\n    buf buf1 (SUM          , xor0_out_SUM   );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_to_one_7cad60b1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_to_one (\n    Y,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input B1;\n    input B2;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign Y = ((A1 & A2 == 0) & (B1 == 1 & B2 == 1)) | ((A1 == 1 & A2 == 0) & (B1 == 0 & B2 == 0)) | ((A1 == 0 & A2 == 1) & (B1 == 0 & B2 == 0)) | ((A1 & A2 == 1) & (B1 == 0 & B2 == 0));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_1b098cb4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n  input clk,\n  input reset,\n  input enable,\n  input d,\n  output reg q\n);\n\n  reg [2:0] shift_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      shift_reg <= 3'b0;\n      q <= 1'b0;\n    end else if (enable) begin\n      shift_reg <= {shift_reg[1:0], d};\n      q <= shift_reg[2];\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rgmii_c92eaa6d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rgmii \n(\n    input   wire        reset,\n    input   wire        generated_clk,\n\n    output  wire [3:0]  phy_txd_rising,\n    output  wire [3:0]  phy_txd_falling,    \n    output  wire        phy_tx_ctl_rising,\n    output  wire        phy_tx_ctl_falling,    \n    output  wire        phy_gtx_clk,\n    input   wire [3:0]  phy_rxd_rising,\n    input   wire [3:0]  phy_rxd_falling,\n    input   wire        phy_rx_ctl_rising,\n    input   wire        phy_rx_ctl_falling,    \n    input   wire        phy_rx_clk,\n\n    input   wire        mac_tx_er,\n    input   wire [7:0]  mac_txd,\n    input   wire        mac_tx_en,\n    output  wire        mac_tx_clk,\n    output  wire        mac_col,\n    output  wire [7:0]  mac_rxd,\n    output  wire        mac_rx_er,\n    output  wire        mac_rx_clk,\n    output  wire        mac_crs,\n    output  wire        mac_rx_dv\n);\n\nassign phy_txd_rising       = mac_txd[3:0];\nassign phy_txd_falling      = mac_txd[7:4];\nassign phy_tx_ctl_rising    = mac_tx_en;\nassign phy_tx_ctl_falling   = mac_tx_en ^ mac_tx_er;\nassign phy_gtx_clk          = generated_clk;\nassign mac_col              = (mac_crs & mac_tx_en) | (mac_rx_dv & mac_tx_en);\nassign mac_rxd [3:0]        = phy_rxd_rising;\nassign mac_rxd [7:4]        = phy_rxd_falling;\nassign mac_rx_er            = phy_rx_ctl_falling ^ phy_rx_ctl_rising;\nassign mac_rx_clk           = phy_rx_clk;\nassign mac_crs              = mac_rx_dv | ( mac_rx_er && mac_rxd == 8'hFF ) | ( mac_rx_er && mac_rxd == 8'h0E ) | ( mac_rx_er && mac_rxd == 8'h0F ) | ( mac_rx_er && mac_rxd == 8'h1F );\nassign mac_rx_dv            = phy_rx_ctl_rising;\nassign mac_tx_clk           = generated_clk;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "assert_unchange_assert #_c568d1f3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule assert_unchange_assert #(\n    parameter width = 8\n) (\n    input clk, reset_n, start_event, xzcheck_enable,\n    input [width-1:0] test_expr,\n    input window, ignore_new_start, reset_on_new_start, error_on_new_start,\n    output reg pass, fail, error\n);\n\n    parameter num_cks = 2;\n\n    reg [width-1:0] prev_test_expr;\n    reg [num_cks-1:0] window_counter;\n    reg start_detected;\n    reg reset_detected;\n\n    always @(posedge clk) begin\n        if (!reset_n) begin\n            prev_test_expr <= 'bx;\n            window_counter <= 0;\n            start_detected <= 0;\n            reset_detected <= 0;\n            pass <= 0;\n            fail <= 0;\n            error <= 0;\n        end else begin\n            if (reset_detected) begin\n                prev_test_expr <= 'bx;\n                window_counter <= 0;\n                start_detected <= 0;\n                reset_detected <= 0;\n                pass <= 0;\n                fail <= 0;\n                error <= 0;\n            end else begin\n                if (start_event && !start_detected) begin\n                    prev_test_expr <= test_expr;\n                    window_counter <= 1;\n                    start_detected <= 1;\n                    reset_detected <= 0;\n                    pass <= 0;\n                    fail <= 0;\n                    error <= 0;\n                end else if (start_event && reset_on_new_start) begin\n                    prev_test_expr <= test_expr;\n                    window_counter <= 1;\n                    start_detected <= 1;\n                    reset_detected <= 0;\n                    pass <= 0;\n                    fail <= 0;\n                    error <= error_on_new_start;\n                end else if (start_event && error_on_new_start) begin\n                    prev_test_expr <= 'bx;\n                    window_counter <= 0;\n                    start_detected <= 0;\n                    reset_detected <= 0;\n                    pass <= 0;\n                    fail <= 0;\n                    error <= 1;\n                end else if (start_detected && window_counter < window) begin\n                    if (test_expr !== prev_test_expr && xzcheck_enable) begin\n                        fail <= 1;\n                        error <= 1;\n                    end else begin\n                        fail <= 0;\n                        error <= 0;\n                    end\n                    prev_test_expr <= test_expr;\n                    window_counter <= window_counter + 1;\n                    pass <= 0;\n                end else if (start_detected && window_counter == window) begin\n                    if (test_expr !== prev_test_expr && xzcheck_enable) begin\n                        fail <= 1;\n                        error <= 1;\n                    end else begin\n                        fail <= 0;\n                        error <= 0;\n                    end\n                    prev_test_expr <= test_expr;\n                    window_counter <= 0;\n                    start_detected <= ignore_new_start;\n                    reset_detected <= 0;\n                    pass <= 1;\n                end else if (start_detected && ignore_new_start) begin\n                    if (test_expr !== prev_test_expr && xzcheck_enable) begin\n                        fail <= 1;\n                        error <= 1;\n                    end else begin\n                        fail <= 0;\n                        error <= 0;\n                    end\n                    prev_test_expr <= test_expr;\n                    window_counter <= window_counter + 1;\n                    pass <= 0;\n                end else if (start_detected && reset_on_new_start) begin\n                    prev_test_expr <= test_expr;\n                    window_counter <= 1;\n                    start_detected <= 1;\n                    reset_detected <= 1;\n                    pass <= 0;\n                    fail <= 0;\n                    error <= 0;\n                end else if (start_detected && error_on_new_start) begin\n                    prev_test_expr <= 'bx;\n                    window_counter <= 0;\n                    start_detected <= 0;\n                    reset_detected <= 0;\n                    pass <= 0;\n                    fail <= 0;\n                    error <= 1;\n                end\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hdll__nor3b_63884955", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hdll__nor3b (\n    Y  ,\n    A  ,\n    B  ,\n    C_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B  ;\n    input  C_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out  ;\n    wire and0_out_Y;\n\n    nor nor0 (nor0_out  , A, B           );\n    and and0 (and0_out_Y, C_N, nor0_out  );\n    buf buf0 (Y         , and0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "BOR_24b8ee49", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule BOR (\n    input wire Vin,\n    input wire Reset_en,\n    input wire Threshold,\n    input wire clk,\n    output reg Reset\n);\n\nparameter RESET_DURATION = 10; // duration of reset pulse (in clock cycles)\n\nreg [1:0] state; // state machine to control reset pulse generation\nreg [7:0] counter; // counter to measure reset pulse duration\n\nwire comparator_out = Vin & Threshold; // Placeholder for comparator logic\n\n// State machine and counter logic\nalways @(posedge clk) begin\n    if (Reset_en) begin\n        case (state)\n            2'b00: begin // Idle state\n                if (comparator_out) begin\n                    state <= 2'b01; // Move to pulse generation state\n                    counter <= 0;\n                    Reset <= 1'b1; // Start the Reset pulse\n                end\n            end\n            2'b01: begin // Reset pulse generation state\n                if (counter < RESET_DURATION) begin\n                    counter <= counter + 1;\n                end else begin\n                    Reset <= 1'b0; // End the Reset pulse\n                    state <= 2'b00; // Return to idle state\n                    counter <= 0;\n                end\n            end\n        endcase\n    end else begin\n        state <= 2'b00; // Reset the state machine\n        counter <= 0;\n        Reset <= 1'b0;\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "inverted_5input_OR_gate_302d1e87", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule inverted_5input_OR_gate (\n  input p1,\n  input p2,\n  input p3,\n  input p4,\n  input p5,\n  output reg y\n);\n\n  always @(*) begin\n    if (p1 || p2 || p3 || p4 || p5) begin\n      y <= 0;\n    end else begin\n      y <= 1;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "parity_bit_d6613f2b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule parity_bit (\n    input [7:0] in,\n    output wire parity\n);\n\nwire [3:0] and_out;\nwire xor_out;\n\nassign and_out = in[7:4] & in[3:0];\nassign xor_out = in[7] ^ in[6] ^ in[5] ^ in[4] ^ in[3] ^ in[2] ^ in[1] ^ in[0];\n\nassign parity = and_out[3] & and_out[2] & and_out[1] & and_out[0] & xor_out;\n\nendmodule\n\nmodule combinational_logic (\n    input [3:0] in,\n    output wire [3:0] out_logic\n);\n\nassign out_logic[0] = in[0] & in[1];\nassign out_logic[1] = in[1] | in[2];\nassign out_logic[2] = in[2] ^ in[3];\nassign out_logic[3] = in[0] & in[3];\n\nendmodule\n\nmodule sum_computation (\n    input parity,\n    input [3:0] xor_out,\n    output wire [3:0] sum\n);\n\nassign sum = (parity + xor_out) % 16;\n\nendmodule\n\nmodule top_module (\n    input [7:0] in,\n    output wire [3:0] out_logic\n);\n\nwire parity;\nwire [3:0] xor_out;\nwire [3:0] sum;\n\nparity_bit parity_bit_inst (\n    .in(in),\n    .parity(parity)\n);\n\ncombinational_logic combinational_logic_inst (\n    .in({in[4], in[5], in[6], in[7]}),\n    .out_logic(xor_out)\n);\n\nsum_computation sum_computation_inst (\n    .parity(parity),\n    .xor_out(xor_out),\n    .sum(sum)\n);\n\nassign out_logic = sum;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wb_mux_2 #_5620eaa6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule wb_mux_2 #\n(\n    parameter DATA_WIDTH = 32,                    parameter ADDR_WIDTH = 32,                    parameter SELECT_WIDTH = (DATA_WIDTH/8)       )\n(\n    input  wire                    clk,\n    input  wire                    rst,\n\n    \n    input  wire [ADDR_WIDTH-1:0]   wbm_adr_i,     input  wire [DATA_WIDTH-1:0]   wbm_dat_i,     output wire [DATA_WIDTH-1:0]   wbm_dat_o,     input  wire                    wbm_we_i,      input  wire [SELECT_WIDTH-1:0] wbm_sel_i,     input  wire                    wbm_stb_i,     output wire                    wbm_ack_o,     output wire                    wbm_err_o,     output wire                    wbm_rty_o,     input  wire                    wbm_cyc_i,     \n    output wire [ADDR_WIDTH-1:0]   wbs0_adr_o,    input  wire [DATA_WIDTH-1:0]   wbs0_dat_i,    output wire [DATA_WIDTH-1:0]   wbs0_dat_o,    output wire                    wbs0_we_o,     output wire [SELECT_WIDTH-1:0] wbs0_sel_o,    output wire                    wbs0_stb_o,    input  wire                    wbs0_ack_i,    input  wire                    wbs0_err_i,    input  wire                    wbs0_rty_i,    output wire                    wbs0_cyc_o,    \n    input  wire [ADDR_WIDTH-1:0]   wbs0_addr,     input  wire [ADDR_WIDTH-1:0]   wbs0_addr_msk, \n    output wire [ADDR_WIDTH-1:0]   wbs1_adr_o,    input  wire [DATA_WIDTH-1:0]   wbs1_dat_i,    output wire [DATA_WIDTH-1:0]   wbs1_dat_o,    output wire                    wbs1_we_o,     output wire [SELECT_WIDTH-1:0] wbs1_sel_o,    output wire                    wbs1_stb_o,    input  wire                    wbs1_ack_i,    input  wire                    wbs1_err_i,    input  wire                    wbs1_rty_i,    output wire                    wbs1_cyc_o,    \n    input  wire [ADDR_WIDTH-1:0]   wbs1_addr,     input  wire [ADDR_WIDTH-1:0]   wbs1_addr_msk  );\n\nwire wbs0_match = ~|((wbm_adr_i ^ wbs0_addr) & wbs0_addr_msk);\nwire wbs1_match = ~|((wbm_adr_i ^ wbs1_addr) & wbs1_addr_msk);\n\nwire wbs0_sel = wbs0_match;\nwire wbs1_sel = wbs1_match & ~(wbs0_match);\n\nwire master_cycle = wbm_cyc_i & wbm_stb_i;\n\nwire select_error = ~(wbs0_sel | wbs1_sel) & master_cycle;\n\nassign wbm_dat_o = wbs0_sel ? wbs0_dat_i :\n                   wbs1_sel ? wbs1_dat_i :\n                   {DATA_WIDTH{1'b0}};\n\nassign wbm_ack_o = wbs0_ack_i |\n                   wbs1_ack_i;\n\nassign wbm_err_o = wbs0_err_i |\n                   wbs1_err_i |\n                   select_error;\n\nassign wbm_rty_o = wbs0_rty_i |\n                   wbs1_rty_i;\n\nassign wbs0_adr_o = wbm_adr_i;\nassign wbs0_dat_o = wbm_dat_i;\nassign wbs0_we_o = wbm_we_i & wbs0_sel;\nassign wbs0_sel_o = wbm_sel_i;\nassign wbs0_stb_o = wbm_stb_i & wbs0_sel;\nassign wbs0_cyc_o = wbm_cyc_i & wbs0_sel;\n\nassign wbs1_adr_o = wbm_adr_i;\nassign wbs1_dat_o = wbm_dat_i;\nassign wbs1_we_o = wbm_we_i & wbs1_sel;\nassign wbs1_sel_o = wbm_sel_i;\nassign wbs1_stb_o = wbm_stb_i & wbs1_sel;\nassign wbs1_cyc_o = wbm_cyc_i & wbs1_sel;\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__lpflow_clkinvkapwr_16d2c055", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__lpflow_clkinvkapwr (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hdll__nand3_0891dbef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hdll__nand3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nand0_out_Y;\n\n    nand nand0 (nand0_out_Y, B, A, C        );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "LedDriver_e2de55af", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule LedDriver(input clk,\n                 input [31:0] value,\n                 input [7:0] enable,\n                 output reg [7:0] SSEG_CA,\n                 output reg [7:0] SSEG_AN);\n  reg [2:0] state;\n  reg [3:0] digit;\n  reg [16:0] timer;\n  \n  always @(posedge clk) begin\n    timer <= timer + 1;\n    if (timer == 20000) begin\n      timer <= 0;\n      state <= state + 1;\n    end\n    case (state)\n    0: begin SSEG_AN <= enable[0] ? 8'b11111110 : 8'b11111111; digit = value[3:0];  end\n    1: begin SSEG_AN <= enable[1] ? 8'b11111101 : 8'b11111111; digit = value[7:4];  end\n    2: begin SSEG_AN <= enable[2] ? 8'b11111011 : 8'b11111111; digit = value[11:8]; end\n    3: begin SSEG_AN <= enable[3] ? 8'b11110111 : 8'b11111111; digit = value[15:12];end\n    4: begin SSEG_AN <= enable[4] ? 8'b11101111 : 8'b11111111; digit = value[19:16];end\n    5: begin SSEG_AN <= enable[5] ? 8'b11011111 : 8'b11111111; digit = value[23:20];end\n    6: begin SSEG_AN <= enable[6] ? 8'b10111111 : 8'b11111111; digit = value[27:24];end\n    7: begin SSEG_AN <= enable[7] ? 8'b01111111 : 8'b11111111; digit = value[31:28];end\n    endcase\n    case (digit)\n    0: SSEG_CA  <= 8'b11000000;\n    1: SSEG_CA  <= 8'b11111001;\n    2: SSEG_CA  <= 8'b10100100;\n    3: SSEG_CA  <= 8'b10110000;\n    4: SSEG_CA  <= 8'b10011001;\n    5: SSEG_CA  <= 8'b10010010;\n    6: SSEG_CA  <= 8'b10000010;\n    7: SSEG_CA  <= 8'b11111000;\n    8: SSEG_CA  <= 8'b10000000;\n    9: SSEG_CA  <= 8'b10010000;\n    10: SSEG_CA <= 8'b10001000; 11: SSEG_CA <= 8'b10000011; 12: SSEG_CA <= 8'b10100111; 13: SSEG_CA <= 8'b10100001; 14: SSEG_CA <= 8'b10000110; 15: SSEG_CA <= 8'b10001110; endcase\n  end\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_2bit_5a588222", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule full_adder_2bit(\n    input [1:0] A,\n    input [1:0] B,\n    input Cin,\n    output [1:0] Sum,\n    output Cout\n);\n\nwire [1:0] s1, s2, s3;\nwire c1, c2, c3;\n\n// First adder\nnand (s1[0], A[0], B[0], Cin);\nnand (c1, A[0], B[0]);\n\n// Second adder\nnand (s2[0], A[1], B[1], s1[0]);\nnand (c2, A[1], B[1]);\n\n// Third adder\nnand (s3[0], A[0], B[0], B[1]);\nnand (c3, A[0], B[0]);\n\nassign Sum = {s2[0], s3[0]};\nassign Cout = (Cin & c1) | (c2 & s1[0]) | (c3 & s2[0]);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__clkdlyinv3sd3_f8b88536", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__clkdlyinv3sd3 (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux2to1_3cb83cae", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux2to1(\n   input         in0, in1, sel,\n   output        out);\n\n   assign out = sel ? in1 : in0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PhaseDelayMain_01be2b83", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule PhaseDelayMain(\n    input clk,\n    input decoderInput,\n    output reg sigOut\n);\n\nparameter NUM_SIZE=7;\nparameter SEQ_SIZE=NUM_SIZE+4;\n\nreg [SEQ_SIZE-1:0] seq1,seq2,seq3,seq4;\n\ninteger i;\n\nalways @(posedge clk) begin\n    // Shift the sequence to the right by one bit\n    seq1 <= {seq1[0], seq1[SEQ_SIZE-1:1]};\n    seq2 <= {seq2[0], seq2[SEQ_SIZE-1:1]};\n    seq3 <= {seq3[0], seq3[SEQ_SIZE-1:1]};\n    seq4 <= {seq4[0], seq4[SEQ_SIZE-1:1]};\n\n    // Update the output signal based on the input binary sequence\n    case ({seq1[NUM_SIZE-1], seq1[NUM_SIZE], seq1[NUM_SIZE+1], decoderInput})\n        4'b0000: sigOut <= 1'b0; // No delay\n        4'b0001: sigOut <= 1'b0; // No delay\n        4'b0010: sigOut <= 1'b0; // No delay\n        4'b0011: sigOut <= 1'b0; // No delay\n        4'b0100: sigOut <= 1'b0; // No delay\n        4'b0101: sigOut <= 1'b0; // No delay\n        4'b0110: sigOut <= 1'b0; // No delay\n        4'b0111: sigOut <= 1'b0; // No delay\n        4'b1000: sigOut <= 1'b0; // No delay\n        4'b1001: sigOut <= 1'b0; // No delay\n        4'b1010: sigOut <= seq2[NUM_SIZE]; // 90 degrees delay\n        4'b1011: sigOut <= seq2[NUM_SIZE+1]; // 90 degrees delay\n        4'b1100: sigOut <= seq3[NUM_SIZE]; // 180 degrees delay\n        4'b1101: sigOut <= seq3[NUM_SIZE+1]; // 180 degrees delay\n        4'b1110: sigOut <= seq4[NUM_SIZE]; // 270 degrees delay\n        4'b1111: sigOut <= seq4[NUM_SIZE+1]; // 270 degrees delay\n    endcase\nend\n\n// Initialize the binary sequences\ninitial begin\n    seq1 = 11'b01000000000; // In phase\n    seq2 = 11'b01001000000; // 90 degrees out of phase\n    seq3 = 11'b01010000000; // 180 degrees out of phase\n    seq4 = 11'b01011000000; // 270 degrees out of phase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "controllerHdl_ADC_Peripheral_To_Phase_Current_6ea3752c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule controllerHdl_ADC_Peripheral_To_Phase_Current\n          (\n           adc_0,\n           adc_1,\n           phase_currents_0,\n           phase_currents_1\n          );\n\n\n  input   signed [17:0] adc_0;  input   signed [17:0] adc_1;  output  signed [17:0] phase_currents_0;  output  signed [17:0] phase_currents_1;  wire signed [17:0] adc [0:1];  wire signed [17:0] ADC_Zero_Offset_out1;  wire signed [19:0] Add_v;  wire signed [19:0] Add_sub_cast;  wire signed [19:0] Add_sub_cast_1;  wire signed [19:0] Add_out1 [0:1];  wire signed [17:0] ADC_Amps_Per_Driver_Unit_out1;  wire signed [37:0] Product_mul_temp;  wire signed [37:0] Product_mul_temp_1;  wire signed [17:0] phase_currents [0:1];  assign adc[0] = adc_0;\n  assign adc[1] = adc_1;\n\n  assign ADC_Zero_Offset_out1 = 18'sb000000000000000000;\n\n\n\n  assign Add_v = {ADC_Zero_Offset_out1[17], {ADC_Zero_Offset_out1, 1'b0}};\n  assign Add_sub_cast = adc[0];\n  assign Add_out1[0] = Add_sub_cast - Add_v;\n  assign Add_sub_cast_1 = adc[1];\n  assign Add_out1[1] = Add_sub_cast_1 - Add_v;\n\n\n\n  assign ADC_Amps_Per_Driver_Unit_out1 = 18'sb010100000000000000;\n\n\n\n  assign Product_mul_temp = Add_out1[0] * ADC_Amps_Per_Driver_Unit_out1;\n  assign phase_currents[0] = ((Product_mul_temp[37] == 1'b0) && (Product_mul_temp[36:34] != 3'b000) ? 18'sb011111111111111111 :\n              ((Product_mul_temp[37] == 1'b1) && (Product_mul_temp[36:34] != 3'b111) ? 18'sb100000000000000000 :\n              $signed(Product_mul_temp[34:17])));\n  assign Product_mul_temp_1 = Add_out1[1] * ADC_Amps_Per_Driver_Unit_out1;\n  assign phase_currents[1] = ((Product_mul_temp_1[37] == 1'b0) && (Product_mul_temp_1[36:34] != 3'b000) ? 18'sb011111111111111111 :\n              ((Product_mul_temp_1[37] == 1'b1) && (Product_mul_temp_1[36:34] != 3'b111) ? 18'sb100000000000000000 :\n              $signed(Product_mul_temp_1[34:17])));\n\n\n\n  assign phase_currents_0 = phase_currents[0];\n\n  assign phase_currents_1 = phase_currents[1];\n\nendmodule  "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "instdec_6f29f266", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule instdec (\ninput\t[31:0]\tcae_inst,\ninput\t[63:0]\tcae_data,\ninput\t\tcae_inst_vld,\n\noutput\t\tinst_val,\noutput\t[4:0]\tinst_caep,\noutput\t\tinst_aeg_wr,\noutput\t\tinst_aeg_rd,\noutput\t[17:0]\tinst_aeg_idx,\n\noutput\t\terr_unimpl\n);\n\n    reg\t\tc_val, c_aeg_wr, c_aeg_rd, c_unimpl;\n    reg [4:0]\tc_caep;\n    reg [17:0]\tc_aeg_idx;\n\n    always @* begin\n\tc_val = 'b0;\n\tc_caep = 'b0;\n\tc_aeg_wr = 'b0;\n\tc_aeg_rd = 'b0;\n\tc_aeg_idx = 'b0;\n\tc_unimpl = 'b0;\n\n\tcasex (cae_inst[28:24])\n\t5'b1101?: begin\n\t    case (cae_inst[24:18])\n\t    7'h40: begin\n\t\tc_aeg_idx = cae_inst[17:0];\n\t\tc_aeg_wr  = cae_inst_vld;\n\t    end\n\t    7'h68: begin\n\t\tc_aeg_idx = cae_data[17:0];\n\t\tc_aeg_rd  = cae_inst_vld;\n\t    end\n\t    7'h70: begin\n\t\tc_aeg_idx = {6'b0, cae_inst[17:6]};\n\t\tc_aeg_rd  = cae_inst_vld;\n\t    end\n\t    default: c_unimpl = cae_inst_vld;\n\t    endcase\n\tend\n\t5'b11100: begin\n\t    case (cae_inst[23:18])\n\t    6'h18: begin\n\t\tc_aeg_idx = {6'b0, cae_inst[17:12], cae_inst[5:0]};\n\t\tc_aeg_wr  = cae_inst_vld;\n\t    end\n\t    6'h20: begin\n\t\tc_aeg_idx = {6'b0, cae_inst[17:12], cae_inst[5:0]};\n\t\tc_aeg_wr  = cae_inst_vld;\n\t    end\n\t    default: c_unimpl = cae_inst_vld;\n\t    endcase\n\tend\n\t5'b11101: begin\n\t    case (cae_inst[23:18])\n\t    6'h1c: begin\n\t\tc_aeg_idx = {6'b0, cae_inst[17:6]};\n\t\tc_aeg_rd  = cae_inst_vld;\n\t    end\n\t    default: c_unimpl = cae_inst_vld;\n\t    endcase\n\tend\n\t5'b11110: begin\n\t    c_caep   = cae_inst[22:18];\n\t    c_val    = cae_inst_vld &  cae_inst[23];\n\t    c_unimpl = cae_inst_vld & !cae_inst[23];\n\tend\n\n\tdefault: c_unimpl = cae_inst_vld;\n\tendcase\n    end\n\n    assign inst_val = c_val;\n    assign inst_caep = c_caep;\n    assign inst_aeg_wr = c_aeg_wr;\n    assign inst_aeg_rd = c_aeg_rd;\n    assign inst_aeg_idx = c_aeg_idx;\n    assign err_unimpl = c_unimpl;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_fc_cntl_4c2d6a59", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule pcie_fc_cntl \n(\ninput\t\t\t\t\t\t\t\t\tpcie_user_clk,\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_rst_n,\n\ninput\t[11:0]\t\t\t\t\t\t\tfc_cpld,\n\tinput\t[7:0]\t\t\t\t\t\t\tfc_cplh,\n\tinput\t[11:0]\t\t\t\t\t\t\tfc_npd,\n\tinput\t[7:0]\t\t\t\t\t\t\tfc_nph,\n\tinput\t[11:0]\t\t\t\t\t\t\tfc_pd,\n\tinput\t[7:0]\t\t\t\t\t\t\tfc_ph,\n\toutput\t[2:0]\t\t\t\t\t\t\tfc_sel,\n\n\tinput\t\t\t\t\t\t\t\t\ttx_cfg_req,\n\toutput\t\t\t\t\t\t\t\t\ttx_cfg_gnt,\n\tinput\t[5:0]\t\t\t\t\t\t\ttx_buf_av,\n\n\toutput\t\t\t\t\t\t\t\t\ttx_cpld_gnt,\n\toutput\t\t\t\t\t\t\t\t\ttx_mrd_gnt,\n\toutput\t\t\t\t\t\t\t\t\ttx_mwr_gnt\n);\n\nparameter\tP_RX_CONSTRAINT_FC_CPLD\t\t= 32;\nparameter\tP_RX_CONSTRAINT_FC_CPLH\t\t= 8;\n\nparameter\tP_TX_CONSTRAINT_FC_CPLD\t\t= 1;\nparameter\tP_TX_CONSTRAINT_FC_CPLH\t\t= 1;\nparameter\tP_TX_CONSTRAINT_FC_NPD\t\t= 1;\nparameter\tP_TX_CONSTRAINT_FC_NPH\t\t= 1;\nparameter\tP_TX_CONSTRAINT_FC_PD\t\t= 32;\nparameter\tP_TX_CONSTRAINT_FC_PH\t\t= 1;\n\nlocalparam\tS_RX_AVAILABLE_FC_SEL\t\t\t= 2'b01;\nlocalparam\tS_TX_AVAILABLE_FC_SEL\t\t\t= 2'b10;\n\nreg\t\t[1:0]\t\t\t\t\t\t\t\tcur_state;\nreg\t\t[1:0]\t\t\t\t\t\t\t\tnext_state;\n\nreg\t\t[11:0]\t\t\t\t\t\t\tr_rx_available_fc_cpld;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_rx_available_fc_cplh;\nreg\t\t[11:0]\t\t\t\t\t\t\tr_rx_available_fc_npd;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_rx_available_fc_nph;\nreg\t\t[11:0]\t\t\t\t\t\t\tr_rx_available_fc_pd;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_rx_available_fc_ph;\n\nreg\t\t[11:0]\t\t\t\t\t\t\tr_tx_available_fc_cpld;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_tx_available_fc_cplh;\nreg\t\t[11:0]\t\t\t\t\t\t\tr_tx_available_fc_npd;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_tx_available_fc_nph;\nreg\t\t[11:0]\t\t\t\t\t\t\tr_tx_available_fc_pd;\nreg\t\t[7:0]\t\t\t\t\t\t\tr_tx_available_fc_ph;\n\nwire\t\t\t\t\t\t\t\t\tw_rx_available_fc_cpld;\nwire\t\t\t\t\t\t\t\t\tw_rx_available_fc_cplh;\n\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_cpld;\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_cplh;\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_npd;\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_nph;\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_pd;\nwire\t\t\t\t\t\t\t\t\tw_tx_available_fc_ph;\n\nreg\t\t[2:0]\t\t\t\t\t\t\tr_fc_sel;\nreg\t\t[1:0]\t\t\t\t\t\t\tr_rd_fc_sel;\nreg\t\t[1:0]\t\t\t\t\t\t\tr_rd_fc_sel_d1;\nreg\t\t[1:0]\t\t\t\t\t\t\tr_rd_fc_sel_d2;\n\nreg\t\t\t\t\t\t\t\t\t\tr_tx_cpld_gnt;\nreg\t\t\t\t\t\t\t\t\t\tr_tx_mrd_gnt;\nreg\t\t\t\t\t\t\t\t\t\tr_tx_mwr_gnt;\n\nassign fc_sel = r_fc_sel;\nassign tx_cfg_gnt = 1'b1;\n\nassign tx_cpld_gnt = r_tx_cpld_gnt;\nassign tx_mrd_gnt = r_tx_mrd_gnt;\nassign tx_mwr_gnt = r_tx_mwr_gnt;\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0)\n\t\tcur_state <= S_RX_AVAILABLE_FC_SEL;\n\telse\n\t\tcur_state <= next_state;\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_RX_AVAILABLE_FC_SEL: begin\n\t\t\tnext_state <= S_TX_AVAILABLE_FC_SEL;\n\t\tend\n\t\tS_TX_AVAILABLE_FC_SEL: begin\n\t\t\tnext_state <= S_RX_AVAILABLE_FC_SEL;\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state <= S_RX_AVAILABLE_FC_SEL;\n\t\tend\n\tendcase\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_RX_AVAILABLE_FC_SEL: begin\n\t\t\tr_fc_sel <= 3'b000;\n\t\t\tr_rd_fc_sel <= 2'b01;\n\t\tend\n\t\tS_TX_AVAILABLE_FC_SEL: begin\n\t\t\tr_fc_sel <= 3'b100;\n\t\t\tr_rd_fc_sel <= 2'b10;\n\t\tend\n\t\tdefault: begin\n\t\t\tr_fc_sel <= 3'b000;\n\t\t\tr_rd_fc_sel <= 2'b00;\n\t\tend\n\tendcase\nend\n\nassign w_rx_available_fc_cpld = (r_rx_available_fc_cpld > P_RX_CONSTRAINT_FC_CPLD);\nassign w_rx_available_fc_cplh = (r_rx_available_fc_cplh > P_RX_CONSTRAINT_FC_CPLH);\n\nassign w_tx_available_fc_cpld = (r_tx_available_fc_cpld > P_TX_CONSTRAINT_FC_CPLD);\nassign w_tx_available_fc_cplh = (r_tx_available_fc_cplh > P_TX_CONSTRAINT_FC_CPLH);\nassign w_tx_available_fc_npd = (r_tx_available_fc_npd > P_TX_CONSTRAINT_FC_NPD);\nassign w_tx_available_fc_nph = (r_tx_available_fc_nph > P_TX_CONSTRAINT_FC_NPH);\nassign w_tx_available_fc_pd = (r_tx_available_fc_pd > P_TX_CONSTRAINT_FC_PD);\nassign w_tx_available_fc_ph = (r_tx_available_fc_ph > P_TX_CONSTRAINT_FC_PH);\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tr_tx_cpld_gnt <= w_tx_available_fc_cpld & w_tx_available_fc_cplh;\n\tr_tx_mrd_gnt <= (w_tx_available_fc_npd & w_tx_available_fc_nph) & (w_rx_available_fc_cpld & w_rx_available_fc_cplh);\n\tr_tx_mwr_gnt <= w_tx_available_fc_pd & w_tx_available_fc_ph;\nend\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0) begin\n\t\tr_rd_fc_sel_d1 <= 0;\n\t\tr_rd_fc_sel_d2 <= 0;\n\tend\n\telse begin\n\t\tr_rd_fc_sel_d1 <= r_rd_fc_sel;\n\t\tr_rd_fc_sel_d2 <= r_rd_fc_sel_d1;\n\tend\nend\n\nalways @ (posedge pcie_user_clk or negedge pcie_user_rst_n)\nbegin\n\tif(pcie_user_rst_n == 0) begin\n\t\tr_rx_available_fc_cpld <= 0;\n\t\tr_rx_available_fc_cplh <= 0;\n\t\tr_rx_available_fc_npd <= 0;\n\t\tr_rx_available_fc_nph <= 0;\n\t\tr_rx_available_fc_pd <= 0;\n\t\tr_rx_available_fc_ph <= 0;\n\n\t\tr_tx_available_fc_cpld <= 0;\n\t\tr_tx_available_fc_cplh <= 0;\n\t\tr_tx_available_fc_npd <= 0;\n\t\tr_tx_available_fc_nph <= 0;\n\t\tr_tx_available_fc_pd <= 0;\n\t\tr_tx_available_fc_ph <= 0;\n\tend\n\telse begin\n\t\tif(r_rd_fc_sel_d2[0] == 1) begin\n\t\t\tr_rx_available_fc_cpld <= fc_cpld;\n\t\t\tr_rx_available_fc_cplh <= fc_cplh;\n\t\t\tr_rx_available_fc_npd <= fc_npd;\n\t\t\tr_rx_available_fc_nph <= fc_nph;\n\t\t\tr_rx_available_fc_pd <= fc_pd;\n\t\t\tr_rx_available_fc_ph <= fc_ph;\n\t\tend\n\t\tif(r_rd_fc_sel_d2[1] == 1) begin\n\t\t\tr_tx_available_fc_cpld <= fc_cpld;\n\t\t\tr_tx_available_fc_cplh <= fc_cplh;\n\t\t\tr_tx_available_fc_npd <= fc_npd;\n\t\t\tr_tx_available_fc_nph <= fc_nph;\n\t\t\tr_tx_available_fc_pd <= fc_pd;\n\t\t\tr_tx_available_fc_ph <= fc_ph;\n\t\tend\n\tend\nend\n\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__a5d97acb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input CLK,\n    input CLR,\n    input LD,\n    input [3:0] DATA,\n    output [3:0] Y\n);\n// Temp Reg\nwire [3:0] counter_output;\nwire [3:0] bitwise_and_output;\n\n// Sub Modules\ncounter counter_inst (\n    .CLK(CLK),\n    .CLR(CLR),\n    .LD(LD),\n    .DATA(DATA),\n    // Output Ports\n    .Q(counter_output)\n);\n\nbitwise_and bitwise_and_inst (\n    .A(counter_output),\n    .B(DATA),\n    // Output Ports\n    .Y(bitwise_and_output)\n);\n\nfunctional_module functional_module_inst (\n    .counter_output(counter_output),\n    .bitwise_and_output(bitwise_and_output),\n    // Output Ports\n    .final_output(Y)\n);\n\nendmodule\n\nmodule counter (\n    input CLK,\n    input CLR,\n    input LD,\n    input [3:0] DATA,\n    // Output Ports\n    output reg [3:0] Q\n);\n\nalways @(posedge CLK or negedge CLR) begin\n    if (CLR == 0) begin\n        Q <= 0;\n    end else if (LD == 1) begin\n        Q <= DATA;\n    end else begin\n        Q <= Q + 1;\n        if (Q == 16) begin\n            Q <= 0;\n        end\n    end\nend\n\nendmodule\n\nmodule bitwise_and (\n    input [3:0] A,\n    input [3:0] B,\n    // Output Ports\n    output reg [3:0] Y\n);\n\nalways @(A or B) begin\n  Y = A & B;\nend\n\nendmodule\n\nmodule functional_module (\n    input [3:0] counter_output,\n    input [3:0] bitwise_and_output,\n    // Output Ports\n    output reg [3:0] final_output\n);\n\nalways @(counter_output or bitwise_and_output) begin\n  final_output = bitwise_and_output & counter_output;\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Multiplexer #_12ef4cbf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Multiplexer #(parameter WIDTH = 1) (\n  input wire ctrl,\n  input wire [WIDTH-1:0] D0,\n  input wire [WIDTH-1:0] D1,\n  output reg [WIDTH-1:0] S\n);\n\n  always @(*) begin\n    if (ctrl == 1'b0) begin\n      S <= D0;\n    end else begin\n      S <= D1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_c87beaec", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder(input A, input B, input Cin, output S, output Cout);\n  assign S = A ^ B ^ Cin;\n  assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "NOR4X0_79909410", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule NOR4X0 (IN1, IN2, IN3, IN4, QN);\n\n   input IN1;\n   input IN2, IN3, IN4;\n   output QN;\n\n   wire n1, n2, n3, n4;\n\n   nand (n1, IN1, IN2);\n   nand (n2, IN3, IN4);\n   nand (n3, n1, n2);\n   nand (n4, n3, n3);\n\n   nand (QN, n4, n4);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FB_IOManager_dffec785", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define STATE_Start 0\n\n\nmodule FB_IOManager \n\n(\n\t\tinput wire clk,\n\t\t\n\t\tinput wire DoorReleaseCanister_eI,\n\t\tinput wire ConveyorChanged_eI,\n\t\tinput wire InjectorPositionChanged_eI,\n\t\tinput wire InjectorControlsChanged_eI,\n\t\tinput wire FillContentsChanged_eI,\n\t\tinput wire StartVacuumTimer_eI,\n\t\tinput wire GoRejectArm_eI,\n\t\tinput wire CanisterCountChanged_eI,\n\t\tinput wire InjectDone_eI,\n\t\t\n\t\toutput wire InjectorArmFinishMovement_eO,\n\t\toutput wire EmergencyStopChanged_eO,\n\t\toutput wire CanisterPressureChanged_eO,\n\t\toutput wire FillContentsAvailableChanged_eO,\n\t\toutput wire LasersChanged_eO,\n\t\toutput wire DoorOverride_eO,\n\t\toutput wire VacuumTimerElapsed_eO,\n\t\t\n\t\tinput wire [7:0] ConveyorSpeed_I,\n\t\tinput wire [7:0] InjectorPosition_I,\n\t\tinput wire  InjectorContentsValveOpen_I,\n\t\tinput wire  InjectorVacuumRun_I,\n\t\tinput wire  InjectorPressurePumpRun_I,\n\t\tinput wire  FillContents_I,\n\t\tinput wire [7:0] CanisterCount_I,\n\t\t\n\t\toutput reg  EmergencyStop_O ,\n\t\toutput reg [7:0] CanisterPressure_O ,\n\t\toutput reg [7:0] FillContentsAvailable_O ,\n\t\toutput reg  DoorSiteLaser_O ,\n\t\toutput reg  InjectSiteLaser_O ,\n\t\toutput reg  RejectSiteLaser_O ,\n\t\toutput reg  RejectBinLaser_O ,\n\t\toutput reg  AcceptBinLaser_O ,\n\t\t\n\n\t\tinput reset\n);\n\n\nwire DoorReleaseCanister;\nassign DoorReleaseCanister = DoorReleaseCanister_eI;\nwire ConveyorChanged;\nassign ConveyorChanged = ConveyorChanged_eI;\nwire InjectorPositionChanged;\nassign InjectorPositionChanged = InjectorPositionChanged_eI;\nwire InjectorControlsChanged;\nassign InjectorControlsChanged = InjectorControlsChanged_eI;\nwire FillContentsChanged;\nassign FillContentsChanged = FillContentsChanged_eI;\nwire StartVacuumTimer;\nassign StartVacuumTimer = StartVacuumTimer_eI;\nwire GoRejectArm;\nassign GoRejectArm = GoRejectArm_eI;\nwire CanisterCountChanged;\nassign CanisterCountChanged = CanisterCountChanged_eI;\nwire InjectDone;\nassign InjectDone = InjectDone_eI;\n\nreg InjectorArmFinishMovement;\nassign InjectorArmFinishMovement_eO = InjectorArmFinishMovement;\nreg EmergencyStopChanged;\nassign EmergencyStopChanged_eO = EmergencyStopChanged;\nreg CanisterPressureChanged;\nassign CanisterPressureChanged_eO = CanisterPressureChanged;\nreg FillContentsAvailableChanged;\nassign FillContentsAvailableChanged_eO = FillContentsAvailableChanged;\nreg LasersChanged;\nassign LasersChanged_eO = LasersChanged;\nreg DoorOverride;\nassign DoorOverride_eO = DoorOverride;\nreg VacuumTimerElapsed;\nassign VacuumTimerElapsed_eO = VacuumTimerElapsed;\n\nreg [7:0] ConveyorSpeed ;\nreg [7:0] InjectorPosition ;\nreg  InjectorContentsValveOpen ;\nreg  InjectorVacuumRun ;\nreg  InjectorPressurePumpRun ;\nreg  FillContents ;\nreg [7:0] CanisterCount ;\n\nreg  EmergencyStop ;\nreg [7:0] CanisterPressure ;\nreg [7:0] FillContentsAvailable ;\nreg  DoorSiteLaser ;\nreg  InjectSiteLaser ;\nreg  RejectSiteLaser ;\nreg  RejectBinLaser ;\nreg  AcceptBinLaser ;\n\nreg   EmergencyStopped ; \nreg  state = `STATE_Start;\nreg entered = 1'b0;\nreg IOAlgorithm_alg_en = 1'b0; \n\nalways@(posedge clk) begin\n\n\tif(reset) begin\n\t\tstate = `STATE_Start;\n\n\t\tInjectorArmFinishMovement = 1'b0;\n\t\tEmergencyStopChanged = 1'b0;\n\t\tCanisterPressureChanged = 1'b0;\n\t\tFillContentsAvailableChanged = 1'b0;\n\t\tLasersChanged = 1'b0;\n\t\tDoorOverride = 1'b0;\n\t\tVacuumTimerElapsed = 1'b0;\n\t\t\n\t\tConveyorSpeed = 0;\n\t\tInjectorPosition = 0;\n\t\tInjectorContentsValveOpen = 0;\n\t\tInjectorVacuumRun = 0;\n\t\tInjectorPressurePumpRun = 0;\n\t\tFillContents = 0;\n\t\tCanisterCount = 0;\n\t\t\n\t\tEmergencyStop = 0;\n\t\tCanisterPressure = 0;\n\t\tFillContentsAvailable = 0;\n\t\tDoorSiteLaser = 0;\n\t\tInjectSiteLaser = 0;\n\t\tRejectSiteLaser = 0;\n\t\tRejectBinLaser = 0;\n\t\tAcceptBinLaser = 0;\n\t\tEmergencyStopped = 0;\n\tend else begin\n\n\t\tInjectorArmFinishMovement = 1'b0;\n\t\tEmergencyStopChanged = 1'b0;\n\t\tCanisterPressureChanged = 1'b0;\n\t\tFillContentsAvailableChanged = 1'b0;\n\t\tLasersChanged = 1'b0;\n\t\tDoorOverride = 1'b0;\n\t\tVacuumTimerElapsed = 1'b0;\n\t\t\n\t\tif(ConveyorChanged) begin \n\t\t\tConveyorSpeed = ConveyorSpeed_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(InjectorPositionChanged) begin \n\t\t\tInjectorPosition = InjectorPosition_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(InjectorControlsChanged) begin \n\t\t\tInjectorContentsValveOpen = InjectorContentsValveOpen_I;\n\t\t\tInjectorVacuumRun = InjectorVacuumRun_I;\n\t\t\tInjectorPressurePumpRun = InjectorPressurePumpRun_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(FillContentsChanged) begin \n\t\t\tFillContents = FillContents_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(CanisterCountChanged) begin \n\t\t\tCanisterCount = CanisterCount_I;\n\t\t\t\n\t\tend\n\t\t\n\t\tentered = 1'b0;\n\t\tcase(state) \n\t\t\t`STATE_Start: begin\n\t\t\t\tif(1) begin\n\t\t\t\t\tstate = `STATE_Start;\n\t\t\t\t\tentered = 1'b1;\n\t\t\t\tend\n\t\t\tend \n\t\t\tdefault: begin\n\t\t\t\tstate = 0;\n\t\t\tend\n\t\tendcase\n\t\tIOAlgorithm_alg_en = 1'b0; \n\t\t\n\t\tif(entered) begin\n\t\t\tcase(state)\n\t\t\t\t`STATE_Start: begin\n\t\t\t\t\tIOAlgorithm_alg_en = 1'b1;\n\t\t\t\t\tEmergencyStopChanged = 1'b1;\n\t\t\t\t\t\n\t\t\t\tend \n\t\t\t\tdefault: begin\n\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\t\tif(IOAlgorithm_alg_en) begin\n\t\t\t\n\t\tend \n\t\t\n\t\tif(EmergencyStopChanged) begin \n\t\t\tEmergencyStop_O = EmergencyStop;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(CanisterPressureChanged) begin \n\t\t\tCanisterPressure_O = CanisterPressure;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(FillContentsAvailableChanged) begin \n\t\t\tFillContentsAvailable_O = FillContentsAvailable;\n\t\t\t\n\t\tend\n\t\t\n\t\tif(LasersChanged) begin \n\t\t\tDoorSiteLaser_O = DoorSiteLaser;\n\t\t\tInjectSiteLaser_O = InjectSiteLaser;\n\t\t\tRejectSiteLaser_O = RejectSiteLaser;\n\t\t\tRejectBinLaser_O = RejectBinLaser;\n\t\t\tAcceptBinLaser_O = AcceptBinLaser;\n\t\t\t\n\t\tend\n\t\t\n\t\tend\nend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "io_mux_47659a65", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule  io_mux (\n\na_din,\n    a_dout,\n    a_dout_en,\n\nb_din,\n    b_dout,\n    b_dout_en,\n\nio_din,\n    io_dout,\n    io_dout_en,\n\nsel\n);\n\nparameter          WIDTH = 8;\n   \noutput [WIDTH-1:0] a_din;\ninput  [WIDTH-1:0] a_dout;\ninput  [WIDTH-1:0] a_dout_en;\n\noutput [WIDTH-1:0] b_din;\ninput  [WIDTH-1:0] b_dout;\ninput  [WIDTH-1:0] b_dout_en;\n\ninput  [WIDTH-1:0] io_din;\noutput [WIDTH-1:0] io_dout;\noutput [WIDTH-1:0] io_dout_en;\n\ninput  [WIDTH-1:0] sel;\n\n\nfunction [WIDTH-1:0] mux (\n   input [WIDTH-1:0] A,\n   input [WIDTH-1:0] B,\n   input [WIDTH-1:0] SEL\n);\n   integer i;   \n   begin\n      mux = {WIDTH{1'b0}};\n      for (i = 0; i < WIDTH; i = i + 1)\n\tmux[i] = sel[i] ? B[i] : A[i];\n   end\nendfunction\n\n\nassign a_din      = mux(       io_din, {WIDTH{1'b0}}, sel);\nassign b_din      = mux({WIDTH{1'b0}},        io_din, sel);\nassign io_dout    = mux(       a_dout,        b_dout, sel);\nassign io_dout_en = mux(    a_dout_en,     b_dout_en, sel);\n\n\t   \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_ctrl_63012dbd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_gate_ctrl (\n    input A,\n    input B,\n    input C1,\n    output Y\n);\n\n    assign Y = (C1 == 1'b1) ? (A & B) : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mc_crt_ba3ec733", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule mc_crt\n  (\n   input\t      mclock,\n   input\t      reset_n,\n   input              pixclk,\n   input\t      crt_clock,\n   input\t      crt_gnt,\n   input\t      crt_req,\n   input [20:0]\t      crt_org,\n   input [4:0]\t      crt_page,\n   input [11:0]\t      crt_ptch,\n   input [9:0]\t      crt_x,\n   input [11:0]\t      crt_y,\n   \n   output reg\t      crt_ready,\n   output reg\t      crt_arb_req,\n   output reg [4:0]   crt_arb_page,\n   output reg [20:0]  crt_arb_addr\n   );\n  \n  reg\t\tcapt_req;\n  reg [20:0]\tcapt_org;\n  reg [11:0]\tcapt_ptch;\n  reg [9:0]\tcapt_x;\n  reg [11:0]\tcapt_y;\n  reg [4:0]\tcapt_page;\n\n  reg\t\treq_sync_m1, req_sync_1, req_sync_2, req_sync_3;\n  reg\t\tgnt_sync_1, gnt_sync_2, gnt_sync_3;\n  reg [20:0] \tpmult, int_add;\n  \n  reg\t\tfinal_grant; reg [1:0] \trequests;\n  reg \t\thold_req;\n  \n  wire \t\treq_toggle;\n\n  always @ (posedge pixclk or negedge reset_n) begin\n    if(!reset_n) begin\n      crt_ready <= 1'b1;\n      capt_req  <= 1'b0;\n      capt_org  <= 21'h0;\n      capt_ptch <= 12'b0;\n      capt_x    <= 10'b0;\n      capt_y    <= 12'b0;\n      capt_page <= 5'b0;\n      gnt_sync_1<= 1'b0;\n      gnt_sync_2<= 1'b0;\n      gnt_sync_3<= 1'b0;\n    end else if (crt_clock) begin\n      if (crt_req) begin\n\tcapt_req <= ~capt_req;\n\tcapt_org <= crt_org;\n\tcapt_ptch <= crt_ptch;\n\tcapt_x <= crt_x;\n\tcapt_y <= crt_y;\n\tcapt_page <= crt_page - 5'b1;\n\tcrt_ready <= 1'b0;\n      end gnt_sync_1 <= final_grant;\n      gnt_sync_2 <= gnt_sync_1;\n      gnt_sync_3 <= gnt_sync_2;\n      if(gnt_sync_2 ^ gnt_sync_3) crt_ready <= 1'b1;\n    end end assign req_toggle = req_sync_2 ^ req_sync_3;\n  \n  always @ (posedge mclock or negedge reset_n) begin\n    if(!reset_n) begin\n      crt_arb_req  <= 1'b0;\n      final_grant  <= 1'b0; requests     <= 2'b0;\n      hold_req     <= 1'b0;\n      pmult        <= 21'b0;\n      int_add      <= 21'b0;\n      req_sync_m1  <= 1'b0;\n      req_sync_1   <= 1'b0;\n      req_sync_2   <= 1'b0;\n      req_sync_3   <= 1'b0;\n      crt_arb_req  <= 1'b0;\n      crt_arb_page <= 5'b0;\n      crt_arb_addr <= 21'b0;\n    end else begin\n\n      case ({crt_gnt, req_toggle})\n\t2'b01: requests <= requests + 2'b1;\n\t2'b10: requests <= requests - 2'b1;\n      endcase\n      \n      pmult <= (capt_y * {{4{capt_ptch[11]}}, capt_ptch});\nint_add <= (capt_org + {{11{capt_x[9]}}, capt_x});\n      \n      req_sync_m1 <= capt_req; req_sync_1 <= req_sync_m1;\n      req_sync_2 <= req_sync_1;\n      req_sync_3 <= req_sync_2;\n\n      if (hold_req && ~&requests[1]) begin\n\thold_req <= 0;\n\tcrt_arb_req <= 1'b1;\n\tcrt_arb_page <= capt_page;\n\tcrt_arb_addr <= pmult + int_add;\n      end else if(req_toggle && ~&requests[1]) begin\n\tcrt_arb_req <= 1'b1;\n\tcrt_arb_page <= capt_page;\n\tcrt_arb_addr <= pmult + int_add;\n      end else if(req_toggle && (&requests[1])) begin\n\thold_req <= 1;\n      end if(crt_gnt) begin\n\tcrt_arb_req <= 1'b0;\n\tfinal_grant <= ~final_grant;\n      end end end endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "int_to_float_c21ce0b2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule int_to_float(\n        input_a,\n        input_a_stb,\n        output_z_ack,\n        clk,\n        rst,\n        output_z,\n        output_z_stb,\n        input_a_ack);\n\n  input     clk;\n  input     rst;\n\n  input     [31:0] input_a;\n  input     input_a_stb;\n  output    input_a_ack;\n\n  output    [31:0] output_z;\n  output    output_z_stb;\n  input     output_z_ack;\n\n  reg       s_output_z_stb;\n  reg       [31:0] s_output_z;\n  reg       s_input_a_ack;\n  reg       s_input_b_ack;\n\n  reg       [2:0] state;\n  parameter get_a         = 3'd0,\n            convert_0     = 3'd1,\n            convert_1     = 3'd2,\n            convert_2     = 3'd3,\n            round         = 3'd4,\n            pack          = 3'd5,\n            put_z         = 3'd6;\n\n  reg [31:0] a, z, value;\n  reg [23:0] z_m;\n  reg [7:0] z_r;\n  reg [7:0] z_e;\n  reg z_s;\n  reg guard, round_bit, sticky;\n\n  always @(posedge clk)\n  begin\n\n    case(state)\n\n      get_a:\n      begin\n        s_input_a_ack <= 1;\n        if (s_input_a_ack && input_a_stb) begin\n          a <= input_a;\n          s_input_a_ack <= 0;\n          state <= convert_0;\n        end\n      end\n\n      convert_0:\n      begin\n        if ( a == 0 ) begin\n          z_s <= 0;\n          z_m <= 0;\n          z_e <= -127;\n          state <= pack;\n        end else begin\n          value <= a[31] ? -a : a;\n          z_s <= a[31];\n          state <= convert_1;\n        end\n      end\n\n      convert_1:\n      begin\n        z_e <= 31;\n        z_m <= value[31:8];\n        z_r <= value[7:0];\n        state <= convert_2;\n      end\n\n      convert_2:\n      begin\n        if (!z_m[23]) begin\n          z_e <= z_e - 1;\n          z_m <= z_m << 1;\n          z_m[0] <= z_r[7];\n          z_r <= z_r << 1;\n        end else begin\n          guard <= z_r[7];\n          round_bit <= z_r[6];\n          sticky <= z_r[5:0] != 0;\n          state <= round;\n        end\n      end\n\n      round:\n      begin\n        if (guard && (round_bit || sticky || z_m[0])) begin\n          z_m <= z_m + 1;\n          if (z_m == 24'hffffff) begin\n            z_e <=z_e + 1;\n          end\n        end\n        state <= pack;\n      end\n\n      pack:\n      begin\n        z[22 : 0] <= z_m[22:0];\n        z[30 : 23] <= z_e + 127;\n        z[31] <= z_s;\n        state <= put_z;\n      end\n\n      put_z:\n      begin\n        s_output_z_stb <= 1;\n        s_output_z <= z;\n        if (s_output_z_stb && output_z_ack) begin\n          s_output_z_stb <= 0;\n          state <= get_a;\n        end\n      end\n\n    endcase\n\n    if (rst == 1) begin\n      state <= get_a;\n      s_input_a_ack <= 0;\n      s_output_z_stb <= 0;\n    end\n\n  end\n  assign input_a_ack = s_input_a_ack;\n  assign output_z_stb = s_output_z_stb;\n  assign output_z = s_output_z;\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gate_93fc5d52", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_gate(\n  input CLK, // clock input\n  input EN, // enable input\n  input TE, // test enable input\n  output reg ENCLK // clock gated output\n);\n\n  always @ (posedge CLK) begin\n    if (EN && TE) begin\n      ENCLK <= 1'b1;\n    end\n    else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__efb105ef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_module (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    nor (X, A1, A2);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "reverse_byte_order_3aa6bd86", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule reverse_byte_order(\n    input [31:0] in,\n    output [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output reg sum,\n    output reg cout\n);\n\n    always @ (a or b or cin) begin\n        {cout, sum} = a + b + cin;\n    end\n\nendmodule\nmodule adder_with_carry_in(\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [4:0] sum\n);\n\n    wire c1, c2, c3;\n\n    full_adder fa1(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder fa2(.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder fa3(.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder fa4(.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(sum[4]));\n\nendmodule\nmodule top_module(\n    input [31:0] in1,\n    input [31:0] in2,\n    input cin,\n    output [31:0] out\n);\n\n    wire [31:0] rev_in1, rev_in2;\n    wire [4:0] sum;\n\n    reverse_byte_order rbo1(.in(in1), .out(rev_in1));\n    reverse_byte_order rbo2(.in(in2), .out(rev_in2));\n    adder_with_carry_in awci(.a(rev_in1[3:0]), .b(rev_in2[3:0]), .cin(cin), .sum(sum));\n    reverse_byte_order rbo3(.in({sum[4], sum[3:0], 27'b0}), .out(out));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_608847cc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder (\n    input A,\n    input B,\n    input CIN,\n    output SUM,\n    output COUT\n);\n\n    wire C1, S1, C2;\n    fa fa1 (\n        .A(A),\n        .B(B),\n        .CI(CIN),\n        .S(S1),\n        .CO(C1)\n    );\n    fa fa2 (\n        .A(S1),\n        .B(C1),\n        .CI(1'b0),\n        .S(SUM),\n        .CO(C2)\n    );\n    assign COUT = C1 | C2;\n\nendmodule \n\nmodule fa (\n    input A,\n    input B,\n    input CI,\n    output S,\n    output CO\n);\n\n    assign {CO, S} = A + B + CI;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Seven_seg_84a63712", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Seven_seg(clk, reset, DAT_I, STB, DAT_O, ACK, WE, Segment, AN, debug_data_hold);\n    input clk, reset;\n    input [31: 0] DAT_I;\n    input STB;\n    input WE;\n    output reg [3: 0] AN;\n    output [7: 0] Segment;\n    output [31: 0] DAT_O;\n    output ACK;\n    output [15: 0] debug_data_hold;\n\n    reg [7: 0] digit_seg, digit;\n    reg [15: 0] data_hold = 16'h2333;\n    reg [31: 0] cnt = 0;\n\n    wire [1: 0] scan;\n\n    always @(posedge clk) begin\n        cnt <= cnt + 1;\n    end\n\n    assign scan = cnt[18: 17];\n\n    assign ACK = STB;\n\n    assign Segment = digit_seg;\n    assign DAT_O = Segment;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) data_hold <= 16'h2333;\n        else data_hold <= STB ? DAT_I : data_hold;\n    end\n\n    always @* begin\n        case(scan)\n            0: AN = 4'b1110;\n            1: AN = 4'b1101;\n            2: AN = 4'b1011;\n            3: AN = 4'b0111;\n        endcase\n    end\n\n    always @* begin\n        case(scan)\n            0: digit = data_hold[3: 0];\n            1: digit = data_hold[7: 4];\n            2: digit = data_hold[11: 8];\n            3: digit = data_hold[15: 12];\n        endcase\n    end\n\n    always @* begin\n        case(digit)\n            4'b0000: digit_seg = 8'b11000000;\n            4'b0001: digit_seg = 8'b11111001;\n            4'b0010: digit_seg = 8'b10100100;\n            4'b0011: digit_seg = 8'b10110000;\n            4'b0100: digit_seg = 8'b10011001;\n            4'b0101: digit_seg = 8'b10010010;\n            4'b0110: digit_seg = 8'b10000010;\n            4'b0111: digit_seg = 8'b11111000;\n            4'b1000: digit_seg = 8'b10000000;\n            4'b1001: digit_seg = 8'b10010000;\n            4'b1010: digit_seg = 8'b10001000;\n            4'b1011: digit_seg = 8'b10000011;\n            4'b1100: digit_seg = 8'b11000110;\n            4'b1101: digit_seg = 8'b10100001;\n            4'b1110: digit_seg = 8'b10000110;\n            4'b1111: digit_seg = 8'b10001110;\n        endcase\n    end\n\n    assign debug_data_hold = data_hold;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "drp_other_registers#_6b9ef748", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule  drp_other_registers#(\n    parameter DRP_ABITS =       8,\n    parameter DRP_REG0 =        8,\n    parameter DRP_REG1 =        9,\n    parameter DRP_REG2 =       10,\n    parameter DRP_REG3 =       11\n)(\n    input                   drp_rst,\n    input                   drp_clk,\n    input                   drp_en, input                   drp_we,\n    input   [DRP_ABITS-1:0] drp_addr,       \n    input            [15:0] drp_di,\n    output reg              drp_rdy,\n    output reg       [15:0] drp_do,\n    output           [15:0] drp_register0,\n    output           [15:0] drp_register1,\n    output           [15:0] drp_register2,\n    output           [15:0] drp_register3\n);\n    \n    reg           [DRP_ABITS-1:0] drp_addr_r;\n    reg                           drp_wr_r;\n    reg                    [ 1:0] drp_rd_r;\n    reg                    [15:0] drp_di_r;\n    reg                           drp_reg0_set;\n    reg                           drp_reg1_set;\n    reg                           drp_reg2_set;\n    reg                           drp_reg3_set;\n    reg                           drp_reg0_get;\n    reg                           drp_reg1_get;\n    reg                           drp_reg2_get;\n    reg                           drp_reg3_get;\n    \n    reg                    [15:0] drp_register0_r;\n    reg                    [15:0] drp_register1_r;\n    reg                    [15:0] drp_register2_r;\n    reg                    [15:0] drp_register3_r;\n    \n    assign drp_register0 = drp_register0_r;\n    assign drp_register1 = drp_register1_r;\n    assign drp_register2 = drp_register2_r;\n    assign drp_register3 = drp_register3_r;\n    \n    always @ (posedge drp_clk) begin\n        drp_addr_r <=           drp_addr;\n        drp_wr_r <=             drp_we && drp_en;\n        drp_rd_r <=             {drp_rd_r[0],~drp_we & drp_en};\n        drp_di_r <=             drp_di;\n        \n        drp_reg0_set <=         drp_wr_r &&    (drp_addr_r == DRP_REG0);\n        drp_reg1_set <=         drp_wr_r &&    (drp_addr_r == DRP_REG1);\n        drp_reg2_set <=         drp_wr_r &&    (drp_addr_r == DRP_REG2);\n        drp_reg3_set <=         drp_wr_r &&    (drp_addr_r == DRP_REG3);\n        drp_reg0_get <=         drp_rd_r[0] && (drp_addr_r == DRP_REG0);       \n        drp_reg1_get <=         drp_rd_r[0] && (drp_addr_r == DRP_REG1);       \n        drp_reg2_get <=         drp_rd_r[0] && (drp_addr_r == DRP_REG2);       \n        drp_reg3_get <=         drp_rd_r[0] && (drp_addr_r == DRP_REG3);       \n        \n        drp_rdy <=              drp_wr_r || drp_rd_r[1];\n        drp_do <=               ({16{drp_reg0_get}} & drp_register0_r) |\n                                ({16{drp_reg1_get}} & drp_register1_r) |\n                                ({16{drp_reg2_get}} & drp_register2_r) |\n                                ({16{drp_reg3_get}} & drp_register3_r);\n                                \n        if      (drp_rst)       drp_register0_r <= 0;\n        else if (drp_reg0_set)  drp_register0_r <= drp_di_r;\n        \n        if      (drp_rst)       drp_register1_r <= 0;\n        else if (drp_reg1_set)  drp_register1_r <= drp_di_r;\n        \n        if      (drp_rst)       drp_register2_r <= 0;\n        else if (drp_reg2_set)  drp_register2_r <= drp_di_r;\n        \n        if      (drp_rst)       drp_register3_r <= 0;\n        else if (drp_reg3_set)  drp_register3_r <= drp_di_r;\n        \n    end\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "uart51_rx_dbfbf133", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule uart51_rx(\nRESET_N,\nBAUD_CLK,\nRX_DATA,\nRX_BUFFER,\nRX_WORD,\nRX_PAR_DIS,\nRX_PARITY,\nPARITY_ERR,\nFRAME,\nREADY\n);\ninput\t\t\t\t\tRESET_N;\ninput\t\t\t\t\tBAUD_CLK;\ninput\t\t\t\t\tRX_DATA;\noutput\t[7:0]\t\tRX_BUFFER;\nreg\t\t[7:0]\t\tRX_BUFFER;\ninput\t\t[1:0]\t\tRX_WORD;\ninput\t\t\t\t\tRX_PAR_DIS;\ninput\t\t[1:0]\t\tRX_PARITY;\noutput\t\t\t\tPARITY_ERR;\nreg\t\t\t\t\tPARITY_ERR;\noutput\t\t\t\tFRAME;\nreg\t\t\t\t\tFRAME;\noutput\t\t\t\tREADY;\nreg\t\t\t\t\tREADY;\nreg\t\t[5:0]\t\tSTATE;\nreg\t\t[2:0]\t\tBIT;\nreg\t\t\t\t\tRX_DATA0;\nreg\t\t\t\t\tRX_DATA1;\n\nalways @ (posedge BAUD_CLK or negedge RESET_N)\nbegin\n\tif(!RESET_N)\n\tbegin\n\t\tRX_BUFFER <= 8'h00;\n\t\tSTATE <= 6'b000000;\n\t\tFRAME <= 1'b0;\n\t\tBIT <= 3'b000;\n\t\tRX_DATA0 <= 1'b1;\n\t\tRX_DATA1 <= 1'b1;\n\t\tREADY <= 1'b0;\n\tend\n\telse\n\tbegin\n\t\tRX_DATA0 <= RX_DATA;\n\t\tRX_DATA1 <= RX_DATA0;\n\t\tcase (STATE)\n\t\t6'b000000:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tBIT <= 3'b000;\n\t\t\tif(~RX_DATA1)\n\t\t\t\tSTATE <= 6'b000001;\n\t\tend\n\t\t6'b001111:\t\t\t\t\t\t\t\tbegin\t\t\t\t\t\t\t\t\t\tREADY <= 1'b0;\n\t\t\tSTATE <= 6'b010000;\n\t\tend\n\t\t6'b010111:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tRX_BUFFER[BIT] <= RX_DATA1;\n\t\t\tSTATE <= 6'b011000;\n\t\tend\n\t\t6'b011111:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tif(BIT == 3'b111)\n\t\t\tbegin\n\t\t\t\tSTATE <= 6'b100000;\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tif((RX_WORD == 2'b01) && (BIT == 3'b110))\n\t\t\t\tbegin\n\t\t\t\t\tSTATE <= 6'b100000;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tif((RX_WORD == 2'b10) && (BIT == 3'b101)) \n\t\t\t\t\tbegin\n\t\t\t\t\t\tSTATE <= 6'b100000;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif((RX_WORD == 2'b11) && (BIT == 3'b100))\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tSTATE <= 6'b100000;\n\t\t\t\t\t\tend\n\t\t\t\t\t\telse\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\tBIT <= BIT + 1'b1;\n\t\t\t\t\t\t\tSTATE <= 6'b010000;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t6'b100000:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tif(RX_PAR_DIS)\n\t\t\t\tSTATE <= 6'b110001;\t\telse\n\t\t\t\tSTATE <= 6'b100001;\t\tend\n\t\t6'b100111:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tPARITY_ERR <= ~RX_PARITY[1] &\t\t\t\t\t\t\t\t\t\t\t(((RX_BUFFER[0] ^ RX_BUFFER[1])\n\t\t\t\t\t\t\t ^ (RX_BUFFER[2] ^ RX_BUFFER[3]))\n\n\t\t\t\t\t\t\t ^((RX_BUFFER[4] ^ RX_BUFFER[5])\n\t\t\t\t\t\t\t ^ (RX_BUFFER[6] ^ RX_BUFFER[7]))\t^ (~RX_PARITY[0] ^ RX_DATA1));\n\t\t\tSTATE <= 6'b101000;\nend\n\t\t6'b110111:\t\t\t\t\t\t\t\t\t\tbegin\n\t\t\tFRAME <= !RX_DATA1;\t\t\tREADY <= 1'b1;\n\t\t\tSTATE <= 6'b111000;\n\t\tend\n6'b111000:\n\t\tbegin\n\t\t\tif(RX_DATA1)\n\t\t\t\tSTATE <= 6'b000000;\n\t\tend\n\t\tdefault: STATE <= STATE + 1'b1;\n\t\tendcase\n\tend\nend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "analinput_de19ae11", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule analinput(clk, pay, pby, miso, mosi, cs, sck);\nparameter PADDLESIZE = 0;\nparameter SCREENHEIGHT = 0;\ninput clk;\noutput reg[9:0] pay;\noutput reg[9:0] pby;\ninput miso;\noutput reg mosi;\noutput reg cs;\noutput sck;\n\nparameter state0 = 0, state1 = 1, state2 = 2, state3 = 3;\n\nreg [1:0] state;\n\nreg [4:0] sckcount;\nreg [11:0] datain;\n\nreg ab;\n\nassign sck = clk;\n\nalways @(posedge sck) begin\n\tcase(state)\n\tstate0:\n\t\tbegin\n\t\t\tab <= 1;\n\t\t\tstate <= state1;\n\t\tend\n\tstate1: \n\t\tbegin\n\t\t\tab <= !ab;\n\t\t\tcs <= 0;\n\t\t\tmosi <= !ab;\n\t\t\tsckcount <= 15;\n\t\t\tstate <= state2;\n\t\tend\n\tstate2:\n\t\tbegin\n\t\t\tif (sckcount != 0) \n\t\t\t\tsckcount <= sckcount - 1'b1;\n\t\t\telse \n\t\t\t\tstate <= state3;\n\t\tend\n\tstate3:\n\t\tbegin\n\t\t\tcs <= 1;\n\t\t\tmosi <= 0;\n\t\t\tif (ab == 0) begin\n\t\t\t\tpay <= paddlelimiter(datain[7:0], PADDLESIZE, SCREENHEIGHT);\n\t\t\tend else begin\n\t\t\t\tpby <= paddlelimiter(datain[10:8], PADDLESIZE, SCREENHEIGHT);\n\t\t\tend\n\t\t\tstate <= state1;\n\t\tend\n\tdefault:\n\t\tstate <= state0;\n\tendcase\nend\n\nalways @(negedge sck) begin\n\tif (state == state2)\n\t\tdatain <= (datain << 1) | miso; \n\telse if (state == state1)\n\t\tdatain <= 0;\nend\n\n\nfunction [9:0] paddlelimiter;\ninput [9:0] py;\ninput [3:0] paddlesize;\ninput [9:0] screenheight;\nbegin\n\tif (py < paddlesize/2) \n\t\tpaddlelimiter = paddlesize/2;\n\telse \n\tif (py > screenheight-96/2)\n\t\tpaddlelimiter = screenheight-paddlesize/2;\n\telse\n\t\tpaddlelimiter = py;\nend\nendfunction\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_efd9f085", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_gate (\n    input A,\n    input B,\n    input C,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VDD;\n    supply0 VSS;\n\n    // AND gate logic\n    assign Y = A & B & C;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "generic_baseblocks_v2_1_mux_enc #_4fdb965f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n \nmodule generic_baseblocks_v2_1_mux_enc #\n  (\n   parameter         C_FAMILY                       = \"rtl\",\n                       parameter integer C_RATIO                        = 4,\n                       parameter integer C_SEL_WIDTH                    = 2,\n                       parameter integer C_DATA_WIDTH                   = 1\n                       )\n  (\n   input  wire [C_SEL_WIDTH-1:0]                    S,\n   input  wire [C_RATIO*C_DATA_WIDTH-1:0]           A,\n   output wire [C_DATA_WIDTH-1:0]                   O,\n   input  wire                                      OE\n   );\n  \n  wire [C_DATA_WIDTH-1:0] o_i;\n  genvar bit_cnt;\n  \n  function [C_DATA_WIDTH-1:0] f_mux\n    (\n     input [C_SEL_WIDTH-1:0] s,\n     input [C_RATIO*C_DATA_WIDTH-1:0] a\n     );\n    integer i;\n    reg [C_RATIO*C_DATA_WIDTH-1:0] carry;\n    begin\n      carry[C_DATA_WIDTH-1:0] = {C_DATA_WIDTH{(s==0)?1'b1:1'b0}} & a[C_DATA_WIDTH-1:0];\n      for (i=1;i<C_RATIO;i=i+1) begin : gen_carrychain_enc\n        carry[i*C_DATA_WIDTH +: C_DATA_WIDTH] = \n          carry[(i-1)*C_DATA_WIDTH +: C_DATA_WIDTH] |\n          ({C_DATA_WIDTH{(s==i)?1'b1:1'b0}} & a[i*C_DATA_WIDTH +: C_DATA_WIDTH]);\n      end\n      f_mux = carry[C_DATA_WIDTH*C_RATIO-1:C_DATA_WIDTH*(C_RATIO-1)];\n    end\n  endfunction\n  \n  function [C_DATA_WIDTH-1:0] f_mux4\n    (\n     input [1:0] s,\n     input [4*C_DATA_WIDTH-1:0] a\n     );\n    integer i;\n    reg [4*C_DATA_WIDTH-1:0] carry;\n    begin\n      carry[C_DATA_WIDTH-1:0] = {C_DATA_WIDTH{(s==0)?1'b1:1'b0}} & a[C_DATA_WIDTH-1:0];\n      for (i=1;i<4;i=i+1) begin : gen_carrychain_enc\n        carry[i*C_DATA_WIDTH +: C_DATA_WIDTH] = \n          carry[(i-1)*C_DATA_WIDTH +: C_DATA_WIDTH] |\n          ({C_DATA_WIDTH{(s==i)?1'b1:1'b0}} & a[i*C_DATA_WIDTH +: C_DATA_WIDTH]);\n      end\n      f_mux4 = carry[C_DATA_WIDTH*4-1:C_DATA_WIDTH*3];\n    end\n  endfunction\n  \n  assign O = o_i & {C_DATA_WIDTH{OE}};  generate\n    if ( C_RATIO < 2 ) begin : gen_bypass\n      assign o_i = A;\n    end else if ( C_FAMILY == \"rtl\" || C_RATIO < 5 ) begin : gen_rtl\n      assign o_i = f_mux(S, A);\n      \n    end else begin : gen_fpga\n      wire [C_DATA_WIDTH-1:0] l;\n      wire [C_DATA_WIDTH-1:0] h;\n      wire [C_DATA_WIDTH-1:0] ll;\n      wire [C_DATA_WIDTH-1:0] lh;\n      wire [C_DATA_WIDTH-1:0] hl;\n      wire [C_DATA_WIDTH-1:0] hh;\n      \n      case (C_RATIO)\n        1, 5, 9, 13: \n          assign hh = A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH];\n        2, 6, 10, 14:\n          assign hh = S[0] ? \n            A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH] :\n            A[(C_RATIO-2)*C_DATA_WIDTH +: C_DATA_WIDTH] ;\n        3, 7, 11, 15:\n          assign hh = S[1] ? \n            A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH] :\n            (S[0] ? \n              A[(C_RATIO-2)*C_DATA_WIDTH +: C_DATA_WIDTH] :\n              A[(C_RATIO-3)*C_DATA_WIDTH +: C_DATA_WIDTH] );\n        4, 8, 12, 16:\n          assign hh = S[1] ? \n            (S[0] ? \n              A[(C_RATIO-1)*C_DATA_WIDTH +: C_DATA_WIDTH] :\n              A[(C_RATIO-2)*C_DATA_WIDTH +: C_DATA_WIDTH] ) :\n            (S[0] ? \n              A[(C_RATIO-3)*C_DATA_WIDTH +: C_DATA_WIDTH] :\n              A[(C_RATIO-4)*C_DATA_WIDTH +: C_DATA_WIDTH] );\n        17:\n          assign hh = S[1] ? \n            (S[0] ? \n              A[15*C_DATA_WIDTH +: C_DATA_WIDTH] :\n              A[14*C_DATA_WIDTH +: C_DATA_WIDTH] ) :\n            (S[0] ? \n              A[13*C_DATA_WIDTH +: C_DATA_WIDTH] :\n              A[12*C_DATA_WIDTH +: C_DATA_WIDTH] );\n        default:\n          assign hh = 0; \n      endcase\n\n      case (C_RATIO)\n        5, 6, 7, 8: begin\n          assign l = f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);\n          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_5_8\n            MUXF7 mux_s2_inst \n            (\n             .I0  (l[bit_cnt]),\n             .I1  (hh[bit_cnt]),\n             .S   (S[2]),\n             .O   (o_i[bit_cnt])\n            ); \n          end\n        end\n          \n        9, 10, 11, 12: begin\n          assign ll = f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);\n          assign lh = f_mux4(S[1:0], A[4*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);\n          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_9_12\n            MUXF7 muxf_s2_low_inst \n            (\n             .I0  (ll[bit_cnt]),\n             .I1  (lh[bit_cnt]),\n             .S   (S[2]),\n             .O   (l[bit_cnt])\n            ); \n            MUXF8 muxf_s3_inst \n            (\n             .I0  (l[bit_cnt]),\n             .I1  (hh[bit_cnt]),\n             .S   (S[3]),\n             .O   (o_i[bit_cnt])\n            ); \n          end\n        end\n          \n        13,14,15,16: begin\n          assign ll = f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);\n          assign lh = f_mux4(S[1:0], A[4*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);\n          assign hl = f_mux4(S[1:0], A[8*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);\n          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_13_16\n            MUXF7 muxf_s2_low_inst \n            (\n             .I0  (ll[bit_cnt]),\n             .I1  (lh[bit_cnt]),\n             .S   (S[2]),\n             .O   (l[bit_cnt])\n            ); \n            MUXF7 muxf_s2_hi_inst \n            (\n             .I0  (hl[bit_cnt]),\n             .I1  (hh[bit_cnt]),\n             .S   (S[2]),\n             .O   (h[bit_cnt])\n            );\n          \n            MUXF8 muxf_s3_inst \n            (\n             .I0  (l[bit_cnt]),\n             .I1  (h[bit_cnt]),\n             .S   (S[3]),\n             .O   (o_i[bit_cnt])\n            ); \n          end\n        end\n          \n        17: begin\n          assign ll = S[4] ? A[16*C_DATA_WIDTH +: C_DATA_WIDTH] : f_mux4(S[1:0], A[0 +: 4*C_DATA_WIDTH]);  assign lh = f_mux4(S[1:0], A[4*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);\n          assign hl = f_mux4(S[1:0], A[8*C_DATA_WIDTH +: 4*C_DATA_WIDTH]);\n          for (bit_cnt = 0; bit_cnt < C_DATA_WIDTH ; bit_cnt = bit_cnt + 1) begin : gen_mux_17\n            MUXF7 muxf_s2_low_inst \n            (\n             .I0  (ll[bit_cnt]),\n             .I1  (lh[bit_cnt]),\n             .S   (S[2]),\n             .O   (l[bit_cnt])\n            ); \n            MUXF7 muxf_s2_hi_inst \n            (\n             .I0  (hl[bit_cnt]),\n             .I1  (hh[bit_cnt]),\n             .S   (S[2]),\n             .O   (h[bit_cnt])\n            ); \n            MUXF8 muxf_s3_inst \n            (\n             .I0  (l[bit_cnt]),\n             .I1  (h[bit_cnt]),\n             .S   (S[3]),\n             .O   (o_i[bit_cnt])\n            ); \n          end\n        end\n          \n        default:  assign o_i = f_mux(S, A);\n      endcase\n    end  endgenerate\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gpio_wb #_c35df79e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule gpio_wb #(parameter BASE_ADDR = 32'h00000400) (\n    \n    input clk_i, \n    input rst_i,\n    \n    input      [31:0] dat_i, \n    output reg [31:0] dat_o, \n    input      [31:0] adr_i, \n    input      we_i, \n    input      [3:0] sel_i, \n    input      cyc_i, \n    input      stb_i, \n    output reg ack_o,\n    \n    input [15:0] sw_bi,\n    output reg [15:0] gpio_bo\n);\n\nlocalparam IDLE = 0;\nlocalparam ACK  = 1;\n\nwire read  = cyc_i & stb_i & !we_i;\nwire write = cyc_i & stb_i & we_i;\n    \nreg state_r;\n    \nalways@(posedge clk_i, posedge rst_i)\n    if(rst_i) begin\n        state_r  <= 0;\n        ack_o    <= 1'b0;\n        gpio_bo  <= 0;\n        dat_o    <= 0;\n    end else begin\n    \n        ack_o <= 1'b0;\n        \n        case(state_r)\n            IDLE: \n                begin\n                    if(write) begin\n                        if(adr_i == BASE_ADDR)\n                            gpio_bo <= dat_i[15:0];\n                        ack_o   <= 1'b1;\n                        state_r <= ACK; \n                    end else if(read) begin\n                        dat_o <= (adr_i == BASE_ADDR)? sw_bi: 0;\n                        state_r <= ACK;\n                    end\n                end\n            ACK:\n                begin\n                    ack_o   <= 1'b1;\n                    state_r <= IDLE;\n                end\n        endcase\n    end\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_or_logical_not_059fc16e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_or_logical_not(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise OR using XOR and inverter gates\n    wire [2:0] xor_result;\n    assign xor_result = a ^ b;\n    assign out_or_bitwise = ~xor_result;\n\n    // Logical OR using AND and OR gates\n    wire [2:0] and_result;\n    assign and_result = a & b;\n    assign out_or_logical = |and_result;\n\n    // NOT using inverter gates\n    wire [2:0] not_a;\n    wire [2:0] not_b;\n    assign not_a = ~a;\n    assign not_b = ~b;\n    assign out_not = {not_a, not_b};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bar #_03f9c6b6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bar #(parameter OP_ADD = 2'b00) (\n   input [3:0] a,\n   input [3:0] b,\n   input [1:0] sel,\n   output reg [3:0] result\n);\n   \n   always @(*) begin\n      case(sel)\n         2'b00: result = a + b;\n         2'b01: result = a + ~b + 1;\n         2'b10: result = a & b;\n         2'b11: result = a | b;\n         default: result = 4'b0;\n      endcase\n   end\n   \n   assign sel[1:0] = OP_ADD; // set sel value for addition operation\n   \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xnor2_fc8c64b8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule xnor2 (\n    Y   ,\n    A   ,\n    B   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    \n    wire A_inv, B_inv, A_B, A_inv_B_inv;\n    \n    // Invert A and B\n    not (A_inv, A);\n    not (B_inv, B);\n    \n    // AND A and B\n    and (A_B, A, B);\n    \n    // AND inverted A and inverted B\n    and (A_inv_B_inv, A_inv, B_inv);\n    \n    // OR the results of the two AND gates\n    or (Y, A_B, A_inv_B_inv);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_21cefbd3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter\n    (input clk, rst, up_down,\n     output reg [1:0] count);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 2'b0;\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "transition_detector_2ae7c513", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule transition_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nreg [31:0] in_reg1, in_reg2, in_reg3, in_reg4;\nreg [31:0] out_reg1, out_reg2, out_reg3, out_reg4;\n\nalways @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n        in_reg1 <= 0;\n        in_reg2 <= 0;\n        in_reg3 <= 0;\n        in_reg4 <= 0;\n        out_reg1 <= 0;\n        out_reg2 <= 0;\n        out_reg3 <= 0;\n        out_reg4 <= 0;\n    end\n    else begin\n        in_reg1 <= in;\n        in_reg2 <= in_reg1;\n        in_reg3 <= in_reg2;\n        in_reg4 <= in_reg3;\n        \n        if (in_reg4 == 32'hFFFFFFFF) begin\n            out_reg1 <= 0;\n            out_reg2 <= 0;\n            out_reg3 <= 0;\n            out_reg4 <= 0;\n        end\n        else if (in_reg4 == 32'hFFFFFFFE) begin\n            out_reg1 <= 1;\n            out_reg2 <= 1;\n            out_reg3 <= 1;\n            out_reg4 <= 1;\n        end\n        else begin\n            out_reg1 <= out_reg2;\n            out_reg2 <= out_reg3;\n            out_reg3 <= out_reg4;\n            out_reg4 <= 0;\n        end\n    end\nend\n\nassign out = out_reg1;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\ntransition_detector td (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(out)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gate_d_ff_1c09765f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_gate_d_ff (\n    input clk,\n    input en,\n    input en_ff,\n    input [31:0] data,\n    output reg q\n);\n\n    wire gated_clk = clk & en; // create a gated clock signal\n    \n    always @(posedge gated_clk) begin // use the gated clock for the flip-flop\n        if (en_ff) begin // only update the output when enabled\n            q <= data;\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_f8e1d5eb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter(\n    input clk, reset, enable,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or posedge reset) begin\n    if(reset) begin\n        q <= 4'b0000;\n    end\n    else if(enable) begin\n        q <= q + 1;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mig_7series_v2_3_poc_edge_store #_4aeb0957", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule mig_7series_v2_3_poc_edge_store #\n  (parameter TCQ                        = 100,\n   parameter TAPCNTRWIDTH               = 7,\n   parameter TAPSPERKCLK                = 112)\n  (\n  fall_lead, fall_trail, rise_lead, rise_trail,\n  clk, run_polarity, run_end, select0, select1, tap, run\n  );\n  \n  input clk;\n\n  input run_polarity;\n  input run_end;\n  input select0;\n  input select1;\n  input [TAPCNTRWIDTH-1:0] tap;\n  input [TAPCNTRWIDTH-1:0] run;\n\n  wire [TAPCNTRWIDTH:0] trailing_edge = run > tap ? tap + TAPSPERKCLK[TAPCNTRWIDTH-1:0] - run\n                                                  : tap - run;\n\n  wire run_end_this = run_end && select0 && select1;\n\n  reg [TAPCNTRWIDTH-1:0] fall_lead_r, fall_trail_r, rise_lead_r, rise_trail_r;\n  output [TAPCNTRWIDTH-1:0] fall_lead, fall_trail, rise_lead, rise_trail;\n  assign fall_lead = fall_lead_r;\n  assign fall_trail = fall_trail_r;\n  assign rise_lead = rise_lead_r;\n  assign rise_trail = rise_trail_r;\n  \n  wire [TAPCNTRWIDTH-1:0] fall_lead_ns = run_end_this & run_polarity ? tap : fall_lead_r;\n  wire [TAPCNTRWIDTH-1:0] rise_trail_ns = run_end_this & run_polarity ? trailing_edge[TAPCNTRWIDTH-1:0]\n                                                                      : rise_trail_r;\n  wire [TAPCNTRWIDTH-1:0] rise_lead_ns = run_end_this & ~run_polarity ? tap : rise_lead_r;\n  wire [TAPCNTRWIDTH-1:0] fall_trail_ns = run_end_this & ~run_polarity ? trailing_edge[TAPCNTRWIDTH-1:0]\n                                                                       : fall_trail_r;\n     \n  always @(posedge clk) fall_lead_r <= #TCQ fall_lead_ns;\n  always @(posedge clk) fall_trail_r <= #TCQ fall_trail_ns;\n  always @(posedge clk) rise_lead_r <= #TCQ rise_lead_ns;\n  always @(posedge clk) rise_trail_r <= #TCQ rise_trail_ns;\n  \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_input_or_gate_f6f6981e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule four_input_or_gate (\n    X   ,\n    A   ,\n    B   ,\n    C   ,\n    D   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A   ;\n    input  B   ;\n    input  C   ;\n    input  D   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n    wire   AB, CD, ABCD;\n\n    or (AB, A, B);\n    or (CD, C, D);\n    or (ABCD, AB, CD);\n\n    assign X = ABCD;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tx_reset_sm_57b9b6b2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule tx_reset_sm\n(\ninput        refclkdiv2,\ninput        rst_n,\ninput        tx_pll_lol_qd_s,\n                                                                                              \noutput   reg    tx_pcs_rst_ch_c,      output   reg    rst_qd_c          );\n                                                                                              \n                                                                                              \nparameter count_index = 17;\n                                                                                              \n                                                                                              \nlocalparam   QUAD_RESET      = 0,\n             WAIT_FOR_TIMER1       = 1,\n             CHECK_PLOL       = 2,\n             WAIT_FOR_TIMER2       = 3,\n             NORMAL    = 4;\n                                                                                              \nlocalparam STATEWIDTH =3;\nreg [STATEWIDTH-1:0]    cs ;               reg [STATEWIDTH-1:0]    ns;               reg tx_pll_lol_qd_s_int;\nreg tx_pll_lol_qd_s_int1;\nreg    [3:0]   tx_pcs_rst_ch_c_int;      reg       rst_qd_c_int;          always @(posedge refclkdiv2 or negedge rst_n)\n   begin\n   if (rst_n == 1'b0)\n      begin\n      cs                     <= QUAD_RESET;\n      tx_pll_lol_qd_s_int    <= 1;\n      tx_pll_lol_qd_s_int1   <= 1;\n      tx_pcs_rst_ch_c        <= 1'b1;\n      rst_qd_c               <= 1;\n      end\n   else\n      begin\n      cs <= ns;\n      tx_pll_lol_qd_s_int1   <= tx_pll_lol_qd_s;\n      tx_pll_lol_qd_s_int    <= tx_pll_lol_qd_s_int1;\n      tx_pcs_rst_ch_c        <= tx_pcs_rst_ch_c_int[0];\n      rst_qd_c               <= rst_qd_c_int;\n      end\n   end\n                                                                                              \nreg reset_timer1, reset_timer2;\n                                                                                              \n                                                                                              \nlocalparam TIMER1WIDTH=3;\nreg [TIMER1WIDTH-1:0] counter1;\nreg TIMER1;\n                                                                                              \nalways @(posedge refclkdiv2 or posedge reset_timer1)\n   begin\n   if (reset_timer1)\n      begin\n      counter1 <= 0;\n      TIMER1 <= 0;\n      end\n   else\n      begin\n      if (counter1[2] == 1)\n         TIMER1 <=1;\n      else\n         begin\n         TIMER1 <=0;\n         counter1 <= counter1 + 1 ;\n         end\n      end\n   end\n                                                                                              \nlocalparam TIMER2WIDTH=18;\nreg [TIMER2WIDTH-1:0] counter2;\nreg TIMER2;\n                                                                                              \nalways @(posedge refclkdiv2 or posedge reset_timer2)\n   begin\n   if (reset_timer2)\n      begin\n      counter2 <= 0;\n      TIMER2 <= 0;\n      end\n   else\n      begin\nif (counter2[count_index] == 1)\n         TIMER2 <=1;\n      else\n         begin\n         TIMER2 <=0;\n         counter2 <= counter2 + 1 ;\n         end\n      end\n   end\n                                                                                              \n                                                                                              \nalways @(*)\n   begin : NEXT_STATE\n   reset_timer1 = 0;\n   reset_timer2 = 0;\n         case (cs)\n                                                                                              \n            QUAD_RESET: begin\n               tx_pcs_rst_ch_c_int = 4'hF;\n               rst_qd_c_int = 1;\n               reset_timer1 = 1;\n               ns = WAIT_FOR_TIMER1;\n               end\n                                                                                              \n            WAIT_FOR_TIMER1: begin\n               tx_pcs_rst_ch_c_int = 4'hF;\n               rst_qd_c_int = 1;\n               if (TIMER1)\n                  ns = CHECK_PLOL;\n               else\n                  ns = WAIT_FOR_TIMER1;\n            end\n                                                                                              \n            CHECK_PLOL: begin\n               tx_pcs_rst_ch_c_int = 4'hF;\n               rst_qd_c_int = 0;\n               reset_timer2 = 1;\n               ns = WAIT_FOR_TIMER2;\n            end\n                                                                                              \n            WAIT_FOR_TIMER2: begin\n               tx_pcs_rst_ch_c_int = 4'hF;\n               rst_qd_c_int = 0;\n               if (TIMER2)\n                  if (tx_pll_lol_qd_s_int)\n                     ns = QUAD_RESET;\n                  else\n                     ns = NORMAL;\n               else\n                     ns = WAIT_FOR_TIMER2;\n            end\n                                                                                              \n            NORMAL: begin\n               tx_pcs_rst_ch_c_int = 4'h0;\n               rst_qd_c_int = 0;\n               if (tx_pll_lol_qd_s_int)\n                  ns = QUAD_RESET;\n               else\n                  ns = NORMAL;\n            end\n                                                                                              \n                                                                                              \n                                                                                              \n            default: begin\n               tx_pcs_rst_ch_c_int = 4'hF;\n               rst_qd_c_int = 1;\n               ns = QUAD_RESET;\n            end\n         endcase end endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__nor2b_20f4a631", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__nor2b (\n    Y  ,\n    A  ,\n    B_N\n);\n\n    output Y  ;\n    input  A  ;\n    input  B_N;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out  ;\n    wire and0_out_Y;\n\n    not not0 (not0_out  , A              );\n    and and0 (and0_out_Y, not0_out, B_N  );\n    buf buf0 (Y         , and0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "three_input_and_gate_dc585bfa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule three_input_and_gate (\n    X,\n    A1,\n    A2,\n    A3\n);\n\n    output X;\n    input A1;\n    input A2;\n    input A3;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\nendmodule\n\nmodule sky130_fd_sc_lp__a311o_0 (\n    output X,\n    input A1,\n    input A2,\n    input A3,\n    input B1,\n    input C1\n);\n\n    assign X = (A1 & A2 & A3 & B1 & C1);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_to_gray_97fa5df5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_to_gray (\n    input [2:0] B,\n    output reg [2:0] G\n);\n\n    always @ (B) begin\n        G[0] = B[0] ^ B[1];\n        G[1] = B[1] ^ B[2];\n        G[2] = B[2];\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "jt51_lin2exp_00953a5a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule jt51_lin2exp(\n  input      [15:0] lin,\n  output reg [9:0] man,\n  output reg [2:0] exp\n);\n\nalways @(*) begin\n  casex( lin[15:9] )\n    7'b10XXXXX: begin\n        man = lin[15:6];\n        exp = 3'd7;\n      end\n    7'b110XXXX: begin\n        man = lin[14:5];\n        exp = 3'd6;\n      end\n    7'b1110XXX: begin\n        man = lin[13:4];\n        exp = 3'd5;\n      end\n    7'b11110XX: begin\n        man = lin[12:3];\n        exp = 3'd4;\n      end\n    7'b111110X: begin\n        man = lin[11:2];\n        exp = 3'd3;\n      end\n    7'b1111110: begin\n        man = lin[10:1];\n        exp = 3'd2;\n      end\n    7'b1111111: begin\n        man = lin[ 9:0];\n        exp = 3'd1;\n      end    \n    7'b01XXXXX: begin\n        man = lin[15:6];\n        exp = 3'd7;\n      end\n    7'b001XXXX: begin\n        man = lin[14:5];\n        exp = 3'd6;\n      end\n    7'b0001XXX: begin\n        man = lin[13:4];\n        exp = 3'd5;\n      end\n    7'b00001XX: begin\n        man = lin[12:3];\n        exp = 3'd4;\n      end\n    7'b000001X: begin\n        man = lin[11:2];\n        exp = 3'd3;\n      end\n    7'b0000001: begin\n        man = lin[10:1];\n        exp = 3'd2;\n      end\n    7'b0000000: begin\n        man = lin[ 9:0];\n        exp = 3'd1;\n      end\n    \n    default: begin\n        man = lin[9:0];\n        exp = 3'd1;\n      end\n  endcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Raster_Laser_Projector_Video_In_video_rgb_resampler_0_9c825eb7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule Raster_Laser_Projector_Video_In_video_rgb_resampler_0 (\n\tclk,\n\treset,\n\n\tstream_in_data,\n\tstream_in_startofpacket,\n\tstream_in_endofpacket,\n\tstream_in_empty,\n\tstream_in_valid,\n\n\tstream_out_ready,\n\t\n\tstream_in_ready,\n\n\n\tstream_out_data,\n\tstream_out_startofpacket,\n\tstream_out_endofpacket,\n\tstream_out_empty,\n\tstream_out_valid\n);\n\n\n\nparameter IDW\t\t= 23;\nparameter ODW\t\t= 7;\n\nparameter IEW\t\t= 1;\nparameter OEW\t\t= 0;\n\nparameter ALPHA\t= 10'h3FF;\n\n\n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t[IDW:0]\tstream_in_data;\ninput\t\t\t\t\t\tstream_in_startofpacket;\ninput\t\t\t\t\t\tstream_in_endofpacket;\ninput\t\t\t[IEW:0]\tstream_in_empty;\ninput\t\t\t\t\t\tstream_in_valid;\n\ninput\t\t\t\t\t\tstream_out_ready;\n\noutput\t\t\t\t\tstream_in_ready;\n\noutput reg\t[ODW:0]\tstream_out_data;\noutput reg\t\t\t\tstream_out_startofpacket;\noutput reg\t\t\t\tstream_out_endofpacket;\noutput reg\t[OEW:0]\tstream_out_empty;\noutput reg\t\t\t\tstream_out_valid;\n\n\n\n\n\n\nwire\t\t[ 9: 0]\tr;\nwire\t\t[ 9: 0]\tg;\nwire\t\t[ 9: 0]\tb;\nwire\t\t[ 9: 0]\ta;\n\nwire\t\t[11: 0]\taverage_color;\t\n\nwire\t\t[ODW:0]\tconverted_data;\n\n\n\n\n\n\nalways @(posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tstream_out_data\t\t\t\t<=  'b0;\n\t\tstream_out_startofpacket\t<= 1'b0;\n\t\tstream_out_endofpacket\t\t<= 1'b0;\n\t\tstream_out_empty\t\t\t\t<=  'b0;\n\t\tstream_out_valid\t\t\t\t<= 1'b0;\n\tend\n\telse if (stream_out_ready | ~stream_out_valid)\n\tbegin\n\t\tstream_out_data\t\t\t\t<= converted_data;\n\t\tstream_out_startofpacket\t<= stream_in_startofpacket;\n\t\tstream_out_endofpacket\t\t<= stream_in_endofpacket;\n\t\tstream_out_empty\t\t\t\t<= stream_in_empty;\n\t\tstream_out_valid\t\t\t\t<= stream_in_valid;\n\tend\nend\n\n\n\nassign stream_in_ready = stream_out_ready | ~stream_out_valid;\n\nassign r = {stream_in_data[23:16], stream_in_data[23:22]};\nassign g = {stream_in_data[15: 8], stream_in_data[15:14]};\nassign b = {stream_in_data[ 7: 0], stream_in_data[ 7: 6]};\n\nassign a = ALPHA;\n\nassign average_color = {2'h0, r} + {1'b0, g, 1'b0} + {2'h0, b};\n\nassign converted_data[ 7: 0] = average_color[11:4];\n\n\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_6889ffa5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n  input clk,\n  input reset,\n  input [3:0] modulus,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      count <= 4'b0;\n    end else if (count == modulus) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_carry_adder_5badc7c9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ripple_carry_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output overflow\n);\n\n    wire [4:0] sum;\n    wire carry;\n\n    assign sum = A + B;\n    assign carry = sum[4];\n\n    assign S = sum[3:0];\n    assign overflow = carry;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__204af974", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input [2:0] a,\n    input [2:0] b,\n    input sel_b1,\n    input sel_b2,\n    output reg out_always,\n    output [2:0] out_or_reg,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // 2-to-1 multiplexer\n    always @(*) begin\n        out_always <= sel_b1 ? b : a;\n    end\n\n    // Bitwise-OR\n    assign out_or_reg = a | b;\n\n    // Logical-OR\n    assign out_or_logical = (a != 0) || (b != 0);\n\n    // Inverse of both vectors\n    assign out_not = ~{a, b};\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_module_b52b57fb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_module(\n    input clk,\n    input rst,\n    input [7:0] A,\n    input [7:0] B,\n    output reg [7:0] R\n);\n\nalways @ (posedge clk) begin\n    if (rst) begin\n        R <= 8'h0;\n    end else begin\n        R <= A + B + 1;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_6623e941", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule priority_encoder (\n    input [7:0] in,\n    output [2:0] pos );\n\n    wire [2:0] pos_int;\n\n    assign pos_int = in[2:0];\n\n    assign pos = ~pos_int;\n\nendmodule\nmodule top_module (\n    input [7:0] in,\n    output [2:0] pos );\n\n    priority_encoder pe(in, pos);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dffs_6_705f2235", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dffs_6 ( clk, set, d, q );\n    input clk;\n    input set;\n    input [5:0] d;\n    output [5:0] q;\n    reg [5:0] q;\n\n    always @(posedge clk or posedge set) begin\n        if (set) begin\n            q <= 6'b111111;\n        end else begin\n            q <= d;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RegFile_3port_6c81f580", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RegFile_3port(CLK, rst_n,\n                     ADDR_IN1, D_IN1, WE1,\n                     ADDR_IN2, D_IN2, WE2,\n                     ADDR_OUT1, ADDR_OUT2, ADDR_OUT3,\n                     D_OUT1, D_OUT2, D_OUT3\n                     );\n\n   parameter data_width = 8;\n   parameter addr_width = 4;\n   parameter depth = 1<<addr_width;\n   \n   input CLK;\n   input rst_n;\n   \n   input [addr_width - 1 : 0] ADDR_IN1;\n   input [data_width - 1 : 0] D_IN1;\n   input WE1;\n   \n   input [addr_width - 1 : 0] ADDR_IN2;\n   input [data_width - 1 : 0] D_IN2;\n   input WE2;\n   \n   input [addr_width - 1 : 0] ADDR_OUT1;\n   input [addr_width - 1 : 0] ADDR_OUT2;\n   input [addr_width - 1 : 0] ADDR_OUT3;\n   \n   output [data_width - 1 : 0] D_OUT1;\n   output [data_width - 1 : 0] D_OUT2;\n   output [data_width - 1 : 0] D_OUT3;\n   \n   reg [data_width - 1 : 0] arr [0 : depth-1];\n   \n   integer i;\n   \n   always @(posedge CLK) begin\n      if (!rst_n) begin\n         for (i = 0; i < depth; i = i + 1) begin\n            arr[i] <= 0;\n         end\n      end else begin\n         if (WE1) begin\n            arr[ADDR_IN1] <= D_IN1;\n         end\n         if (WE2) begin\n            arr[ADDR_IN2] <= D_IN2;\n         end\n      end\n   end\n   \n   assign D_OUT1 = arr[ADDR_OUT1];\n   assign D_OUT2 = arr[ADDR_OUT2];\n   assign D_OUT3 = arr[ADDR_OUT3];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "karnaugh_map_00f51d02", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule karnaugh_map(\n  input wire A, B, C, D,\n  output reg F\n);\n\n  always @(*) begin\n    case ({A,B,C,D})\n      4'b0000: F = 1'b0;\n      4'b0001: F = 1'b1;\n      4'b0010: F = 1'b1;\n      4'b0011: F = 1'b0;\n      4'b0100: F = 1'b1;\n      4'b0101: F = 1'b0;\n      4'b0110: F = 1'b0;\n      4'b0111: F = 1'b1;\n      4'b1000: F = 1'b0;\n      4'b1001: F = 1'b1;\n      4'b1010: F = 1'b1;\n      4'b1011: F = 1'b0;\n      4'b1100: F = 1'b0;\n      4'b1101: F = 1'b1;\n      4'b1110: F = 1'b1;\n      4'b1111: F = 1'b0;\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "compute_tm_count_8d384773", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule compute_tm_count (\n  input atm_valid,\n  input dtm_valid,\n  input itm_valid,\n  output reg [1:0] compute_tm_count\n);\n\n  always @* begin\n    case ({itm_valid, atm_valid, dtm_valid})\n      3'b000: compute_tm_count = 2'b00;\n      3'b001: compute_tm_count = 2'b01;\n      3'b010: compute_tm_count = 2'b01;\n      3'b011: compute_tm_count = 2'b10;\n      3'b100: compute_tm_count = 2'b01;\n      3'b101: compute_tm_count = 2'b10;\n      3'b110: compute_tm_count = 2'b10;\n      3'b111: compute_tm_count = 2'b11;\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fsm_299962aa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fsm(X, RESET, CLOCK, Z);\n  input X, RESET, CLOCK;\n  output reg Z;\n\n  // State variables\n  reg [1:0] CurrentState;\n  reg [1:0] NextState;\n\n  // State codes\n  parameter State0 = 2'b00, State1 = 2'b01, State2 = 2'b10, State3 = 2'b11;\n\n  // Output logic\n  always @ (CurrentState)\n    begin\n    case (CurrentState)\n      State0: Z <= 1;\n      State3: Z <= 0;\n      default: Z <= 0;\n    endcase\n    end\n\n  // State registers\n  always @ (posedge CLOCK or posedge RESET)\n    if (RESET == 1)\n      CurrentState <= State0;\n    else\n      CurrentState <= NextState;\n\n  // Next state logic\n  always @ (CurrentState or X)\n    begin\n    case (CurrentState)\n      State0: if (X == 0) NextState <= State1;\n              else NextState <= State0;\n      State1: if (X == 0) NextState <= State1;\n              else NextState <= State0;\n      State3: if (X == 0) NextState <= State1;\n              else NextState <= State2;\n      State2: NextState <= State2;\n    endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sasc_fifo4_89f41488", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n`include \"timescale.v\"\n\n// 4 entry deep fast fifo\nmodule sasc_fifo4(clk, rst, clr,  din, we, dout, re, full, empty);\n\ninput\t\tclk, rst;\ninput\t\tclr;\ninput   [7:0]\tdin;\ninput\t\twe;\noutput  [7:0]\tdout;\ninput\t\tre;\noutput\t\tfull, empty;\n\n\n\nreg     [7:0]\tmem[0:3];\nreg     [1:0]   wp;\nreg     [1:0]   rp;\nwire    [1:0]   wp_p1;\nwire    [1:0]   wp_p2;\nwire    [1:0]   rp_p1;\nwire\t\tfull, empty;\nreg\t\tgb;\n\n\nalways @(posedge clk or negedge rst)\n        if(!rst)\twp <= #1 2'h0;\n        else\n        if(clr)\t\twp <= #1 2'h0;\n        else\n        if(we)\t\twp <= #1 wp_p1;\n\nassign wp_p1 = wp + 2'h1;\nassign wp_p2 = wp + 2'h2;\n\nalways @(posedge clk or negedge rst)\n        if(!rst)\trp <= #1 2'h0;\n        else\n        if(clr)\t\trp <= #1 2'h0;\n        else\n        if(re)\t\trp <= #1 rp_p1;\n\nassign rp_p1 = rp + 2'h1;\n\n// Fifo Output\nassign  dout = mem[ rp ];\n\n// Fifo Input \nalways @(posedge clk)\n        if(we)     mem[ wp ] <= #1 din;\n\n// Status\nassign empty = (wp == rp) & !gb;\nassign full  = (wp == rp) &  gb;\n\n// Guard Bit ...\nalways @(posedge clk)\n\tif(!rst)\t\t\tgb <= #1 1'b0;\n\telse\n\tif(clr)\t\t\t\tgb <= #1 1'b0;\n\telse\n\tif((wp_p1 == rp) & we)\t\tgb <= #1 1'b1;\n\telse\n\tif(re)\t\t\t\tgb <= #1 1'b0;\n\nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_module_e67f8366", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_module(\n    input wire a,\n    input wire b,\n    input wire c,\n    input wire d,\n    output wire out0,\n    output wire out1,\n    output wire out2,\n    output wire out3\n);\n\n    assign out0 = a & b;\n    assign out1 = b & c;\n    assign out2 = (a == 1) ? d : 1'b0;\n    assign out3 = b & d;\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "output_generator_8b24106f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule output_generator(\n  input [3:0] num1,\n  input [3:0] num2,\n  input [1:0] operation,\n  output [3:0] result\n);\n\n  reg [3:0] result_reg; // declare result as a register\n\n  always @(*) begin\n    case(operation)\n      2'b00: result_reg = num1 + num2; // addition\n      2'b01: result_reg = num1 - num2; // subtraction\n      2'b10: result_reg = num1 * num2; // multiplication\n      2'b11: result_reg = num1 / num2; // division\n      default: result_reg = 4'b0000; // default case\n    endcase\n  end\n\n  assign result = result_reg; // assign result to the output port\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_c546856a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\nwire [8:0] sum;\nwire carry;\n\nassign {carry, sum} = a + b;\n\nassign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nassign s = sum[7:0];\n\nendmodule\nmodule xor_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = in ^ 8'b10101010;\n\nendmodule\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow,\n    output [7:0] out\n);\n\nwire [7:0] adder_out;\n\nadder adder_inst (.a(a), .b(b), .s(adder_out), .overflow(overflow));\nxor_module xor_inst (.in(adder_out), .out(out));\n\nassign s = adder_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decade_counter_ae2306d9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule decade_counter (\n    input clk,\n    input pause,\n    input resume,\n    input reset,\n    output reg [3:0] q\n);\n\n    // Define states\n    parameter [2:0] COUNT_0 = 3'b000;\n    parameter [2:0] COUNT_1 = 3'b001;\n    parameter [2:0] COUNT_2 = 3'b010;\n    parameter [2:0] COUNT_3 = 3'b011;\n    parameter [2:0] COUNT_4 = 3'b100;\n    parameter [2:0] COUNT_5 = 3'b101;\n    parameter [2:0] COUNT_6 = 3'b110;\n    parameter [2:0] COUNT_7 = 3'b111;\n\n    // Define signals\n    reg [2:0] state;\n    reg [3:0] next_q;\n\n    // Default output\n    always @* begin\n        q = next_q;\n    end\n\n    // State machine\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= COUNT_0;\n            next_q <= 4'b0000;\n        end else begin\n            if (pause == 1'b0) begin\n                case (state)\n                    COUNT_0: begin\n                        next_q <= 4'b0001;\n                        state <= COUNT_1;\n                    end\n                    COUNT_1: begin\n                        next_q <= 4'b0010;\n                        state <= COUNT_2;\n                    end\n                    COUNT_2: begin\n                        next_q <= 4'b0011;\n                        state <= COUNT_3;\n                    end\n                    COUNT_3: begin\n                        next_q <= 4'b0100;\n                        state <= COUNT_4;\n                    end\n                    COUNT_4: begin\n                        next_q <= 4'b0101;\n                        state <= COUNT_5;\n                    end\n                    COUNT_5: begin\n                        next_q <= 4'b0110;\n                        state <= COUNT_6;\n                    end\n                    COUNT_6: begin\n                        next_q <= 4'b0111;\n                        state <= COUNT_7;\n                    end\n                    COUNT_7: begin\n                        next_q <= 4'b1000;\n                        state <= COUNT_0;\n                    end\n                endcase\n            end\n            if(resume == 1'b1)\n                state <= state + 1;\n        end\n    end\n\nendmodule\nmodule top_module (\n    input clk,\n    input pause,\n    input resume,\n    input reset,\n    output [3:0] q\n);\n\n    // Instantiate decade counter\n    decade_counter counter (\n        .clk(clk),\n        .pause(pause),\n        .resume(resume),\n        .reset(reset),\n        .q(q)\n    );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "smr_reg_ac72d38f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule smr_reg(clk, rst, we, incr, wr, rd);\n\n\tparameter width = 'd16; parameter add_width = 'd13; input wire clk , rst ; input wire we , incr ; input wire [width-1:0] wr ;\n\n\toutput wire [add_width-1:0] rd ;\n\n\treg [width-1:0] mem ;\n\n\tassign rd [add_width-1:0] = mem [add_width-1:0];\n\n\talways@(posedge clk) begin\n\t\tif(rst) mem [width-1:0] <= {width{1'b0}}; else if(we) mem [width-1:0] <= wr [width-1:0]; else if(incr) mem [width-1:0] <= mem [width-1:0] + 1'b1; end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MPUC1307_04b7671f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule MPUC1307 ( CLK,DS ,ED, MPYJ,DR,DI ,DOR ,DOI  );\n\t\n\tparameter total_bits = 32;\n\tinput CLK ;\n\twire CLK ;\n\tinput DS ;\n\twire DS ;\n\tinput ED; \t\t\t\t\tinput MPYJ ;\t\t\t\twire MPYJ ;\n\tinput [total_bits-1:0] DR ;\n\twire signed [total_bits-1:0] DR ;\n\tinput [total_bits-1:0] DI ;\n\twire signed [total_bits-1:0] DI ;\t   \n\t\n\toutput [total_bits:0] DOR ;\n\treg [total_bits:0] DOR ;\t\n\toutput [total_bits:0] DOI ;\n\treg [total_bits:0] DOI ;\t \n\t\n\treg signed [total_bits+2 :0] dx5;\t \n\treg signed [total_bits-1 :0] dx7;\t \n\treg signed [total_bits-1 :0] dii;\t \n\treg signed\t[total_bits : 0] dt;\t\t   \n\twire signed [total_bits+3 : 0]  dx5p; \n\twire  signed  [total_bits+3 : 0] dot;\t\n\treg edd,edd2, edd3;        \t\treg mpyjd,mpyjd2,mpyjd3;\n\treg [total_bits:0] doo ;\t\n\treg [total_bits:0] droo ;\t\n\t\n\talways @(posedge CLK)\n\t\tbegin\n\t\t\tif (ED) begin\t  \n\t\t\t\t\tedd<=DS;\n\t\t\t\t\tedd2<=edd;\t\n\t\t\t\t\tedd3<=edd2;\t\n\t\t\t\t\tmpyjd<=MPYJ;\n\t\t\t\t\tmpyjd2<=mpyjd;\n\t\t\t\t\tmpyjd3<=mpyjd2;\t\t\t\t\t if (DS)\t begin\t\t\t\t   \t\tdx5<=DR+(DR <<2);\t dx7<=DR-(DR>>>3);\t dt<=DR;\t  \n\t\t\t\t\t\t\tdii<=DI;\n\t\t\t\t\t\tend\n\t\t\t\t\telse\t begin\n\t\t\t\t\t\t\tdx5<=dii+(dii <<2);\t dx7<=dii-(dii>>>3);\t dt<=dii;\n\t\t\t\t\t\tend\n\t\t\t\t\tdoo<=dot >>>3;\t\n\t\t\t\t\tdroo<=doo;\t\n\t\t\t\t\tif (edd3) \t \n\t\t\t\t\t\tif (mpyjd3) begin\n\t\t\t\t\t\t\t\tDOR<=doo;\n\t\t\t\t\t\t\tDOI<= - droo; end\n\t\t\t\t\t\telse begin\n\t\t\t\t\t\t\t\tDOR<=droo;\n\t\t\t\t\t\t\tDOI<=  doo; end\t\t\t\t\t\n\t\t\t\tend \n\t\tend\t\t\n\t\n\tassign\tdx5p=(dx5<<1)+(dx7>>>1);\t\tassign   dot=\t(dx5p+(dt>>>6) -(dx5>>>13));endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_data_receiver_1de04073", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pcie_data_receiver (\n    input clk,\n    input rst,\n    input rx,\n    input rx_valid,\n    output reg rx_ready,\n    output reg rx_ack,\n    output reg tx,\n    output reg tx_valid,\n    input tx_ready,\n    input tx_ack\n);\n\nparameter BUFFER_SIZE = 16; // Set the size of the FIFO buffer\n\nreg [7:0] buffer[BUFFER_SIZE-1:0]; // Create a FIFO buffer to store the received data\nreg [3:0] head = 0; // Track the head of the buffer\nreg [3:0] tail = 0; // Track the tail of the buffer\nreg [3:0] count = 0; // Track the number of elements in the buffer\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        head <= 0;\n        tail <= 0;\n        count <= 0;\n        rx_ready <= 0; // Assign rx_ready value in reset condition\n    end else begin\n        rx_ready <= (count < BUFFER_SIZE); // Set rx_ready to indicate whether there is space in the buffer\n\n        if (rx_valid && rx_ready) begin\n            buffer[head] <= rx;\n            head <= (head == BUFFER_SIZE-1) ? 0 : head + 1;\n            count <= count + 1;\n            rx_ack <= 1;\n        end else begin\n            rx_ack <= 0;\n        end\n\n        if (tx_ready && count > 0) begin\n            tx <= buffer[tail];\n            tail <= (tail == BUFFER_SIZE-1) ? 0 : tail + 1;\n            count <= count - 1;\n            tx_valid <= 1;\n        end else begin\n            tx_valid <= 0;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "controller_m_5ea7a84b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule controller_m(\n    input clock, reset, start, Zero,\n    output Ready, Load_regs, Add_dec\n);\nparameter S_Idle = 1'b0, S_Mul = 1'b1;\n\nreg state, next_state;\n\nalways @(posedge clock, posedge reset)\n    if (reset)\n        state <= S_Idle;\n    else\n        state <= next_state;\n\nalways @(*)\nbegin\n    case (state)\n        S_Idle: next_state = Load_regs ? S_Mul : S_Idle;\n        S_Mul: next_state = Add_dec ? S_Idle : S_Mul;\n        default: next_state = 1'bx;\n    endcase\nend\n\nassign Ready = state == S_Idle;\nassign Load_regs = Ready & start;\nassign Add_dec = (state == S_Mul & ~Zero);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_8dd2da84", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder ( input A, B, Ci, output S, Co );\n  wire   n1, n2, n3;\n\n  assign n1 = ~(A ^ B);\n  assign n2 = ~(n1 ^ Ci);\n  assign n3 = ~(A ^ Ci);\n  assign Co = n1 & Ci;\n  assign S = n2 & n3;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gate_4ec41ffd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_gate(\n  input CLK,\n  input EN,\n  input TE,\n  output reg ENCLK\n);\n\n  always @ (posedge CLK) begin\n    if (EN && !TE) begin\n      ENCLK <= 1'b1;\n    end else begin\n      ENCLK <= 1'b0;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "StateUpdater_bb54fa09", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule StateUpdater(clk, enable, code, addr, state);\n\ninput clk, enable;\ninput [6:0] addr;\ninput [6:0] code;\noutput reg [3:0] state;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        case (code)\n            7'b0000000: state <= 4'b0000; // all 0s\n            7'b1111111: state <= 4'b1111; // all 1s\n            7'bxxxxxx1: state <= state ^ (1 << addr); // toggle\n            7'bxxxxx1x: state <= state | (1 << addr); // set to 1\n            7'bxxxx1xx: state <= state & ~(1 << addr); // set to 0\n            7'bxxx1xxx: state <= state ^ (1 << addr); // invert\n            7'bxx1xxxx: state <= {state[2:0], 1'b0}; // left shift\n            7'bx1xxxxx: state <= {1'b0, state[3:1]}; // right shift\n        endcase\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_b615a26f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(a, b, op, clk, result);\n\n  input [7:0] a, b;\n  input [1:0] op;\n  input clk;\n  output [7:0] result;\n\n  reg [7:0] temp_result;\n  \n  always @(posedge clk) begin\n    case(op)\n      2'b00: temp_result <= a + b; // addition\n      2'b01: temp_result <= a - b; // subtraction\n      2'b10: temp_result <= a * b; // multiplication\n      2'b11: temp_result <= a / b; // division\n    endcase\n  end\n  \n  assign result = temp_result;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rgbmatrix_14249b15", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rgbmatrix (\n    input clk,\n    input rst,\n    output reg R0,\n\t output reg G0,\n\t output reg B0,\n    output reg R1,\n\t output reg G1,\n\t output reg B1,\n\t output reg A,\n\t output reg B,\n\t output reg C,\n\t output reg D,\n\t output reg MATCLK,\n\t output reg MATLAT,\n\t output reg MATOE\n);\n\nlocalparam WAIT = 0,\n\t\t   BLANK = 1,\n\t\t   LATCH = 2,\n\t\t   UNBLANK = 3,\n\t\t   READ = 4,\n\t\t   SHIFT1 = 5,\n\t\t   SHIFT2 = 6;\n\nreg [2:0] state;\n\nreg [10:0] timer;\nreg [3:0] delay;\nreg [3:0] rd_row;\nreg [1:0] rd_bit;\nreg [4:0] rd_col;\n\nalways @ (posedge clk or posedge rst)\nbegin\n\tif (rst)\n\tbegin\n\t\tR0 <= 0;\n\t\tG0 <= 0;\n\t\tB0 <= 0;\n\t\tR1 <= 0;\n\t\tG1 <= 0;\n\t\tB1 <= 0;\n\t\tA <= 0;\n\t\tB <= 0;\n\t\tC <= 0;\n\t\tD <= 0;\n\t\tMATCLK <= 0;\n\t\tMATLAT <= 0;\n\t\tMATOE <= 1;\n\t\t\n\t\tstate <= READ;\n\n\t\ttimer <= 0;\n\t\tdelay <= 0;\n\n\t\trd_row <= 0;\n\t\trd_bit <= 0;\n\t\trd_col <= 0;\n\tend\n\telse\n\tbegin\n\t\tif (timer == 0)\n\t\tbegin\n\t\t\tcase (rd_bit)\n\t\t\t\t0: timer <= 191;\n\t\t\t\t1: timer <= 383;\n\t\t\t\t2: timer <= 767;\n\t\t\t\t3: timer <= 1535;\n\t\t\tendcase\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\ttimer <= timer - 1;\n\t\tend\n\n\t\tcase (state)\n\n\t\t\tWAIT: begin\n\t\t\t\tMATCLK <= 0;\n\t\t\t\tif (timer == 0)\n\t\t\t\tbegin\n\t\t\t\t\tMATOE <= 1;\n\t\t\t\t\tdelay <= 8;\n\t\t\t\t\tstate <= BLANK;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tBLANK: begin\n\t\t\t\tif (delay == 0)\n\t\t\t\tbegin\n\t\t\t\t\tMATLAT <= 1;\n\t\t\t\t\tdelay <= 8;\n\t\t\t\t\tstate <= LATCH;\n\t\t\t\t\tA <= rd_row[0];\n\t\t\t\t\tB <= rd_row[1];\n\t\t\t\t\tC <= rd_row[2];\n\t\t\t\t\tD <= rd_row[3];\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tdelay <= delay - 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tLATCH: begin\n\t\t\t\tif (delay == 0)\n\t\t\t\tbegin\n\t\t\t\t\tMATOE <= 0;\n\t\t\t\t\tMATLAT <= 0;\n\t\t\t\t\tstate <= UNBLANK;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tdelay <= delay - 1;\n\t\t\t\tend\n\t\t\tend\n\n\t\t\tUNBLANK: begin\n\t\t\t\tif (rd_bit == 3)\n\t\t\t\tbegin\n\t\t\t\t\trd_bit <= 0;\n\t\t\t\t\tif (rd_row == 15)\n\t\t\t\t\tbegin\n\t\t\t\t\t\trd_row <= 0;\n\t\t\t\t\tend\n\t\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\trd_row <= rd_row + 1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trd_bit <= rd_bit + 1;\n\t\t\t\tend\n\t\t\t\trd_col <= 0;\n\t\t\t\tstate <= READ;\n\t\t\tend\n\t\t\t\n\t\t\tREAD: begin\n\t\t\t\tstate <= SHIFT1;\n\t\t\t\tMATCLK <= 0;\n\t\t\tend\n\n\t\t\tSHIFT1: begin\n\t\t\t\tR0 <= rd_row[0];\n\t\t\t\tG0 <= rd_row[1];\n\t\t\t\tB0 <= 0;\n\t\t\t\tR1 <= 0;\n\t\t\t\tG1 <= rd_row[1];\n\t\t\t\tB1 <= 0;\n\t\t\t\tstate <= SHIFT2;\n\t\t\tend\n\n\t\t\tSHIFT2: begin\n\t\t\t\tMATCLK <= 1;\n\t\t\t\tif (rd_col == 31)\n\t\t\t\tbegin\n\t\t\t\t\trd_col <= 0;\n\t\t\t\t\tstate <= WAIT;\n\t\t\t\tend\n\t\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\trd_col <= rd_col + 1;\n\t\t\t\t\tstate <= READ;\n\t\t\t\tend\n\t\t\tend\n\n\t\tendcase\n\tend\nend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ao22_874d0464", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ao22 (\n  q,\n  i0,\n  i1,\n  i2,\n  i3\n);\n  output q;\n  input i0;\n  input i1;\n  input i2;\n  input i3;\n\n  wire [1:0] int_0n;\n\n  // AND gate for int_0n[0]\n  and I0 (int_0n[0], i0, i1);\n\n  // AND gate for int_0n[1]\n  and I1 (int_0n[1], i2, i3);\n\n  // OR gate for q\n  or I2 (q, int_0n[0], int_0n[1]);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_e9286adf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4to1 (\n    input A,\n    input B,\n    input C,\n    input D,\n    input sel0,\n    input sel1,\n    output Y\n);\n\n    wire w1, w2, w3, w4, w5, w6;\n\n    assign w1 = (~sel1 & ~sel0) ? A : 1'b0;\n    assign w2 = (~sel1 & sel0) ? B : 1'b0;\n    assign w3 = (sel1 & ~sel0) ? C : 1'b0;\n    assign w4 = (sel1 & sel0) ? D : 1'b0;\n\n    assign w5 = w1 | w2;\n    assign w6 = w3 | w4;\n\n    assign Y = w5 | w6;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_575f84dd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule full_adder ( A, B, Ci, S, Co );\n  input A, B, Ci;\n  output S, Co;\n  wire   n1, n2, n3;\n\n  xor (n1, A, B);\n  xor (S, n1, Ci);\n  and (n2, A, B);\n  and (n3, n1, Ci);\n  or (Co, n2, n3);\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "TwosComplement_06c807a8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule TwosComplement (\n   input clk,\n   input [3:0] in,\n   output reg [3:0] out\n   );\n\n   always @(posedge clk) begin\n      out <= ~in + 1;\n   end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_81cb2674", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator (\n    input [15:0] A,\n    input [15:0] B,\n    output reg result\n);\n\n    always @(*) begin\n        if (A <= B) begin\n            result = 1'b1;\n        end else begin\n            result = 1'b0;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_d708aa1d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n    input clk,\n    input up_down,\n    input load,\n    output reg [2:0] count\n);\n\nreg [2:0] count_reg1;\nreg [2:0] count_reg2;\n\nalways @(posedge clk) begin\n    if (load) begin\n        count_reg1 <= 3'b0;\n        count_reg2 <= 3'b0;\n    end else begin\n        count_reg1 <= count_reg2;\n        count_reg2 <= count;\n    end\nend\n\nalways @(*) begin\n    if (up_down) begin\n        count = count_reg1 + 3'b001;\n    end else begin\n        count = count_reg1 - 3'b001;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "key_b1da4d35", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule key (\n  input [1:0] address,\n  input chipselect,\n  input clk,\n  input in_port,\n  input reset_n,\n  input write_n,\n  input [31:0] writedata,\n  output irq,\n  output [31:0] readdata\n);\n\n  reg [31:0] mem [3:0];\n  reg [31:0] read_mux_out;\n  reg [31:0] readdata_reg;\n  reg irq_mask;\n  wire clk_en;\n\n  assign clk_en = 1;\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      readdata_reg <= 0;\n      irq_mask <= 0;\n    end else if (clk_en) begin\n      readdata_reg <= read_mux_out;\n      // *** fix conflict\n      if (chipselect & write_n && (address == 2)) begin\n        irq_mask <= writedata;\n      end\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      mem[0] <= 0;\n      mem[1] <= 0;\n      mem[2] <= 0;\n      mem[3] <= 0;\n    end else if (chipselect && ~write_n) begin\n      mem[address] <= writedata;\n    end\n  end\n\n  always @(posedge clk or negedge reset_n) begin\n    if (~reset_n) begin\n      read_mux_out <= 0;\n    end else begin\n      case (address)\n        2'b00: read_mux_out <= mem[0];\n        2'b01: read_mux_out <= mem[1];\n        2'b10: read_mux_out <= irq_mask;\n        2'b11: read_mux_out <= mem[3];\n      endcase\n    end\n  end\n\n  assign irq = |(in_port & irq_mask);\n\n  assign readdata = readdata_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "signal_decoder #_d9c388ff", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule signal_decoder # \n(\n    parameter ADC_WIDTH = 14,\n    parameter AXIS_TDATA_WIDTH = 32,\n    parameter BIT_OFFSET = 4 )\n(\n    \n    input [AXIS_TDATA_WIDTH-1:0]    S_AXIS_tdata,\n    input                           S_AXIS_tvalid,\n    input                           clk,\n    input                           rst,\n\toutput reg [7:0]                led_out\n);\n    wire [2:0] value;\n    \n    assign value = S_AXIS_tdata[ADC_WIDTH-BIT_OFFSET-1:ADC_WIDTH-BIT_OFFSET-3];\n \n    always @(posedge clk)\n       if (~rst)\n          led_out <= 8'hFF;\n       else\n          case (value)\n             3'b011  : led_out <= 8'b00000001;\n             3'b010  : led_out <= 8'b00000010;\n             3'b001  : led_out <= 8'b00000100;\n             3'b000  : led_out <= 8'b00001000;\n             3'b111  : led_out <= 8'b00010000;\n             3'b110  : led_out <= 8'b00100000;\n             3'b101  : led_out <= 8'b01000000;\n             3'b100  : led_out <= 8'b10000000;\n             default : led_out <= 8'b00000000;\n          endcase\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__a2bb2o_392751e0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__a2bb2o (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out ;\n    wire nor0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , B1, B2            );\n    nor nor0 (nor0_out , A1_N, A2_N        );\n    or  or0  (or0_out_X, nor0_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__or2b_4ac82166", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_hd__or2b (\n    input A,\n    input B_N,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    reg A_reg;\n    reg B_N_reg;\n    reg X_reg;\n\n    wire A_stable;\n    wire B_N_stable;\n    wire X_stable;\n\n    assign A_stable = (A_reg === A);\n    assign B_N_stable = (B_N_reg === B_N);\n    assign X_stable = (X_reg === X);\n\n    always @(posedge VPWR) begin // Using posedge operator for VPWR\n        A_reg <= A;\n        B_N_reg <= B_N;\n    end\n\n    always @(A or B_N or A_stable or B_N_stable or X_stable) begin\n        if (A_stable && B_N_stable) begin\n            X_reg <= A | B_N;\n        end else begin\n            X_reg <= #2 A | B_N;\n        end\n    end\n\n    assign X = X_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Inverse_Clarke_Transform_3db426bf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Inverse_Clarke_Transform (\n    input signed [17:0] alpha_voltage,\n    input signed [17:0] beta_voltage,\n    output signed [17:0] phase_voltages_0,\n    output signed [17:0] phase_voltages_1,\n    output signed [17:0] phase_voltages_2\n);\n\n    wire signed [35:0] voltage_phase_a;\n    wire signed [35:0] Gain1_out1;\n    wire signed [35:0] Gain_out1;\n    wire signed [35:0] voltage_phase_b;\n    wire signed [37:0] Add1_cast;\n    wire signed [37:0] Add1_cast_1;\n    wire signed [37:0] Add1_sub_cast;\n    wire signed [37:0] Add1_sub_temp;\n    wire signed [35:0] voltage_phase_c;\n    wire signed [35:0] Mux_out1 [0:2];\n    wire signed [17:0] Current_Data_Type_out1 [0:2];\n\n    assign voltage_phase_a = {{2{alpha_voltage[17]}}, {alpha_voltage, 16'b0000000000000000}};\n    assign Gain1_out1 = 56756 * beta_voltage;\n    assign Gain_out1 = {{3{alpha_voltage[17]}}, {alpha_voltage, 15'b000000000000000}};\n    assign voltage_phase_b = Gain1_out1 - Gain_out1;\n    assign Add1_cast = Gain_out1;\n    assign Add1_cast_1 =  - (Add1_cast);\n    assign Add1_sub_cast = Gain1_out1;\n    assign Add1_sub_temp = Add1_cast_1 - Add1_sub_cast;\n    assign voltage_phase_c = Add1_sub_temp[35:0];\n    assign Mux_out1[0] = voltage_phase_a;\n    assign Mux_out1[1] = voltage_phase_b;\n    assign Mux_out1[2] = voltage_phase_c;\n\n    assign Current_Data_Type_out1[0] = ((Mux_out1[0][35] == 1'b0) && (Mux_out1[0][34:30] != 5'b00000) ? 18'sb011111111111111111 :\n              ((Mux_out1[0][35] == 1'b1) && (Mux_out1[0][34:30] != 5'b11111) ? 18'sb100000000000000000 :\n              $signed(Mux_out1[0][30:13])));\n    assign Current_Data_Type_out1[1] = ((Mux_out1[1][35] == 1'b0) && (Mux_out1[1][34:30] != 5'b00000) ? 18'sb011111111111111111 :\n              ((Mux_out1[1][35] == 1'b1) && (Mux_out1[1][34:30] != 5'b11111) ? 18'sb100000000000000000 :\n              $signed(Mux_out1[1][30:13])));\n    assign Current_Data_Type_out1[2] = ((Mux_out1[2][35] == 1'b0) && (Mux_out1[2][34:30] != 5'b00000) ? 18'sb011111111111111111 :\n              ((Mux_out1[2][35] == 1'b1) && (Mux_out1[2][34:30] != 5'b11111) ? 18'sb100000000000000000 :\n              $signed(Mux_out1[2][30:13])));\n\n    assign phase_voltages_0 = Current_Data_Type_out1[0];\n    assign phase_voltages_1 = Current_Data_Type_out1[1];\n    assign phase_voltages_2 = Current_Data_Type_out1[2];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__78382287", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nreg [7:0] q_reg1, q_reg2, q_reg3, q_reg4, q_reg5, q_reg6, q_reg7, q_reg8;\n\nalways @(negedge clk) begin\n    q_reg1 <= d;\n    q_reg2 <= q_reg1;\n    q_reg3 <= q_reg2;\n    q_reg4 <= q_reg3;\n    q_reg5 <= q_reg4;\n    q_reg6 <= q_reg5;\n    q_reg7 <= q_reg6;\n    q_reg8 <= q_reg7;\nend\n\nassign q = q_reg8;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_scd_sce_1d620ffb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule d_ff_scd_sce (\n    input CLK,\n    input D,\n    input SCD,\n    input SCE,\n    output reg Q,\n    output reg Q_N\n);\n\n    always @(posedge CLK) begin\n        if (SCD) begin\n            Q <= 0;\n            Q_N <= 1;\n        end else if (SCE) begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lin_transmitter_f905ba42", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule lin_transmitter (\n  input clk,\n  input rst,\n  input tx_en,\n  input [7:0] tx_data,\n  input [5:0] id,\n  output reg tx\n);\n\n  // Define LIN frame structure\n  parameter SYNC_BYTE = 8'h55;\n  parameter ID_BYTE = 6;\n  parameter DATA_BYTE = 8;\n  parameter CHECKSUM_BYTE = 8;\n  parameter FRAME_SIZE = SYNC_BYTE + ID_BYTE + DATA_BYTE + CHECKSUM_BYTE;\n  \n  // Define state machine states\n  parameter IDLE = 2'b00;\n  parameter SYNC = 2'b01;\n  parameter ID = 2'b10;\n  parameter DATA = 2'b11;\n  \n  // Define state machine signals\n  reg [1:0] state;\n  reg [FRAME_SIZE-1:0] frame;\n  reg [7:0] checksum;\n  reg [3:0] bit_count;\n  reg [7:0] data_byte;\n  \n  // Initialize state machine\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      state <= IDLE;\n      bit_count <= 0;\n      checksum <= 0;\n      tx <= 1;\n    end else begin\n      case (state)\n        IDLE: begin\n          if (tx_en) begin\n            state <= SYNC;\n            frame[SYNC_BYTE-1:0] <= SYNC_BYTE;\n          end\n        end\n        SYNC: begin\n          if (bit_count == 0) begin\n            tx <= 0;\n            bit_count <= 1;\n          end else if (bit_count == 1) begin\n            tx <= 1;\n            bit_count <= 2;\n          end else if (bit_count == 2) begin\n            tx <= 0;\n            bit_count <= 3;\n          end else if (bit_count == 3) begin\n            tx <= 1;\n            bit_count <= 4;\n          end else if (bit_count == 4) begin\n            tx <= 0;\n            bit_count <= 5;\n          end else if (bit_count == 5) begin\n            tx <= 1;\n            bit_count <= 6;\n          end else if (bit_count == 6) begin\n            tx <= 0;\n            bit_count <= 7;\n          end else if (bit_count == 7) begin\n            tx <= 1;\n            bit_count <= 0;\n            state <= ID;\n            frame[ID_BYTE+SYNC_BYTE-1:SYNC_BYTE] <= {1'b0, id};\n            checksum <= id;\n          end\n        end\n        ID: begin\n          if (bit_count == 0) begin\n            tx <= 0;\n            bit_count <= 1;\n          end else if (bit_count == 1) begin\n            tx <= 1;\n            bit_count <= 2;\n          end else if (bit_count == 2) begin\n            tx <= 0;\n            bit_count <= 3;\n          end else if (bit_count == 3) begin\n            tx <= 1;\n            bit_count <= 4;\n          end else if (bit_count == 4) begin\n            tx <= 0;\n            bit_count <= 5;\n          end else if (bit_count == 5) begin\n            tx <= 1;\n            bit_count <= 6;\n          end else if (bit_count == 6) begin\n            tx <= 0;\n            bit_count <= 7;\n          end else if (bit_count == 7) begin\n            tx <= 1;\n            bit_count <= 0;\n            state <= DATA;\n            frame[DATA_BYTE+ID_BYTE+SYNC_BYTE-1:ID_BYTE+SYNC_BYTE] <= tx_data;\n            checksum <= checksum + tx_data;\n          end\n        end\n        DATA: begin\n          if (bit_count == 0) begin\n            tx <= 0;\n            bit_count <= 1;\n          end else if (bit_count == 1) begin\n            tx <= 1;\n            bit_count <= 2;\n          end else if (bit_count == 2) begin\n            tx <= 0;\n            bit_count <= 3;\n          end else if (bit_count == 3) begin\n            tx <= 1;\n            bit_count <= 4;\n          end else if (bit_count == 4) begin\n            tx <= 0;\n            bit_count <= 5;\n          end else if (bit_count == 5) begin\n            tx <= 1;\n            bit_count <= 6;\n          end else if (bit_count == 6) begin\n            tx <= 0;\n            bit_count <= 7;\n          end else if (bit_count == 7) begin\n            tx <= 1;\n            bit_count <= 0;\n            state <= IDLE;\n            frame[FRAME_SIZE-1:DATA_BYTE+ID_BYTE+SYNC_BYTE] <= ~checksum;\n          end\n        end\n      endcase\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "edge_detection_b7091468", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule edge_detection (\n    input clk,\n    input rst_n,\n    input signal,\n    output reg rise,\n    output reg fall\n);\n\nreg prev_signal;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        rise <= 0;\n        fall <= 0;\n        prev_signal <= 0;\n    end else begin\n        rise <= signal & ~prev_signal;\n        fall <= ~signal & prev_signal;\n        prev_signal <= signal;\n    end\nend\n\nendmodule\n\nmodule minimum_finding (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min_val\n);\n\nalways @(*) begin\n    if(a < b && a < c && a < d) begin\n        min_val = a;\n    end else if(b < c && b < d) begin\n        min_val = b;\n    end else if(c < d) begin\n        min_val = c;\n    end else begin\n        min_val = d;\n    end\nend\n\nendmodule\n\nmodule functional_module (\n    input clk,\n    input rst_n,\n    input rise,\n    input fall,\n    input [7:0] min_val,\n    output reg out\n);\n\nreg [7:0] max_val;\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        max_val <= 0;\n    end else begin\n        if(rise) begin\n            max_val <= 8'hFF; // Set max_val to the maximum possible value\n        end\n\n        if(fall) begin\n            out <= min_val; // Output the minimum value\n        end\n\n        if(max_val > min_val) begin\n            out <= max_val; // Output the maximum value if it's greater than the minimum value\n        end\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input rst_n,\n    input [7:0] a, // It's 7 bits wide in the top_module instantiation, but 8 bits wide in the minimum_finding instantiation. This is an error.\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output wire out\n);\n\nreg signal;\nwire rise, fall;\nwire [7:0] min_val;\n\nedge_detection ed(\n    .clk(clk),\n    .rst_n(rst_n),\n    .signal(signal),\n    .rise(rise),\n    .fall(fall)\n);\n\nminimum_finding mf(\n    .a(a), // Mismatch between the width of a (7 bits) and the width of the ports of the minimum_finding module (8 bits)\n    .b(b),\n    .c(c),\n    .d(d),\n    .min_val(min_val)\n);\n\nfunctional_module fm(\n    .clk(clk),\n    .rst_n(rst_n),\n    .rise(rise),\n    .fall(fall),\n    .min_val(min_val),\n    .out(out)\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        signal <= 0;\n    end else begin\n        signal <= a;\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_4to16_pipeline_b24efc70", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_4to16_pipeline (\n    input [1:0] select,\n    input en,\n    input clk,\n    output reg [15:0] out\n);\n\nreg [1:0] select_reg;\nreg en_reg;\n\nalways @(posedge clk) begin\n    select_reg <= select;\n    en_reg <= en;\nend\n\nalways @(posedge clk) begin\n    if (en_reg == 0) begin\n        case (select_reg)\n            2'b00: out <= 16'b1111111111111110;\n            2'b01: out <= 16'b1111111111111101;\n            2'b10: out <= 16'b1111111111111011;\n            2'b11: out <= 16'b1111111111110111;\n        endcase;\n    end else begin\n        out <= 16'b1111111111111111;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_b9277b84", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_register (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] load_value,\n    output [3:0] shift_out\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk, negedge reset) begin\n    if (!reset) begin\n        shift_reg <= 4'b0;\n    end else if (load) begin\n        shift_reg <= load_value;\n    end else begin\n        shift_reg <= {shift_reg[2:0], 1'b0};\n    end\nend\n\nassign shift_out = shift_reg;\n\nendmodule\n\nmodule d_flip_flop (\n    input clk,\n    input d,\n    input aset,\n    input areset,\n    output q\n);\n\nreg q;\n\nalways @(posedge clk, negedge areset) begin\n    if (!areset) begin\n        q <= 1'b0;\n    end else if (aset) begin\n        q <= 1'b1;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] load_value,\n    input d,\n    input aset,\n    input areset,\n    output q,\n    output [3:0] shift_out\n);\n\nshift_register shift_reg (\n    .clk(clk),\n    .reset(reset),\n    .load(load),\n    .load_value(load_value),\n    .shift_out(shift_out)\n);\n\nd_flip_flop d_ff (\n    .clk(clk),\n    .d(d),\n    .aset(aset),\n    .areset(areset),\n    .q(q)\n);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipelined_adder_45ee7613", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipelined_adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\nwire [7:0] p, g, c;\n\nassign p = a ^ b;\nassign g = a & b;\nassign c[0] = 1'b0;\n\ngenvar i;\n\ngenerate\n    for (i = 1; i < 8; i = i + 1) begin : carry_lookahead\n        assign c[i] = g[i-1] | (p[i-1] & c[i-1]);\n    end\nendgenerate\n\nassign s = a + b + c;\n\nassign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule\n\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\npipelined_adder adder(a, b, s, overflow);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand_gate_e98f4921", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nand_gate (\n    A,\n    B,\n    X,\n    SLEEP_B\n);\n\n    input A;\n    input B;\n    output X;\n    input SLEEP_B;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign X = ~(A & B) & SLEEP_B;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clk_synchronizer#_0e048b28", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule clk_synchronizer#(\n\tparameter\tSYSCLK_FREQ_HZ\t\t= 64'd100_000_000,\n\tparameter\tPPS_HIGH_LEVEL_US\t= 64'd10_000,\n\tparameter\tGENCLK_FREQ_HZ\t\t= 1,\n\tparameter\tFORWARD_OFFSET_CLK\t= 0\n)(\n\tinput\t\tclk,\n\tinput\t\trst_n,\n\tinput\t\tpps_in,\n\toutput\t\tsync_clk_out,\n\toutput\t\tclk_sync_ok_out\n);\n\nfunction integer log2ceil;\ninput reg [63 : 0] val;\nreg [63 : 0] i;\nbegin\n\ti = 1;\n\tlog2ceil = 0;\n\twhile (i < val) begin\n\t\tlog2ceil = log2ceil + 1;\n\t\ti = i << 1;\n\tend\nend\nendfunction\n\nlocalparam\t\t\t\t\t\tDUTY_CNT_N\t= SYSCLK_FREQ_HZ * PPS_HIGH_LEVEL_US / 64'd1_000_000;\nlocalparam\t\t\t\t\t\tDIVIDER_NUM\t= SYSCLK_FREQ_HZ / GENCLK_FREQ_HZ;\nlocalparam\t\t\t\t\t\tDIVIDER_BIT\t= log2ceil(DIVIDER_NUM);\n\nreg\t\t\t\t\t\t\t\tclk_sync_flag;\nreg\t\t\t\t\t\t\t\trst_release;\nwire\t\t\t\t\t\t\trst_pps_rst;\nreg\t\t\t\t\t\t\t\trst_pps;\nreg\t\t[DIVIDER_BIT - 1 : 0]\tclk_divider;\nwire\t\t\t\t\t\t\tclk_gen_forward;\nreg\t\t\t\t\t\t\t\tclk_generated;\n\nalways @ (posedge pps_in or posedge rst_pps_rst)\nbegin\n\tif (rst_pps_rst) begin\n\t\trst_pps <= 0;\n\tend\n\telse begin\n\t\trst_pps <= 1;\n\tend\nend\n\nalways @ (posedge clk or negedge rst_n)\nbegin\n\tif (!rst_n) begin\n\t\trst_release <= 0;\n\tend\n\telse if ((rst_pps == 1) || (clk_sync_flag == 1)) begin\n\t\trst_release <= 1;\n\tend\n\telse begin\n\t\trst_release <= 0;\n\tend\nend\n\nalways @ (posedge clk or negedge rst_n)\nbegin\n\tif (!rst_n) begin\n\t\tclk_sync_flag <= 0;\n\tend\n\telse if (rst_release == 1) begin\n\t\tclk_sync_flag <= 1;\n\tend\n\telse begin\n\t\tclk_sync_flag <= clk_sync_flag;\n\tend\nend\n\nalways @ (posedge clk or posedge rst_pps)\nbegin\n\tif (rst_pps) begin\n\t\tclk_divider <= FORWARD_OFFSET_CLK + 2;\n\tend\n\telse if (clk_divider < DIVIDER_NUM - 1) begin\n\t\tclk_divider <= clk_divider + 1'b1;\n\tend\n\telse begin\n\t\tclk_divider <= 0;\n\tend\nend\n\nalways @ (posedge clk or negedge rst_n)\nbegin\n\tif (!rst_n) begin\n\t\tclk_generated <= 0;\n\tend\n\telse if (clk_sync_flag) begin\n\t\tclk_generated <= clk_gen_forward;\n\tend\n\telse begin\n\t\tclk_generated <= 0;\n\tend\nend\n\nassign rst_pps_rst = rst_release | (~rst_n);\nassign clk_gen_forward = (clk_divider < DUTY_CNT_N) ? 1'b1: 1'b0;\nassign clk_sync_ok_out = clk_sync_flag;\nassign sync_clk_out = clk_generated;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lab4_3_1_df54a8dc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule lab4_3_1(\n    input m,clk,\n    output reg [3:0] Z\n    );\n    reg [1:0] state,nextstate;\n    parameter S0 = 2'b00,S1 = 2'b01,S2 = 2'b11,S3 = 2'b10;\n    initial\n    begin\n        state = S0;\n      end\n    always @(posedge clk)\n    begin\n       state = nextstate;\n      end\n    always @(state)\n    begin\n        case(state)\n        S0:if(m) Z = 4'b0001;else Z = 4'b0001;\n        S1:if(m) Z = 4'b0010;else Z = 4'b1000;\n        S2:if(m) Z = 4'b0100;else Z = 4'b0100;\n        S3:if(m) Z = 4'b1000;else Z = 4'b0010;\n        endcase\n    end\n    always @(state)\n    begin\n        case(state)\n        S0: nextstate = S1;\n        S1: nextstate = S2;\n        S2: nextstate = S3;\n        S3: nextstate = S0;\n        endcase\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "register_4bit_ae2e5113", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule register_4bit (\n    input [3:0] data_in,\n    input load,\n    input reset,\n    input clk,\n    output reg [3:0] Q\n);\n\n    // Local signals\n    reg [3:0] Q_reg;\n\n    // Instantiate 4 D Flip-Flops with Set and Reset functionality\n    always @ (posedge clk or posedge reset)\n    begin\n        if (reset)\n        begin\n            Q_reg <= 4'b0;\n        end\n        else if (load)\n        begin\n            Q_reg <= data_in;\n        end\n    end\n\n    always @*\n    begin\n        Q = Q_reg;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "baudgen_f57d4b12", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule baudgen(\n  input wire clk,\n  input wire resetq,\n  input wire [31:0] baud,\n  input wire restart,\n  output wire ser_clk);\n  parameter CLKFREQ = 1000000;\n  \n  parameter RWIDTH = 25;\n\n  wire [RWIDTH-1:0] aclkfreq = CLKFREQ;\n  reg [RWIDTH-1:0] d;\n  wire [RWIDTH-1:0] dInc = d[RWIDTH-1] ? ({4'd0, baud}) : (({4'd0, baud}) - aclkfreq);\n  wire [RWIDTH-1:0] dN = restart ? 0 : (d + dInc);\n  wire fastclk = ~d[RWIDTH-1];\n  assign ser_clk = fastclk;\n\n  always @(negedge resetq or posedge clk)\n  begin\n    if (!resetq) begin\n      d <= 0;\n    end else begin\n      d <= dN;\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "blk_mem_gen_0blk_mem_gen_v8_2_synth_78c96151", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule blk_mem_gen_0blk_mem_gen_v8_2_synth\n  (\n    output [63:0] doutb,\n    input enb,\n    input clkb,\n    input wea,\n    input clka,\n    input [8:0] addrb,\n    input [8:0] addra,\n    input [63:0] dina\n  );\n\n  parameter ADDR_WIDTH = 9;\n  parameter DATA_WIDTH = 64;\n  parameter DEPTH = 2 ** ADDR_WIDTH;\n\n  // Internal wires\n  reg  [DATA_WIDTH-1:0] mem [DEPTH-1:0];\n  wire [ADDR_WIDTH-1:0] addr;\n  reg  [DATA_WIDTH-1:0] data;\n\n  // Address decoding\n  assign addr = (clka) ? addra : addrb;\n\n  // Read/Write operations\n  always @(posedge clkb) begin\n    if (enb) begin\n      if (wea) begin // Write operation\n        mem[addr] <= dina;\n      end else begin // Read operation\n        data <= mem[addr];\n      end\n    end\n  end\n\n  assign doutb = data;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RegisterAdd_parameterized8_ffaa5dca", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RegisterAdd_parameterized8\n   (\n    input clk,\n    input rst,\n    input load,\n    input [7:0] D1,\n    input [7:0] D2,\n    output reg [7:0] Q\n  );\n\n  reg [7:0] reg1;\n  reg [7:0] reg2;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      reg1 <= 8'b0;\n      reg2 <= 8'b0;\n    end else if (load) begin\n      reg1 <= D1;\n      reg2 <= D2;\n    end else begin\n      Q <= reg1 + reg2;\n    end\n  end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "store_data_translator #_f0d5a09c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule store_data_translator #(\n    parameter WIDTH=32\n)(\n    input [WIDTH-1:0] write_data,\n    input [1:0] d_address,\n    input [1:0] store_size,\n    output [3:0] d_byteena,\n    output [WIDTH-1:0] d_writedataout\n);\n\n\nreg [3:0] d_byteena;\nreg [WIDTH-1:0] d_writedataout;\n\nalways @*\nbegin\n    case (store_size)\n        2'b11:\n            case(d_address[1:0])\n                0: \n                begin \n                    d_byteena=4'b1000; \n                    d_writedataout={write_data[7:0],24'b0}; \n                end\n                1: \n                begin \n                    d_byteena=4'b0100; \n                    d_writedataout={8'b0,write_data[7:0],16'b0}; \n                end\n                2: \n                begin \n                    d_byteena=4'b0010; \n                    d_writedataout={16'b0,write_data[7:0],8'b0}; \n                end\n                default: \n                begin \n                    d_byteena=4'b0001; \n                    d_writedataout={24'b0,write_data[7:0]}; \n                end\n            endcase\n        2'b01:\n            case(d_address[1])\n                0: \n                begin \n                    d_byteena=4'b1100; \n                    d_writedataout={write_data[15:0],16'b0}; \n                end\n                default: \n                begin \n                    d_byteena=4'b0011; \n                    d_writedataout={16'b0,write_data[15:0]}; \n                end\n            endcase\n        default:\n        begin\n            d_byteena=4'b1111;\n            d_writedataout=write_data;\n        end\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "data_transfer_2dc00c47", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule data_transfer(clk, rst, input_data, input_valid, output_data, output_valid);\n  input clk, rst, input_valid;\n  input [7:0] input_data;\n  output [7:0] output_data;\n  output output_valid;\n  \n  reg [7:0] data_reg;\n  reg valid_reg;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      data_reg <= 0;\n      valid_reg <= 0;\n    end else if (input_valid) begin\n      data_reg <= input_data;\n      valid_reg <= 1;\n    end else begin\n      valid_reg <= 0;\n    end\n  end\n  \n  assign output_data = data_reg;\n  assign output_valid = valid_reg;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__774ee52b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output reg q\n);\n\n    wire mux_out;\n    mux_2to1 mux_inst (\n        .a(a),\n        .b(b),\n        .sel(sel_b1),\n        .out(mux_out)\n    );\n\n    d_flip_flop dff_inst (\n        .clk(clk),\n        .d(mux_out),\n        .q(q)\n    );\n\nendmodule\n\nmodule mux_2to1 (\n    input a,\n    input b,\n    input sel,\n    output reg out\n);\n\n    always @(*) begin\n        if (sel == 1'b0) begin\n            out = a;\n        end else begin\n            out = b;\n        end\n    end\n\nendmodule\n\nmodule d_flip_flop (\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__and3b_ace64a1d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__and3b (\n    X  ,\n    A_N,\n    B  ,\n    C\n);\n\n    output X  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out  ;\n    wire and0_out_X;\n\n    not not0 (not0_out  , A_N            );\n    and and0 (and0_out_X, C, not0_out, B );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "r_FAULT_STATUS_914e227c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule r_FAULT_STATUS(output reg [7:0] reg_0x1F, input wire reset, input wire wenb, input wire [7:0] in_data, input wire clk);\n    always @(posedge clk) begin\n        if (reset == 1'b1) begin\n            reg_0x1F <= 8'h00;\n        end\n        else begin\n            if (wenb == 1'b0) begin\n                reg_0x1F <= in_data;\n            end\n            else begin\n                reg_0x1F <= reg_0x1F;\n            end\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Arithmetic_Unit_32b68c8a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Arithmetic_Unit(a, b, ctrl, result);\n    input [3:0] a, b;\n    input [1:0] ctrl;\n    output reg [3:0] result;\n    \n    always @(*) begin\n        case(ctrl)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "a23_multiply_3db8e73d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule a23_multiply (\ninput                       i_clk,\ninput                       i_rst,\n\ninput       [31:0]          i_a_in,         input       [31:0]          i_b_in,         input       [1:0]           i_function,\ninput                       i_execute,\n\noutput      [31:0]          o_out,\noutput      [1:0]           o_flags,        output                      o_done    );\n\n\nwire        enable;\nwire        accumulate;\n\nreg  [31:0] product;\nreg  [3:0]  count;\n\nassign enable         = i_function[0];\nassign accumulate     = i_function[1];\n\nassign o_out   = product;\n\nassign o_flags = {o_out[31], o_out == 32'd0 }; \nassign o_done  = 1'b1;\n\n\nalways @(posedge i_clk or posedge i_rst) begin\n  if (i_rst) begin\n    product <= 32'b0;\n    count <= 4'b0;\n  end else if(enable) begin\n    count <= count + 1;\n    if (i_execute && count == 0) begin\n      product <= i_a_in*i_b_in;\n    end else if (i_execute && accumulate && count == 3) begin\n      product <= product + i_a_in;\n    end\n  end else begin\n    product <= 32'b0;\n    count <= 4'b0;\n  end\nend\n\nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bin2gray_d5720010", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bin2gray(\n    input [3:0] bin_in,\n    output [3:0] gray_out\n);\n\n    assign gray_out[0] = bin_in[0];\n    assign gray_out[1] = bin_in[0] ^ bin_in[1];\n    assign gray_out[2] = bin_in[1] ^ bin_in[2];\n    assign gray_out[3] = bin_in[2] ^ bin_in[3];\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "INV4BITS_2b36abec", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule INV4BITS (\n    input [3:0] in,\n    output [3:0] out\n);\n\n    assign out = ~in;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rfid_1c5db08e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rfid (\n  input clk,\n  input [7:0] tx_data,\n  input tx_en,\n  input rx_en,\n  output [7:0] rx_data\n);\n\n  // Define modulation scheme used by transmitter block\n  // For simplicity, we will use amplitude shift keying (ASK)\n  reg [1:0] tx_mod;\n  always @ (posedge clk) begin\n    if (tx_en) begin\n      if (tx_data[0]) begin\n        tx_mod <= 2'b11; // High amplitude\n      end else begin\n        tx_mod <= 2'b01; // Low amplitude\n      end\n    end else begin\n      tx_mod <= 2'b00; // No transmission\n    end\n  end\n  \n  // Define decoding algorithm used by receiver block\n  // For simplicity, we will use amplitude detection for ASK\n  reg [7:0] rx_data_reg;\n  always @ (posedge clk) begin\n    if (rx_en) begin\n      if (tx_mod == 2'b11) begin\n        rx_data_reg <= 8'b11111111; // High amplitude detected, set all bits to 1\n      end else begin\n        rx_data_reg <= tx_data; // Low amplitude detected, retrieve original data\n      end\n    end\n  end\n  \n  // Connect inputs to transmitter and receiver blocks\n  assign rx_data = rx_data_reg;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "BOOL_EXP_850bea89", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule BOOL_EXP (\n  input A,\n  input B,\n  output OUT\n);\n\n  wire a_and_not_b_or_a = A & ~(B | A);\n  wire not_a_and_b = ~A & B;\n  \n  assign OUT = a_and_not_b_or_a | not_a_and_b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "win_blk_mem_gen_prim_width__parameterized3_27dc6486", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule win_blk_mem_gen_prim_width__parameterized3 (\n    douta10,\n    douta11,\n    clka,\n    addra,\n    dina,\n    wea\n);\n\n    output [7:0] douta10;\n    output douta11;\n    input clka;\n    input [13:0] addra;\n    input [8:0] dina;\n    input wea;\n\n    // Code for the module implementation\n\nendmodule\n\nmodule block_mem\n(\n    input clk,\n    input [12:0] addr,\n    input [9:0] din,\n    input we,\n    output reg [9:0] dout\n);\n\n    wire [7:0] douta10;\n    wire douta11;\n    wire [13:0] addra;\n    wire [8:0] dina;\n    wire wea;\n\n    assign addra = addr;\n    assign dina = din;\n    assign wea = we;\n\n    win_blk_mem_gen_prim_width__parameterized3 mem\n    (\n        .douta10(douta10),\n        .douta11(douta11),\n        .clka(clk),\n        .addra(addra),\n        .dina(dina),\n        .wea(wea)\n    );\n\n    always @(posedge clk) begin\n        if (douta11) begin\n            dout <= {1'b0, douta10};\n        end\n        else begin\n            dout <= douta10;\n        end\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_471fc984", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4to1 (\n    input  [3:0] data_in,\n    input  [1:0] sel,\n    output reg     data_out\n);\n\n    wire [3:0] sel_inv;\n    assign sel_inv = ~sel;\n\n    always @ (*) begin\n        if (sel == 2'b00) begin\n            data_out = data_in[0];\n        end else if (sel == 2'b01) begin\n            data_out = data_in[1];\n        end else if (sel == 2'b10) begin\n            data_out = data_in[2];\n        end else if (sel == 2'b11) begin\n            data_out = data_in[3];\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_59748d65", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux4to1 (input [1:0] S, input D0, input D1, input D2, input D3, input OE, output Y);\n\nwire Z0, Z1, Z2, Z3;\nassign Z0 = OE ? D0 : 1'b0;\nassign Z1 = OE ? D1 : 1'b0;\nassign Z2 = OE ? D2 : 1'b0;\nassign Z3 = OE ? D3 : 1'b0;\n\nassign Y = (S == 2'b00) ? Z0 :\n           (S == 2'b01) ? Z1 :\n           (S == 2'b10) ? Z2 :\n           (S == 2'b11) ? Z3 : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_dee2bd19", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule four_bit_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\nwire [3:0] c;\nassign c[0] = cin;\nassign c[1] = a[0] & b[0];\nassign c[2] = a[1] & b[1] | a[1] & c[1] | b[1] & c[1];\nassign c[3] = a[2] & b[2] | a[2] & c[2] | b[2] & c[2];\nassign sum = a + b + c;\nassign cout = (a[3] & b[3]) | (a[3] & c[3]) | (b[3] & c[3]);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_8bit_a046b0a8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_8bit(\n  input [7:0] A,\n  input [7:0] B,\n  input enable,\n  output reg [7:0] C\n);\n\n  always @(*) begin\n    if(enable) begin\n      C <= A + B;\n    end else begin\n      C <= 8'b0;\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ram_16x1k_sp_2b163ff9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ram_16x1k_sp (\n  clka,\n  ena,\n  wea,\n  addra,\n  dina,\n  douta\n);\n\ninput clka;\ninput ena;\ninput [1 : 0] wea;\ninput [9 : 0] addra;\ninput [15 : 0] dina;\noutput [15 : 0] douta;\n\n\nreg [15:0] mem[0:16383];\n\nalways @(posedge clka) begin\n    if (ena) begin\n        if (wea == 2'b01) // byte write\n            mem[addra][7:0] <= dina[7:0];\n        else if (wea == 2'b10) // half-word write\n            mem[addra][15:8] <= dina[15:8];\n        else if (wea == 2'b11) // word write\n            mem[addra] <= dina;\n    end\nend\n\nassign douta = mem[addra];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__a61e3d19", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input a, b, c,\n    input [7:0] in,\n    output reg [2:0] pos,\n    output reg w, x, y, z\n);\n\n    // Priority Encoder\n    wire [7:0] in_inv;\n    assign in_inv = ~in;\n    wire [2:0] pos_inv;\n    priority_encoder pe(\n        .in(in_inv),\n        .pos(pos_inv)\n    );\n    \n    // Multiplexer\n    wire [1:0] sel = pos_inv[1:0];\n    mux4to1 mux(\n        .a(a),\n        .b(b),\n        .c(c),\n        .d(0),\n        .sel(sel)\n    );\n    \n    // Output\n    always @(*) begin\n        case (pos_inv)\n            3'b000: begin\n                w <= in[sel];\n                x <= 0;\n                y <= 0;\n                z <= 0;\n            end\n            3'b001: begin\n                w <= 0;\n                x <= in[sel];\n                y <= 0;\n                z <= 0;\n            end\n            3'b010: begin\n                w <= 0;\n                x <= 0;\n                y <= in[sel];\n                z <= 0;\n            end\n            3'b011: begin\n                w <= 0;\n                x <= 0;\n                y <= 0;\n                z <= in[sel];\n            end\n            default: begin\n                w <= 0;\n                x <= 0;\n                y <= 0;\n                z <= 0;\n            end\n        endcase\n    end\n    \n    // Output Position\n    always @(in) begin\n        if (in == 8'b00000000) begin\n            pos <= 3'b000;\n        end else begin\n            pos <= pos_inv;\n        end\n    end\n    \nendmodule\nmodule mux4to1 (\n    input a, b, c, d,\n    input [1:0] sel,\n    output reg out\n);\n\n    always @* begin\n        case (sel)\n            2'b00: out <= a;\n            2'b01: out <= b;\n            2'b10: out <= c;\n            2'b11: out <= d;\n            default: out <= 0;\n        endcase\n    end\n    \nendmodule\nmodule priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @* begin\n        casez (in)\n            8'b00000001: pos <= 3'b000;\n            8'b00000011: pos <= 3'b001;\n            8'b00000111: pos <= 3'b010;\n            8'b00001111: pos <= 3'b011;\n            8'b00011111: pos <= 3'b100;\n            8'b00111111: pos <= 3'b101;\n            8'b01111111: pos <= 3'b110;\n            8'b11111111: pos <= 3'b111;\n            default: pos <= 3'b000;\n        endcase\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_en_gated_4b80d57d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule d_ff_en_gated (\n  input CLK,\n  input EN,\n  input TE,\n  output reg ENCLK\n);\n\n  reg ENCLK_internal = 0; // Initialize to 0 \n  always @ (posedge CLK) \n    if (EN) \n      ENCLK_internal <= TE;\n    else \n      ENCLK_internal <= 0;\n\n  always @*\n    ENCLK = ENCLK_internal;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "modulo_92734193", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule modulo (\n  input [31:0] A,\n  input [31:0] B,\n  output [31:0] C\n);\n\n  // If B is zero, the output C should be zero.\n  // If A is zero, the output C should be zero.\n  // In both cases, we can simply assign zero to the output.\n  assign C = (B == 0) ? 0 : ((A == 0) ? 0 : ((A < 0) ? ((B < 0) ? -A % -B : -A % B) : ((B < 0) ? A % -B : A % B)));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MULT18X18S_62982c69", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MULT18X18S\n  (output reg signed [35:0] P,\n   input signed [17:0] A,\n   input signed [17:0] B,\n   input C,    input CE,   input R     );\n   \n   always @(posedge C)\n     if(R)\n       P <= 36'sd0;\n     else if(CE)\n       P <= A * B;\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "test_831fd56e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule test(I1,I2,I3,I4,enter,win,lose,reset,equal,bigger,smaller,nums,CLK,outs,numa);\n\tinput CLK;\n\twire good;\n\toutput reg outs;\n\treg[0:22] out;\n\talways @(posedge good or posedge reset) begin\n\t\tif(reset)\n\t\t\touts = 0 ;\n\t\telse\n\t\t\touts = ~outs;\n\tend\n\talways @(posedge CLK or posedge reset) begin\n\t\tif(reset)\n\t\t\tout = 0 ;\n\t\telse\n\t\t\tout = out + 1;\n\tend\n\tassign good = (out == 23'd100000);\n\tinput I1, I2, I3, I4, enter,reset; \n\treg[0:6] a1,a2,a3,a4,suc,b1,b2,b3,b4;\n\toutput reg[0:3] numa;\n\treg[0:3] numb;\n\toutput reg win,lose;\n\toutput reg equal,bigger,smaller;\n\treg runa,runb;\n\treg [0:3] turn;\n\toutput reg [0:3] nums;\n\treg [0:4] ins;\n\tinitial begin\n\t\tins = 0;\n\t\tnums = 0;\n\t\twin = 0;\n\t\tsuc = 0;\n\t\truna = 1;\n\t\trunb = 0;\n\t\tlose = 0;\n\t\tequal = 0;\n\t\tbigger = 0;\n\t\tsmaller = 0;\n\t\ta1 = 0;\n\t\ta2 = 0;\n\t\ta3 = 0;\n\t\ta4 = 0;\n\t\tb1 = 0;\n\t\tb2 = 0;\n\t\tb3 = 0;\n\t\tb4 = 0;\n\t\tnuma = 0;\n\t\tnumb = 0;\n\t\tturn = 0;\n\tend\n\talways @(posedge good or posedge reset) begin\n\t\tif(reset) begin\n\t\t\twin = 0;\n\t\t\tsuc = 0;\n\t\t\truna = 1;\n\t\t\trunb = 0;\n\t\t\tlose = 0;\n\t\t\tequal = 0;\n\t\t\tbigger = 0;\n\t\t\tsmaller = 0;\n\t\t\tnums = 0;\n\t\t\ta1 = 0;\n\t\t\ta2 = 0;\n\t\t\ta3 = 0;\n\t\t\ta4 = 0;\n\t\t\tb1 = 0;\n\t\t\tb2 = 0;\n\t\t\tb3 = 0;\n\t\t\tb4 = 0;\n\t\t\tnuma = 0;\n\t\t\tnumb = 0;\n\t\t\tturn = 0;\n\t\t\tins = 0;\n\t\tend\n\t\telse begin\n\t\t\tif(I1 & ~ins[0]) begin\n\t\t\t\tins[0] = 1;\n\t\t\t\tnums = 0;\n\t\t\t\tnums[0] = 1;\n\t\t\t\tif(runa) begin\n\t\t\t\t\ta1[numa] = 1;\n\t\t\t\t\tnuma = numa + 1;\n\t\t\t\tend\n\t\t\t\tif(runb) begin\n\t\t\t\t\tb1[numb] = 1;\n\t\t\t\t\tnumb=numb + 1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse if(~I1)\n\t\t\t\tins[0] = 0;\n\t\t\tif(I2 & ~ins[1]) begin\n\t\t\t\tnums = 0;\n\t\t\t\tnums[1] = 1;\n\t\t\t\tif(runa) begin\n\t\t\t\t\ta2[numa] = 1;\n\t\t\t\t\tnuma=numa+1;\n\t\t\t\tend\n\t\t\t\tif(runb) begin\n\t\t\t\t\tb2[numb] = 1;\n\t\t\t\t\tnumb=numb+1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse if(~I2)\n\t\t\t\tins[1] = 0;\n\t\t\tif(I3 & ~ins[2]) begin\n\t\t\t\tnums = 0;\n\t\t\t\tins[2] = 1;\n\t\t\t\tnums[2] = 1;\n\t\t\t\tif(runa) begin\n\t\t\t\t\ta3[numa] = 1;\n\t\t\t\t\tnuma=numa+1;\n\t\t\t\tend\n\t\t\t\tif(runb) begin\n\t\t\t\t\tb3[numb] = 1;\n\t\t\t\t\tnumb=numb+1;\n\t\t\t\tend\n\t\t\tend\n\t\t\telse if(~I3)\n\t\t\t\tins[2] = 0;\n\t\t\tif(I4 & ~ins[3]) begin\n\t\t\t\tins[3] = 1;\n\t\t\t\tnums = 0;\n\t\t\t\tnums[3] = 1;\n\t\t\t\tif(runa) begin\n\t\t\t\t\ta4[numa] = 1;\n\t\t\t\t\tnuma=numa+1;\n\t\t\t\tend\n\t\t\t\tif(runb) begin\n\t\t\t\t\tb4[numb] = 1;\n\t\t\t\t\tnumb=numb+1;\n\t\t\t\tend   \n\t\t\tend\n\t\t\telse if(~I4)\n\t\t\t\tins[3] = 0;\n\t\t\tif(enter & ~ins[4]) begin\n\t\t\t\tif(numa > 3) begin\n\t\t\t\t\truna = 0;\n\t\t\t\t\trunb = 1;\n\t\t\t\tend\n\t\t\t\telse if(numa < 4) begin\n\t\t\t\t  a1 = 0;\n\t\t\t\t  a2 = 0;\n\t\t\t\t  a3 = 0;\n\t\t\t\t  a4 = 0;\n\t\t\t\t  numa = 0;\n\t\t\t\tend\n\t\t\t\tif(numb >=4) begin\n\t\t\t\t\tsuc = (a1~^b1)&(a2~^b2)&(a3~^b3)&(a4~^b4);\n\t\t\t\t\twin = suc[0]&suc[1]&suc[2]&suc[3]&suc[4]&suc[5]&suc[6];\n\t\t\t\t\tif((~win) & (turn <3)) begin\n\t\t\t\t\t\tturn=turn+1;\n\t\t\t\t\t\tb1=0;\n\t\t\t\t\t\tb2=0;\n\t\t\t\t\t\tb3=0;\n\t\t\t\t\t\tb4=0;\n\t\t\t\t\tend\n\t\t\t\t\tif(numb > numa) begin\n\t\t\t\t\t\tsmaller = 1;\n\t\t\t\t\t\tbigger = 0;\n\t\t\t\t\t\tequal = 0;\n\t\t\t\t\tend\n\t\t\t\t\tif(numb == numa) begin\n\t\t\t\t\t\tsmaller = 0;\n\t\t\t\t\t\tbigger = 0;\n\t\t\t\t\t\tequal = 1;\n\t\t\t\t\tend\n\t\t\t\t\tif(numb < numa) begin\n\t\t\t\t\t\tsmaller = 0;\n\t\t\t\t\t\tbigger = 1;\n\t\t\t\t\t\tequal = 0;\n\t\t\t\t\tend\n\t\t\t\t  numb = 0;\n\t\t\t\tend \n\t\t\t\tif((~win) & (turn >= 3))\n\t\t\t\t\tlose = 1;\n\t\t\tend\n\t\t\telse if(~enter)\n\t\t\t\tins[4] = 0;\n\t\t\tbegin\n\t\t\t\tif(numa == 7) begin\n\t\t\t\t\truna = 0;\n\t\t\t\t\trunb = 1;\n\t\t\t\tend\n\t\t\t\tif(numb == 7)\n\t\t\t\t\trunb = 0;\n\t\t\tend\n\t\tend\n\tend\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_counter_1fec7a47", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_counter (\n  input clk,\n  input reset,\n  output reg [3:0] count_out\n);\n\nreg j, k;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    count_out <= 4'b0000;\n    j <= 1'b0;\n    k <= 1'b0;\n  end\n  else begin\n    case ({j,k})\n      2'b00: begin // Qn-1 = 0, Qn = 0\n        count_out <= count_out + 1;\n        j <= 1'b1;\n      end\n      2'b01: begin // Qn-1 = 0, Qn = 1\n        j <= 1'b0;\n        k <= 1'b1;\n      end\n      2'b10: begin // Qn-1 = 1, Qn = 0\n        j <= 1'b1;\n        k <= 1'b0;\n      end\n      2'b11: begin // Qn-1 = 1, Qn = 1\n        j <= 1'b1;\n        k <= 1'b1;\n      end\n    endcase\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PLL_2f8e48c1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule PLL (\n    inclk0,\n    c0\n);\n\n    parameter   integer   DIV_FACTOR = 2;\n\n    input       inclk0;\n    output      c0;\n\n    reg         [31:0]   counter;\n    reg                   clk_out;\n\n    always @(posedge inclk0) begin\n        if (counter == DIV_FACTOR - 1) begin\n            counter <= 0;\n            clk_out <= ~clk_out;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign c0 = clk_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_ones_counter_388df24e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_ones_counter (\n    input [15:0] data_in,\n    output reg [3:0] ones_count\n);\n\n    integer i;\n    reg [15:0] temp;\n\n    always @ (data_in) begin\n        temp = data_in;\n        ones_count = 0;\n        for (i = 0; i < 16; i = i + 1) begin\n            if (temp[0] == 1'b1) begin\n                ones_count = ones_count + 1;\n            end\n            temp = temp >> 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_module_1f07a7c9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_module(\n    input CLOCK_IN,\n    input RESET,\n    input [2:0] SWITCH,\n    output reg [3:0] LED\n);\n\nalways @(posedge CLOCK_IN) begin\n    if(RESET) begin\n        LED <= 4'b0000;\n    end\n    else begin\n        case(SWITCH)\n            3'b000: LED <= 4'b0001;\n            3'b001: LED <= 4'b0010;\n            3'b010: LED <= 4'b0100;\n            3'b011: LED <= 4'b1000;\n            default: LED <= 4'b1111;\n        endcase\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sub_8f0029e7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sub (\n    // Outputs\n    outy_w92, outz_w22,\n    // Inputs\n    clk, inw_w31, inx_w11\n    );\n\n    input clk;\n    input        inw_w31;\n    input [60:0] inx_w11;\n    output [91:0] outy_w92;\n    output [21:0] outz_w22;\n\n    wire [29:0] outc_w30;\n    wire [72:0] outd_w73;\nendmodule\n\nmodule t (\n    // Outputs\n    outc_w30,\n    outd_w73,\n    // Inputs\n    clk,\n    ina_w1,\n    inb_w61\n    );\n\n    input clk;\n    input ina_w1;\n    input [60:0] inb_w61;\n    output [29:0] outc_w30;\n    output [72:0] outd_w73;\n\n    assign outc_w30 = ina_w1 - inb_w61[30:0];\n    assign outd_w73 = ina_w1 * inb_w61;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "unsigned_non_restoring_divider_5ba12919", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule unsigned_non_restoring_divider (\n  input [N-1:0] dividend,\n  input [N-1:0] divisor,\n  input clk,\n  input rst,\n  output [N-1:0] quotient,\n  output [N-1:0] remainder\n);\n\nparameter N = 8; // number of bits for dividend and divisor\n\nreg [N-1:0] dividend_reg;\nreg [N-1:0] divisor_reg;\nreg [N-1:0] quotient_reg;\nreg [N-1:0] remainder_reg;\nreg [N-1:0] dividend_shift_reg;\nreg [N:0] counter_reg;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    dividend_reg <= 0;\n    divisor_reg <= 0;\n    quotient_reg <= 0;\n    remainder_reg <= 0;\n    dividend_shift_reg <= {dividend, 1'b0};\n    counter_reg <= N+1;\n  end\n  else begin\n    dividend_reg <= dividend_shift_reg[N-1:0];\n    divisor_reg <= divisor;\n    if (counter_reg == 0) begin\n      remainder_reg <= dividend_shift_reg[N-1:0];\n      quotient_reg <= quotient_reg << 1 | dividend[N-1];\n      dividend_shift_reg <= {dividend, 1'b0};\n      counter_reg <= N+1;\n    end\n    else begin\n      if (remainder_reg >= divisor_reg) begin\n        remainder_reg <= remainder_reg - divisor_reg;\n        quotient_reg <= quotient_reg | 1<<(counter_reg-1);\n      end\n      else begin\n        quotient_reg <= quotient_reg | 0<<(counter_reg-1);\n      end\n      counter_reg <= counter_reg - 1;\n    end\n  end\nend\n\nassign quotient = quotient_reg;\nassign remainder = remainder_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "karnaugh_map_5_2b23a91c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule karnaugh_map_5(\n  input wire A, B, C, D, E,\n  output reg F\n);\n\nalways @(*) begin\n  case ({A,B,C,D,E})\n    5'b00000: F = 1'b0;\n    5'b00001: F = 1'b1;\n    5'b00010: F = 1'b0;\n    5'b00011: F = 1'b1;\n    5'b00100: F = 1'b0;\n    5'b00101: F = 1'b1;\n    5'b00110: F = 1'b0;\n    5'b00111: F = 1'b1;\n    5'b01000: F = 1'b0;\n    5'b01001: F = 1'b1;\n    5'b01010: F = 1'b0;\n    5'b01011: F = 1'b1;\n    5'b01100: F = 1'b0;\n    5'b01101: F = 1'b1;\n    5'b01110: F = 1'b0;\n    5'b01111: F = 1'b1;\n    default: F = 1'b0;\n  endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4_20544d3a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux4 (\n    input A, B, C, D,\n    input S0, S1,\n    output X\n);\n\n    wire not_S0, not_S1, and0, and1, and2, and3, or0, or1;\n\n    not (not_S0, S0);\n    not (not_S1, S1);\n\n    and (and0, A, not_S0, not_S1);\n    and (and1, B, not_S0, S1);\n    and (and2, C, S0, not_S1);\n    and (and3, D, S0, S1);\n\n    or (or0, and0, and1);\n    or (or1, and2, and3);\n\n    or (X, or0, or1);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplier_block_acad15d2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0]\n    o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w32768,\n    w32769,\n    w8192,\n    w24577,\n    w16,\n    w24593,\n    w128,\n    w24465;\n\n  assign w1 = i_data0;\n  assign w128 = w1 << 7;\n  assign w16 = w1 << 4;\n  assign w32768 = w1 << 15;\n  assign w32769 = w1 + w32768;\n  assign w8192 = w1 << 13;\n  assign w24577 = w32769 - w8192;\n  assign w24593 = w24577 + w16;\n  assign w24465 = w24593 - w128;\n\n  assign o_data0 = w24465;\n\n  //multiplier_block area estimate = 6350.09758873383;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_op_635c92df", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_op(input [7:0] A, input [7:0] B, input [1:0] C, output reg [7:0] out);\n    always @(*) begin\n        case(C)\n            2'b00: out = A & B;\n            2'b01: out = A | B;\n            2'b10: out = A ^ B;\n            2'b11: out = ~(A ^ B);\n        endcase\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__31ed6d49", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    // Instantiate the barrel shifter module\n    barrel_shifter bs(\n        .data(in),\n        .shift(1),\n        .out(wire_bs_out)\n    );\n    \n    // Instantiate the two's complement module\n    twos_complement tc(\n        .in(wire_bs_out),\n        .out(out)\n    );\n\n    // Declare wire for output of barrel shifter module\n    wire [3:0] wire_bs_out;\n\nendmodule\n\n// Barrel shifter module\nmodule barrel_shifter (\n    input [3:0] data,\n    input [1:0] shift,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case(shift)\n            2'b00: out = data; // No shift\n            2'b01: out = {data[2:0], data[3]}; // Rotate left by 1 bit\n            2'b10: out = {data[1:0], data[3:2]}; // Rotate left by 2 bits\n            2'b11: out = {data[0], data[3:1]}; // Rotate left by 3 bits\n        endcase\n    end\n\nendmodule\n\n// Two's complement module\nmodule twos_complement (\n    input [3:0] in,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        out = ~in + 1;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lfsr_count255_a8647800", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule lfsr_count255(\n                     input i_sys_clk,\n                     input i_sys_rst,\n                     output reg o_lfsr_256_done);\n\n    reg [7:0]                   lfsr_reg_i;\n    wire                        lfsr_d0_i,lfsr_256_equal_i;\n\n    // Feedback polynomial: x^7 + x^5 + x^4 + x^3 + 1\n    xnor(lfsr_d0_i,lfsr_reg_i[7],lfsr_reg_i[5],lfsr_reg_i[4],lfsr_reg_i[3]);\n    assign lfsr_256_equal_i = (lfsr_reg_i == 8'hFF);\n\n    always @(posedge i_sys_clk,posedge i_sys_rst) begin\n        if(i_sys_rst) begin\n            lfsr_reg_i <= 0;\n            o_lfsr_256_done <= 0;\n        end\n        else begin\n            lfsr_reg_i <= lfsr_256_equal_i ? 8'h0 : {lfsr_reg_i[6:0],lfsr_d0_i};\n            o_lfsr_256_done <= lfsr_256_equal_i;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "erx_remap_062afcf0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule erx_remap (\n   emesh_access_out, emesh_packet_out,\n   clk, emesh_access_in, emesh_packet_in, remap_mode, remap_sel,\n   remap_pattern, remap_base\n   );\n\n   parameter AW = 32;\n   parameter DW = 32;\n   parameter PW = 104;\n   parameter ID = 12'h808;\n   \n   input          clk;\n   \n   input          emesh_access_in;\n   input [PW-1:0] emesh_packet_in;\n   \n   input [1:0] \t  remap_mode;    input [11:0]   remap_sel;     input [11:0]   remap_pattern; input [31:0]   remap_base;    output \t   emesh_access_out;\n   output [PW-1:0] emesh_packet_out;\n\n   wire [31:0] \t   static_remap;\n   wire [31:0] \t   dynamic_remap;\n   wire [31:0] \t   remap_mux;\n   wire [31:0] \t   addr_in;\n   wire [31:0] \t   addr_out;\n   wire \t   remap_en;\n   \n   reg \t\t   emesh_access_out;\n   reg [PW-1:0]    emesh_packet_out;\n\n   parameter[5:0]  colid = ID[5:0];\n   \n   assign addr_in[31:0]  =  emesh_packet_in[39:8];\n \n   \n   assign static_remap[31:20] = (remap_sel[11:0] & remap_pattern[11:0]) |\n\t\t\t        (~remap_sel[11:0] & addr_in[31:20]);\n\n   assign static_remap[19:0]  = addr_in[19:0];\n    \n   assign dynamic_remap[31:0] = addr_in[31:0]    - (colid << 20)     + remap_base[31:0]  - (addr_in[31:26]<<$clog2(colid));\n     \t\t\t     \n   assign remap_mux[31:0]  = (addr_in[31:20]==ID)     ? addr_in[31:0] : (remap_mode[1:0]==2'b00) ? addr_in[31:0] :\n\t\t\t     (remap_mode[1:0]==2'b01) ? static_remap[31:0] :\n\t  \t\t                                dynamic_remap[31:0];\n\n   always @ (posedge clk)\n       emesh_access_out <= emesh_access_in;\n\n   always @ (posedge clk)    \n       emesh_packet_out[PW-1:0] <= {emesh_packet_in[103:40],\n                                    remap_mux[31:0],\n                                    emesh_packet_in[7:0]\n\t\t\t\t    };\n   \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "daala_idct4_stream_v1_0_S00_AXIS #_fa4449e0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\tmodule daala_idct4_stream_v1_0_S00_AXIS #\n\t(\n\t\tparameter integer C_S_AXIS_TDATA_WIDTH\t= 32\n\t)\n\t(\n\t\tinput wire  S_AXIS_ACLK,\n\t\tinput wire  S_AXIS_ARESETN,\n\t\toutput wire  S_AXIS_TREADY,\n\t\tinput wire [C_S_AXIS_TDATA_WIDTH-1 : 0] S_AXIS_TDATA,\n\t\tinput wire [(C_S_AXIS_TDATA_WIDTH/8)-1 : 0] S_AXIS_TSTRB,\n\t\tinput wire  S_AXIS_TLAST,\n\t\tinput wire  S_AXIS_TVALID\n\t);\n\tfunction integer clogb2 (input integer bit_depth);\n\t  begin\n\t    for(clogb2=0; bit_depth>0; clogb2=clogb2+1)\n\t      bit_depth = bit_depth >> 1;\n\t  end\n\tendfunction\n\n\tlocalparam NUMBER_OF_INPUT_WORDS  = 8;\n\tlocalparam bit_num  = clogb2(NUMBER_OF_INPUT_WORDS-1);\n\tparameter [1:0] IDLE = 1'b0,        WRITE_FIFO  = 1'b1; wire  \taxis_tready;\n\treg mst_exec_state;  \n\tgenvar byte_index;     \n\twire fifo_wren;\n\treg fifo_full_flag;\n\treg [bit_num-1:0] write_pointer;\n\treg writes_done;\n\tassign S_AXIS_TREADY\t= axis_tready;\n\talways @(posedge S_AXIS_ACLK) \n\tbegin  \n\t  if (!S_AXIS_ARESETN) \n\t  begin\n\t      mst_exec_state <= IDLE;\n\t    end  \n\t  else\n\t    case (mst_exec_state)\n\t      IDLE: \n\t        if (S_AXIS_TVALID)\n\t            begin\n\t              mst_exec_state <= WRITE_FIFO;\n\t            end\n\t          else\n\t            begin\n\t              mst_exec_state <= IDLE;\n\t            end\n\t      WRITE_FIFO: \n\t        if (writes_done)\n\t          begin\n\t            mst_exec_state <= IDLE;\n\t          end\n\t        else\n\t          begin\n\t            mst_exec_state <= WRITE_FIFO;\n\t          end\n\n\t    endcase\n\tend\n\tassign axis_tready = ((mst_exec_state == WRITE_FIFO) && (write_pointer <= NUMBER_OF_INPUT_WORDS-1));\n\n\talways@(posedge S_AXIS_ACLK)\n\tbegin\n\t  if(!S_AXIS_ARESETN)\n\t    begin\n\t      write_pointer <= 0;\n\t      writes_done <= 1'b0;\n\t    end  \n\t  else\n\t    if (write_pointer <= NUMBER_OF_INPUT_WORDS-1)\n\t      begin\n\t        if (fifo_wren)\n\t          begin\n\t            write_pointer <= write_pointer + 1;\n\t            writes_done <= 1'b0;\n\t          end\n\t          if ((write_pointer == NUMBER_OF_INPUT_WORDS-1)|| S_AXIS_TLAST)\n\t            begin\n\t              writes_done <= 1'b1;\n\t            end\n\t      end  \n\tend\n\n\tassign fifo_wren = S_AXIS_TVALID && axis_tready;\n\n\tgenerate \n\t  for(byte_index=0; byte_index<= (C_S_AXIS_TDATA_WIDTH/8-1); byte_index=byte_index+1)\n\t  begin:FIFO_GEN\n\n\t    reg  [(C_S_AXIS_TDATA_WIDTH/4)-1:0] stream_data_fifo [0 : NUMBER_OF_INPUT_WORDS-1];\n\n\t    always @( posedge S_AXIS_ACLK )\n\t    begin\n\t      if (fifo_wren)begin\n\t          stream_data_fifo[write_pointer] <= S_AXIS_TDATA[(byte_index*8+7) -: 8];\n\t        end  \n\t    end  \n\t  end\t\t\n\tendgenerate\n\n\tendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_adder_e1c2d7d0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ripple_adder(\n    input [3:0] a,\n    input [3:0] b,\n    input clk,  // Added clock input\n    output reg [4:0] sum\n);\n\nreg [3:0] a_reg, b_reg;\nreg [3:0] carry_reg;\n\nalways @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\nend\n\nalways @(posedge clk) begin\n    // Initialize the carry input for the first stage\n    carry_reg[0] <= 0;\n\n    sum[0] <= a_reg[0] ^ b_reg[0] ^ carry_reg[0];\n    carry_reg[0] <= (a_reg[0] & b_reg[0]) | (a_reg[0] & carry_reg[0]) | (b_reg[0] & carry_reg[0]);\n    sum[1] <= a_reg[1] ^ b_reg[1] ^ carry_reg[1];\n    carry_reg[1] <= (a_reg[1] & b_reg[1]) | (a_reg[1] & carry_reg[1]) | (b_reg[1] & carry_reg[1]);\n    sum[2] <= a_reg[2] ^ b_reg[2] ^ carry_reg[2];\n    carry_reg[2] <= (a_reg[2] & b_reg[2]) | (a_reg[2] & carry_reg[2]) | (b_reg[2] & carry_reg[2]);\n    sum[3] <= a_reg[3] ^ b_reg[3] ^ carry_reg[3];\n    carry_reg[3] <= (a_reg[3] & b_reg[3]) | (a_reg[3] & carry_reg[3]) | (b_reg[3] & carry_reg[3]);\n    sum[4] <= carry_reg[3];\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_data_info_cd4f3897", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fifo_data_info (\n  // inputs:\n  address,\n  clk,\n  in_port,\n  reset_n,\n\n  // outputs:\n  readdata\n);\n\n  output [31:0] readdata;\n  input [1:0] address;\n  input clk;\n  input [13:0] in_port;\n  input reset_n;\n\n  reg [13:0] fifo [0:13];\n  reg [3:0] write_ptr;\n  reg [3:0] read_ptr;\n  reg [3:0] count;\n\n  // Write enable signal\n  wire we;\n  assign we = (count < 14);\n\n  // Read enable signal\n  wire re;\n  assign re = (count > 0);\n\n  // Write pointer incrementer\n  always @(posedge clk)\n    if (we && reset_n)\n      write_ptr <= write_ptr + 1;\n\n  // Read pointer incrementer\n  always @(posedge clk)\n    if (re && reset_n)\n      read_ptr <= read_ptr + 1;\n\n  // Count incrementer/decrementer\n  always @(posedge clk)\n    if (we && reset_n)\n      count <= count + 1;\n    else if (re && reset_n)\n      count <= count - 1;\n\n  // Write data to FIFO\n  always @(posedge clk)\n    if (we && reset_n)\n      fifo[write_ptr] <= in_port;\n\n  // Read data from FIFO\n  assign readdata = (re && reset_n) ? fifo[read_ptr] : 0;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mkSoC_Map_28e40fa5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`ifdef BSV_ASSIGNMENT_DELAY\n`else\n  `define BSV_ASSIGNMENT_DELAY\n`endif\n\n`ifdef BSV_POSITIVE_RESET\n  `define BSV_RESET_VALUE 1'b1\n  `define BSV_RESET_EDGE posedge\n`else\n  `define BSV_RESET_VALUE 1'b0\n  `define BSV_RESET_EDGE negedge\n`endif\n\nmodule mkSoC_Map(CLK,\n\t\t RST_N,\n\n\t\t m_plic_addr_base,\n\n\t\t m_plic_addr_size,\n\n\t\t m_plic_addr_lim,\n\n\t\t m_near_mem_io_addr_base,\n\n\t\t m_near_mem_io_addr_size,\n\n\t\t m_near_mem_io_addr_lim,\n\n\t\t m_flash_mem_addr_base,\n\n\t\t m_flash_mem_addr_size,\n\n\t\t m_flash_mem_addr_lim,\n\n\t\t m_ethernet_0_addr_base,\n\n\t\t m_ethernet_0_addr_size,\n\n\t\t m_ethernet_0_addr_lim,\n\n\t\t m_dma_0_addr_base,\n\n\t\t m_dma_0_addr_size,\n\n\t\t m_dma_0_addr_lim,\n\n\t\t m_uart16550_0_addr_base,\n\n\t\t m_uart16550_0_addr_size,\n\n\t\t m_uart16550_0_addr_lim,\n\n\t\t m_gpio_0_addr_base,\n\n\t\t m_gpio_0_addr_size,\n\n\t\t m_gpio_0_addr_lim,\n\n\t\t m_boot_rom_addr_base,\n\n\t\t m_boot_rom_addr_size,\n\n\t\t m_boot_rom_addr_lim,\n\n\t\t m_ddr4_0_uncached_addr_base,\n\n\t\t m_ddr4_0_uncached_addr_size,\n\n\t\t m_ddr4_0_uncached_addr_lim,\n\n\t\t m_ddr4_0_cached_addr_base,\n\n\t\t m_ddr4_0_cached_addr_size,\n\n\t\t m_ddr4_0_cached_addr_lim,\n\n\t\t m_is_mem_addr_addr,\n\t\t m_is_mem_addr,\n\n\t\t m_is_IO_addr_addr,\n\t\t m_is_IO_addr,\n\n\t\t m_is_near_mem_IO_addr_addr,\n\t\t m_is_near_mem_IO_addr,\n\n\t\t m_pc_reset_value,\n\n\t\t m_mtvec_reset_value,\n\n\t\t m_nmivec_reset_value);\n  input  CLK;\n  input  RST_N;\n\n  output [63 : 0] m_plic_addr_base;\n\n  output [63 : 0] m_plic_addr_size;\n\n  output [63 : 0] m_plic_addr_lim;\n\n  output [63 : 0] m_near_mem_io_addr_base;\n\n  output [63 : 0] m_near_mem_io_addr_size;\n\n  output [63 : 0] m_near_mem_io_addr_lim;\n\n  output [63 : 0] m_flash_mem_addr_base;\n\n  output [63 : 0] m_flash_mem_addr_size;\n\n  output [63 : 0] m_flash_mem_addr_lim;\n\n  output [63 : 0] m_ethernet_0_addr_base;\n\n  output [63 : 0] m_ethernet_0_addr_size;\n\n  output [63 : 0] m_ethernet_0_addr_lim;\n\n  output [63 : 0] m_dma_0_addr_base;\n\n  output [63 : 0] m_dma_0_addr_size;\n\n  output [63 : 0] m_dma_0_addr_lim;\n\n  output [63 : 0] m_uart16550_0_addr_base;\n\n  output [63 : 0] m_uart16550_0_addr_size;\n\n  output [63 : 0] m_uart16550_0_addr_lim;\n\n  output [63 : 0] m_gpio_0_addr_base;\n\n  output [63 : 0] m_gpio_0_addr_size;\n\n  output [63 : 0] m_gpio_0_addr_lim;\n\n  output [63 : 0] m_boot_rom_addr_base;\n\n  output [63 : 0] m_boot_rom_addr_size;\n\n  output [63 : 0] m_boot_rom_addr_lim;\n\n  output [63 : 0] m_ddr4_0_uncached_addr_base;\n\n  output [63 : 0] m_ddr4_0_uncached_addr_size;\n\n  output [63 : 0] m_ddr4_0_uncached_addr_lim;\n\n  output [63 : 0] m_ddr4_0_cached_addr_base;\n\n  output [63 : 0] m_ddr4_0_cached_addr_size;\n\n  output [63 : 0] m_ddr4_0_cached_addr_lim;\n\n  input  [63 : 0] m_is_mem_addr_addr;\n  output m_is_mem_addr;\n\n  input  [63 : 0] m_is_IO_addr_addr;\n  output m_is_IO_addr;\n\n  input  [63 : 0] m_is_near_mem_IO_addr_addr;\n  output m_is_near_mem_IO_addr;\n\n  output [63 : 0] m_pc_reset_value;\n\n  output [63 : 0] m_mtvec_reset_value;\n\n  output [63 : 0] m_nmivec_reset_value;\n\n  wire [63 : 0] m_boot_rom_addr_base,\n\t\tm_boot_rom_addr_lim,\n\t\tm_boot_rom_addr_size,\n\t\tm_ddr4_0_cached_addr_base,\n\t\tm_ddr4_0_cached_addr_lim,\n\t\tm_ddr4_0_cached_addr_size,\n\t\tm_ddr4_0_uncached_addr_base,\n\t\tm_ddr4_0_uncached_addr_lim,\n\t\tm_ddr4_0_uncached_addr_size,\n\t\tm_dma_0_addr_base,\n\t\tm_dma_0_addr_lim,\n\t\tm_dma_0_addr_size,\n\t\tm_ethernet_0_addr_base,\n\t\tm_ethernet_0_addr_lim,\n\t\tm_ethernet_0_addr_size,\n\t\tm_flash_mem_addr_base,\n\t\tm_flash_mem_addr_lim,\n\t\tm_flash_mem_addr_size,\n\t\tm_gpio_0_addr_base,\n\t\tm_gpio_0_addr_lim,\n\t\tm_gpio_0_addr_size,\n\t\tm_mtvec_reset_value,\n\t\tm_near_mem_io_addr_base,\n\t\tm_near_mem_io_addr_lim,\n\t\tm_near_mem_io_addr_size,\n\t\tm_nmivec_reset_value,\n\t\tm_pc_reset_value,\n\t\tm_plic_addr_base,\n\t\tm_plic_addr_lim,\n\t\tm_plic_addr_size,\n\t\tm_uart16550_0_addr_base,\n\t\tm_uart16550_0_addr_lim,\n\t\tm_uart16550_0_addr_size;\n  wire m_is_IO_addr, m_is_mem_addr, m_is_near_mem_IO_addr;\n\n  wire NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d37,\n       NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d82,\n       m_is_IO_addr_addr_ULT_0x30000000___d80,\n       m_is_IO_addr_addr_ULT_0x70000000___d35,\n       m_is_IO_addr_addr_ULT_1073741824___d13;\n\n  assign m_plic_addr_base = 64'h000000000C000000 ;\n\n  assign m_plic_addr_size = 64'h0000000000400000 ;\n\n  assign m_plic_addr_lim = 64'd205520896 ;\n\n  assign m_near_mem_io_addr_base = 64'h0000000010000000 ;\n\n  assign m_near_mem_io_addr_size = 64'h0000000000010000 ;\n\n  assign m_near_mem_io_addr_lim = 64'd268500992 ;\n\n  assign m_flash_mem_addr_base = 64'h0000000040000000 ;\n\n  assign m_flash_mem_addr_size = 64'h0000000008000000 ;\n\n  assign m_flash_mem_addr_lim = 64'd1207959552 ;\n\n  assign m_ethernet_0_addr_base = 64'h0000000062100000 ;\n\n  assign m_ethernet_0_addr_size = 64'h0000000000040000 ;\n\n  assign m_ethernet_0_addr_lim = 64'd1645477888 ;\n\n  assign m_dma_0_addr_base = 64'h0000000062200000 ;\n\n  assign m_dma_0_addr_size = 64'h0000000000010000 ;\n\n  assign m_dma_0_addr_lim = 64'd1646329856 ;\n\n  assign m_uart16550_0_addr_base = 64'h0000000062300000 ;\n\n  assign m_uart16550_0_addr_size = 64'h0000000000001000 ;\n\n  assign m_uart16550_0_addr_lim = 64'd1647316992 ;\n\n  assign m_gpio_0_addr_base = 64'h000000006FFF0000 ;\n\n  assign m_gpio_0_addr_size = 64'h0000000000010000 ;\n\n  assign m_gpio_0_addr_lim = 64'd1879048192 ;\n\n  assign m_boot_rom_addr_base = 64'h0000000070000000 ;\n\n  assign m_boot_rom_addr_size = 64'h0000000000001000 ;\n\n  assign m_boot_rom_addr_lim = 64'd1879052288 ;\n\n  assign m_ddr4_0_uncached_addr_base = 64'h0000000080000000 ;\n\n  assign m_ddr4_0_uncached_addr_size = 64'h0000000040000000 ;\n\n  assign m_ddr4_0_uncached_addr_lim = 64'h00000000C0000000 ;\n\n  assign m_ddr4_0_cached_addr_base = 64'h00000000C0000000 ;\n\n  assign m_ddr4_0_cached_addr_size = 64'h0000000040000000 ;\n\n  assign m_ddr4_0_cached_addr_lim = 64'h0000000100000000 ;\n\n  assign m_is_mem_addr =\n\t     m_is_mem_addr_addr >= 64'h00000000C0000000 &&\n\t     m_is_mem_addr_addr < 64'h0000000100000000 ;\n\n  assign m_is_IO_addr =\n\t     NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d82 ||\n\t     !m_is_IO_addr_addr_ULT_0x30000000___d80 &&\n\t     m_is_IO_addr_addr_ULT_1073741824___d13 ;\n\n  assign m_is_near_mem_IO_addr =\n\t     m_is_near_mem_IO_addr_addr >= 64'h0000000010000000 &&\n\t     m_is_near_mem_IO_addr_addr < 64'd268500992 ;\n\n  assign m_pc_reset_value = 64'h0000000070000000 ;\n\n  assign m_mtvec_reset_value = 64'h0000000000001000 ;\n\n  assign m_nmivec_reset_value = 64'hAAAAAAAAAAAAAAAA ;\n\n  assign NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d37 =\n\t     m_is_IO_addr_addr >= 64'h000000000C000000 &&\n\t     m_is_IO_addr_addr < 64'd205520896 ||\n\t     m_is_IO_addr_addr >= 64'h0000000010000000 &&\n\t     m_is_IO_addr_addr < 64'd268500992 ||\n\t     !m_is_IO_addr_addr_ULT_1073741824___d13 &&\n\t     m_is_IO_addr_addr < 64'd1207959552 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062100000 &&\n\t     m_is_IO_addr_addr < 64'd1645477888 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062200000 &&\n\t     m_is_IO_addr_addr < 64'd1646329856 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062300000 &&\n\t     m_is_IO_addr_addr < 64'd1647316992 ||\n\t     m_is_IO_addr_addr >= 64'h000000006FFF0000 &&\n\t     m_is_IO_addr_addr_ULT_0x70000000___d35 ;\n  assign NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d82 =\n\t     NOT_m_is_IO_addr_addr_ULT_0xC000000_AND_m_is_I_ETC___d37 ||\n\t     !m_is_IO_addr_addr_ULT_0x70000000___d35 &&\n\t     m_is_IO_addr_addr < 64'd1879052288 ||\n\t     m_is_IO_addr_addr >= 64'h0000000080000000 &&\n\t     m_is_IO_addr_addr < 64'h00000000C0000000 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062400000 &&\n\t     m_is_IO_addr_addr < 64'd1648365568 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062310000 &&\n\t     m_is_IO_addr_addr < 64'd1647382528 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062320000 &&\n\t     m_is_IO_addr_addr < 64'd1647448064 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062360000 &&\n\t     m_is_IO_addr_addr < 64'd1647710208 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062330000 &&\n\t     m_is_IO_addr_addr < 64'd1647513600 ||\n\t     m_is_IO_addr_addr >= 64'h0000000062370000 &&\n\t     m_is_IO_addr_addr < 64'd1647775744 ||\n\t     m_is_IO_addr_addr >= 64'h0000000020000000 &&\n\t     m_is_IO_addr_addr_ULT_0x30000000___d80 ;\n  assign m_is_IO_addr_addr_ULT_0x30000000___d80 =\n\t     m_is_IO_addr_addr < 64'h0000000030000000 ;\n  assign m_is_IO_addr_addr_ULT_0x70000000___d35 =\n\t     m_is_IO_addr_addr < 64'h0000000070000000 ;\n  assign m_is_IO_addr_addr_ULT_1073741824___d13 =\n\t     m_is_IO_addr_addr < 64'd1073741824 ;\nendmodule  "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_op_ba80c9ff", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_op (\n    input [15:0] in1,\n    input [15:0] in2,\n    input [15:0] in3,\n    input [15:0] in4,\n    input reset,\n    output reg [15:0] out1,\n    output reg [15:0] out2\n);\n\n    always @(*) begin\n        if (reset) begin\n            out1 <= 16'b0;\n            out2 <= 16'b0;\n        end else begin\n            out1 <= in1 & in2;\n            out2 <= in3 ^ in4;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "myModule_83298c19", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule myModule (\n    input CLK,\n    input ready_downstream,\n    output reg ready,\n    input reset,\n    input [64:0] process_input,\n    output reg [64:0] process_output\n);\n\nreg too_soon = process_input[64];\nreg [31:0] output_count = 0;\n\nalways @(posedge CLK) begin\n    if (reset) begin\n        ready <= 1'b0;\n        output_count <= 0;\n        process_output <= 0;\n    end else if (too_soon) begin\n        ready <= 1'b0;\n    end else if (ready_downstream && output_count < 76800) begin\n        ready <= 1'b1;\n        output_count <= output_count + 1;\n        process_output <= ~reset;\n    end else begin\n        ready <= 1'b1;\n        output_count <= output_count + 1;\n        process_output <= {1'b1, process_input[63:0]};\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "qmem_sram #_d53f81bf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\n\n\n\n\n\nmodule qmem_sram #(\n  parameter AW = 32,\n  parameter DW = 32,\n  parameter SW = DW/8\n)(\n  input  wire           clk50,\n  input  wire           clk100,\n  input  wire           rst,\n  input  wire [AW-1:0]  adr,\n  input  wire           cs,\n  input  wire           we,\n  input  wire [SW-1:0]  sel,\n  input  wire [DW-1:0]  dat_w,\n  output reg  [DW-1:0]  dat_r,\n  output wire           ack,\n  output wire           err,\n  output wire [18-1:0]  sram_adr,\n  output wire           sram_ce_n,\n  output wire           sram_we_n,\n  output wire           sram_ub_n,\n  output wire           sram_lb_n,\n  output wire           sram_oe_n,\n  output wire [16-1:0]  sram_dat_w,\n  input  wire [16-1:0]  sram_dat_r\n);\n\n\n\n`ifndef QMEM_SRAM_ASYNC\n`ifdef QMEM_SRAM_SLOW\n\nlocalparam S_ID  = 3'b000; localparam S_HI1 = 3'b011; localparam S_HI2 = 3'b111;\nlocalparam S_LO1 = 3'b010; localparam S_LO2 = 3'b110;\nlocalparam S_FH  = 3'b001; reg [2:0] state, next_state;\n\nalways @ (*)\nbegin\n  case (state)\n    S_ID    : begin if (cs) next_state = S_HI1; else next_state = S_ID; end\n    S_HI1   : begin if (cs) next_state = S_HI2; else next_state = S_ID; end\n    S_HI2   : begin if (cs) next_state = S_LO1; else next_state = S_ID; end\n    S_LO1   : begin if (cs) next_state = S_LO2; else next_state = S_ID; end\n    S_LO2   : begin if (cs) next_state = S_FH;  else next_state = S_ID; end\n    S_FH    : begin                                  next_state = S_ID; end\n    default : begin                                  next_state = S_ID; end\n  endcase\nend\n\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    state <= #1 S_ID;\n  else\n    state <= #1 next_state;\nend\n\n\n\n\nreg [17:0] s_adr;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI1)\n    s_adr <= #1 {adr[18:2], 1'b0};\n  else if (next_state == S_LO1)\n    s_adr <= #1 {adr[18:2], 1'b1};\nend\n\nreg s_ce_n;\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    s_ce_n <= #1 1'b1;\n  else if ((next_state == S_HI1) || (next_state == S_HI2) || (next_state == S_LO1) || (next_state == S_LO2))\n    s_ce_n <= #1 1'b0;\n  else\n    s_ce_n <= #1 1'b1;\nend\n\nreg s_we_n;\nalways @ (posedge clk100)\nbegin\n  if ((next_state == S_HI1) || (next_state == S_HI2) || (next_state == S_LO1) || (next_state == S_LO2))\n    s_we_n <= #1 !we;\nend\n\nreg s_ub_n, s_lb_n;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI1)\n    {s_ub_n, s_lb_n} <= #1 {!sel[3], !sel[2]};\n  else if (next_state == S_LO1)\n    {s_ub_n, s_lb_n} <= #1 {!sel[1], !sel[0]};\nend\n\nreg s_oe_n;\nalways @ (posedge clk100)\nbegin\n  if ((next_state == S_HI1) || (next_state == S_HI2) || (next_state == S_LO1) || (next_state == S_LO2))\n    s_oe_n <= #1 we;\n  else\n    s_oe_n <= #1 1'b0;\nend\n\nreg [15:0] s_dat_w;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI1)\n    s_dat_w <= #1 dat_w[31:16];\n  else if (next_state == S_LO1)\n    s_dat_w <= #1 dat_w[15:0];\nend\n\n\n\n\nreg [31:0] s_dat_r;\nalways @ (posedge clk100)\nbegin\n  if ((next_state == S_LO1) && !we)\n    dat_r[31:16] <= #1 sram_dat_r;\n  else if ((next_state == S_FH) && !we)\n    dat_r[15: 0] <= #1 sram_dat_r;\nend\n\nreg s_ack;\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    s_ack <= #1 1'b0;\n  else if ((state == S_LO2) || (state == S_FH))\n    s_ack <= #1 1'b1;\n  else\n    s_ack <= #1 1'b0;\nend\n\n\n\nassign sram_adr   = s_adr;\nassign sram_ce_n  = s_ce_n;\nassign sram_we_n  = s_we_n;\nassign sram_ub_n  = s_ub_n;\nassign sram_lb_n  = s_lb_n;\nassign sram_oe_n  = s_oe_n;\nassign sram_dat_w = s_dat_w;\nassign ack        = s_ack;\nassign err        = 1'b0;\n\n\n`else \nlocalparam S_ID = 2'b00; localparam S_HI = 2'b11; localparam S_LO = 2'b10; localparam S_FH = 2'b01; reg [1:0] state, next_state;\n\nalways @ (*)\nbegin\n  case (state)\n    S_ID    : begin if (cs) next_state = S_HI; else next_state = S_ID; end\n    S_HI    : begin if (cs) next_state = S_LO; else next_state = S_ID; end\n    S_LO    : begin if (cs) next_state = S_FH; else next_state = S_ID; end\n    S_FH    : begin                                 next_state = S_ID; end\n    default : begin                                 next_state = S_ID; end\n  endcase\nend\n\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    state <= #1 S_ID;\n  else\n    state <= #1 next_state;\nend\n\n\n\n\nreg [17:0] s_adr;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI)\n    s_adr <= #1 {adr[18:2], 1'b0};\n  else if (next_state == S_LO)\n    s_adr <= #1 {adr[18:2], 1'b1};\nend\n\nreg s_ce_n;\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    s_ce_n <= #1 1'b1;\n  else if ((next_state == S_HI) || (next_state == S_LO))\n    s_ce_n <= #1 1'b0;\n  else\n    s_ce_n <= #1 1'b1;\nend\n\nreg s_we_n;\nalways @ (posedge clk100)\nbegin\n  if ((next_state == S_HI) || (next_state == S_LO))\n    s_we_n <= #1 !we;\nend\n\nreg s_ub_n, s_lb_n;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI)\n    {s_ub_n, s_lb_n} <= #1 {!sel[3], !sel[2]};\n  else if (next_state == S_LO)\n    {s_ub_n, s_lb_n} <= #1 {!sel[1], !sel[0]};\nend\n\nreg s_oe_n;\nalways @ (posedge clk100)\nbegin\n  if ((next_state == S_HI) || (next_state == S_LO))\n    s_oe_n <= #1 we;\n  else\n    s_oe_n <= #1 1'b0;\nend\n\nreg [15:0] s_dat_w;\nalways @ (posedge clk100)\nbegin\n  if (next_state == S_HI)\n    s_dat_w <= #1 dat_w[31:16];\n  else if (next_state == S_LO)\n    s_dat_w <= #1 dat_w[15:0];\nend\n\n\n\n\nreg [31:0] s_dat_r;\nalways @ (posedge clk100)\nbegin\n  if ((state == S_LO) && !we)\n    dat_r[31:16] <= #1 sram_dat_r;\n  else if ((state == S_FH) && !we)\n    dat_r[15: 0] <= #1 sram_dat_r;\nend\n\nreg s_ack;\nalways @ (posedge clk100 or posedge rst)\nbegin\n  if (rst)\n    s_ack <= #1 1'b0;\n  else if (state == S_LO)\n    s_ack <= #1 1'b1;\n  else\n    s_ack <= #1 1'b0;\nend\n\n\n\nassign sram_adr   = s_adr;\nassign sram_ce_n  = s_ce_n;\nassign sram_we_n  = s_we_n;\nassign sram_ub_n  = s_ub_n;\nassign sram_lb_n  = s_lb_n;\nassign sram_oe_n  = s_oe_n;\nassign sram_dat_w = s_dat_w;\nassign ack        = s_ack;\nassign err        = 1'b0;\n\n\n`endif `else \nreg  [ AW-1:0] adr_r;\nwire           adr_changed;\nreg            cnt;\nreg  [ 16-1:0] rdat_r;\n\n\n\nalways @ (posedge clk50) adr_r <= #1 adr;\nassign adr_changed = (adr != adr_r);\n\n\n\nalways @ (posedge clk50 or posedge rst)\nbegin\n  if (rst)\n    cnt <= #1 1'b0;\n  else if (adr_changed)\n    cnt <= #1 1'b0;\n  else if (cs)\n    cnt <= #1 !cnt;\nend\n\n\n\nalways @ (posedge clk50) if (cs && !cnt && !we) rdat_r <= #1 sram_dat_r;\n\n\n\nalways @ (posedge clk50) if (cs && cnt && !we) dat_r <= #1 {sram_dat_r, rdat_r};\nassign ack = cnt;\nassign err = 1'b0;\n\n\n\nassign sram_adr   = (!cnt) ? {adr[18:2], 1'b0} : {adr[18:2], 1'b1};\nassign sram_ce_n  = !cs;\nassign sram_we_n  = !we;\nassign sram_ub_n  = !((!cnt) ? sel[1] : sel[3]);\nassign sram_lb_n  = !((!cnt) ? sel[0] : sel[2]);\nassign sram_oe_n  = we;\nassign sram_dat_w = (!cnt) ?  dat_w[15:0] : dat_w[31:16];\n\n\n`endif endmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "even_parity_checker_79668709", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule even_parity_checker(\n    input D0, D1, D2, D3, RST, ECLK, DQSW,\n    output reg Q\n);\n\n    reg [3:0] data_reg;\n\n    always @(posedge ECLK) begin\n        if (RST) begin\n            Q <= 1'b0;\n            data_reg <= 4'b0;\n        end\n        else if (!DQSW) begin\n            data_reg <= {data_reg[2:0], D3};\n        end\n        else begin\n            Q <= ~^data_reg;\n            data_reg <= {D3, D2, D1, D0};\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_2to4_adder_85148b9a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_2to4_adder (\n    input clk, \n    input [1:0] in,\n    input ena,\n    input cin,\n    output reg [3:0] out,\n    output reg cout\n);\n\n// Pipeline registers\nreg [1:0] in_reg;\nreg ena_reg;\nreg cin_reg;\n\n// 2-to-4 decoder\nwire [3:0] dec_out;\n// Corrected decoder logic\nassign dec_out = ena ? (1 << in) : 4'b0000;\n\n// Adder logic corrected\nwire [3:0] add_out;\nwire [3:0] add_in = {2'b00, in_reg}; // Ensure matching bit widths for addition\nwire cout_temp; // Temporary carry-out\n\nassign {cout_temp, add_out[1:0]} = add_in[1:0] + {2'b00, cin_reg};\nassign add_out[3:2] = 2'b00; // Upper bits of add_out are not affected by addition\n\n\nalways @(posedge clk) begin\n    in_reg <= in;\n    ena_reg <= ena;\n    cin_reg <= cin;\n    \n    if (ena_reg) begin\n        out <= dec_out | add_out;\n        cout <= cout_temp; \n    end else begin\n        out <= 4'b0000;\n        cout <= 0;\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_async_reset_26d88d43", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule d_ff_async_reset (\n    input D,\n    input RESET_B,\n    input CLK,\n    output Q,\n    output Q_N\n);\n\n    reg q;\n    assign Q = q;\n    assign Q_N = ~q;\n\n    always @(posedge CLK or negedge RESET_B) begin\n        if (~RESET_B) begin\n            q <= 0;\n        end else begin\n            q <= D;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "NV_NVDLA_RT_csb2cacc_25f5b5aa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n// File Name: NV_NVDLA_RT_csb2cacc.v\n\nmodule NV_NVDLA_RT_csb2cacc (\n   nvdla_core_clk\n  ,nvdla_core_rstn\n  ,csb2cacc_req_src_pvld\n  ,csb2cacc_req_src_prdy\n  ,csb2cacc_req_src_pd\n  ,cacc2csb_resp_src_valid\n  ,cacc2csb_resp_src_pd\n  ,csb2cacc_req_dst_pvld\n  ,csb2cacc_req_dst_prdy\n  ,csb2cacc_req_dst_pd\n  ,cacc2csb_resp_dst_valid\n  ,cacc2csb_resp_dst_pd\n  );\n\ninput  nvdla_core_clk;\ninput  nvdla_core_rstn;\n\ninput         csb2cacc_req_src_pvld;  \noutput        csb2cacc_req_src_prdy;  \ninput  [62:0] csb2cacc_req_src_pd;\n\ninput        cacc2csb_resp_src_valid;  \ninput [33:0] cacc2csb_resp_src_pd;     \n\noutput        csb2cacc_req_dst_pvld;  \ninput         csb2cacc_req_dst_prdy;  \noutput [62:0] csb2cacc_req_dst_pd;\n\noutput        cacc2csb_resp_dst_valid;  \noutput [33:0] cacc2csb_resp_dst_pd;     \n\nwire [33:0] cacc2csb_resp_pd_d0;\nwire        cacc2csb_resp_valid_d0;\nwire [62:0] csb2cacc_req_pd_d0;\nwire        csb2cacc_req_pvld_d0;\nreg  [33:0] cacc2csb_resp_pd_d1;\nreg  [33:0] cacc2csb_resp_pd_d2;\nreg  [33:0] cacc2csb_resp_pd_d3;\nreg         cacc2csb_resp_valid_d1;\nreg         cacc2csb_resp_valid_d2;\nreg         cacc2csb_resp_valid_d3;\nreg  [62:0] csb2cacc_req_pd_d1;\nreg  [62:0] csb2cacc_req_pd_d2;\nreg  [62:0] csb2cacc_req_pd_d3;\nreg         csb2cacc_req_pvld_d1;\nreg         csb2cacc_req_pvld_d2;\nreg         csb2cacc_req_pvld_d3;\n\n\nassign csb2cacc_req_src_prdy = 1'b1;\n\n\n\n\nassign csb2cacc_req_pvld_d0 = csb2cacc_req_src_pvld;\nassign csb2cacc_req_pd_d0 = csb2cacc_req_src_pd;\n\n\nassign cacc2csb_resp_valid_d0 = cacc2csb_resp_src_valid;\nassign cacc2csb_resp_pd_d0 = cacc2csb_resp_src_pd;\n\n\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    csb2cacc_req_pvld_d1 <= 1'b0;\n  end else begin\n  csb2cacc_req_pvld_d1 <= csb2cacc_req_pvld_d0;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((csb2cacc_req_pvld_d0) == 1'b1) begin\n    csb2cacc_req_pd_d1 <= csb2cacc_req_pd_d0;\n  // VCS coverage off\n  end else if ((csb2cacc_req_pvld_d0) == 1'b0) begin\n  end else begin\n    csb2cacc_req_pd_d1 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    cacc2csb_resp_valid_d1 <= 1'b0;\n  end else begin\n  cacc2csb_resp_valid_d1 <= cacc2csb_resp_valid_d0;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((cacc2csb_resp_valid_d0) == 1'b1) begin\n    cacc2csb_resp_pd_d1 <= cacc2csb_resp_pd_d0;\n  // VCS coverage off\n  end else if ((cacc2csb_resp_valid_d0) == 1'b0) begin\n  end else begin\n    cacc2csb_resp_pd_d1 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    csb2cacc_req_pvld_d2 <= 1'b0;\n  end else begin\n  csb2cacc_req_pvld_d2 <= csb2cacc_req_pvld_d1;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((csb2cacc_req_pvld_d1) == 1'b1) begin\n    csb2cacc_req_pd_d2 <= csb2cacc_req_pd_d1;\n  // VCS coverage off\n  end else if ((csb2cacc_req_pvld_d1) == 1'b0) begin\n  end else begin\n    csb2cacc_req_pd_d2 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    cacc2csb_resp_valid_d2 <= 1'b0;\n  end else begin\n  cacc2csb_resp_valid_d2 <= cacc2csb_resp_valid_d1;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((cacc2csb_resp_valid_d1) == 1'b1) begin\n    cacc2csb_resp_pd_d2 <= cacc2csb_resp_pd_d1;\n  // VCS coverage off\n  end else if ((cacc2csb_resp_valid_d1) == 1'b0) begin\n  end else begin\n    cacc2csb_resp_pd_d2 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    csb2cacc_req_pvld_d3 <= 1'b0;\n  end else begin\n  csb2cacc_req_pvld_d3 <= csb2cacc_req_pvld_d2;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((csb2cacc_req_pvld_d2) == 1'b1) begin\n    csb2cacc_req_pd_d3 <= csb2cacc_req_pd_d2;\n  // VCS coverage off\n  end else if ((csb2cacc_req_pvld_d2) == 1'b0) begin\n  end else begin\n    csb2cacc_req_pd_d3 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\nalways @(posedge nvdla_core_clk or negedge nvdla_core_rstn) begin\n  if (!nvdla_core_rstn) begin\n    cacc2csb_resp_valid_d3 <= 1'b0;\n  end else begin\n  cacc2csb_resp_valid_d3 <= cacc2csb_resp_valid_d2;\n  end\nend\nalways @(posedge nvdla_core_clk) begin\n  if ((cacc2csb_resp_valid_d2) == 1'b1) begin\n    cacc2csb_resp_pd_d3 <= cacc2csb_resp_pd_d2;\n  // VCS coverage off\n  end else if ((cacc2csb_resp_valid_d2) == 1'b0) begin\n  end else begin\n    cacc2csb_resp_pd_d3 <= 'bx;  // spyglass disable STARC-2.10.1.6 W443 NoWidthInBasedNum-ML -- (Constant containing x or z used, Based number `bx contains an X, Width specification missing for based number)\n  // VCS coverage on\n  end\nend\n\n\n\n\nassign csb2cacc_req_dst_pvld = csb2cacc_req_pvld_d3;\nassign csb2cacc_req_dst_pd = csb2cacc_req_pd_d3;\n\n\nassign cacc2csb_resp_dst_valid = cacc2csb_resp_valid_d3;\nassign cacc2csb_resp_dst_pd = cacc2csb_resp_pd_d3;\n\n\n\n\n\nendmodule // NV_NVDLA_RT_csb2cacc\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "half_subtractor_36a8da1e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule half_subtractor (\n  input a,\n  input b,\n  output diff,\n  output bout\n);\n  assign diff = a ^ b;\n  assign bout = a & ~b;\nendmodule\n\nmodule full_subtractor (\n  input a,\n  input b,\n  input bin,\n  output diff,\n  output bout\n);\n  wire temp_diff1, temp_diff2, temp_bout1, temp_bout2;\n  half_subtractor hs1(.a(a), .b(b), .diff(temp_diff1), .bout(temp_bout1));\n  half_subtractor hs2(.a(temp_diff1), .b(bin), .diff(diff), .bout(temp_bout2));\n  assign bout = temp_bout1 | temp_bout2;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux6to1_pipeline_696119fa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux6to1_pipeline (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'bx;\n    endcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__7f26b86e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [15:0] in,\n    output reg [7:0] out_sum);\n\n    // Split input into two 8-bit outputs using a barrel shifter\n    reg [7:0] upper_out;\n    reg [7:0] lower_out;\n    always @(*) begin\n        upper_out = in >> 8;\n        lower_out = in & 8'hFF;\n    end\n\n    // 4-bit binary counter\n    reg [3:0] counter;\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 4'h0;\n        end else if (counter == 4'hF) begin\n            counter <= 4'h0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    // Adder to sum the two values\n    reg [7:0] sum;\n    always @(*) begin\n        sum = upper_out + counter + lower_out;\n    end\n\n    // Output the sum\n    always @(posedge clk) begin\n        if (reset) begin\n            out_sum <= 8'h0;\n        end else begin\n            out_sum <= sum;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_52c8b630", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n    input clk,\n    input reset,\n    output reg [3:0] Q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            Q <= 4'b0000;\n        end else begin\n            Q <= Q + 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_9b1c5f5f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n    input clk,\n    input up_down,\n    input load,\n    input [3:0] binary,\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        count <= binary;\n    end else if (up_down) begin\n        count <= count + 1;\n    end else begin\n        count <= count - 1;\n    end\nend\n\nendmodule\n\nmodule binary_to_bcd_converter (\n    input [3:0] binary,\n    output [3:0] BCD_HIGH,\n    output [3:0] BCD_LOW\n);\n\nassign BCD_HIGH = binary / 10;\nassign BCD_LOW = binary % 10;\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input up_down,\n    input load,\n    input [3:0] binary,\n    output [3:0] BCD_HIGH,\n    output [3:0] BCD_LOW\n);\n\nwire [3:0] count;\nup_down_counter counter(.clk(clk), .up_down(up_down), .load(load), .binary(binary), .count(count));\nbinary_to_bcd_converter converter(.binary(count), .BCD_HIGH(BCD_HIGH), .BCD_LOW(BCD_LOW));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dmac_2d_transfer_9b61e966", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dmac_2d_transfer (\n\tinput req_aclk,\n\tinput req_aresetn,\n\n\tinput req_valid,\n\toutput reg req_ready,\n\n\tinput [31:C_ADDR_ALIGN_BITS] req_dest_address,\n\tinput [31:C_ADDR_ALIGN_BITS] req_src_address,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_x_length,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_y_length,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_dest_stride,\n\tinput [C_DMA_LENGTH_WIDTH-1:0] req_src_stride,\n\tinput req_sync_transfer_start,\n\toutput reg req_eot,\n\t\n\toutput reg out_req_valid,\n\tinput out_req_ready,\n\toutput [31:C_ADDR_ALIGN_BITS] out_req_dest_address,\n\toutput [31:C_ADDR_ALIGN_BITS] out_req_src_address,\n\toutput [C_DMA_LENGTH_WIDTH-1:0] out_req_length,\n\toutput reg out_req_sync_transfer_start,\n\tinput out_eot\n);\n\nparameter C_DMA_LENGTH_WIDTH = 24;\nparameter C_ADDR_ALIGN_BITS = 3;\n\nreg [31:C_ADDR_ALIGN_BITS] dest_address;\nreg [31:C_ADDR_ALIGN_BITS] src_address;\nreg [C_DMA_LENGTH_WIDTH-1:0] x_length;\nreg [C_DMA_LENGTH_WIDTH-1:0] y_length;\nreg [C_DMA_LENGTH_WIDTH-1:0] dest_stride;\nreg [C_DMA_LENGTH_WIDTH-1:0] src_stride;\n\nreg [1:0] req_id;\nreg [1:0] eot_id;\nreg [3:0] last_req;\n\nassign out_req_dest_address = dest_address;\nassign out_req_src_address = src_address;\nassign out_req_length = x_length;\n\nalways @(posedge req_aclk)\nbegin\n\tif (req_aresetn == 1'b0) begin\n\t\treq_id <= 2'b0;\n\t\teot_id <= 2'b0;\n\t\treq_eot <= 1'b0;\n\tend else begin\n\t\tif (out_req_valid && out_req_ready) begin\n\t\t\treq_id <= req_id + 1'b1;\n\t\t\tlast_req[req_id] <= y_length == 0;\n\t\tend\n\t\treq_eot <= 1'b0;\n\t\tif (out_eot) begin\n\t\t\teot_id <= eot_id + 1'b1;\n\t\t\treq_eot <= last_req[eot_id];\n\t\tend\n\tend\nend\n\nalways @(posedge req_aclk)\nbegin\n\tif (req_aresetn == 1'b0) begin\n\t\tdest_address <= 'h00;\n\t\tsrc_address <= 'h00;\n\t\tx_length <= 'h00;\n\t\ty_length <= 'h00;\n\t\tdest_stride <= 'h00;\n\t\tsrc_stride <= 'h00;\n\t\treq_ready <= 1'b1;\n\t\tout_req_valid <= 1'b0;\n\t\tout_req_sync_transfer_start <= 1'b0;\n\tend else begin\n\t\tif (req_ready) begin\n\t\t\tif (req_valid) begin\n\t\t\t\tdest_address <= req_dest_address;\n\t\t\t\tsrc_address <= req_src_address;\n\t\t\t\tx_length <= req_x_length;\n\t\t\t\ty_length <= req_y_length;\n\t\t\t\tdest_stride <= req_dest_stride;\n\t\t\t\tsrc_stride <= req_src_stride;\n\t\t\t\tout_req_sync_transfer_start <= req_sync_transfer_start;\n\t\t\t\treq_ready <= 1'b0;\n\t\t\t\tout_req_valid <= 1'b1;\n\t\t\tend\n\t\tend else begin\n\t\t\tif (out_req_valid && out_req_ready) begin\n\t\t\t\tdest_address <= dest_address + dest_stride[C_DMA_LENGTH_WIDTH-1:C_ADDR_ALIGN_BITS];\n\t\t\t\tsrc_address <= src_address + src_stride[C_DMA_LENGTH_WIDTH-1:C_ADDR_ALIGN_BITS];\n\t\t\t\ty_length <= y_length - 1'b1;\n\t\t\t\tout_req_sync_transfer_start <= 1'b0;\n\t\t\t\tif (y_length == 0) begin\n\t\t\t\t\tout_req_valid <= 1'b0;\n\t\t\t\t\treq_ready <= 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_3to8_22e96d73", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule decoder_3to8 (\n    input A,\n    input B,\n    input C,\n    output Y0,\n    output Y1,\n    output Y2,\n    output Y3,\n    output Y4,\n    output Y5,\n    output Y6,\n    output Y7\n);\n\nreg [2:0] input_reg;\nwire [7:0] output_wire;\n\nassign output_wire = (input_reg == 3'b000) ? 8'b00000001 :\n                     (input_reg == 3'b001) ? 8'b00000010 :\n                     (input_reg == 3'b010) ? 8'b00000100 :\n                     (input_reg == 3'b011) ? 8'b00001000 :\n                     (input_reg == 3'b100) ? 8'b00010000 :\n                     (input_reg == 3'b101) ? 8'b00100000 :\n                     (input_reg == 3'b110) ? 8'b01000000 :\n                                           8'b10000000 ;\n\nalways @(A or B or C) begin\n    input_reg <= {C, B, A};\nend\n\nassign {Y7, Y6, Y5, Y4, Y3, Y2, Y1, Y0} = output_wire;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SERIAL_OUT_935e530d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule SERIAL_OUT(CLK,BYTEIN,ADDR,READ,READY,CLEAR,RX_D,RESET);\ninput CLK,READY,RESET;\ninput [7:0]BYTEIN;\noutput reg RX_D,READ,CLEAR=1;\noutput reg [4:0]ADDR=0;\n\nreg [9:0] data_out=0;\nreg [6:0] count=0;\n\nalways@(posedge CLK or negedge RESET)\nbegin\n\n\tif(RESET==0)\n\t\tbegin\n\t\tcount=0;\n\t\tADDR=0;\n\t\tCLEAR=1;\n\t\tREAD=0;\n\t\tRX_D=1;\n\t\tend\n\telse\n\t\tbegin\n\t\tif(READY==1)\n\t\t\tbegin\n\t\t\tdata_out[0]=0;\n\t\t\tdata_out[1]=BYTEIN[0];\n\t\t\tdata_out[2]=BYTEIN[1];\n\t\t\tdata_out[3]=BYTEIN[2];\n\t\t\tdata_out[4]=BYTEIN[3];\n\t\t\tdata_out[5]=BYTEIN[4];\n\t\t\tdata_out[6]=BYTEIN[5];\n\t\t\tdata_out[7]=BYTEIN[6];\n\t\t\tdata_out[8]=BYTEIN[7];\n\t\t\tdata_out[9]=1;\n\t\t\t\n\t\t\tif(count==9)\n\t\t\t\tbegin\n\t\t\t\tREAD=1;\n\t\t\t\tcount=0;\n\t\t\t\tRX_D=1;\n\t\t\t\tend\n\t\t\telse if(count==8)\n\t\t\t\tbegin\n\t\t\t\tRX_D=data_out[count];\n\t\t\t\tcount=count+1;\n\t\t\t\tREAD=0;\n\t\t\t\tADDR=ADDR+1;\n\t\t\t\tif(ADDR==32)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tADDR=0;\n\t\t\t\t\t\tCLEAR=0;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\tRX_D=data_out[count];\n\t\t\t\tcount=count+1;\n\t\t\t\tREAD=0;\n\t\t\t\tend\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\tCLEAR=1;\n\t\t\tADDR=0;\n\t\t\tRX_D=1;\n\t\t\tend\n\t\tend\n\nend\n\nendmodule\n\n\t\t\t\n\n\t\t\t"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hdll__bufinv_d3f21ae3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hdll__bufinv (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_4to1_ac23265a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_4to1(\n    input [7:0] d0, d1, d2, d3,\n    input s0, s1,\n    output [7:0] out\n);\n\nwire [1:0] sel;\nassign sel = {s1, s0};\n\nassign out = (sel == 2'b00) ? d0 :\n             (sel == 2'b01) ? d1 :\n             (sel == 2'b10) ? d2 :\n             (sel == 2'b11) ? d3 : 8'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fmlarb_dack_22edecc2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule fmlarb_dack(\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\tinput stb,\n\tinput eack,\n\tinput we,\n\n\toutput stbm,\n\toutput reg ack\n);\n\nwire read = eack & ~we;\nwire write = eack & we;\n\nreg ack_read2;\nreg ack_read1;\nreg ack_read0;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tack_read2 <= 1'b0;\n\t\tack_read1 <= 1'b0;\n\t\tack_read0 <= 1'b0;\n\tend else begin\n\t\tack_read2 <= read;\n\t\tack_read1 <= ack_read2;\n\t\tack_read0 <= ack_read1;\n\tend\nend\n\nreg ack0;\nalways @(posedge sys_clk) begin\n\tif(sys_rst) begin\n\t\tack0 <= 1'b0;\n\t\tack <= 1'b0;\n\tend else begin\nack <= ack_read0|write;\n\n\tend\nend\n\nreg mask;\nassign stbm = stb & ~mask;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tmask <= 1'b0;\n\telse begin\n\t\tif(eack)\n\t\t\tmask <= 1'b1;\n\t\tif(ack)\n\t\t\tmask <= 1'b0;\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "commutation_top_91f7a6cf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule commutation_top(\n    input clk,\n    input enable_i,\n    input reset_i,\n    input advance_i,\n    input direction_i,\n    input break_i,\n    input align_i,\n    output reg [3:0] state_o\n);\n\nparameter STATE_IDLE = 4'b0000;\nparameter STATE_ADVANCE = 4'b0001;\nparameter STATE_BREAK = 4'b0010;\nparameter STATE_ALIGN = 4'b0011;\n\nalways @(posedge clk) begin\n    if (reset_i) begin\n        state_o <= STATE_IDLE;\n    end else begin\n        case (state_o)\n            STATE_IDLE: begin\n                if (enable_i) begin\n                    if (advance_i) begin\n                        state_o <= STATE_ADVANCE;\n                    end else if (break_i) begin\n                        state_o <= STATE_BREAK;\n                    end else if (align_i) begin\n                        state_o <= STATE_ALIGN;\n                    end else begin\n                        state_o <= STATE_IDLE;\n                    end\n                end else begin\n                    state_o <= STATE_IDLE;\n                end\n            end\n            STATE_ADVANCE: begin\n                if (direction_i) begin\n                    state_o <= STATE_IDLE;\n                end else begin\n                    state_o <= STATE_ADVANCE;\n                end\n            end\n            STATE_BREAK: begin\n                state_o <= STATE_IDLE;\n            end\n            STATE_ALIGN: begin\n                state_o <= STATE_IDLE;\n            end\n            default: begin\n                state_o <= STATE_IDLE;\n            end\n        endcase\n    end\nend\n\nendmodule\nmodule timer(\n    input clk,\n    input enable_i,\n    input reset_i,\n    input [15:0] compare_i,\n    input [15:0] autoreload_i,\n    output compare_o,\n    output [15:0] value_o\n);\n\nreg [15:0] counter;\n\nalways @(posedge clk) begin\n    if (reset_i) begin\n        counter <= 16'b0;\n    end else if (enable_i) begin\n        if (counter == compare_i) begin\n            counter <= autoreload_i;\n        end else begin\n            counter <= counter + 1'b1;\n        end\n    end else begin\n        counter <= counter;\n    end\nend\n\nassign compare_o = (counter == compare_i);\nassign value_o = counter;\n\nendmodule\nmodule debouncer(\n    input clk_i,\n    input reset_i,\n    input pin_i,\n    output pos_o,\n    output neg_o,\n    output debounced_o\n);\n\nparameter DEBOUNCE_COUNT = 2;\n\nreg [DEBOUNCE_COUNT-1:0] counter;\nreg prev_pin_i;\nreg pos_flag;\nreg neg_flag;\n\nalways @(posedge clk_i) begin\n    if (reset_i) begin\n        counter <= {DEBOUNCE_COUNT{1'b0}};\n        prev_pin_i <= 1'b0;\n        pos_flag <= 1'b0;\n        neg_flag <= 1'b0;\n    end else begin\n        counter <= counter + 1'b1;\n        prev_pin_i <= pin_i;\n        if (pin_i && !prev_pin_i) begin\n            pos_flag <= 1'b1;\n        end else begin\n            pos_flag <= 1'b0;\n        end\n        if (!pin_i && prev_pin_i) begin\n            neg_flag <= 1'b1;\n        end else begin\n            neg_flag <= 1'b0;\n        end\n    end\nend\n\nassign pos_o = pos_flag;\nassign neg_o = neg_flag;\nassign debounced_o = counter == DEBOUNCE_COUNT;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_bfc77ab4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n  input clk,\n  input reset,\n  input enable,\n  input mode,\n  output reg [2:0] q\n);\n\n  always @(posedge clk or negedge reset) begin\n    if (!reset) begin\n      q <= 3'b0;\n    end else if (enable) begin\n      if (mode) begin\n        // Down mode\n        if (q == 3'b000) begin\n          q <= 3'b111;\n        end else begin\n          q <= q - 1;\n        end\n      end else begin\n        // Up mode\n        if (q == 3'b111) begin\n          q <= 3'b000;\n        end else begin\n          q <= q + 1;\n        end\n      end\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "arbiter_24ddbe6f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n`ifndef _arbiter_ `define _arbiter_\n\n\nmodule arbiter\n  #(parameter\n    NUM_PORTS = 6,\n    SEL_WIDTH = ((NUM_PORTS > 1) ? $clog2(NUM_PORTS) : 1))\n   (input                       clk,\n    input                       rst,\n    input      [NUM_PORTS-1:0]  request,\n    output reg [NUM_PORTS-1:0]  grant,\n    output reg [SEL_WIDTH-1:0]  select,\n    output reg                  active\n);\n\n    \n\n    localparam WRAP_LENGTH = 2*NUM_PORTS;\n\n\n    function [SEL_WIDTH-1:0] ff1 (\n        input [NUM_PORTS-1:0] in\n    );\n        reg     set;\n        integer i;\n\n        begin\n            set = 1'b0;\n            ff1 = 'b0;\n\n            for (i = 0; i < NUM_PORTS; i = i + 1) begin\n                if (in[i] & ~set) begin\n                    set = 1'b1;\n                    ff1 = i[0 +: SEL_WIDTH];\n                end\n            end\n        end\n    endfunction\n\n\n`ifdef VERBOSE\n    initial $display(\"Bus arbiter with %d units\", NUM_PORTS);\n`endif\n\n\n    \n\n    integer                 yy;\n\n    wire                    next;\n    wire [NUM_PORTS-1:0]    order;\n\n    reg  [NUM_PORTS-1:0]    token;\n    wire [NUM_PORTS-1:0]    token_lookahead [NUM_PORTS-1:0];\n    wire [WRAP_LENGTH-1:0]  token_wrap;\n\n\n    \n\n    assign token_wrap   = {token, token};\n\n    assign next         = ~|(token & request);\n\n\n    always @(posedge clk)\n        grant <= token & request;\n\n\n    always @(posedge clk)\n        select <= ff1(token & request);\n\n\n    always @(posedge clk)\n        active <= |(token & request);\n\n\n    always @(posedge clk)\n        if (rst) token <= 'b1;\n        else if (next) begin\n\n            for (yy = 0; yy < NUM_PORTS; yy = yy + 1) begin : TOKEN_\n\n                if (order[yy]) begin\n                    token <= token_lookahead[yy];\n                end\n            end\n        end\n\n\n    genvar xx;\n    generate\n        for (xx = 0; xx < NUM_PORTS; xx = xx + 1) begin : ORDER_\n\n            assign token_lookahead[xx]  = token_wrap[xx +: NUM_PORTS];\n\n            assign order[xx]            = |(token_lookahead[xx] & request);\n\n        end\n    endgenerate\n\n\nendmodule\n\n`endif "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_reg_ee76b712", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_reg(\n    input rx,\n    output reg[(reg_length-1):0] shifted_bus,\n\toutput reg finished_rx,\n    input rst,\n    input baud_clk\n    );\n\t\n\tparameter reg_length = 150;\n\n\tinitial finished_rx = 0;\n\tparameter idle = 2'b00, reading = 2'b01, finished = 2'b10, finished_and_waiting = 2'b11;\n\treg[1:0] current_state, next_state;\n\t\n\treg [(reg_length-1):0] bitShiftReg = {reg_length{1'b1}};\n\n\talways @(posedge baud_clk or posedge rst) begin\n\t\tif(rst) begin\n\t\t\tbitShiftReg <= {reg_length{1'b1}};\n\t\t\tcurrent_state <=  idle;\n\t\tend\n\t\telse begin\n\t\t\tcurrent_state <= next_state;\n\t\t\tbitShiftReg <= {bitShiftReg[(reg_length-2):0],rx};\n\t\tend\n\tend\n\talways @(rx or bitShiftReg or current_state) begin\n\t\tcase(current_state) \n\t\t\tidle: begin\n\t\t\t\tif(rx == 1)\n\t\t\t\t\tnext_state <= idle;\n\t\t\t\telse \n\t\t\t\t\tnext_state <= reading;\n\t\t\t\tend\n\t\t\treading: begin\n\t\t\t\tif(bitShiftReg[6:0] == {7{1'b1}})\n\t\t\t\t\tnext_state <= finished;\n\t\t\t\telse\n\t\t\t\t\tnext_state <= reading;\n\t\t\t\tend\n\t\t\tfinished: begin\n\t\t\t\tnext_state<= finished_and_waiting;\n\t\t\tend\n\t\t\t\n\t\t\tdefault: begin\n\t\t\t\tnext_state<=idle;\n\t\t\tend\n\t\tendcase\n\tend\n\t\n\talways @ (current_state) begin\n\t\tif(current_state == finished)\n\t\t\tfinished_rx <= 1;\n\t\telse\n\t\t\tfinished_rx <= 0;\n\tend\n\t\n\talways @ (posedge finished_rx or posedge rst) begin\n\t\tif(rst) \n\t\t\tshifted_bus <= {reg_length{1'b1}};\n\t\telse\n\t\t\tshifted_bus <= bitShiftReg;\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "reversed_gate_5cc51311", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule reversed_gate (clk, ctrl, din, sel, dout);\n   input clk;\n   input [4:0] ctrl;\n   input [15:0] din;\n   input [3:0] \tsel;\n   output reg [31:0] dout;\n   always @(posedge clk)\n     case ((({(32)-((ctrl)*(sel))})+(1))-(2))\n       0:\n         dout[1:0] <= din;\n       1:\n         dout[2:1] <= din;\n       2:\n         dout[3:2] <= din;\n       3:\n         dout[4:3] <= din;\n       4:\n         dout[5:4] <= din;\n       5:\n         dout[6:5] <= din;\n       6:\n         dout[7:6] <= din;\n       7:\n         dout[8:7] <= din;\n       8:\n         dout[9:8] <= din;\n       9:\n         dout[10:9] <= din;\n       10:\n         dout[11:10] <= din;\n       11:\n         dout[12:11] <= din;\n       12:\n         dout[13:12] <= din;\n       13:\n         dout[14:13] <= din;\n       14:\n         dout[15:14] <= din;\n       15:\n         dout[16:15] <= din;\n       16:\n         dout[17:16] <= din;\n       17:\n         dout[18:17] <= din;\n       18:\n         dout[19:18] <= din;\n       19:\n         dout[20:19] <= din;\n       20:\n         dout[21:20] <= din;\n       21:\n         dout[22:21] <= din;\n       22:\n         dout[23:22] <= din;\n       23:\n         dout[24:23] <= din;\n       24:\n         dout[25:24] <= din;\n       25:\n         dout[26:25] <= din;\n       26:\n         dout[27:26] <= din;\n       27:\n         dout[28:27] <= din;\n       28:\n         dout[29:28] <= din;\n       29:\n         dout[30:29] <= din;\n       30:\n         dout[31:30] <= din;\n       31:\n         dout[31:31] <= din;\n     endcase\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "receiver #_29d8d787", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule receiver #(\n    parameter DATA_BITS = 32\n)(\n    input clk, rst, stb,\n    input [DATA_BITS-1:0] data,  // Added the data input\n    output [DATA_BITS-1:0] data_out,\n    output ack, valid\n);\n\n    reg [DATA_BITS-1:0] data_reg;\n    reg ack_reg, valid_reg;\n    wire stb_selected;\n\n    // Synchronizer for stb signal\n    wire stb_sync;\n    synchronizer_1bit sync1 (clk, rst, stb, stb_sync);\n    assign stb_selected = stb_sync;\n\n    // Latch data into register on stb signal assertion\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_reg <= 0;\n        end else if (stb_selected) begin\n            data_reg <= data;\n        end\n    end\n\n    // Connect data_out to stored data value\n    assign data_out = data_reg;\n\n    // Acknowledge signal\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            ack_reg <= 1'b0;\n        end else if (stb_selected) begin\n            ack_reg <= 1'b1;\n        end\n    end\n    assign ack = ack_reg;\n\n    // Valid signal\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            valid_reg <= 1'b0;\n        end else if (ack_reg) begin\n            valid_reg <= 1'b1;\n        end\n    end\n    assign valid = valid_reg;\n\nendmodule\nmodule synchronizer_1bit (\n    input clk, rst, in,\n    output out\n);\n\n    reg [1:0] sync_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sync_reg <= 2'b00;\n        end else begin\n            sync_reg <= {sync_reg[0], in};\n        end\n    end\n\n    assign out = sync_reg[1];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "precision_dac #_c445a7dd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule precision_dac #\n(\n  parameter CLK_DIV = 3\n)\n(\n  input wire                      clk,\n  input wire [16*4-1:0]           data,\n  input wire                      valid,\n  input wire [4-1:0]              cmd,\n\n  output reg                      sync,\n  output reg                      sclk,\n  output reg                      sdi,\n  output reg                      ldac\n);\n  reg [16*8-1:0] data_reg;\n  reg [4-1:0] cmd_reg;\n  reg [CLK_DIV-1:0] cnt_clk  = 0; reg [7-1: 0] cnt_sclk = 0;\n  initial sync = 1'b1;\n\n  always @(posedge clk) begin\n    if (valid == 1'b1) begin\n      cnt_clk <= cnt_clk + 1;\n\n      if (cnt_clk == {{1'b0}, {(CLK_DIV-1){1'b1}}}) begin\n        sclk <= 1'b1;\n        if (cnt_sclk == {(7){1'b0}}) begin\n          ldac <= 1'b1;\n          cmd_reg <= cmd;\n          data_reg <= data;\n        end\n\n        if (cnt_sclk[5-1:0] == {(5){1'b0}}) begin\n          sync <= 1'b0;\n        end\n\n        cnt_sclk <= cnt_sclk + 1;\n\n        if (sync == 1'b0 | cnt_sclk[5-1:0] == {(5){1'b0}}) begin\n          if (cnt_sclk[5-1:2] == 3'b000) begin\n            sdi <= cmd[3-cnt_sclk[2-1:0]]; end else if (cnt_sclk[5-1:2] == 3'b001) begin\n            sdi <= (cnt_sclk[7-1:5] == ~cnt_sclk[2-1:0]);\n          end else if (cnt_sclk[5-1:0] == 5'b11000) begin\n            sync <= 1'b1;\n            if (cnt_sclk[7-1:5] == 3'b11) begin\n              ldac <= 1'b0;\n            end\n          end else begin\n            sdi <= data_reg[16*cnt_sclk[7-1:5] + 23 - cnt_sclk[5-1:0]];\n          end\n        end\n      end\n      if (cnt_clk == {(CLK_DIV){1'b1}}) begin\n        sclk <= 1'b0;\n      end\n    end else begin cnt_clk <= 0;\n      cnt_sclk <= 0;\n      sync <= 1;\n      sdi <= 0;\n      ldac <= 0;\n      sclk <= 0;\n    end\n  end\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__52ed1c3d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [3:0] multiplier,\n    input [3:0] multiplicand,\n    input [15:0] in0,\n    input [15:0] in1,\n    input ctrl,\n    output reg [15:0] out\n);\n\n    wire [7:0] unsigned_mult_out;\n    wire [3:0] add_sub_out;\n    wire [15:0] final_out;\n\n    unsigned_multiplier unsigned_mult(.a(multiplier), .b(multiplicand), .p(unsigned_mult_out));\n    add_sub add_sub(.a(multiplier), .b(multiplicand), .ctrl(ctrl), .s(add_sub_out));\n    functional_module functional(.in0(unsigned_mult_out), .in1(add_sub_out), .out(final_out));\n\n    always @(*) begin\n        if (ctrl == 0) begin\n            out = final_out;\n        end else begin\n            out = final_out + in0 + in1;\n        end\n    end\n\nendmodule\n\nmodule unsigned_multiplier (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [7:0] p\n);\n\n    always @(*) begin\n        p = a * b;\n    end\n\nendmodule\n\nmodule add_sub (\n    input [3:0] a,\n    input [3:0] b,\n    input ctrl,\n    output reg [3:0] s\n);\n\n    always @(*) begin\n        if (ctrl == 0) begin\n            s = a + b;\n        end else begin\n            s = a - b;\n        end\n    end\n\nendmodule\n\nmodule functional_module (\n    input [7:0] in0,\n    input [3:0] in1,\n    output reg [15:0] out\n);\n\n    always @(*) begin\n        out = {8'b0, in0} + {12'b0, in1};\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_add_sub_553992c6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_add_sub (\n    input clk,\n    input reset,\n    input [7:0] in_a,\n    input [7:0] in_b,\n    input select,\n    output reg [7:0] out\n);\n\nreg [7:0] a_shifted;\nreg [7:0] b_shifted;\nreg [7:0] result;\n\nalways @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n        a_shifted <= 8'b0;\n        b_shifted <= 8'b0;\n        result <= 8'b0;\n    end else begin\n        a_shifted <= {in_a[7], in_a[6], in_a[5], in_a[4], in_a[3], in_a[2], in_a[1], in_a[0]};\n        b_shifted <= {in_b[7], in_b[6], in_b[5], in_b[4], in_b[3], in_b[2], in_b[1], in_b[0]};\n        if (select == 1) begin\n            result <= a_shifted + b_shifted;\n        end else begin\n            result <= a_shifted - b_shifted;\n        end\n    end\nend\n\nalways @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n        out <= 8'b0;\n    end else begin\n        out <= {result[0], result[1], result[2], result[3], result[4], result[5], result[6], result[7]};\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__6a035f51", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,         // Clock input\n    input reset,       // Synchronous active-high reset\n    input [7:0] in,    // 8-bit input signal for the edge detector\n    input select,      // Select input to choose between counter and edge detector\n    output [3:0] counter_out,  // 4-bit output from the counter\n    output [7:0] edge_out,     // 8-bit output from the edge detector\n    output [7:0] and_out       // Output from the functional module\n);\n\n    // Counter module\n    reg [3:0] counter_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            counter_reg <= 4'b0;\n        end else begin\n            counter_reg <= counter_reg + 1;\n        end\n    end\n    assign counter_out = counter_reg;\n\n    // Edge detector module\n    reg [7:0] edge_reg;\n    reg [7:0] edge_out_reg;\n    always @(posedge clk) begin\n        edge_reg <= {edge_reg[6:0], in};\n        if (edge_reg[7] != edge_reg[6]) begin\n            edge_out_reg <= 8'b11111111;\n        end else begin\n            edge_out_reg <= edge_out_reg;\n        end\n    end\n    assign edge_out = edge_out_reg;\n\n    // Functional module\n    reg [7:0] and_out_reg;\n    always @(posedge clk) begin\n        if (select) begin\n            and_out_reg <= edge_out_reg & counter_reg;\n        end else begin\n            and_out_reg <= 8'b0;\n        end\n    end\n    assign and_out = and_out_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_gate_ad9f6486", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule xor_gate(\n    input a,\n    input b,\n    output wire xor_out\n);\n\nassign xor_out = a ^ b;\n\nendmodule\n\nmodule functional_module(\n    input xor_out,\n    output reg func_out\n);\n\nalways @(*) begin\n    if(xor_out == 1'b1) begin\n        func_out = 1'b1;\n    end else begin\n        func_out = 1'b0;\n    end\nend\n\nendmodule\n\nmodule control_logic(\n    input a,\n    input b,\n    input select,\n    output reg out\n);\n\nwire xor_out;\nwire func_out;\n\nxor_gate xor_inst(\n    .a(a),\n    .b(b),\n    .xor_out(xor_out)\n);\n\nfunctional_module func_inst(\n    .xor_out(xor_out),\n    .func_out(func_out)\n);\n\nalways @(*) begin\n    if(select == 1'b1) begin\n        out = func_out;\n    end else begin\n        out = xor_out;\n    end\nend\n\nendmodule\n\nmodule top_module(\n    input a, \n    input b,\n    input select,\n    output wire out\n);\n\ncontrol_logic control_inst(\n    .a(a),\n    .b(b),\n    .select(select),\n    .out(out)\n);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "CSADD_bd21f8a3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule CSADD(clk, rst, x, y, ld, sum);\n    input clk, rst;\n    input x, y;\n    input ld;\n    output reg sum;\n\n    reg sc;\n\n    // Half Adders logic\n    wire hsum1, hco1;\n    assign hsum1 = y ^ sc;\n    assign hco1 = y & sc;\n\n    wire hsum2, hco2;\n    assign hsum2 = x ^ hsum1;\n    assign hco2 = x & hsum1;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            //Reset logic goes here.\n            sum <= 1'b0;\n            sc <= 1'b0;\n        end\n        else if (ld) begin\n             sum <= 1'b0;\n             sc  <= 1'b0;\n        end\n        else begin\n            //Sequential logic goes here.\n            sum <= hsum2;\n            sc <= hco1 ^ hco2;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_asr_en_df6360f7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_asr_en (CLK, D, SET, RESET, EN, Q, QN);\n   input CLK, D, SET, RESET, EN;\n   output Q, QN;\n   reg Q;\n\n   always @(posedge CLK) begin\n      if (EN) begin\n         if (SET) Q <= 1'b1;\n         else if (RESET) Q <= 1'b0;\n         else Q <= D;\n      end\n   end\n\n   assign QN = ~Q;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__7c0a3e7b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n  input clk,\n  input reset,      // Synchronous active-high reset\n  input [2:0] load_data, // 3-bit input for the shift register\n  input load, // Parallel load input for the shift register\n  output serial_out // Serial output from the shift register\n);\n\n  reg [2:0] shift_reg;\n  reg [63:0] jc_output;\n  wire [2:0] sr_output;\n  wire result;\n\n  // Instantiate the Johnson counter module\n  chatgpt_generate_JC_counter jc_counter (\n    .clk(clk),\n    .rst_n(reset),\n    .Q(jc_output)\n  );\n\n  // Instantiate the shift register module\n  shift_register shift_reg_inst (\n    .clk(clk),\n    .load(load),\n    .load_data(load_data),\n    .shift_in(jc_output[0]),\n    .shift_out(sr_output)\n  );\n\n  // Instantiate the functional module\n  functional_module func_inst (\n    .jc_output(jc_output),\n    .sr_output(sr_output),\n    .result(result)\n  );\n\n  // Assign the serial output to the result of the shift register\n  assign serial_out = sr_output[2];\n\nendmodule\nmodule chatgpt_generate_JC_counter(\n  input                clk,\n  input                rst_n,\n  output reg  [63:0]   Q\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      Q <= 64'b1;\n    end else begin\n      Q <= {Q[62:0], ~Q[63]};\n    end\n  end\n\nendmodule\nmodule shift_register(\n  input clk,\n  input load,\n  input [2:0] load_data,\n  input shift_in,\n  output reg [2:0] shift_out\n);\n\n  always @(posedge clk) begin\n    if (load) begin\n      shift_out <= load_data;\n    end else begin\n      shift_out <= {shift_out[1:0], shift_in};\n    end\n  end\n\nendmodule\nmodule functional_module(\n  input [63:0] jc_output, // Output from Johnson counter\n  input [2:0] sr_output, // Output from shift register\n  output reg result // XOR of the two inputs\n);\n\n  always @* begin\n    result = jc_output[0] ^ sr_output[0];\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipelined_add_sub_5ded90bf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule pipelined_add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] sum\n);\n\nwire [31:0] csa_out;\nwire [31:0] cla_out;\n\n// Carry save adder\ncsa csa_inst(\n    .a(a),\n    .b(b),\n    .c(sub),\n    .s(csa_out)\n);\n\n// Carry lookahead adder\ncla cla_inst(\n    .a(csa_out),\n    .b({32{sub}}),\n    .c(32'b0),\n    .s(cla_out)\n);\n\n// Output sum\nassign sum = cla_out;\n\nendmodule\nmodule csa(\n    input [31:0] a,\n    input [31:0] b,\n    input c,\n    output [31:0] s\n);\n\nwire [31:0] p;\nwire [31:0] g;\n\n// Generate and propagate signals\ngen_propagate gen_propagate_inst(\n    .a(a),\n    .b(b),\n    .p(p),\n    .g(g)\n);\n\n// Sum calculation\nassign s = p ^ c ^ g;\n\nendmodule\nmodule gen_propagate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] p,\n    output [31:0] g\n);\n\nassign p = a ^ b;\nassign g = a & b;\n\nendmodule\nmodule cla(\n    input [31:0] a,\n    input [31:0] b,\n    input [31:0] c,\n    output [31:0] s\n);\n\nwire [31:0] p;\nwire [31:0] g;\n\n// Generate and propagate signals\ngen_propagate gen_propagate_inst(\n    .a(a),\n    .b(b),\n    .p(p),\n    .g(g)\n);\n\n// Carry lookahead signals\nwire [31:0] c0;\nwire [31:0] c1;\nwire [31:0] c2;\nwire [31:0] c3;\n\nassign c0 = c[0];\nassign c1 = g[0] | (p[0] & c0);\nassign c2 = g[1] | (p[1] & c1);\nassign c3 = g[2] | (p[2] & c2);\n\n// Sum calculation\nassign s = p ^ c ^ (c3 << 3);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "niosii_nios2_gen2_0_cpu_nios2_oci_dtrace_5ea2e7a9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule niosii_nios2_gen2_0_cpu_nios2_oci_dtrace (\n  // inputs:\n  clk,\n  cpu_d_address,\n  cpu_d_read,\n  cpu_d_readdata,\n  cpu_d_wait,\n  cpu_d_write,\n  cpu_d_writedata,\n  jrst_n,\n  trc_ctrl,\n  // outputs:\n  atm,\n  dtm\n);\n\n  output [31:0] atm;\n  output [31:0] dtm;\n  input clk;\n  input [22:0] cpu_d_address;\n  input cpu_d_read;\n  input [31:0] cpu_d_readdata;\n  input cpu_d_wait;\n  input cpu_d_write;\n  input [31:0] cpu_d_writedata;\n  input jrst_n;\n  input [15:0] trc_ctrl;\n\n  reg [31:0] atm;\n  reg [31:0] dtm;\n\n  wire [31:0] cpu_d_address_0_padded;\n  wire [31:0] cpu_d_readdata_0_padded;\n  wire [31:0] cpu_d_writedata_0_padded;\n  wire dummy_tie_off;\n  wire record_load_addr;\n  wire record_load_data;\n  wire record_store_addr;\n  wire record_store_data;\n  wire [3:0] td_mode_trc_ctrl;\n\n  assign cpu_d_writedata_0_padded = {7'b0, cpu_d_writedata};\n  assign cpu_d_readdata_0_padded = {7'b0, cpu_d_readdata};\n  assign cpu_d_address_0_padded = {7'b0, cpu_d_address[22:0]};\n\n  niosii_nios2_gen2_0_cpu_nios2_oci_td_mode niosii_nios2_gen2_0_cpu_nios2_oci_trc_ctrl_td_mode_inst  (\n    .ctrl(trc_ctrl),\n    .td_mode(td_mode_trc_ctrl)\n  );\n\n  assign {record_load_addr, record_store_addr, record_load_data, record_store_data} = td_mode_trc_ctrl;\n\n  always @(posedge clk or negedge jrst_n) begin\n    if (jrst_n == 0) begin\n      atm <= 0;\n      dtm <= 0;\n    end\n    else begin\n      if (cpu_d_wait == 0) begin\n        if (cpu_d_read == 1) begin\n          if (record_load_addr) begin\n            atm <= cpu_d_address_0_padded[31:0];\n          end\n          if (record_load_data) begin\n            dtm <= cpu_d_readdata_0_padded[31:0];\n          end\n        end\n        else if (cpu_d_write == 1) begin\n          if (record_store_addr) begin\n            atm <= cpu_d_address_0_padded[31:0];\n          end\n          if (record_store_data) begin\n            dtm <= cpu_d_writedata_0_padded[31:0];\n          end\n        end\n      end\n    end\n  end\n\n  assign dummy_tie_off = cpu_d_wait | cpu_d_read | cpu_d_write;\n\nendmodule\nmodule niosii_nios2_gen2_0_cpu_nios2_oci_td_mode (\n  ctrl,\n  td_mode\n);\n\n  input  [15:0] ctrl;\n  output [3:0] td_mode;\n\n  assign td_mode = ctrl[3:0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_to_bcd_converter_cbeba535", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_to_bcd_converter (\n  input clk,\n  input reset,\n  input [3:0] binary_input,\n  output reg [3:0] msd_output,\n  output reg [3:0] lsd1_output,\n  output reg [3:0] lsd2_output\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      msd_output <= 4'b0000;\n      lsd1_output <= 4'b0000;\n      lsd2_output <= 4'b0000;\n    end else begin\n      case (binary_input)\n        4'b0000: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0000;\n          lsd2_output <= 4'b0000;\n        end\n        4'b0001: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0000;\n          lsd2_output <= 4'b0001;\n        end\n        4'b0010: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0001;\n          lsd2_output <= 4'b0000;\n        end\n        4'b0011: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0001;\n          lsd2_output <= 4'b0001;\n        end\n        4'b0100: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0010;\n          lsd2_output <= 4'b0000;\n        end\n        4'b0101: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0010;\n          lsd2_output <= 4'b0001;\n        end\n        4'b0110: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0011;\n          lsd2_output <= 4'b0000;\n        end\n        4'b0111: begin\n          msd_output <= 4'b0000;\n          lsd1_output <= 4'b0011;\n          lsd2_output <= 4'b0001;\n        end\n        4'b1000: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0000;\n          lsd2_output <= 4'b0000;\n        end\n        4'b1001: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0000;\n          lsd2_output <= 4'b0001;\n        end\n        4'b1010: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0001;\n          lsd2_output <= 4'b0000;\n        end\n        4'b1011: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0001;\n          lsd2_output <= 4'b0001;\n        end\n        4'b1100: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0010;\n          lsd2_output <= 4'b0000;\n        end\n        4'b1101: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0010;\n          lsd2_output <= 4'b0001;\n        end\n        4'b1110: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0011;\n          lsd2_output <= 4'b0000;\n        end\n        4'b1111: begin\n          msd_output <= 4'b0001;\n          lsd1_output <= 4'b0011;\n          lsd2_output <= 4'b0001;\n        end\n      endcase\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__o221ai_21446f6f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__o221ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire or0_out    ;\n    wire or1_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , B2, B1              );\n    or   or1   (or1_out    , A2, A1              );\n    nand nand0 (nand0_out_Y, or1_out, or0_out, C1);\n    buf  buf0  (Y          , nand0_out_Y         );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_f6d0d653", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    output reg [3:0] q);\n    \n    // Define states\n    parameter [1:0]\n        S0 = 2'b00,\n        S1 = 2'b01,\n        S2 = 2'b10,\n        S3 = 2'b11;\n    \n    // Define state register and next state logic\n    reg [1:0] state, next_state;\n    always @ (posedge clk, posedge reset) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n    \n    // Define output logic\n    always @ (*) begin\n        case (state)\n            S0: q = 4'b0000;\n            S1: q = 4'b0001;\n            S2: q = 4'b0010;\n            S3: q = 4'b0011;\n        endcase\n    end\n    \n    // Define next state logic\n    always @ (*) begin\n        case (state)\n            S0: next_state = S1;\n            S1: next_state = S2;\n            S2: next_state = S3;\n            S3: next_state = S0;\n        endcase\n    end\n    \nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    output [3:0] q);\n    \n    binary_counter counter (\n        .clk(clk),\n        .reset(reset),\n        .q(q)\n    );\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__o41ai_0b084048", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__o41ai (\n    Y ,\n    A1,\n    A2,\n    A3,\n    A4,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  A4;\n    input  B1;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A4, A3, A2, A1 );\n    nand nand0 (nand0_out_Y, B1, or0_out    );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_8bit_4a87b6e9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator_8bit (\n  input [7:0] in1,\n  input [7:0] in2,\n  output reg match\n);\n\n  reg [7:0] temp;\n  integer i;\n\n  always @* begin\n    match = 1;\n    for (i = 0; i < 8; i = i + 1) begin\n      temp[i] = (in1[i] == in2[i]);\n      match = match & temp[i];\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "freq_synth_f1e8e7f9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule freq_synth (\n  input clk,\n  input [31:0] ref_clk,\n  input [31:0] out_freq,\n  output reg [7:0] synth_freq\n);\n\nparameter resolution = 8; // number of bits used to represent the synthesized frequency\nparameter frequency_range = 100000000; // range of output frequencies that can be generated by the synthesizer (in Hz)\n\nreg [31:0] integer_value; // programmable integer value used to divide the reference clock frequency\nreg [31:0] synthesized_freq; // synthesized frequency generated by the frequency synthesizer\n\nalways @ (posedge clk) begin\n  integer_value <= (ref_clk / out_freq) - 1; // calculate the integer value by dividing the reference clock frequency by the desired output frequency\n  synthesized_freq <= ref_clk / (integer_value + 1); // generate the synthesized frequency by dividing the reference clock frequency by the integer value\n  synth_freq <= synthesized_freq / (frequency_range / (2 ** resolution)); // output the synthesized frequency in binary format with the specified resolution\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_bcd_mux_3e0160b9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule priority_bcd_mux (\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] C,\n    input [3:0] D,\n    input [1:0] S,\n    input [3:0] binary_in,\n    input clk,\n    output reg [6:0] seven_segment_out,\n    output reg EN1,\n    output reg EN2,\n    output reg EN3\n);\n\nreg [3:0] priority_input;\nreg [3:0] bcd_out;\nreg [1:0] digit_counter;\nreg [3:0] bcd_counter;\n\nalways @(posedge clk) begin\n    // Priority encoder\n    case ({A, B, C, D})\n        4'b1110: priority_input <= A;\n        4'b1101: priority_input <= B;\n        4'b1011: priority_input <= C;\n        4'b0111: priority_input <= D;\n        default: priority_input <= 4'b0000;\n    endcase\n    \n    // Binary to BCD converter\n    if (digit_counter == 0) begin\n        bcd_out <= binary_in % 10;\n    end else if (digit_counter == 1) begin\n        bcd_out <= (binary_in / 10) % 10;\n    end else if (digit_counter == 2) begin\n        bcd_out <= (binary_in / 100) % 10;\n    end else begin\n        bcd_out <= (binary_in / 1000) % 10;\n    end\n    \n    // Output selection\n    case (S)\n        2'b00: seven_segment_out <= bcd_out;\n        2'b01: seven_segment_out <= priority_input;\n        2'b10: seven_segment_out <= 7'b1111111;\n        2'b11: seven_segment_out <= 7'b0000000;\n    endcase\n    \n    // Digit enable signals\n    if (digit_counter == 0) begin\n        EN1 <= 1;\n        EN2 <= 0;\n        EN3 <= 0;\n    end else if (digit_counter == 1) begin\n        EN1 <= 0;\n        EN2 <= 1;\n        EN3 <= 0;\n    end else if (digit_counter == 2) begin\n        EN1 <= 0;\n        EN2 <= 0;\n        EN3 <= 1;\n    end else begin\n        EN1 <= 0;\n        EN2 <= 0;\n        EN3 <= 0;\n    end\n    \n    // Digit counter\n    if (digit_counter == 3) begin\n        digit_counter <= 0;\n    end else begin\n        digit_counter <= digit_counter + 1;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clk_gated_module_c3e83d3e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule clk_gated_module(\n    src_clk            ,clk_en             ,gated_clk           );\n\n    input               src_clk     ;input               clk_en      ;output              gated_clk   ;reg                 clk_en_reg      ;always @(posedge src_clk) begin : CLK_EN_REG\n        clk_en_reg  <= clk_en;\n    end\n    assign  gated_clk   = clk_en_reg & src_clk ;\n    \n    endmodule    \n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "register_02188486", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule register (\n  input clk,\n  input reset,\n  input load,\n  input [3:0] data_in,\n  output [3:0] data_out\n);\n\n  reg [3:0] reg_data;\n\n  always @(posedge clk or negedge reset) begin\n    if (reset == 0) begin\n      reg_data <= 4'b0000;\n    end\n    else if (load == 1) begin\n      reg_data <= data_in;\n    end\n  end\n\n  assign data_out = reg_data;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_block #_68c8999d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator_block #(\n  parameter n = 4\n)(\n  input [n-1:0] A,\n  input [n-1:0] B,\n  output reg [1:0] eq_gt\n);\n\n\nalways @(*) begin\n  if (A === B) begin // A is equal to B\n    eq_gt = 2'b11;\n  end else if (A > B) begin // A is greater than B\n    eq_gt = 2'b10;\n  end else if (A < B) begin // A is less than B\n    eq_gt = 2'b01;\n  end else if (A === {n{1'bx}} && B !== {n{1'bx}}) begin // A is X and B is not X\n    eq_gt = 2'b01;\n  end else if (A !== {n{1'bx}} && B === {n{1'bx}}) begin // A is not X and B is X\n    eq_gt = 2'b10;\n  end else begin // A and B are both X (unknown)\n    eq_gt = 2'b10;\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_a2da623d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule priority_encoder (\n  input clk,\n  input reset,\n  input in0,\n  input in1,\n  input in2,\n  input in3,\n  output reg [1:0] out,\n  output reg valid\n);\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      out <= 2'b00;\n      valid <= 1'b0;\n    end else begin\n      casez({in3, in2, in1, in0})\n        4'b0001: out <= 2'b00;\n        4'b0010: out <= 2'b01;\n        4'b0100: out <= 2'b10;\n        4'b1000: out <= 2'b11;\n        default: out <= out;\n      endcase\n      if (in0 || in1 || in2 || in3) begin\n        valid <= 1'b1;\n      end else begin\n        valid <= 1'b0;\n      end\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "manchester_coder_56d499dc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule manchester_coder (\n  input clk_in,\n  input data_in,\n  output data_out,\n  output reg data_decoded\n);\n\n// No parameters needed for this module\n\n// input signals\nassign data_out = (clk_in ^ data_in) ? 1'b0 : 1'b1;\n\n// output signals\nalways @(posedge clk_in)\nbegin\n  if (data_out == 1'b0)\n    data_decoded <= 1'b0;\n  else if (data_out == 1'b1)\n    data_decoded <= 1'b1;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "i2s_d2111017", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule i2s\n(\n    clk_i,\n    rst_i,\n    pcm_data_i,\n    pcm_fifo_empty_i,\n    pcm_fifo_rd_o,\n    pcm_fifo_ur_o,\n    bclk_o,\n    ws_o,\n    data_o\n);\n\nparameter       CLK_DIVISOR = 6;\n\ninput           clk_i ;\ninput           rst_i ;\ninput[31:0]     pcm_data_i ;\ninput           pcm_fifo_empty_i ;\noutput          pcm_fifo_rd_o ;\noutput          pcm_fifo_ur_o ;\noutput          bclk_o ;\noutput          ws_o ;\noutput          data_o ;\n\nreg             audio_clock;\ninteger         audio_clock_div;\ninteger         bit_count;\nreg             word_sel;\n\nreg [15:0]      input_reg0;\nreg [15:0]      input_reg1;\n\nreg [31:0]      pcm_data_last;\nreg             prev_audio_clock;\n\nreg             pcm_fifo_rd_o;\nreg             pcm_fifo_ur_o;\nreg             bclk_o;\nreg             data_o;\n\nalways @(posedge clk_i or posedge rst_i) \nbegin\n    if (rst_i == 1'b1) \n    begin\n        audio_clock_div <= 0;\n        audio_clock     <= 1'b0;\n    end \n    else \n    begin\n        if (audio_clock_div == (CLK_DIVISOR - 1))\n        begin\n            audio_clock     <= ~audio_clock;\n            audio_clock_div <= 0;\n        end\n        else \n            audio_clock_div <= audio_clock_div + 1;\n    end\nend\n\nalways @(posedge clk_i or posedge rst_i) \nbegin\n    if (rst_i == 1'b1) \n    begin\n        input_reg0      <= 16'h0000;\n        input_reg1      <= 16'h0000;\n        bit_count       <= 0;\n        data_o          <= 1'b0;\n        word_sel        <= 1'b0;\n        prev_audio_clock<= 1'b0;\n        pcm_fifo_rd_o   <= 1'b0;\n        pcm_fifo_ur_o   <= 1'b0;\n        pcm_data_last   <= 32'h00000000;\n    end \n    else \n    begin\n        pcm_fifo_rd_o   <= 1'b0;\n        pcm_fifo_ur_o   <= 1'b0;\n      \n        prev_audio_clock <= audio_clock;\n        \n        if ((prev_audio_clock == 1'b1) && (audio_clock == 1'b0)) \n        begin\n            bclk_o <= 1'b0;\n            \n            if (bit_count == 0) \n            begin\n                if (word_sel == 1'b0)\n                    data_o <= input_reg0[15];\n                else \n                    data_o <= input_reg1[15];\n                \n                word_sel <=  ~word_sel;\n                \n                bit_count <= bit_count + 1;\n                \n                if (pcm_fifo_empty_i == 1'b0) \n                begin\n                    pcm_data_last   <= pcm_data_i;\n                    input_reg0      <= pcm_data_i[31:16];\n                    input_reg1      <= pcm_data_i[15:0];\n                    pcm_fifo_rd_o   <= 1'b1;\n                end\n                else \n                begin\n                    input_reg0      <= pcm_data_last[31:16];\n                    input_reg1      <= pcm_data_last[15:0];\n                    pcm_fifo_ur_o   <= 1'b1;\n                end\n            end\n            else \n            begin\n                if (word_sel == 1'b0) \n                begin\n                    data_o <= input_reg0[15];\n                    \n                    input_reg0 <= {input_reg0[14:0], 1'b0};\n                end\n                else \n                begin\n                    data_o <= input_reg1[15];\n                    \n                    input_reg1 <= {input_reg1[14:0], 1'b0};\n                end\n                \n                if (bit_count == 15)\n                    bit_count <= 0;\n                else \n                    bit_count <= bit_count + 1;\n            end\n        end\n        else if((prev_audio_clock == 1'b0) && (audio_clock == 1'b1)) \n            bclk_o <= 1'b1;\n    end\nend\n\nassign ws_o = word_sel;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "LLbit_reg_2a563aea", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule LLbit_reg(\n    input wire clk,\n    input wire rst,\n    input wire flush,\n    input wire LLbit_i,\n    input wire we,\n    output reg LLbit_o\n);\n\n    always @ (posedge clk) begin\n        if (rst) begin\n            LLbit_o <= 1'b0;\n        end else if (flush) begin\n            LLbit_o <= 1'b0;\n        end else if (we) begin\n            LLbit_o <= LLbit_i;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand4_2bf9e7ec", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nand4 (\n    input a,\n    input b,\n    input c,\n    input d,\n    output y\n);\n\n    wire temp;\n\n    assign temp = a & b & c & d;\n    assign y = ~temp;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ddr_interface_09be53e1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ddr_interface(\n   inout [14:0]         DDR_addr,\n   inout [2:0]          DDR_ba,\n   inout                DDR_cas_n,\n   inout                DDR_ck_n,\n   inout                DDR_ck_p,\n   inout                DDR_cke,\n   inout                DDR_cs_n,\n   inout [3:0]          DDR_dm,\n   inout [31:0]         DDR_dq,\n   inout [3:0]          DDR_dqs_n,\n   inout [3:0]          DDR_dqs_p,\n   inout                DDR_odt,\n   inout                DDR_ras_n,\n   inout                DDR_reset_n,\n   inout                DDR_we_n,\n   inout                FIXED_IO_ddr_vrn,\n   inout                FIXED_IO_ddr_vrp,\n   inout [53:0]         FIXED_IO_mio,\n   inout                FIXED_IO_ps_clk,\n   inout                FIXED_IO_ps_porb,\n   inout                FIXED_IO_ps_srstb,\n\n   input                PL_SGMII_REFCLK_125M_P,\n   input                PL_SGMII_REFCLK_125M_N,\n\n   output reg [1:0]     pl_led      ,\n   output reg [1:0]     pl_pmod\n);\n\n   reg [23:0] cnt_0;\n   reg [24:0] cnt_1;\n   reg [24:0] cnt_2;\n   reg [23:0] cnt_3;\n\n   always @(posedge FIXED_IO_ps_clk) begin\n     if (cnt_0 == 24'd8388607) cnt_0 <= 0;\n     else cnt_0 <= cnt_0 + 1'b1;\n   end\n   always @(posedge FIXED_IO_ps_clk) begin\n     if (cnt_1 == 25'd16777215) cnt_1 <= 0;\n     else cnt_1 <= cnt_1 + 1'b1;\n   end\n   always @(posedge FIXED_IO_ps_clk) begin\n     if (cnt_2 == 25'd33554431) cnt_2 <= 0;\n     else cnt_2 <= cnt_2 + 1'b1;\n   end\n   always @(posedge PL_SGMII_REFCLK_125M_P) begin\n     if (cnt_3 == 24'd16777215) cnt_3 <= 0;\n     else cnt_3 <= cnt_3 + 1'b1;\n   end\n\n   always @(cnt_0) begin\n     pl_led[0] = cnt_0[23];\n   end\n   always @(cnt_1) begin\n     pl_led[1] = cnt_1[24];\n   end\n   always @(cnt_2) begin\n     pl_pmod[0] = cnt_2[24];\n   end\n   always @(cnt_3) begin\n     pl_pmod[1] = cnt_3[23];\n   end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_carry_adder_2ad58563", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ripple_carry_adder(\n    input [7:0] a,\n    input [7:0] b,\n    input clk,\n    input rst,\n    output reg [8:0] sum\n);\n\nreg [8:0] carry;\n\nalways @ (posedge clk) begin\n    if (rst) begin\n        sum <= 0;\n        carry <= 0;\n    end else begin\n        {carry, sum} <= a + b + carry;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_93ef39ef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n    input clk,\n    input reset,\n    input [1:0] op,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [7:0] result,\n    output reg overflow\n);\n\n    // Use an intermediate variable for multiplication to capture the full result\n    reg [15:0] mult_result;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            result <= 0;\n            overflow <= 0;\n        end else begin\n            case (op)\n                2'b00: begin // Addition\n                    {overflow, result} <= operand1 + operand2;\n                end\n                2'b01: begin // Subtraction\n                    {overflow, result} <= {1'b0, operand1} - {1'b0, operand2};\n                    overflow <= overflow != result[7] && (operand1[7] != operand2[7]);\n                end\n                2'b10: begin // Multiplication\n                    mult_result <= operand1 * operand2;\n                    result <= mult_result[7:0]; // Assign the lower 8 bits to the result\n                    overflow <= |mult_result[15:8]; // Overflow if any of the upper 8 bits are set\n                end\n                2'b11: begin // Division\n                    if (operand2 == 0) begin\n                        result <= 0; // Define behavior for division by zero\n                        overflow <= 1; // Set overflow flag\n                    end else begin\n                        result <= operand1 / operand2;\n                        overflow <= 0; // Overflow is not applicable in normal division\n                    end\n                end\n                default: begin\n                    result <= 0;\n                    overflow <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "driver_b7312272", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule driver (clk, state, enable);\n\n\ninput clk;\ninput [6:0] state; output enable; reg enableReg; reg [2:0] settleTimeCntr;\nreg [4:0] enableOnCntr;\n\nreg settleTimeFlag; reg enableOnFlag; reg [6:0] stateLast; parameter SETTLE_TIME=3'b111;\nparameter ENABLE_ON_TIME=5'b11111;\n\ninitial begin\n\tstateLast=7'b0; settleTimeCntr=3'b0; enableOnCntr=5'b0; settleTimeFlag=1'b0; enableOnFlag=1'b0; enableReg=1'b0; end\n\nalways @(posedge clk) begin\n\tif(|(stateLast - state)) begin settleTimeCntr=3'b0;\n\t\t\n\t\tsettleTimeFlag=1'b1;\n\t\t\n\t\tstateLast=state; end\n\t\n\tif(settleTimeFlag) begin\n\t\tif(settleTimeCntr==SETTLE_TIME) begin\n\t\t\tsettleTimeFlag=1'b0; enableOnFlag=1'b1; settleTimeCntr=3'b0; enableOnCntr=5'b0;\n\t\tend else settleTimeCntr=settleTimeCntr+3'b1; end\n\t\n\tif(enableOnFlag) begin\n\t\tif(enableOnCntr==ENABLE_ON_TIME) begin\n\t\t\tenableReg=1'b0; enableOnFlag=1'b0; enableOnCntr=5'b0; end else begin\n\t\t\tenableReg=1'b1; enableOnCntr=enableOnCntr+5'b1; end\n\tend\nend\n\nassign enable=enableReg; endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_subtractor_7b5eabda", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule adder_subtractor (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  input Mode,\n  output [3:0] Sum,\n  output Cout\n);\n\n  wire [3:0] Adder_out;\n  wire [3:0] Sub_out;\n  wire [3:0] Twos_comp;\n  wire Mode_inv;\n\n  assign Mode_inv = ~Mode;\n\n  // Adder\n  assign Adder_out = A + B + Cin;\n\n  // Subtractor\n  assign Twos_comp = ~B + 1;\n  assign Sub_out = A - Twos_comp + Mode;\n\n  // Multiplexer\n  assign Sum = Mode_inv ? Adder_out : Sub_out;\n\n  // Carry out\n  assign Cout = Mode_inv ? Adder_out[3] : Sub_out[3];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__bufinv_18433002", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__bufinv (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "alu_0ea0a8cd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule alu(a,b,aluc,result\n\t);\n\tinput wire [31:0] a,b;\n\tinput wire [4:0] aluc;\n\toutput reg [31:0] result;\n\t\n\talways @*\n\tbegin\n\t\tcase(aluc)\n\t\t\t5'd0:result=a+b;\n\t\t\t5'd1:result=a+b;\n\t\t\t5'd2:result=a-b;\n\t\t\t5'd3:result=a-b;\n\t\t\t5'd4:result=a&b;\n\t\t\t5'd5:result=a|b;\n\t\t\t5'd6:result=a^b;\n\t\t\t5'd7:result=~(a|b);\n\t\t\t5'd8:result=a<b;\n\t\t\t5'd9:result=a<b;\n\t\t\t5'd10:result=b<<a;\n\t\t\t5'd11:result=b>>a;\n\t\t\t5'd12:begin\n\t\t\t\tcase(a[4:0])\n\t\t\t\t5'd0:result=b;\n\t\t\t\t5'd1:result={b[31],b[31:1]};\n\t\t\t\t5'd2:result={{2{b[31]}},b[31:2]};\n\t\t\t\t5'd3:result={{3{b[31]}},b[31:3]};\n\t\t\t\t5'd4:result={{4{b[31]}},b[31:4]};\n\t\t\t\t5'd5:result={{5{b[31]}},b[31:5]};\n\t\t\t\t5'd6:result={{6{b[31]}},b[31:6]};\n\t\t\t\t5'd7:result={{7{b[31]}},b[31:7]};\n\t\t\t\t5'd8:result={{8{b[31]}},b[31:8]};\n\t\t\t\t5'd9:result={{9{b[31]}},b[31:9]};\n\t\t\t\t5'd10:result={{10{b[31]}},b[31:10]};\n\t\t\t\t5'd11:result={{11{b[31]}},b[31:11]};\n\t\t\t\t5'd12:result={{12{b[31]}},b[31:12]};\n\t\t\t\t5'd13:result={{13{b[31]}},b[31:13]};\n\t\t\t\t5'd14:result={{14{b[31]}},b[31:14]};\n\t\t\t\t5'd15:result={{15{b[31]}},b[31:15]};\n\t\t\t\t5'd16:result={{16{b[31]}},b[31:16]};\n\t\t\t\t5'd17:result={{17{b[31]}},b[31:17]};\n\t\t\t\t5'd18:result={{18{b[31]}},b[31:18]};\n\t\t\t\t5'd19:result={{19{b[31]}},b[31:19]};\n\t\t\t\t5'd20:result={{20{b[31]}},b[31:20]};\n\t\t\t\t5'd21:result={{21{b[31]}},b[31:21]};\n\t\t\t\t5'd22:result={{22{b[31]}},b[31:22]};\n\t\t\t\t5'd23:result={{23{b[31]}},b[31:23]};\n\t\t\t\t5'd24:result={{24{b[31]}},b[31:24]};\n\t\t\t\t5'd25:result={{25{b[31]}},b[31:25]};\n\t\t\t\t5'd26:result={{26{b[31]}},b[31:26]};\n\t\t\t\t5'd27:result={{27{b[31]}},b[31:27]};\n\t\t\t\t5'd28:result={{28{b[31]}},b[31:28]};\n\t\t\t\t5'd29:result={{29{b[31]}},b[31:29]};\n\t\t\t\t5'd30:result={{30{b[31]}},b[31:30]};\n\t\t\t\t5'd31:result={32{b[31]}};\n\t\t\t\tendcase\n\t\t\tend\n\t\t\t5'd14:result={b[15:0],16'b0};\n\t\t\tdefault:\n\t\t\tbegin\n\t\t\t\tresult=0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__nand4b_19e2b096", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__nand4b (\n    Y  ,\n    A_N,\n    B  ,\n    C  ,\n    D\n);\n\n    output Y  ;\n    input  A_N;\n    input  B  ;\n    input  C  ;\n    input  D  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out   ;\n    wire nand0_out_Y;\n\n    not  not0  (not0_out   , A_N              );\n    nand nand0 (nand0_out_Y, D, C, B, not0_out);\n    buf  buf0  (Y          , nand0_out_Y      );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "falling_edge_detector_ea4c0bdf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule falling_edge_detector (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nalways @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n        out <= 0;\n    end else begin\n        out <= (in ^ (in & (in - 1))) & ~out;\n    end\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [31:0] in,\n    output [31:0] out\n);\n\nfalling_edge_detector detector (\n    .clk(clk),\n    .reset(reset),\n    .in(in),\n    .out(out)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rx_control_data_rdy_12369f58", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rx_control_data_rdy(\n\t\t\t\tinput posedge_clk,\n\t\t\t\tinput rx_resetn,\n\n\t\t\t\tinput rx_error_c,\n\t\t\t\tinput rx_error_d,\n\n\t\t\t\tinput [2:0] control,\n\t\t\t\tinput [2:0] control_l_r,\n\n\t\t\t\tinput is_control,\n\t\t\t\tinput [5:0] counter_neg,\n\t\t\t\tinput last_is_control,\n\n\t\t\t\toutput reg rx_error,\n\t\t\t\toutput reg ready_control_p_r,\n\t\t\t\toutput reg ready_data_p_r,\n\t\t\t\toutput reg rx_got_fct_fsm\n\t\t\t  );\n\nalways@(posedge posedge_clk or negedge rx_resetn)\nbegin\n\tif(!rx_resetn)\n\tbegin\n\t\trx_got_fct_fsm  <=  1'b0;\n\t\tready_control_p_r <= 1'b0;\n\t\tready_data_p_r  <=  1'b0;\n\t\trx_error <= 1'b0;\n\tend\n\telse\n\tbegin\n\n\t\trx_error <= rx_error_c | rx_error_d;\n\n\t\tif(counter_neg == 6'd4 && is_control)\n\t\tbegin\n\t\t\tready_control_p_r <= 1'b1;\n\t\t\tready_data_p_r <= 1'b0;\n\t\tend\n\t\telse if(counter_neg  == 6'd32)\n\t\tbegin\n\t\t\tready_control_p_r <= 1'b0;\n\t\t\tready_data_p_r <= 1'b1;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tready_control_p_r <= 1'b0;\n\t\t\tready_data_p_r <= 1'b0;\n\t\tend\n\n\t\tif((control_l_r[2:0] != 3'd7 && control[2:0] == 3'd4 && last_is_control == 1'b1 ) == 1'b1)\n\t\t\trx_got_fct_fsm <= 1'b1;\n\t\telse\n\t\t\trx_got_fct_fsm <= rx_got_fct_fsm;\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "JNOR3C_a9b6aef1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule JNOR3C(A1, A2, A3, A4, O);\ninput   A1;\ninput   A2;\ninput   A3;\ninput   A4;\noutput  O;\n\nwire    M1;\nwire    M2;\nwire    M3;\nwire    N1;\nwire    N2;\n\n// Implement majority gate using standard gates\nassign M1 = A1 & A2;\nassign M2 = A2 & A3;\nassign M3 = A1 & A3;\nassign N1 = ~(M1 | M2);\nassign N2 = ~(M1 | M3);\nassign O = ~(N1 | N2 | (A1 & A2 & A3 & A4));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MISTRAL_FF_f9c5cf53", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule MISTRAL_FF(\n    input DATAIN,\n     input CLK,\n    input ACLR, ENA, SCLR, SLOAD, SDATA,\n    output reg Q\n);\n\n`ifdef cyclonev\nspecify\n    if (ENA && ACLR !== 1'b0 && !SCLR && !SLOAD) (posedge CLK => (Q : DATAIN)) = 731;\n    if (ENA && SCLR) (posedge CLK => (Q : 1'b0)) = 890;\n    if (ENA && !SCLR && SLOAD) (posedge CLK => (Q : SDATA)) = 618;\n\n    $setup(DATAIN, posedge CLK,  0);\n    $setup(ENA, posedge CLK,  0);\n    $setup(SCLR, posedge CLK,  0);\n    $setup(SLOAD, posedge CLK,  0);\n    $setup(SDATA, posedge CLK,  0);\n\n    if (ACLR === 1'b0) (ACLR => Q) = 282;\nendspecify\n`endif\n`ifdef cyclone10gx\nspecify\n    if (ENA && ACLR !== 1'b0 && !SCLR && !SLOAD) (posedge CLK => (Q : DATAIN)) = 219;\n    if (ENA && SCLR) (posedge CLK => (Q : 1'b0)) = 219;\n    if (ENA && !SCLR && SLOAD) (posedge CLK => (Q : SDATA)) = 219;\n\n    $setup(DATAIN, posedge CLK, 268);\n    $setup(ENA, posedge CLK, 268);\n    $setup(SCLR, posedge CLK, 268);\n    $setup(SLOAD, posedge CLK, 268);\n    $setup(SDATA, posedge CLK, 268);\n\n    if (ACLR === 1'b0) (ACLR => Q) = 0;\nendspecify\n`endif\n\ninitial begin\n    Q = 0;\nend\n\nalways @(posedge CLK, negedge ACLR) begin\n    if (!ACLR) Q <= 0;\n    else if (ENA) begin\n        if (SCLR) Q <= 0;\n        else if (SLOAD) Q <= SDATA;\n        else Q <= DATAIN;\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_4142baeb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n  input clk,\n  input reset,\n  input ena,\n  output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n  if (reset) begin\n    q <= 4'b0000;\n  end else if (ena) begin\n    q <= q + 1;\n    if (q == 4'b1111) begin\n      q <= 4'b0000;\n    end\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_8e653aef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator (\n    input [3:0] A,\n    input [3:0] B,\n    output greater_than,\n    output less_than,\n    output equal_to,\n    output valid\n);\n\n    reg [1:0] result;\n    \n    always @* begin\n        if (A > B) begin\n            result = 2'b01;\n        end\n        else if (A < B) begin\n            result = 2'b10;\n        end\n        else begin\n            result = 2'b00;\n        end\n    end\n    \n    assign greater_than = (result == 2'b01);\n    assign less_than = (result == 2'b10);\n    assign equal_to = (result == 2'b00);\n    assign valid = (result != 2'b11);\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__51d95b81", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_module (\n    input input1,\n    input input2,\n    input [3:0] input3,\n    input [3:0] input4,\n    input [7:0] input5,\n    input [7:0] input6,\n    input [7:0] input7,\n    input [7:0] input8,\n    input [7:0] input9,\n    input [7:0] input10,\n    output reg [15:0] output1\n);\n\n    reg [3:0] sum1;\n    reg [47:0] concat1;\n\n    always @(*) begin\n        if (input2 == 0) begin\n            output1 = 0;\n        end else begin\n            output1 = input1;\n        end\n\n        sum1 = input3 + input4;\n        concat1 = {input5, input6, input7, input8, input9, input10};\n        output1 = output1 + {sum1, concat1};\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hs__sdlclkp_b1870005", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_hs__sdlclkp (\n    GCLK,\n    GATE,\n    CLK ,\n    SCE\n);\n\n    output GCLK;\n    input  GATE;\n    input  CLK ;\n    input  SCE ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    reg gate_state;\n\n    always @ (posedge SCE)\n    begin\n        gate_state <= GATE;\n    end\n\n    assign GCLK = (gate_state == 1'b1) ? CLK : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_carry_adder_2a14b4d0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ripple_carry_adder(\n    input [1:0] a,\n    input [1:0] b,\n    input cin,\n    output [1:0] sum,\n    output cout\n);\n\nassign {cout, sum} = a + b + cin;\n\nendmodule\nmodule detect_carry_adder(\n    input [1:0] a,\n    input [1:0] b,\n    input cin,\n    output p,\n    output g\n);\n\nassign p = a & b;\nassign g = a | b;\n\nendmodule\nmodule GDA_St_N8_M4_P2(\n    input [7:0] in1,\n    input [7:0] in2,\n    output [7:0] res\n);\n\nwire [1:0] temp1, temp2, temp3, temp4;\nwire g0, g1, g2, g3, g4, g5;\nwire p0, p1, p2, p3, p4, p5;\nwire p1g0, p3g2, p5g4;\nwire c2, c4, c6;\n\nripple_carry_adder rca_0(.a(in1[1:0]), .b(in2[1:0]), .cin(1'b0), .sum(temp1), .cout(c2));\nripple_carry_adder rca_1(.a(in1[3:2]), .b(in2[3:2]), .cin(c2), .sum(temp2), .cout(c4));\nripple_carry_adder rca_2(.a(in1[5:4]), .b(in2[5:4]), .cin(c4), .sum(temp3), .cout(c6));\nripple_carry_adder rca_3(.a(in1[7:6]), .b(in2[7:6]), .cin(c6), .sum(temp4), .cout());\n\ndetect_carry_adder dca_0(.a(in1[1:0]), .b(in2[1:0]), .cin(1'b0), .p(p0), .g(g0));\ndetect_carry_adder dca_1(.a(in1[1:0]), .b(in2[1:0]), .cin(p1g0), .p(p1), .g(g1));\ndetect_carry_adder dca_2(.a(in1[3:2]), .b(in2[3:2]), .cin(p1g0), .p(p2), .g(g2));\ndetect_carry_adder dca_3(.a(in1[3:2]), .b(in2[3:2]), .cin(p3g2), .p(p3), .g(g3));\ndetect_carry_adder dca_4(.a(in1[5:4]), .b(in2[5:4]), .cin(p3g2), .p(p4), .g(g4));\ndetect_carry_adder dca_5(.a(in1[5:4]), .b(in2[5:4]), .cin(p5g4), .p(p5), .g(g5));\n\nassign p1g0 = p1 & g0;\nassign p3g2 = p3 & g2;\nassign p5g4 = p5 & g4;\n\nassign res[1:0] = temp1;\nassign res[3:2] = temp2;\nassign res[5:4] = temp3;\nassign res[7:6] = temp4;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cf_add_e99343b9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule cf_add (\n  clk,\n  data_1,\n  data_2,\n  data_3,\n  data_4,\n  data_p,\n  ddata_in,\n  ddata_out);\n\n  parameter DELAY_DATA_WIDTH = 16;\n  parameter DW = DELAY_DATA_WIDTH - 1;\n\n  input           clk;\n  input   [24:0]  data_1;\n  input   [24:0]  data_2;\n  input   [24:0]  data_3;\n  input   [24:0]  data_4;\n  output  [ 7:0]  data_p;\n  input   [DW:0]  ddata_in;\n  output  [DW:0]  ddata_out;\n\n  reg     [DW:0]  p1_ddata = 'd0;\n  reg     [24:0]  p1_data_1 = 'd0;\n  reg     [24:0]  p1_data_2 = 'd0;\n  reg     [24:0]  p1_data_3 = 'd0;\n  reg     [24:0]  p1_data_4 = 'd0;\n  reg     [DW:0]  p2_ddata = 'd0;\n  reg     [24:0]  p2_data_0 = 'd0;\n  reg     [24:0]  p2_data_1 = 'd0;\n  reg     [DW:0]  p3_ddata = 'd0;\n  reg     [24:0]  p3_data = 'd0;\n  reg     [DW:0]  ddata_out = 'd0;\n  reg     [ 7:0]  data_p = 'd0;\n\n  wire    [24:0]  p1_data_1_p_s;\n  wire    [24:0]  p1_data_1_n_s;\n  wire    [24:0]  p1_data_1_s;\n  wire    [24:0]  p1_data_2_p_s;\n  wire    [24:0]  p1_data_2_n_s;\n  wire    [24:0]  p1_data_2_s;\n  wire    [24:0]  p1_data_3_p_s;\n  wire    [24:0]  p1_data_3_n_s;\n  wire    [24:0]  p1_data_3_s;\n  wire    [24:0]  p1_data_4_p_s;\n  wire    [24:0]  p1_data_4_n_s;\n  wire    [24:0]  p1_data_4_s;\n\n  assign p1_data_1_p_s = {1'b0, data_1[23:0]};\n  assign p1_data_1_n_s = ~p1_data_1_p_s + 1'b1;\n  assign p1_data_1_s = (data_1[24] == 1'b1) ? p1_data_1_n_s : p1_data_1_p_s;\n\n  assign p1_data_2_p_s = {1'b0, data_2[23:0]};\n  assign p1_data_2_n_s = ~p1_data_2_p_s + 1'b1;\n  assign p1_data_2_s = (data_2[24] == 1'b1) ? p1_data_2_n_s : p1_data_2_p_s;\n\n  assign p1_data_3_p_s = {1'b0, data_3[23:0]};\n  assign p1_data_3_n_s = ~p1_data_3_p_s + 1'b1;\n  assign p1_data_3_s = (data_3[24] == 1'b1) ? p1_data_3_n_s : p1_data_3_p_s;\n\n  assign p1_data_4_p_s = {1'b0, data_4[23:0]};\n  assign p1_data_4_n_s = ~p1_data_4_p_s + 1'b1;\n  assign p1_data_4_s = (data_4[24] == 1'b1) ? p1_data_4_n_s : p1_data_4_p_s;\n\n  always @(posedge clk) begin\n    p1_ddata <= ddata_in;\n    p1_data_1 <= p1_data_1_s;\n    p1_data_2 <= p1_data_2_s;\n    p1_data_3 <= p1_data_3_s;\n    p1_data_4 <= p1_data_4_s;\n  end\n\n  always @(posedge clk) begin\n    p2_ddata <= p1_ddata;\n    p2_data_0 <= p1_data_1 + p1_data_2;\n    p2_data_1 <= p1_data_3 + p1_data_4;\n  end\n\n  always @(posedge clk) begin\n    p3_ddata <= p2_ddata;\n    p3_data <= p2_data_0 + p2_data_1;\n  end\n\n  always @(posedge clk) begin\n    ddata_out <= p3_ddata;\n    if (p3_data[24] == 1'b1) begin\n      data_p <= 8'h00;\n    end else if (p3_data[23:20] == 'd0) begin\n      data_p <= p3_data[19:12];\n    end else begin\n      data_p <= 8'hff;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_02af291a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo\n   #(\n  \tparameter adr_width = 4,\n\tparameter dat_width = 8\n   )\n   (\n    input  clk, reset,\n    input  rd, wr,\n    input  [dat_width-1:0] data_in,\n    output [dat_width-1:0] data_out,\n    output empty, \n    output full\n   );\n\n   \n   parameter depth = (1 << adr_width);\n\n   reg [dat_width-1:0] array_reg [depth-1:0];reg [adr_width-1:0] w_ptr_reg, w_ptr_next;\n   reg [adr_width-1:0] r_ptr_reg, r_ptr_next;\n   reg full_reg, empty_reg, full_next, empty_next;\n   wire wr_en;\n\treg\t[1:0]\torden;\n\n\n   assign data_out = array_reg[r_ptr_reg];\n   assign wr_en = wr & ~full_reg;\n\n   assign full = full_reg;\n   assign empty = empty_reg;\n\n   always @(posedge clk) begin\n      if (wr_en)\n         array_reg[w_ptr_reg] <= data_in;\n   end\n\n   always @(posedge clk, posedge reset) begin\n      if (reset)\n         begin\n            w_ptr_reg <= 0;\n            r_ptr_reg <= 0;\n            full_reg <= 1'b0;\n            empty_reg <= 1'b1;\n         end\n      else\n         begin\n            w_ptr_reg <= w_ptr_next;\n            r_ptr_reg <= r_ptr_next;\n            full_reg <= full_next;\n            empty_reg <= empty_next;\n         end\n   end\n\n\talways @(posedge clk)\n\tbegin\n\t\tif(!wr&&rd)\n\t\tbegin\n\t\t\torden = 2'b01;\n\t\tend\n\t\tif(wr&&!rd)\n\t\tbegin\n\t\t\torden = 2'b10;\n\t\tend\n\t\tif(wr&&rd)\n\t\tbegin\n\t\t\torden = 2'b11;\n\t\tend\n\tend\n\n   \n   always @(posedge clk)\n   begin\n      if (reset) begin\n\tw_ptr_next =  0;\n        r_ptr_next =  0;       \n      end else begin\n\t      full_next = full_reg;\n\t      empty_next = empty_reg;\n\t      case (orden)\n\t\t 2'b01: if (~empty_reg) begin\n\t\t          r_ptr_next = r_ptr_reg + 1;\n\t\t          full_next = 1'b0;\n\t\t          if (r_ptr_next==w_ptr_reg)\n\t\t             empty_next = 1'b1;\n\t\t       end\n\t\t 2'b10: if (~full_reg) begin\n\t\t          w_ptr_next = w_ptr_reg + 1;\n\t\t          empty_next = 1'b0;\n\t\t          if (w_ptr_next==r_ptr_reg)\n\t\t             full_next = 1'b1;\n\t\t       end\n\t\t 2'b11: begin\n\t\t       w_ptr_next =  w_ptr_reg + 1;\n\t\t       r_ptr_next = r_ptr_reg + 1;\n\t\t    end\n\t      endcase\n\tend\n   end\n\n\n  \nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_7x_v1_3_qpll_reset #_597a5f47", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule pcie_7x_v1_3_qpll_reset #\n(\n\n    parameter PCIE_PLL_SEL       = \"CPLL\",                  parameter PCIE_POWER_SAVING  = \"TRUE\",                  parameter PCIE_LANE          = 1,                       parameter BYPASS_COARSE_OVRD = 1                        )\n\n(\n\n    input                           QRST_CLK,\n    input                           QRST_RST_N,\n    input                           QRST_MMCM_LOCK,\n    input       [PCIE_LANE-1:0]     QRST_CPLLLOCK,\n    input       [(PCIE_LANE-1)>>2:0]QRST_DRP_DONE,\n    input       [(PCIE_LANE-1)>>2:0]QRST_QPLLLOCK,\n    input       [ 1:0]              QRST_RATE,\n    input       [PCIE_LANE-1:0]     QRST_QPLLRESET_IN,\n    input       [PCIE_LANE-1:0]     QRST_QPLLPD_IN,\n\n    output                          QRST_OVRD,\n    output                          QRST_DRP_START,\n    output                          QRST_QPLLRESET_OUT,\n    output                          QRST_QPLLPD_OUT,\n    output                          QRST_IDLE,\n    output      [11:0]              QRST_FSM\n\n);\n\n    reg                             mmcm_lock_reg1;\n    reg         [PCIE_LANE-1:0]     cplllock_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg1;\n    reg         [ 1:0]              rate_reg1;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg1;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg1;\n\n    reg                             mmcm_lock_reg2;\n    reg         [PCIE_LANE-1:0]     cplllock_reg2;\n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg2;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg2;\n    reg         [ 1:0]              rate_reg2;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg2;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg2;\n\n    reg                             ovrd              =  1'd0;\n    reg                             qpllreset         =  1'd1;\n    reg                             qpllpd            =  1'd0;\n    reg         [11:0]              fsm               = 12'd2;\n\n    localparam                      FSM_IDLE          = 12'b000000000001;\n    localparam                      FSM_WAIT_LOCK     = 12'b000000000010;\n    localparam                      FSM_MMCM_LOCK     = 12'b000000000100;\n    localparam                      FSM_DRP_START_NOM = 12'b000000001000;\n    localparam                      FSM_DRP_DONE_NOM  = 12'b000000010000;\n    localparam                      FSM_QPLLLOCK      = 12'b000000100000;\n    localparam                      FSM_DRP_START_OPT = 12'b000001000000;\n    localparam                      FSM_DRP_DONE_OPT  = 12'b000010000000;\n    localparam                      FSM_QPLL_RESET    = 12'b000100000000;\n    localparam                      FSM_QPLLLOCK2     = 12'b001000000000;\n    localparam                      FSM_QPLL_PDRESET  = 12'b010000000000;\n    localparam                      FSM_QPLL_PD       = 12'b100000000000;\n\n\n\nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin\n        mmcm_lock_reg1    <=  1'd0;\n        cplllock_reg1     <= {PCIE_LANE{1'd1}};\n        drp_done_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};\n        qplllock_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};\n        rate_reg1         <=  2'd0;\n        qpllreset_in_reg1 <= {PCIE_LANE{1'd1}};\n        qpllpd_in_reg1    <= {PCIE_LANE{1'd0}};\n        mmcm_lock_reg2    <=  1'd0;\n        cplllock_reg2     <= {PCIE_LANE{1'd1}};\n        drp_done_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};\n        qplllock_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};\n        rate_reg2         <=  2'd0;\n        qpllreset_in_reg2 <= {PCIE_LANE{1'd1}};\n        qpllpd_in_reg2    <= {PCIE_LANE{1'd0}};\n        end\n    else\n        begin\n        mmcm_lock_reg1    <= QRST_MMCM_LOCK;\n        cplllock_reg1     <= QRST_CPLLLOCK;\n        drp_done_reg1     <= QRST_DRP_DONE;\n        qplllock_reg1     <= QRST_QPLLLOCK;\n        rate_reg1         <= QRST_RATE;\n        qpllreset_in_reg1 <= QRST_QPLLRESET_IN;\n        qpllpd_in_reg1    <= QRST_QPLLPD_IN;\n        mmcm_lock_reg2    <= mmcm_lock_reg1;\n        cplllock_reg2     <= cplllock_reg1;\n        drp_done_reg2     <= drp_done_reg1;\n        qplllock_reg2     <= qplllock_reg1;\n        rate_reg2         <= rate_reg1;\n        qpllreset_in_reg2 <= qpllreset_in_reg1;\n        qpllpd_in_reg2    <= qpllpd_in_reg1;\n        end\n\nend\n\n\n\nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin\n        fsm       <= FSM_WAIT_LOCK;\n        ovrd      <= 1'd0;\n        qpllreset <= 1'd1;\n        qpllpd    <= 1'd0;\n        end\n    else\n        begin\n\n        case (fsm)\n\n        FSM_IDLE :\n\n            begin\n            if (!QRST_RST_N)\n                begin\n                fsm       <= FSM_WAIT_LOCK;\n                ovrd      <= 1'd0;\n                qpllreset <= 1'd1;\n                qpllpd    <= 1'd0;\n                end\n            else\n                begin\n                fsm       <= FSM_IDLE;\n                ovrd      <= ovrd;\n                qpllreset <= &qpllreset_in_reg2;\n                qpllpd    <= &qpllpd_in_reg2;\n                end\n            end\n\n        FSM_WAIT_LOCK :\n\n            begin\n            fsm       <= ((&(~cplllock_reg2)) && (&(~qplllock_reg2)) ? FSM_MMCM_LOCK : FSM_WAIT_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_MMCM_LOCK :\n\n            begin\n            fsm       <= ((mmcm_lock_reg2 && (&cplllock_reg2)) ? FSM_DRP_START_NOM : FSM_MMCM_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_START_NOM:\n\n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_NOM : FSM_DRP_START_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_NOM :\n\n            begin\n            fsm       <= (&drp_done_reg2 ? FSM_QPLLLOCK : FSM_DRP_DONE_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_QPLLLOCK :\n\n            begin\n            fsm       <= (&qplllock_reg2 ? ((BYPASS_COARSE_OVRD == 1) ? FSM_QPLL_PDRESET : FSM_DRP_START_OPT) : FSM_QPLLLOCK);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_START_OPT:\n\n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_OPT : FSM_DRP_START_OPT);\n            ovrd      <= 1'd1;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_OPT :\n\n            begin\n            if (&drp_done_reg2)\n                begin\n                fsm       <= ((PCIE_PLL_SEL == \"QPLL\") ? FSM_QPLL_RESET : FSM_QPLL_PDRESET);\n                ovrd      <= ovrd;\n                qpllreset <= (PCIE_PLL_SEL == \"QPLL\");\n                qpllpd    <= qpllpd;\n                end\n            else\n                begin\n                fsm       <= FSM_DRP_DONE_OPT;\n                ovrd      <= ovrd;\n                qpllreset <= qpllreset;\n                qpllpd    <= qpllpd;\n                end\n            end\n\n        FSM_QPLL_RESET :\n\n            begin\n            fsm       <= (&(~qplllock_reg2) ? FSM_QPLLLOCK2 : FSM_QPLL_RESET);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd1;\n            qpllpd    <= 1'd0;\n            end\n\n        FSM_QPLLLOCK2 :\n\n            begin\n            fsm       <= (&qplllock_reg2 ? FSM_IDLE : FSM_QPLLLOCK2);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n\n        FSM_QPLL_PDRESET :\n\n            begin\n            fsm       <= FSM_QPLL_PD;\n            ovrd      <= ovrd;\n            qpllreset <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_QPLL_PD :\n\n            begin\n            fsm       <= FSM_IDLE;\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0;\n            end\n\n        default :\n\n            begin\n            fsm       <= FSM_WAIT_LOCK;\n            ovrd      <= 1'd0;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n\n        endcase\n\n        end\n\nend\n\n\n\nassign QRST_OVRD          = ovrd;\nassign QRST_DRP_START     = (fsm == FSM_DRP_START_NOM) || (fsm == FSM_DRP_START_OPT);\nassign QRST_QPLLRESET_OUT = qpllreset;\nassign QRST_QPLLPD_OUT    = ((PCIE_POWER_SAVING == \"FALSE\") ? 1'd0 : qpllpd);\nassign QRST_IDLE          = (fsm == FSM_IDLE);\nassign QRST_FSM           = fsm;\n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_15f2b0ba", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n    input clk,\n    output reg [3:0] Q\n);\n\nreg [3:0] Q_reg1, Q_reg2, Q_reg3;\n\nalways @(posedge clk) begin\n    Q_reg1 <= Q;\nend\n\nalways @(posedge clk) begin\n    Q_reg2 <= Q_reg1;\nend\n\nalways @(posedge clk) begin\n    Q_reg3 <= Q_reg2;\nend\n\nalways @(posedge clk) begin\n    if (Q_reg3 == 4'b1111) begin\n        Q <= 4'b0000;\n    end else begin\n        Q <= Q_reg3 + 1;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "LUT1_9a742ba5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule LUT1 (\n    input I0,\n    output O\n);\n\nassign O = (I0 == 1'b1) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule shift_register\n(\n    input [8:0]in,\n    output [8:0]out,\n    input clk\n);\n\nreg [8:0]shift_reg;\n\nassign out[8] = shift_reg[8];\nassign out[7] = shift_reg[7];\nassign out[6] = shift_reg[6];\nassign out[5] = shift_reg[5];\nassign out[4] = shift_reg[4];\nassign out[3] = shift_reg[3];\nassign out[2] = shift_reg[2];\nassign out[1] = shift_reg[1];\nassign out[0] = shift_reg[0];\n\nalways @(posedge clk) begin\n    shift_reg <= {shift_reg[7:0], in[8]};\nend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "softusb_timer_78fd7a03", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule softusb_timer(\n\tinput usb_clk,\n\tinput usb_rst,\n\n\tinput io_we,\n\tinput [5:0] io_a,\n\toutput reg [7:0] io_do\n);\n\nreg [31:0] counter;\n\nalways @(posedge usb_clk) begin\n\tif(usb_rst) begin\n\t\tcounter <= 32'd0;\n\t\tio_do <= 8'd0;\n\tend else begin\n\t\tio_do <= 8'd0;\n\t\tcase(io_a)\n\t\t\t6'h20: io_do <= counter[7:0];\n\t\t\t6'h21: io_do <= counter[15:8];\n\t\t\t6'h22: io_do <= counter[23:16];\n\t\t\t6'h23: io_do <= counter[31:24];\n\t\tendcase\n\t\tif(io_we & ((io_a == 6'h20)|(io_a == 6'h21)|(io_a == 6'h22)|(io_a == 6'h23)))\n\t\t\tcounter <= 32'd0;\n\t\telse\n\t\t\tcounter <= counter + 32'd1;\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "scan_chain_interface_88ae7d9b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule scan_chain_interface (\n    input ctu_tst_pre_grst_l,\n    input arst_l,\n    input global_shift_enable,\n    input ctu_tst_scan_disable,\n    input ctu_tst_scanmode,\n    input ctu_tst_macrotest,\n    input ctu_tst_short_chain,\n    input long_chain_so_0,\n    input short_chain_so_0,\n    input long_chain_so_1,\n    input short_chain_so_1,\n    input long_chain_so_2,\n    input short_chain_so_2,\n    output mux_drive_disable,\n    output mem_write_disable,\n    output sehold,\n    output se,\n    output testmode_l,\n    output mem_bypass,\n    output so_0,\n    output so_1,\n    output so_2\n);\n\n    wire pin_based_scan;\n    wire short_chain_en;\n    wire short_chain_select;\n\n    assign pin_based_scan = ctu_tst_scan_disable;\n    assign se = global_shift_enable;\n    assign testmode_l = ~ctu_tst_scanmode;\n    assign mem_bypass = ~ctu_tst_macrotest & ~testmode_l;\n    assign short_chain_en = ~(pin_based_scan & se);\n    assign short_chain_select = ctu_tst_short_chain & ~testmode_l & short_chain_en;\n    assign so_0 = short_chain_select ? short_chain_so_0 : long_chain_so_0;\n    assign so_1 = short_chain_select ? short_chain_so_1 : long_chain_so_1;\n    assign so_2 = short_chain_select ? short_chain_so_2 : long_chain_so_2;\n    assign mux_drive_disable = ~ctu_tst_pre_grst_l | short_chain_select | se;\n    assign mem_write_disable = ~ctu_tst_pre_grst_l | se;\n    assign sehold = ctu_tst_macrotest & ~se;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4x1_6e56b68d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4x1(\n    input clk,\n    input rst,\n    input sel0,\n    input sel1,\n    input [143:0] port0_ci,\n    input [143:0] port1_ci,\n    input [143:0] port2_ci,\n    input [143:0] port3_ci,\n    output reg [143:0] port_co\n    );\n\n  always @(posedge clk, posedge rst) begin\n    if (rst) begin\n      port_co <= 144'h000000000000000000000000000000000000;\n    end else begin\n      case ({sel1, sel0})\n        2'b00: port_co <= port0_ci;\n        2'b01: port_co <= port1_ci;\n        2'b10: port_co <= port2_ci;\n        2'b11: port_co <= port3_ci;\n      endcase\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_gate_8b58eda3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule xor_gate (\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output reg XOR_output\n);\n\n    always @(*) begin\n        XOR_output = VPB ^ VNB;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Clock_Divider_c09e9e36", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Clock_Divider(\n    input clock,\n    input reset,\n    output reg clock_out\n);\n\nreg [1:0] counter;\nalways @(posedge clock or posedge reset) begin\n    if (reset) begin\n        counter <= 2'b0;\n        clock_out <= 1'b0;\n    end else begin\n        counter <= counter + 1;\n        if (counter == 2'b10) begin\n            counter <= 2'b0;\n            clock_out <= ~clock_out;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_7x_v1_3_fast_cfg_init_cntr #_6ba54a9d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pcie_7x_v1_3_fast_cfg_init_cntr #(\n  parameter PATTERN_WIDTH = 8,\n  parameter INIT_PATTERN  = 8'hA5,\n  parameter TCQ           = 1\n) (\n  input                          clk,\n  input                          rst,\n  output reg [PATTERN_WIDTH-1:0] pattern_o\n);\n\nalways @(posedge clk) begin\n  if(rst) begin\n    pattern_o <= #TCQ {PATTERN_WIDTH{1'b0}};\n  end else begin\n    if(pattern_o != INIT_PATTERN) begin\n      pattern_o <= #TCQ pattern_o + 1;\n    end\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dual_edge_triggered_ff_ef2ce85c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dual_edge_triggered_ff (\n  input clk,\n  input reset,\n  input data,\n  output reg q\n);\n\nreg q1, q2;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    q1 <= 1'b0;\n    q2 <= 1'b0;\n  end else begin\n    q1 <= data;\n    q2 <= q1;\n  end\nend\n\nalways @(negedge clk) begin\n  if (reset) begin\n    q <= 1'b0;\n  end else begin\n    q <= q2;\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "profibus_master_2efca194", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule profibus_master (\n  input clk,\n  input reset,\n  input [7:0] tx_data,\n  output reg tx_en,\n  output reg tx_done\n);\n\n  // Define Profibus frame format\n  parameter FRAME_START = 8'hFF;\n  parameter FRAME_END = 8'hFF;\n  parameter FRAME_ADDR = 8'h00;\n  parameter FRAME_CONTROL = 8'h00;\n  parameter FRAME_DATA_LEN = 8'h01;\n  \n  // Define internal signals\n  reg [7:0] tx_frame [0:10];\n  reg [3:0] tx_state;\n  reg tx_busy;\n  \n  // Initialize internal signals\n  initial begin\n    tx_frame[0] = FRAME_START;\n    tx_frame[1] = FRAME_ADDR;\n    tx_frame[2] = FRAME_CONTROL;\n    tx_frame[3] = FRAME_DATA_LEN;\n    tx_frame[4] = tx_data;\n    tx_frame[5] = FRAME_END;\n    tx_state = 0;\n    tx_busy = 0;\n  end\n  \n  // State machine for transmitting Profibus frame\n  always @(posedge clk) begin\n    if (reset) begin\n      tx_state <= 0;\n      tx_busy <= 0;\n    end else begin\n      case (tx_state)\n        0: begin // Idle state\n          if (tx_busy) begin\n            tx_state <= 1;\n          end\n        end\n        1: begin // Send start of frame\n          tx_en <= 1;\n          if (tx_done) begin\n            tx_state <= 2;\n          end\n        end\n        2: begin // Send address and control bytes\n          tx_en <= 1;\n          if (tx_done) begin\n            tx_state <= 3;\n          end\n        end\n        3: begin // Send data length and data\n          tx_en <= 1;\n          if (tx_done) begin\n            tx_state <= 4;\n          end\n        end\n        4: begin // Send end of frame\n          tx_en <= 1;\n          if (tx_done) begin\n            tx_state <= 0;\n            tx_busy <= 0;\n          end\n        end\n      endcase\n    end\n  end\n  \n  // Trigger transmission of Profibus frame\n  always @(posedge clk) begin\n    if (reset) begin\n      tx_busy <= 0;\n    end else begin\n      if (!tx_busy && tx_state == 0) begin\n        tx_busy <= 1;\n      end\n    end\n  end\n  \nendmodule\nmodule profibus_slave (\n  input clk,\n  input reset,\n  input [7:0] rx_data,\n  output reg rx_en,\n  output wire rx_done\n);\n\n  // Define Profibus frame format\n  parameter FRAME_START = 8'hFF;\n  parameter FRAME_END = 8'hFF;\n  parameter FRAME_ADDR = 8'h00;\n  parameter FRAME_CONTROL = 8'h00;\n  parameter FRAME_DATA_LEN = 8'h01;\n  \n  // Define internal signals\n  reg [7:0] rx_frame [0:10];\n  reg [3:0] rx_state;\n  wire rx_busy;\n  \n  // Initialize internal signals\n  initial begin\n    rx_state = 0;\n  end\n  \n  // State machine for receiving Profibus frame\n  always @(posedge clk) begin\n    if (reset) begin\n      rx_state <= 0;\n    end else begin\n      case (rx_state)\n        0: begin // Idle state\n          if (rx_busy) begin\n            rx_state <= 1;\n          end\n        end\n        1: begin // Wait for start of frame\n          rx_en <= 1;\n          if (rx_done && rx_data == FRAME_START) begin\n            rx_frame[0] <= rx_data;\n            rx_state <= 2;\n          end\n        end\n        2: begin // Receive address and control bytes\n          rx_en <= 1;\n          if (rx_done) begin\n            rx_frame[1] <= rx_data;\n            rx_frame[2] <= rx_data;\n            rx_state <= 3;\n          end\n        end\n        3: begin // Receive data length and data\n          rx_en <= 1;\n          if (rx_done) begin\n            rx_frame[3] <= rx_data;\n            rx_frame[4] <= rx_data;\n            rx_state <= 4;\n          end\n        end\n        4: begin // Wait for end of frame\n          rx_en <= 1;\n          if (rx_done && rx_data == FRAME_END) begin\n            rx_frame[5] <= rx_data;\n            rx_state <= 0;\n          end\n        end\n      endcase\n    end\n  end\n  \n  // Trigger reception of Profibus frame\n  assign rx_busy = (rx_state != 0);\n  \n  assign rx_done = (rx_state == 4) && (rx_data == FRAME_END);\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "simple_cpu_2c0a4153", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule simple_cpu(\n    input clk,\n    input reset,\n    input [7:0] address,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n\nreg [15:0] accumulator;\nreg [7:0] program_counter;\n\nreg [15:0] memory [255:0];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        accumulator <= 16'b0;\n        program_counter <= 8'b0;\n    end else begin\n        case (memory[program_counter])\n            3'h0: accumulator <= accumulator + memory[address];\n            3'h1: accumulator <= accumulator - memory[address];\n            3'h2: accumulator <= accumulator & memory[address];\n            3'h3: accumulator <= accumulator | memory[address];\n            3'h4: accumulator <= accumulator ^ memory[address];\n            3'h5: accumulator <= memory[address];\n            3'h6: memory[address] <= accumulator;\n            default: accumulator <= accumulator;\n        endcase\n        program_counter <= program_counter + 1;\n    end\nend\n\nassign data_out = accumulator;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__9aa193d1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input d1,\n    input d2,\n    input reset,\n    input [15:0] in1,\n    input [15:0] in2,\n    output reg q1,\n    output reg q2,\n    output [15:0] out_xor,\n    output [15:0] out_and,\n    output [15:0] out_final\n );\n\n    // Define the T flip-flop for D1\n    reg t1;\n    always @(posedge clk) begin\n        if (reset) begin\n            q1 <= 0;\n        end else begin\n            q1 <= t1;\n        end\n    end\n    always @(posedge clk) begin\n        if (reset) begin\n            t1 <= 0;\n        end else begin\n            t1 <= d1;\n        end\n    end\n    \n    // Define the JK flip-flop for D2\n    reg j2, k2;\n    always @(posedge clk) begin\n        if (reset) begin\n            q2 <= 0;\n        end else begin\n            j2 <= d2;\n            k2 <= ~d2;\n            if (j2 && k2) begin\n                q2 <= ~q2;\n            end else if (j2) begin\n                q2 <= 1;\n            end else if (k2) begin\n                q2 <= 0;\n            end\n        end\n    end\n    \n    // Define the combinational circuit for XOR and AND\n    assign out_xor = in1 ^ in2;\n    assign out_and = in1 & in2;\n    \n    // Define the functional module for bitwise OR\n    assign out_final = q2 | out_and;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_gate_e8e83455", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule xor_gate (\n    input wire a,\n    input wire b,\n    output wire  out\n);\n\n    assign out = a ^ b;\n\nendmodule\nmodule byte_reversal (\n    input wire [31:0] in,\n    output wire  [31:0] out\n);\n\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\nmodule functional_module (\n    input wire  in1,\n    input wire [31:0] in2,\n    output wire  [31:0] out\n);\n\n    assign out = {31'b0, in1} | in2;\n\nendmodule\nmodule top_module (\n    input wire a,\n    input wire b,\n    input wire [31:0] in,\n    input wire select,\n    output wire [31:0] out\n);\n\n    wire out_xor;\n    wire [31:0] byte_rev_out;\n    wire [31:0] func_out;\n\n    xor_gate xor_inst (\n        .a(a),\n        .b(b),\n        .out(out_xor)\n    );\n\n    byte_reversal byte_rev_inst (\n        .in(in),\n        .out(byte_rev_out)\n    );\n\n    functional_module func_inst (\n        .in1(out_xor),\n        .in2(byte_rev_out),\n        .out(func_out)\n    );\n\n    assign out = (select) ? func_out : {31'b0, out_xor};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "BitsliceALU_b0dc94d5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule BitsliceALU (\n    input  [15:0] A,\n    input  [15:0] B,\n    input  [5:0] Op,\n    output [15:0] Q,\n    output [2:0] Flags\n);\n\n    wire [15:0] result;\n    wire [3:0] X, Y;\n    wire [4:0] C;\n    wire [3:0] Z;\n    wire [3:0] C_out;\n\n    Circuit74181b slice3 (\n        .a(A[15:12]),\n        .b(B[15:12]),\n        .c(Op[4:1]),\n        .d(C[2]),\n        .e(Op[5]),\n        .f(1'b0),\n        .g(result[15:12]),\n        .h(X[3]),\n        .i(Y[3]),\n        .j(C[3])\n    );\n    Circuit74181b slice2 (\n        .a(A[11:8]),\n        .b(B[11:8]),\n        .c(Op[4:1]),\n        .d(C[1]),\n        .e(Op[5]),\n        .f(1'b0),\n        .g(result[11:8]),\n        .h(X[2]),\n        .i(Y[2]),\n        .j(C[2])\n    );\n    Circuit74181b slice1 (\n        .a(A[7:4]),\n        .b(B[7:4]),\n        .c(Op[4:1]),\n        .d(C[0]),\n        .e(Op[5]),\n        .f(1'b0),\n        .g(result[7:4]),\n        .h(X[1]),\n        .i(Y[1]),\n        .j(C[1])\n    );\n    Circuit74181b slice0 (\n        .a(A[3:0]),\n        .b(B[3:0]),\n        .c(Op[4:1]),\n        .d(Op[5]),\n        .e(Op[0]),\n        .f(1'b0),\n        .g(result[3:0]),\n        .h(X[0]),\n        .i(Y[0]),\n        .j(C[0])\n    );\n\n    assign Q = result;\n\n    assign Flags[0] = ~C_out[3];\n    assign Flags[1] = result[15];\n    assign Flags[2] = (result == 16'h0000);\n\n    assign C_out[0] = C[0];\n    assign C_out[1] = C[1] | (C[0] & ~Y[1]);\n    assign C_out[2] = C[2] | (C[1] & ~Y[2]) | (C[0] & ~Y[1] & ~Y[2]);\n    assign C_out[3] = C[3] | (C[2] & ~Y[3]) | (C[1] & ~Y[2] & ~Y[3]) | (C[0] & ~Y[1] & ~Y[2] & ~Y[3]);\nendmodule\nmodule Circuit74181b (\n    input [3:0] a,\n    input [3:0] b,\n    input [3:0] c,\n    input d,\n    input e,\n    input [1:0] f,\n    output [3:0] g,\n    output h,\n    output i,\n    output j\n);\n    wire [3:0] P, G;\n\n    assign P[0] = a[0] & b[0];\n    assign P[1] = a[1] & b[1];\n    assign P[2] = a[2] & b[2];\n    assign P[3] = a[3] & b[3];\n\n    assign G[0] = a[0] | b[0];\n    assign G[1] = a[1] | b[1];\n    assign G[2] = a[2] | b[2];\n    assign G[3] = a[3] | b[3];\n\n    assign g[0] = P[0];\n    assign g[1] = P[1] | (P[0] & G[1]);\n    assign g[2] = P[2] | (P[1] & G[2]) | (P[0] & G[1] & G[2]);\n    assign g[3] = P[3] | (P[2] & G[3]) | (P[1] & G[2] & G[3]) | (P[0] & G[1] & G[2] & G[3]);\n\n    assign h = c[0];\n    assign i = e & f[0];\n    assign j = ~e | ~f[1];\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sram_e84a1d0a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sram (\n\tclock,\n\tdata,\n\trdaddress,\n\twraddress,\n\twren,\n\tq);\n\n\tinput\t  clock;\n\tinput\t[15:0]  data;\n\tinput\t[11:0]  rdaddress;\n\tinput\t[11:0]  wraddress;\n\tinput\t  wren;\n\toutput reg [15:0]  q;\n\n\treg [15:0] mem [0:(1<<12)-1];\n\n\talways @(posedge clock) begin\n\t\tif (wren) begin\n\t\t\tmem[wraddress] <= data;\n\t\tend else begin\n\t\t\tq <= mem[rdaddress];\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rst_generator_3f5a5829", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rst_generator(\n    input       clk,            input       rst_i,          output  reg rst_o           );\n\n    reg [6:0] counter_r;\n    reg       rst_i_sync_0;\n    reg       rst_i_sync_1;\n\n  initial begin\n        rst_o     <= 1'b0;\n        counter_r <= 7'b0;\n    end\n\n    always @(posedge clk) begin\n        rst_i_sync_0 <= rst_i;\n        rst_i_sync_1 <= rst_i_sync_0;\n\n        if (rst_o != rst_i_sync_1) begin\n            counter_r <= counter_r + 7'b1;\n        end\n        else begin\n            counter_r <= 7'b0;\n        end\n\n        if (counter_r == 7'h7F) begin\n            rst_o <= ~rst_o;\n        end\n        else begin\n            rst_o <= rst_o;\n        end\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "eth_outputcontrol_d239338d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule eth_outputcontrol(Clk, Reset, InProgress, ShiftedBit, BitCounter, WriteOp, NoPre, MdcEn_n, Mdo, MdoEn);\n\ninput         Clk;                // Host Clock\ninput         Reset;              // General Reset\ninput         WriteOp;            // Write Operation Latch (When asserted, write operation is in progress)\ninput         NoPre;              // No Preamble (no 32-bit preamble)\ninput         InProgress;         // Operation in progress\ninput         ShiftedBit;         // This bit is output of the shift register and is connected to the Mdo signal\ninput   [6:0] BitCounter;         // Bit Counter\ninput         MdcEn_n;            // MII Management Data Clock Enable signal is asserted for one Clk period before Mdc falls.\n\noutput        Mdo;                // MII Management Data Output\noutput        MdoEn;              // MII Management Data Output Enable\n\nwire          SerialEn;\n\nreg           MdoEn_2d;\nreg           MdoEn_d;\nreg           MdoEn;\n\nreg           Mdo_2d;\nreg           Mdo_d;\nreg           Mdo;                // MII Management Data Output\n\n// Generation of the Serial Enable signal (enables the serialization of the data)\nassign SerialEn =  WriteOp & InProgress & ( BitCounter>31 | ( ( BitCounter == 0 ) & NoPre ) )\n                | ~WriteOp & InProgress & (( BitCounter>31 & BitCounter<46 ) | ( ( BitCounter == 0 ) & NoPre ));\n\n// Generation of the MdoEn signal.\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      MdoEn_2d <= 1'b0;\n      MdoEn_d <= 1'b0;\n      MdoEn <= 1'b0;\n    end\n  else\n    begin\n      if(MdcEn_n)\n        begin\n          MdoEn_2d <= SerialEn | InProgress & BitCounter<32;\n          MdoEn_d <= MdoEn_2d;\n          MdoEn <= MdoEn_d;\n        end\n    end\nend\n\n// Generation of the Mdo signal.\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    begin\n      Mdo_2d <= 1'b0;\n      Mdo_d <= 1'b0;\n      Mdo <= 1'b0;\n    end\n  else\n    begin\n      if(MdcEn_n)\n        begin\n          Mdo_2d <= ~SerialEn & BitCounter<32;\n          Mdo_d <= ShiftedBit | Mdo_2d;\n          Mdo <= Mdo_d;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_5e5772e0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule barrel_shifter (\n    input [7:0] data_in,\n    input [1:0] shift_amt,\n    input shift_dir,\n    input enable,\n    output [7:0] data_out\n);\n\nreg [7:0] data_out_int;\n\nalways @(*) begin\n    if (enable) begin\n        if (shift_dir) begin\n            data_out_int = data_in << shift_amt;\n        end else begin\n            data_out_int = data_in >> shift_amt;\n        end\n    end else begin\n        data_out_int = data_in;\n    end\nend\n\nassign data_out = data_out_int;\n\nendmodule\n\nmodule up_down_counter (\n    input clk,\n    input rst,\n    input load,\n    input up_down,\n    input [7:0] data_in,\n    output [7:0] data_out\n);\n\nreg [7:0] count;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 0;\n    end else if (load) begin\n        count <= data_in;\n    end else begin\n        if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nend\n\nassign data_out = count;\n\nendmodule\n\nmodule bitwise_and (\n    input [7:0] data_in1,\n    input [7:0] data_in2,\n    output [7:0] data_out\n);\n\nassign data_out = data_in1 & data_in2;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "addr_gen_e221f5ad", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule addr_gen(nrst, clk, wr_en, wr_inc, load_w2r, rd_inc, rd_step, addr_wr, addr_rd, wr_end);\n    input nrst;\n    input clk;\n    input wr_en;\n    input wr_inc;\n    input load_w2r;\n    input rd_inc;\n    input [7:0] rd_step;\n    output [17:0] addr_wr;\n    output [17:0] addr_rd;\n    output wr_end;\n    \n    wire [17:0] addr_wr;\n    wire [17:0] addr_rd;\n    wire [17:0] rd_step_ex;\n    reg wr_end;\n    wire wr_inc_sig;\n    wire reach;\n    \n    // \u5199\u5730\u5740\u8fd4\u56de\u5230\u8bfb\u5730\u5740\u8868\u793a\u5199\u6ee1\uff0c\u5b9e\u73b0\u9884\u89e6\u53d1\u6df1\u5ea6\u8c03\u6574\u662f\u89e6\u53d1\u540e\u7acb\u5373\u4fee\u6539\u8bfb\u5730\u5740\u5230\u9700\u8981\u4f4d\u7f6e\n    assign reach = (addr_wr == addr_rd);\n    assign wr_inc_sig = wr_en & wr_inc & ~wr_end;\n    \n    assign rd_step_ex = {{11{rd_step[7]}}, rd_step[6:0]};\n    \n    // \u5199\u5730\u5740\u81ea\u589e\n    cnt #(18) u_wrcnt(.nrst(nrst), .clk(clk),\n        .en(wr_inc_sig), .step(1), .load(0), .cin(0), .cnt(addr_wr));\n    \n    // \u89e6\u53d1\u65f6\u8bbe\u7f6e\u8bfb\u5730\u5740\u4e3a\u5199\u5730\u5740\uff0c\u5426\u5219\u81ea\u589e\u6216\u81ea\u51cf\n    cnt #(18) u_rdcnt(.nrst(nrst), .clk(clk),\n        .en(rd_inc), .step(rd_step_ex), .load(load_w2r), .cin(addr_wr), .cnt(addr_rd));\n    \n    // \u751f\u6210\u91c7\u6837\u5b8c\u6210\u4fe1\u53f7\uff0c\u5728\u505c\u6b62\u91c7\u6837\u65f6\u6e05\u9664\n    always @(posedge clk or negedge nrst) begin\n        if (~nrst) begin\n            wr_end <= 1'b0;\n        end else if (reach) begin\n            wr_end <= 1'b1;\n        end else if (~wr_en) begin\n            wr_end <= 1'b0;\n        end\n    end\nendmodule\nmodule cnt #(parameter WIDTH = 8)\n(\n    input nrst,\n    input clk,\n    input en,\n    input [WIDTH-1:0] step,\n    input load,\n    input [WIDTH-1:0] cin,\n    output reg [WIDTH-1:0] cnt\n);\n\n    always @(posedge clk or negedge nrst) begin\n        if (~nrst) begin\n            cnt <= 'b0;\n        end else if (load) begin\n            cnt <= cin;\n        end else if (en) begin\n            cnt <= cnt + step;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "OAI21X1_3e58a631", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule OAI21X1 (input IN1, IN2, IN3, output QN, input VDD, VSS);\n\n  wire a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z;\n\n  assign a = IN1 | IN2;\n  assign b = ~a;\n  assign c = ~IN2;\n  assign d = c | IN3;\n  assign e = b & d;\n  assign f = ~c;\n  assign g = f & IN3;\n  assign h = e | g;\n  assign i = ~h;\n  assign j = i & VDD;\n  assign k = ~VSS;\n  assign l = j & k;\n  assign m = ~l;\n  assign n = m & VDD;\n  assign o = ~VSS;\n  assign p = n & o;\n  assign q = ~p;\n  assign r = q & VDD;\n  assign s = ~VSS;\n  assign t = r & s;\n  assign u = ~t;\n  assign v = u & VDD;\n  assign w = ~VSS;\n  assign x = v & w;\n  assign y = ~x;\n  assign z = y & VDD;\n\n  assign QN = z & ~VSS;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux32bits_32to1_69eaa406", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux32bits_32to1 (\n  input [4:0] s,\n  input [31:0] i31,\n  input [31:0] i30,\n  input [31:0] i29,\n  input [31:0] i28,\n  input [31:0] i27,\n  input [31:0] i26,\n  input [31:0] i25,\n  input [31:0] i24,\n  input [31:0] i23,\n  input [31:0] i22,\n  input [31:0] i21,\n  input [31:0] i20,\n  input [31:0] i19,\n  input [31:0] i18,\n  input [31:0] i17,\n  input [31:0] i16,\n  input [31:0] i15,   \n  input [31:0] i14,\n  input [31:0] i13,\n  input [31:0] i12,\n  input [31:0] i11,\n  input [31:0] i10,\n  input [31:0] i9 ,\n  input [31:0] i8 ,\n  input [31:0] i7 ,\n  input [31:0] i6 ,\n  input [31:0] i5 ,\n  input [31:0] i4 ,\n  input [31:0] i3 ,\n  input [31:0] i2 ,\n  input [31:0] i1 ,\n  input [31:0] i0 ,\n  output reg [31:0] z\n);\n\n  always @(*) begin\n    case (s)\n      5'b00001: z <= i0;\n      5'b00010: z <= i1;\n      5'b00011: z <= i2;\n      5'b00100: z <= i3;\n      5'b00101: z <= i4;\n      5'b00110: z <= i5;\n      5'b00111: z <= i6;\n      5'b01000: z <= i7;\n      5'b01001: z <= i8;\n      5'b01010: z <= i9;\n      5'b01011: z <= i10;\n      5'b01100: z <= i11;\n      5'b01101: z <= i12;\n      5'b01110: z <= i13;\n      5'b01111: z <= i14;\n      5'b10000: z <= i15;\n      5'b10001: z <= i16;\n      5'b10010: z <= i17;\n      5'b10011: z <= i18;\n      5'b10100: z <= i19;\n      5'b10101: z <= i20;\n      5'b10110: z <= i21;\n      5'b10111: z <= i22;\n      5'b11000: z <= i23;\n      5'b11001: z <= i24;\n      5'b11010: z <= i25;\n      5'b11011: z <= i26;\n      5'b11100: z <= i27;\n      5'b11101: z <= i28;\n      5'b11110: z <= i29;\n      5'b11111: z <= i30;\n      default:  z <= 0;\n    endcase\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hdll__einvn_083e6873", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hdll__einvn (\n    Z   ,\n    A   ,\n    TE_B\n);\n\n    output Z   ;\n    input  A   ;\n    input  TE_B;\n\n    notif0 notif00 (Z     , A, TE_B        );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_4bit_e7e50ed7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter_4bit(clk, rst, q);\n\ninput clk, rst;\noutput reg [3:0] q;\n\nalways @(posedge clk) begin\n\tif (rst == 1'b1) // Synchronous reset\n\t\tq <= 4'b0;\n\telse if (q == 4'b1111) // Counter rolls over to 0\n\t\tq <= 4'b0;\n\telse\n\t\tq <= q + 1; // Counter increments\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_cc4a7249", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module(\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    input [3:0] data6,\n    input [3:0] data7,\n    output [3:0] out\n);\n\n// 8-to-1 MUX implementation\nassign out = (sel == 3'd0) ? data0 :\n             (sel == 3'd1) ? data1 :\n             (sel == 3'd2) ? data2 :\n             (sel == 3'd3) ? data3 :\n             (sel == 3'd4) ? data4 :\n             (sel == 3'd5) ? data5 :\n             (sel == 3'd6) ? data6 :\n                             data7;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_6b6b905f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder(\n    input clk,\n    input [63:0] probe0,\n    input [63:0] probe1,\n    input [0:0] probe2,\n    input [0:0] probe3,\n    input [0:0] probe4,\n    input [0:0] probe5,\n    input [0:0] probe6,\n    input [63:0] probe7,\n    input [0:0] probe8,\n    input [0:0] probe9,\n    input [0:0] probe10,\n    input [0:0] probe11,\n    input [63:0] probe12,\n    input [0:0] probe13,\n    input [0:0] probe14,\n    input [0:0] probe15,\n    input [0:0] probe16,\n    input [0:0] probe17,\n    input [7:0] probe18,\n    input [8:0] probe19,\n    input [0:0] probe20,\n    input [2:0] probe21,\n    input [2:0] probe22,\n    input [0:0] probe23,\n    input [7:0] probe24,\n    output reg [63:0] output0,\n    output reg output1,\n    output reg [63:0] output2,\n    output reg [7:0] output3,\n    output reg [8:0] output4\n);\n\nalways @(posedge clk) begin\n    output0 <= {probe0, probe1};\n    output1 <= &{probe2, probe3, probe4, probe5, probe6};\n    output2 <= {probe7, probe12};\n    output3 <= {probe18, probe24};\n    output4 <= {probe19, probe21, probe22};\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_flip_flop_7c645a11", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule d_flip_flop (\n    input D,\n    input CLK,\n    input SET,\n    input RESET,\n    input CE,\n    output reg Q,\n    output reg Q_N\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Flip-flop implementation\n    always @(posedge CLK or negedge CE) begin\n        if (CE == 0) begin\n            Q <= Q;\n            Q_N <= Q_N;\n        end else if (SET == 0) begin\n            Q <= 1'b1;\n            Q_N <= 1'b0;\n        end else if (RESET == 0) begin\n            Q <= 1'b0;\n            Q_N <= 1'b1;\n        end else begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "a23_multiply_29907fe6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule a23_multiply (\ninput                       i_clk,\ninput                       i_fetch_stall,\n\ninput       [31:0]          i_a_in,         input       [31:0]          i_b_in,         input       [1:0]           i_function,\ninput                       i_execute,\n\noutput      [31:0]          o_out,\noutput      [1:0]           o_flags,        output reg                  o_done = 'd0    );\n\n\nwire        enable;\nwire        accumulate;\nwire [33:0] multiplier;\nwire [33:0] multiplier_bar;\nwire [33:0] sum;\nwire [33:0] sum34_b;\n\nreg  [5:0]  count = 'd0;\nreg  [5:0]  count_nxt;\nreg  [67:0] product = 'd0;\nreg  [67:0] product_nxt;\nreg  [1:0]  flags_nxt;\nwire [32:0] sum_acc1;           assign enable         = i_function[0];\nassign accumulate     = i_function[1];\n \nassign multiplier     =  { 2'd0, i_a_in} ;\nassign multiplier_bar = ~{ 2'd0, i_a_in} + 34'd1 ;\n\nassign sum34_b        =  product[1:0] == 2'b01 ? multiplier     :\n                         product[1:0] == 2'b10 ? multiplier_bar :\n                                                 34'd0          ;\n\n\n`ifdef XILINX_FPGA\n    `ifdef XILINX_SPARTAN6_FPGA\n        xs6_addsub_n #(.WIDTH(34)) \n    `endif\n    `ifdef XILINX_VIRTEX6_FPGA\n        xv6_addsub_n #(.WIDTH(34))  \n    `endif\n        \n        u_xx_addsub_34_sum (\n        .i_a    ( product[67:34]        ),\n        .i_b    ( sum34_b               ),\n        .i_cin  ( 1'd0                  ),\n        .i_sub  ( 1'd0                  ),\n        .o_sum  ( sum                   ),\n        .o_co   (                       )\n    );\n\n    `ifdef XILINX_SPARTAN6_FPGA\n        xs6_addsub_n #(.WIDTH(33)) \n    `endif\n    `ifdef XILINX_VIRTEX6_FPGA\n        xv6_addsub_n #(.WIDTH(33)) \n    `endif\n        u_xx_addsub_33_acc1 (\n        .i_a    ( {1'd0, product[32:1]} ),\n        .i_b    ( {1'd0, i_a_in}        ),\n        .i_cin  ( 1'd0                  ),\n        .i_sub  ( 1'd0                  ),\n        .o_sum  ( sum_acc1              ),\n        .o_co   (                       )\n    );\n\n`else\n \n    assign sum =  product[67:34] + sum34_b;\n     \n    assign sum_acc1 = {1'd0, product[32:1]} + {1'd0, i_a_in};\n     \n`endif\n\n\nalways @*\n    begin\n    count_nxt           = count;\n    product_nxt         = product;\n    \n    flags_nxt   = { product[32], product[32:1] == 32'd0 }; \n    \n\n    if ( count == 6'd0 )\n        product_nxt = {33'd0, 1'd0, i_b_in, 1'd0 } ;\n    else if ( count <= 6'd33 )\n        product_nxt = { sum[33], sum, product[33:1]} ;\n    else if ( count == 6'd34 && accumulate )\n        begin\n        product_nxt         = { product[64:33], sum_acc1[31:0], 1'd0}; end\n        \n    if (count == 6'd0)  count_nxt   = enable ? 6'd1 : 6'd0;\n    else if ((count == 6'd34 && !accumulate) ||  (count == 6'd35 &&  accumulate)  )  count_nxt   = 6'd0;\n    else\n        count_nxt   = count + 1'd1;\n    end\n\n\nalways @ ( posedge i_clk )\n    if ( !i_fetch_stall )\n        begin\n        count           <= i_execute ? count_nxt          : count;           \n        product         <= i_execute ? product_nxt        : product;        \n        o_done          <= i_execute ? count == 6'd31     : o_done;          \n        end\n\nassign o_out   = product[32:1]; \nassign o_flags = flags_nxt;\n                     \nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dct_processor_dd5690eb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule dct_processor (\n  input clk,\n  input [29:0] dct_buffer,\n  input [3:0] dct_count,\n  input test_ending,\n  input test_has_ended,\n  output [15:0] current_coefficient,\n  output [3:0] total_coefficients\n);\n\n  reg [29:0] dct_buffer_reg;\n  reg [3:0] dct_count_reg;\n  reg [15:0] current_coefficient_reg;\n  reg [3:0] total_coefficients_reg;\n  reg processing;\n  \n  always @(posedge clk) begin\n    if (test_ending == 1) begin\n      processing <= 0;\n    end else if (processing == 1 && dct_count_reg == 0) begin\n      processing <= 0;\n    end else if (processing == 0 && dct_count_reg > 0) begin\n      processing <= 1;\n    end\n  end\n  \n  always @(posedge clk) begin\n    if (processing == 1) begin\n      current_coefficient_reg <= dct_buffer_reg[15:0];\n      dct_buffer_reg <= {dct_buffer_reg[14:0], 1'b0};\n      dct_count_reg <= dct_count_reg - 1;\n      if (dct_count_reg == 0) begin\n        total_coefficients_reg <= total_coefficients_reg + 1;\n      end\n    end else begin\n      current_coefficient_reg <= 0;\n      dct_buffer_reg <= dct_buffer;\n      dct_count_reg <= dct_count;\n      total_coefficients_reg <= 0;\n    end\n  end\n  \n  assign current_coefficient = current_coefficient_reg;\n  assign total_coefficients = total_coefficients_reg;\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_08a5011c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo\n(\n    input  clk,            // bus clock\n    input  reset,          // reset\n    input  [15:0] in,      // data in\n    output reg [15:0] out, // data out\n    input  rd,             // read from fifo\n    input  wr,             // write to fifo\n    output reg empty,      // fifo is empty\n    output reg full,       // fifo is full\n    output [11:0] cnt      // number of entries in FIFO\n);\n\n    // local signals and registers\n    reg  [15:0] mem [2047:0]; // 2048 words by 16 bit wide fifo memory (for 2 MFM-encoded sectors)\n    reg  [11:0] in_ptr;       // fifo input pointer\n    reg  [11:0] out_ptr;      // fifo output pointer\n    wire equal;               // lower 11 bits of in_ptr and out_ptr are equal\n\n    // count of FIFO entries\n    assign cnt = in_ptr - out_ptr;\n\n    // main fifo memory (implemented using synchronous block ram)\n    always @(posedge clk)\n    if (wr)\n        mem[in_ptr[10:0]] <= in;\n\n    always @(posedge clk)\n    out=mem[out_ptr[10:0]];\n\n    // fifo write pointer control\n    always @(posedge clk)\n    if (reset)\n        in_ptr[11:0] <= 0;\n    else if(wr)\n        in_ptr[11:0] <= in_ptr[11:0] + 12'd1;\n\n    // fifo read pointer control\n    always @(posedge clk)\n    if (reset)\n        out_ptr[11:0] <= 0;\n    else if (rd)\n        out_ptr[11:0] <= out_ptr[11:0] + 12'd1;\n\n    // check lower 11 bits of pointer to generate equal signal\n    assign equal = (in_ptr[10:0]==out_ptr[10:0]) ? 1'b1 : 1'b0;\n\n    // assign output flags, empty is delayed by one clock to handle ram delay\n    always @(posedge clk)\n    if (equal && (in_ptr[11]==out_ptr[11]))\n        empty <= 1'b1;\n    else\n        empty <= 1'b0;\n    \n    always @(posedge clk)\n    if (equal && (in_ptr[11]!=out_ptr[11]))\n        full <= 1'b1;\n    else\n        full <= 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "uart_rx_d88c1233", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule uart_rx (\n  input clk,\n  input reset,\n  input rxd,\n  output reg ack,\n  output reg [7:0] rx_data,\n  output reg rx_full\n);\n\n  parameter IDLE = 2'd0;\n  parameter START = 2'd1;\n  parameter DATA = 2'd2;\n  parameter STOP = 2'd3;\n  \n  reg [1:0] state;\n  reg [2:0] bit_count;\n  reg [7:0] data_bits;\n  reg stop_bit;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      bit_count <= 0;\n      data_bits <= 0;\n      stop_bit <= 1;\n      rx_full <= 0;\n    end else begin\n      case (state)\n        IDLE: begin\n          if (!rxd) begin\n            state <= START;\n            bit_count <= 0;\n            data_bits <= 0;\n            stop_bit <= 1;\n          end\n        end\n        START: begin\n          if (bit_count == 0) begin\n            if (!rxd) begin\n              bit_count <= bit_count + 1;\n            end\n          end else if (bit_count < 9) begin\n            data_bits[bit_count-1] <= rxd;\n            bit_count <= bit_count + 1;\n          end else if (bit_count == 9) begin\n            stop_bit <= rxd;\n            bit_count <= bit_count + 1;\n          end else begin\n            state <= DATA;\n            bit_count <= 0;\n          end\n        end\n        DATA: begin\n          if (bit_count < 8) begin\n            data_bits[bit_count] <= rxd;\n            bit_count <= bit_count + 1;\n          end else begin\n            state <= STOP;\n            bit_count <= 0;\n          end\n        end\n        STOP: begin\n          if (bit_count == 0) begin\n            if (rxd == stop_bit) begin\n              ack <= 1;\n              rx_data <= data_bits;\n              rx_full <= 1;\n            end else begin\n              ack <= 0;\n              rx_data <= 0;\n              rx_full <= 0;\n            end\n            state <= IDLE;\n          end else begin\n            bit_count <= bit_count + 1;\n          end\n        end\n      endcase\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "initial_config_91499612", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define REG_SIZE 20\nmodule initial_config(\n\niCLK, iRST_n, oINITIAL_START,\niINITIAL_ENABLE,\n);\n\n\ninput iCLK;\ninput iRST_n;\noutput oINITIAL_START;\ninput\tiINITIAL_ENABLE;\n\nwire oINITIAL_START;\nreg [`REG_SIZE-1:0] cnt;\n\nalways@(posedge iCLK or negedge iRST_n)\n\tbegin\n\t\tif (!iRST_n)\n\t\t\tbegin \n\t\t\t\tcnt <= 0;\n\t\t\tend\n\t\telse if (cnt == 20'hfffff)\n\n\t\t\tbegin\n\t\t\t\tcnt <=20'hfffff;\n\n\t\t\tend\n\t\telse\n\t\t\tbegin\n\t\t\t\tcnt <= cnt + 1;\t\n\t\t\tend\n\tend\n\t\n\t\nassign oINITIAL_START = ((cnt == 20'hffffe)&iINITIAL_ENABLE) ? 1'b1: 1'b0;\n\n\nendmodule\n\n\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__o31ai_6b4963a1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__o31ai (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A2, A1, A3     );\n    nand nand0 (nand0_out_Y, B1, or0_out    );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_interface_bae50a22", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule memory_interface(clka, wea, addra, dina, douta);\n  parameter MEM_SIZE = 2**8; // 14-bit address gives 2^14 memory locations\n  parameter MEM_WIDTH = 12; // each memory location holds 1 byte of data\n  reg [MEM_WIDTH-1:0] mem [0:MEM_SIZE-1]; // declare memory array\n\n  input clka;\n  input  wea;\n  input [7:0] addra;\n  input [MEM_WIDTH-1:0] dina;\n  output reg [MEM_WIDTH-1:0] douta;\n\n  always @(posedge clka) begin\n    if (wea == 1'b1) begin // write to memory\n      mem[addra] <= dina;\n    end\n    douta <= mem[addra];\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FrameWriter_ac8ef0da", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule FrameWriter (\n\tinput clk,\n\tinput rst,\n\n\tinput [23:0] din_data,\n\tinput din_valid,\n\toutput wire din_ready,\n\tinput wire din_sop,\n\tinput wire din_eop,\n\t\n\toutput wire [DATA_WIDTH-1:0] data_fifo_out,\n\toutput wire data_valid_fifo_out,\n\tinput wire [FIFO_DEPTH_LOG2:0] usedw_fifo_out,\n\t\n\tinput start,\n\toutput endf\n);\n\n\tparameter DATA_WIDTH = 32;\n\tparameter FIFO_DEPTH = 256;\n\tparameter FIFO_DEPTH_LOG2 = 8;\n\n\treg video_reg;\n\twire set_video;\n\twire reset_video;\n\t\n\treg [1:0] run;\n\n\talways @ (posedge clk) begin\n\t\tif (start == 1) begin\n\t\t\tvideo_reg <= 0;\n\t\tend\telse begin\n\t\t\tif (reset_video == 1) begin\n\t\t\t\tvideo_reg <= 0;\n\t\t\tend \n\t\t\tif (set_video == 1) begin\n\t\t\t\tvideo_reg <= 1;\n\t\t\tend \n\t\tend\n\tend\n\t\n\talways @ (posedge clk or posedge rst) begin\n\t\tif (rst == 1) begin\n\t\t\trun <= 0;\n\t\tend else begin\n\t\t\tif (start == 1) begin\n\t\t\t\trun <= 1;\n\t\t\tend else begin\n\t\t\t\tif (reset_video == 1) begin\n\t\t\t\t\trun <= 2;\n\t\t\t\tend\n\t\t\t\tif (endf == 1) begin\n\t\t\t\t\trun <= 0;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\t\n\tassign set_video = (din_sop == 1) & (din_data == 0) & (din_valid == 1) & (run == 1);\n\tassign reset_video = (din_eop == 1) & (din_valid == 1) & (video_reg == 1);\n\t\n\tassign data_fifo_out = {8'd0, din_data};\n\tassign data_valid_fifo_out = (video_reg == 1) & (din_valid == 1) & (run == 1);\n\n\tassign din_ready = (usedw_fifo_out < (FIFO_DEPTH - 1));\n\t\n\tassign endf = (run == 2);\n   \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_ae1b12d9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top(clk,a,b,c,set);\nparameter A_WIDTH = 6 ;\nparameter B_WIDTH = 6 ;\ninput set;\ninput clk;\ninput signed [(A_WIDTH - 1):0] a;\ninput signed [(B_WIDTH - 1):0] b;\noutput signed [(A_WIDTH + B_WIDTH - 1):0] c;\nreg [(A_WIDTH + B_WIDTH - 1):0] reg_tmp_c;\nassign c = reg_tmp_c;\nalways @(posedge clk)\nbegin\n    if(set)\n    begin\n        reg_tmp_c <= 0;\n    end\n    else\n    begin\n        reg_tmp_c <= a * b + c;\n    end\nend\nendmodule\n\nmodule top2(clk,a,b,c,hold);\nparameter A_WIDTH = 6 ;\nparameter B_WIDTH = 6 ;\ninput hold;\ninput clk;\ninput signed [(A_WIDTH - 1):0] a;\ninput signed [(B_WIDTH - 1):0] b;\noutput signed [(A_WIDTH + B_WIDTH - 1):0] c;\nreg signed [A_WIDTH-1:0] reg_a;\nreg signed [B_WIDTH-1:0] reg_b;\nreg [(A_WIDTH + B_WIDTH - 1):0] reg_tmp_c;\nassign c = reg_tmp_c;\nalways @(posedge clk)\nbegin\n    if (!hold) begin\n        reg_a <= a;\n        reg_b <= b;\n        reg_tmp_c <= reg_a * reg_b + c;\n    end\nend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter #_82a46624", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule counter #(\n    parameter AWIDTH = 8 // Change to a constant value\n)(\n    input clk,\n    input ce,\n    output reg [7:0] q\n);\n\n\nwire [AWIDTH-1:0] addr;\nwire ce0;\nwire [7:0] data;\n\nassign addr = q;\nassign ce0 = ce;\n\n// Instantiate the ROM module\nLoop_loop_height_jbC_rom rom (\n    .addr0(addr),\n    .ce0(ce0),\n    .q0(data),\n    .clk(clk)\n);\n\n// Update the counter value\nalways @(posedge clk) begin\n    if (ce) begin\n        q <= q + 1;\n    end\nend\n\nendmodule\nmodule Loop_loop_height_jbC_rom (\n    input [7:0] addr0,\n    input ce0,\n    output reg [7:0] q0,\n    input clk\n);\n\n    // ROM contents\n    reg [7:0] rom [0:255];\n\n   \n    always @(posedge clk) begin\n        if (ce0) begin\n            q0 <= rom[addr0];\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_shift_1f1580d6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ripple_shift (\n    input clk,\n    input reset,\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    input [2:0] parallel_load,\n    input shift,\n    input control,\n    output [3:0] sum,\n    output cout,\n    output [2:0] out,\n    output [2:0] xor_result\n);\n\n    // Ripple Carry Adder\n    wire [3:0] ripple_sum;\n    wire ripple_cout;\n    ripple_adder ripple_adder_inst(.A(A), .B(B), .cin(cin), .sum(ripple_sum), .cout(ripple_cout));\n\n    // Shift Register\n    reg [2:0] shift_reg;\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 3'b0;\n        end else if (parallel_load != 3'b0) begin\n            shift_reg <= parallel_load;\n        end else if (shift) begin\n            if (control) begin\n                shift_reg <= {shift_reg[1:0], 1'b0};\n            end else begin\n                shift_reg <= {1'b0, shift_reg[2:1]};\n            end\n        end\n    end\n\n    // XOR Module\n    assign xor_result = ripple_sum ^ shift_reg;\n\n    // Output Assignments\n    assign sum = ripple_sum;\n    assign cout = ripple_cout;\n    assign out = shift_reg ^ ripple_sum;\n\nendmodule\nmodule ripple_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [3:0] full_sum;\n    wire carry1, carry2, carry3;\n\n    assign {carry1, full_sum[0]} = A[0] + B[0] + cin;\n    assign {carry2, full_sum[1]} = A[1] + B[1] + carry1;\n    assign {carry3, full_sum[2]} = A[2] + B[2] + carry2;\n    assign {cout, full_sum[3]} = A[3] + B[3] + carry3;\n\n    assign sum = full_sum;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipeline_splitter_fc581f70", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipeline_splitter (\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo,\n    input wire clk\n);\n\nwire [15:0] stage1_out;\nwire [7:0] stage2_out;\n\npipeline_stage1 stage1(.in(in), .clk(clk), .out(stage1_out));\npipeline_stage2 stage2(.in(stage1_out[7:0]), .clk(clk), .out(stage2_out));\n\nassign out_hi = stage2_out;\nassign out_lo = stage1_out[15:8];\n\nendmodule\n\nmodule pipeline_stage1 (\n    input wire [15:0] in,\n    input wire clk,\n    output reg [15:0] out\n);\n\nalways @ (posedge clk) begin\n    out <= in;\nend\n\nendmodule\n\nmodule pipeline_stage2 (\n    input wire [7:0] in,\n    input wire clk,\n    output reg [7:0] out\n);\n\nalways @ (posedge clk) begin\n    out <= in;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplier_30308bef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiplier (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [7:0] result\n);\n    \n    reg [7:0] temp;\n    reg [3:0] i, j;\n    \n    always @(*) begin\n        temp = 8'b0;\n        for (i = 0; i < 4; i = i + 1) begin\n            for (j = 0; j < 4; j = j + 1) begin\n                if ((a[i] == 1) && (b[j] == 1)) begin\n                    temp[i+j] = temp[i+j] + 1;\n                end\n            end\n        end\n        \n        for (i = 0; i < 7; i = i + 1) begin\n            if (temp[i] == 2) begin\n                temp[i] = 0;\n                temp[i+1] = temp[i+1] + 1;\n            end\n        end\n    end\n    \n    always @* begin\n        result = temp;\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hvl__a21oi_beb96dc1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hvl__a21oi (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_4bit_f8c81419", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator_4bit (\n    input [3:0] in_a,\n    input [3:0] in_b,\n    input clk,\n    output eq,\n    output gt,\n    output lt\n);\n\nreg [3:0] a_reg, b_reg;\nreg eq_reg, gt_reg, lt_reg;\n\nalways @(posedge clk) begin\n    a_reg <= in_a;\n    b_reg <= in_b;\nend\n\nalways @(posedge clk) begin\n    if (a_reg == b_reg) begin\n        eq_reg <= 1'b1;\n        gt_reg <= 1'b0;\n        lt_reg <= 1'b0;\n    end else if (a_reg > b_reg) begin\n        eq_reg <= 1'b0;\n        gt_reg <= 1'b1;\n        lt_reg <= 1'b0;\n    end else begin\n        eq_reg <= 1'b0;\n        gt_reg <= 1'b0;\n        lt_reg <= 1'b1;\n    end\nend\n\nassign eq = eq_reg;\nassign gt = gt_reg;\nassign lt = lt_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "karnaugh_map_ef45779b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule karnaugh_map(\n  input wire A, B, C, D, E,\n  output reg F\n);\n\nalways @(*) begin\n  case ({A,B,C,D,E})\n    5'b00000: F = 1;\n    5'b00001: F = 0;\n    5'b00011: F = 0;\n    5'b00010: F = 0;\n    5'b00110: F = 0;\n    5'b00111: F = 1;\n    5'b00101: F = 1;\n    5'b00100: F = 0;\n    5'b01100: F = 0;\n    5'b01101: F = 1;\n    5'b01111: F = 1;\n    5'b01110: F = 1;\n    5'b01010: F = 1;\n    5'b01011: F = 1;\n    5'b01001: F = 1;\n    5'b01000: F = 0;\n    5'b11000: F = 1;\n    5'b11001: F = 0;\n    5'b11011: F = 0;\n    5'b11010: F = 0;\n    5'b11110: F = 1;\n    5'b11111: F = 1;\n    5'b11101: F = 0;\n    5'b11100: F = 0;\n    5'b10100: F = 0;\n    5'b10101: F = 0;\n    5'b10111: F = 0;\n    5'b10110: F = 0;\n    5'b10010: F = 1;\n    5'b10011: F = 1;\n    5'b10001: F = 0;\n    5'b10000: F = 0;\n    default: F = 0;\n  endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_86929f13", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_gate (\n  input a,\n  input b,\n  input rst,\n  output out\n);\n\n  reg out_reg;\n\n  always @(a, b, rst) begin\n    if (rst == 1'b0) begin\n      out_reg <= 1'b0;\n    end else begin\n      out_reg <= a & b;\n    end\n  end\n\n  assign out = out_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DispScan_f031f7bb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule DispScan\n(\n\tinput clk,en,\n\tinput [3:0]in0,in1,in2,in3,\n\tinput indip,\n\toutput reg [3:0]select,out,\n\toutput reg outdip\n);\n\n\treg\t\t[1:0]state;\n\n\tlocalparam S0 = 0, S1 = 1, S2 = 2, S3 = 3;\n\n\talways @ (state or en) \n\tbegin\n\t\tif (en)\n\t\t\tbegin\n\t\t\tcase (state)\n\t\t\t\tS0:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tselect <= 4'b0001;\n\t\t\t\t\t\tout[3:0] <= in0[3:0];\n\t\t\t\t\t\toutdip <= 0;\n\t\t\t\t\tend\n\t\t\t\tS1:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tselect <= 4'b0010;\n\t\t\t\t\t\tout[3:0] <= in1[3:0];\n\t\t\t\t\t\tif(indip)\n\t\t\t\t\t\t   outdip <= 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\toutdip <= 0;\n\t\t\t\t\tend\t\n\t\t\t\tS2:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tselect <= 4'b0100;\n\t\t\t\t\t\tout[3:0] <= in2[3:0];\n\t\t\t\t\t\toutdip <= 0;\n\t\t\t\t\tend\n\t\t\t\tS3:\n\t\t\t\t\tbegin\n\t\t\t\t\t\tselect <= 4'b1000;\n\t\t\t\t\t\tout[3:0] <= in3[3:0];\n\t\t\t\t\t\toutdip <= 0;\n\t\t\t\t\tend\n\t\t\t\tdefault:\n\t\t\t\t\t{out, outdip} = 5'b00000;\n\t\t\tendcase\n\t\t\tend\n\t\telse\n\t\t\t{select, outdip} <= 5'b00000;\n\tend\n\n\talways @ (posedge clk) begin\n\t\tcase (state)\n\t\t\tS0:\n\t\t\t\tstate <= S1;\n\t\t\tS1:\n\t\t\t\tstate <= S2;\n\t\t\tS2:\n\t\t\t\tstate <= S3;\n\t\t\tS3:\n\t\t\t\tstate <= S0;\n\t\tendcase\n\tend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__o2111a_f0a3eba5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_ls__o2111a (\n    //# {{data|Data Signals}}\n    input  A1,\n    input  A2,\n    input  B1,\n    input  C1,\n    input  D1,\n    output X\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Intermediate signals\n    wire and1_out;\n    wire and2_out;\n    wire and3_out;\n    wire and4_out;\n    wire or1_out;\n\n    // AND gates\n    and and1 (and1_out, A1, A2);\n    and and2 (and2_out, B1, C1);\n    and and3 (and3_out, C1, D1);\n    and and4 (and4_out, and1_out, and2_out, and3_out);\n\n    // OR gate\n    or or1 (X, and4_out);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "aurora_201_CHANNEL_ERROR_DETECT_fabbd8c9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule aurora_201_CHANNEL_ERROR_DETECT\n(\n    SOFT_ERROR,\n    HARD_ERROR,\n    LANE_UP,\n\n\n    USER_CLK,\n    POWER_DOWN,\n\n    CHANNEL_SOFT_ERROR,\n    CHANNEL_HARD_ERROR,\n\n\n    RESET_CHANNEL\n);\n\n`define DLY #1\n\n\ninput              SOFT_ERROR;\n    input              HARD_ERROR;\n    input              LANE_UP;\n\n\n    input              USER_CLK;\n    input              POWER_DOWN;\n\n    output             CHANNEL_SOFT_ERROR;\n    output             CHANNEL_HARD_ERROR;\n\n\n    output             RESET_CHANNEL;\n\n\nreg                CHANNEL_SOFT_ERROR;\n    reg                CHANNEL_HARD_ERROR;\n    reg                RESET_CHANNEL;\n\n\nreg                soft_error_r;\n    reg                hard_error_r;\n\n\nwire               channel_soft_error_c;\n    wire               channel_hard_error_c;\n    wire               reset_channel_c;\n\n\nalways @(posedge USER_CLK)\n    begin\n        soft_error_r    <=  `DLY    SOFT_ERROR;\n        hard_error_r    <=  `DLY    HARD_ERROR;\n    end\n\n\n\n    initial\n        CHANNEL_SOFT_ERROR = 1'b1;\n\n    assign channel_soft_error_c = soft_error_r;\n\n    always @(posedge USER_CLK)\n        CHANNEL_SOFT_ERROR  <=  `DLY    channel_soft_error_c;\n\n\n\n    initial\n        CHANNEL_HARD_ERROR = 1'b1;\n\n    assign channel_hard_error_c = hard_error_r;\n\n    always @(posedge USER_CLK)\n        CHANNEL_HARD_ERROR  <=  `DLY    channel_hard_error_c;\n\n\n\n\n    initial\n        RESET_CHANNEL   =  1'b1;\n\n    assign reset_channel_c = !LANE_UP;\n\n    always @(posedge USER_CLK)\n        RESET_CHANNEL    <=  `DLY    reset_channel_c | POWER_DOWN;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_545dccbb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter(\n    input clk,\n    input reset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DelayLoop_c898e7ac", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule DelayLoop(Clear, Timeout, CLOCK);\n    input Clear, CLOCK;\n    output reg Timeout;\n    parameter COUNT_MAX = 100; //change this value to change the delay time\n    \n    reg [7:0] count;\n    \n    always @(posedge CLOCK) begin\n        if(Clear) begin\n            count <= 0;\n            Timeout <= 0;\n        end\n        else begin\n            if(count == COUNT_MAX) begin\n                count <= 0;\n                Timeout <= 1;\n            end\n            else begin\n                count <= count + 1;\n                Timeout <= 0;\n            end\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_logic_gate_21de8a3a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_logic_gate (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    D1 \n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n\n\n    wire and1;\n    wire and2;\n    wire or1;\n\n    and base(\n        .Y(and1),\n        .A(A1),\n        .B(A2),\n        .C(B1),\n        .D(C1),\n        .E(D1)\n    );\n\n    and and_gate1(\n        .Y(and2),\n        .A(B1),\n        .B(C1),\n        .C(D1)\n    );\n\n    or or_gate1(\n        .Y(Y),\n        .A(and1),\n        .B(and2)\n    );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "modbus_7723d332", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule modbus (\n  input clk,\n  input rst,\n  input en,\n  input [7:0] addr,\n  input [7:0] data_in,\n  output [7:0] data_out,\n  output done\n);\n\nparameter is_master = 1; // set to 1 for master and 0 for slave\n\nreg [7:0] reg_addr;\nreg [7:0] reg_data;\nreg [7:0] request;\nreg [7:0] response;\nreg [2:0] state;\nreg done;\n\nassign data_out = response;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    state <= 0;\n    done <= 0;\n  end else if (en) begin\n    case (state)\n      0: begin // idle\n        if (is_master) begin\n          state <= 1;\n          request <= {addr, 0, reg_addr, reg_data}; // read holding register\n        end else begin\n          if (addr == request[0]) begin\n            case (request[1])\n              3: begin // read holding register\n                state <= 1;\n              end\n              default: begin\n                state <= 0;\n              end\n            endcase\n          end\n        end\n      end\n      1: begin // send request\n        if (is_master) begin\n          state <= 2;\n        end else begin\n          response <= {addr, request[1], reg_data};\n          state <= 0;\n          done <= 1;\n        end\n      end\n      2: begin // wait for response\n        if (is_master) begin\n          state <= 3;\n        end else begin\n          state <= 0;\n        end\n      end\n      3: begin // receive response\n        if (is_master) begin\n          response <= data_in;\n          state <= 0;\n          done <= 1;\n        end else begin\n          reg_data <= data_in;\n          response <= {addr, request[1], reg_data};\n          state <= 0;\n          done <= 1;\n        end\n      end\n      default: begin\n        state <= 0;\n      end\n    endcase\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_be4c1188", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module(\n    input [4:0] in,\n    input select,\n    output out_and,\n    output out_or,\n    output out_nor\n);\n\nwire [3:0] decoder_out;\nwire en_and, en_or, en_nor;\n\ndecoder_2to4_with_enable dec(\n    .in(in[1:0]),\n    .enable(select),\n    .out(decoder_out)\n);\n\nand_gate_5input and_gate(\n    .in(in),\n    .enable(en_and),\n    .out(out_and)\n);\n\nor_gate_5input or_gate(\n    .in(in),\n    .enable(en_or),\n    .out(out_or)\n);\n\nnor_gate_5input nor_gate(\n    .in(in),\n    .enable(en_nor),\n    .out(out_nor)\n);\n\nassign en_and = decoder_out[0];\nassign en_or = decoder_out[1];\nassign en_nor = decoder_out[2];\n\nendmodule\n\nmodule decoder_2to4_with_enable(\n    input [1:0] in,\n    input enable,\n    output [3:0] out\n);\n\nwire [3:0] dec_out;\n\ndecoder_2to4 dec(\n    .in(in),\n    .out(dec_out)\n);\n\nassign out = enable ? dec_out : 4'b0000;\n\nendmodule\n\nmodule decoder_2to4(\n    input [1:0] in,\n    output [3:0] out\n);\n\nassign out = 4'b0001 << in;\n\nendmodule\n\nmodule and_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nassign out = enable ? (in[0] & in[1] & in[2] & in[3] & in[4]) : 1'b0;\n\nendmodule\n\nmodule or_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nassign out = enable ? (in[0] | in[1] | in[2] | in[3] | in[4]) : 1'b0;\n\nendmodule\n\nmodule nor_gate_5input(\n    input [4:0] in,\n    input enable,\n    output out\n);\n\nwire or_out;\n\nor_gate_5input or_gate(\n    .in(in),\n    .enable(enable),\n    .out(or_out)\n);\n\nassign out = ~or_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SUB_1 #_6512f9ce", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule SUB_1 #(parameter N = 32)(\n    input [N-1:0] A, B,\n    output [N:0] D\n);\n\n    wire CO;\n\n    assign D[N] = ~CO;\n\n    ADD #(\n        .N(N)\n    )\n    ADD_\n    (\n        .A(A),\n        .B(~B),\n        .CI(1'b1),\n        .S(D[N-1:0]), \n        .CO(CO)\n    );\n\nendmodule\nmodule ADD #(parameter N = 32)(\n    input [N-1:0] A, B,\n    input CI,\n    output [N-1:0] S,\n    output CO\n);\n\n    assign {CO, S} = A + B + CI;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "audio_shifter_2e1514dd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule audio_shifter(\n  input  wire           clk,    //32MHz\n  input  wire           nreset,\n  input  wire           mix,\n  input  wire [ 15-1:0] rdata,\n  input  wire [ 15-1:0] ldata,\n  input  wire           exchan,\n  output wire           aud_bclk,\n  output wire           aud_daclrck,\n  output wire           aud_dacdat,\n  output wire           aud_xck\n);\n\n  // L-R mixer\n  wire [ 16-1:0] rdata_mix;\n  wire [ 16-1:0] ldata_mix;\n\n  assign rdata_mix = {rdata[14], rdata} + {{2{ldata[14]}}, ldata[14:1]};\n  assign ldata_mix = {ldata[14], ldata} + {{2{rdata[14]}}, rdata[14:1]};\n\n  // data mux\n  reg [16-1:0] rdata_mux;\n  reg [16-1:0] ldata_mux;\n\n  always @ (posedge clk) begin\n    rdata_mux <= mix ? rdata_mix : {rdata, rdata[13]};\n    ldata_mux <= mix ? ldata_mix : {ldata, ldata[13]};\n  end\n\n  // audio output shifter\n  reg  [  9-1:0] shiftcnt;\n  reg  [ 16-1:0] shift;\n\n  always @(posedge clk, negedge nreset) begin\n    if(~nreset)\n      shiftcnt <= 9'd0;\n    else\n      shiftcnt <= shiftcnt - 9'd1;\n  end\n\n  always @ (posedge clk) begin\n    if(~|shiftcnt[2:0]) begin\n      if (~|shiftcnt[6:3])\n        shift <= {shift[14:0], rdata_mux[0]} ^ (exchan ? 17'b10000000000000000 : 17'b00000000000000000);\n      else\n        shift <= {shift[14:0], 1'b0};\n    end\n  end\n\n  // output\n  assign aud_daclrck = shiftcnt[7];\n  assign aud_bclk    = ~shiftcnt[2];\n  assign aud_xck     = shiftcnt[0];\n  assign aud_dacdat  = shift[15];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_uart_rx8to8_8629a30e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_uart_rx8to8(\n\tclk,\n\trst_n,\n\tuart_ctl,\n\trs_rx,\n\t\n\tdata_in,\n\tdata_sign\n    );\n\t\n\tinput \tclk;\n\tinput\trst_n;\n\tinput\t[2:0]\tuart_ctl;\n\tinput\trs_rx;\n\t\n\toutput [7:0]\tdata_in;\n\toutput data_sign;\n\t\n\tparameter \tbps9600_2 \t= 13'd2604,\n\t\t\t\tbps19200_2\t= 13'd1301,\n\t\t\t\tbps38400_2\t= 13'd650,\n\t\t\t\tbps57600_2\t= 13'd433,\n\t\t\t\tbps115200_2 = 13'd217,  \n\t\t\t\tbps256000_2 = 13'd97; \n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tparameter\tIDLE = 2'b01,\n\t\t\t\tTRAN = 2'b10;\n\t\t\t\t\n\t\n\treg\t[1:0]\tstate;\n\t\n\treg\t\t\tbps_sel, sign_sel;\n\t\n\treg\t[12:0]\tcnt;\n\t\n\treg\t[4:0]\ttran_cnt;\n\t\n\treg\t[7:0]\tdata_in;\n\treg\t\t\tdata_sign;\n\t\n\twire\t\trecv_comp;\n\t\n\tassign recv_comp = (tran_cnt == 19 && bps_sel);\n\t\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tstate <= IDLE;\n\t\tend\n\t\telse begin\n\t\t\t\n\t\t\tcase(state)\n\t\t\t\tIDLE :  state <= ~rs_rx ? TRAN : IDLE;\n\t\t\t\tTRAN :  state <= recv_comp ? IDLE : TRAN;\n\t\t\t\tdefault: state <= IDLE;\n\t\t\tendcase\n\t\t\t\n\t\t\t\n\t\tend\n\tend\n\t\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tbps_sel <= 1'b0;\n\t\t\tsign_sel <= 1'b0;\n\t\t\tcnt <= 'h0;\n\t\t\ttran_cnt <= 'h0;\n\t\tend\n\t\telse begin\n\t\t\tif(state == TRAN ) begin\n\t\t\t\tcase(uart_ctl)\n\t\t\t\t\t3'h0: if(cnt == bps9600_2) begin \n\t\t\t\t\t       cnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\t bps_sel <= ~sign_sel; \n\t\t\t\t\t\t\t sign_sel <= ~sign_sel; \n\t\t\t\t\t\t\t tran_cnt <=  tran_cnt + 1'b1;  \n\t\t\t\t\t\t\t end\n\t\t\t\t\t\t  else begin \n\t\t\t\t\t\t\tcnt <=  cnt + 1'b1; \n\t\t\t\t\t\t\tbps_sel <= 1'b0; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t3'h1: if(cnt == bps19200_2) begin \n\t\t\t\t\t\t\tcnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\tbps_sel <= ~sign_sel; \n\t\t\t\t\t\t\tsign_sel <= ~sign_sel; \n\t\t\t\t\t\t\ttran_cnt <=  tran_cnt + 1'b1;  \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t  else begin \n\t\t\t\t\t\t\tcnt <=  cnt + 1'b1; \n\t\t\t\t\t\t\tbps_sel <= 1'b0; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t3'h2: if(cnt == bps38400_2) begin \n\t\t\t\t\t\t\tcnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\tbps_sel <= ~sign_sel; \n\t\t\t\t\t\t\tsign_sel <= ~sign_sel; \n\t\t\t\t\t\t\ttran_cnt <=  tran_cnt + 1'b1; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t  else begin \n\t\t\t\t\t\t  cnt <=  cnt + 1'b1; \n\t\t\t\t\t\t  bps_sel <= 1'b0; \n\t\t\t\t\t\t  end\n\t\t\t\t\t3'h3: if(cnt == bps57600_2) begin \n\t\t\t\t\t\t\tcnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\tbps_sel <= ~sign_sel; \n\t\t\t\t\t\t\tsign_sel <= ~sign_sel; \n\t\t\t\t\t\t\ttran_cnt <=  tran_cnt + 1'b1; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\telse \tbegin \n\t\t\t\t\t\t\tcnt <=  cnt + 1'b1; \n\t\t\t\t\t\t\tbps_sel <= 1'b0; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t3'h4: if(cnt == bps115200_2) begin \n\t\t\t\t\t\t\tcnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\tbps_sel <= ~sign_sel; \n\t\t\t\t\t\t\tsign_sel <= ~sign_sel; \n\t\t\t\t\t\t\ttran_cnt <=  tran_cnt + 1'b1; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t  else begin \n\t\t\t\t\t\t\tcnt <=  cnt + 1'b1; \n\t\t\t\t\t\t\tbps_sel <= 1'b0; end\n\t\t\t\t\t3'h5: if(cnt == bps256000_2) begin \n\t\t\t\t\t\t\tcnt <=  'h0; \t\t\t\n\t\t\t\t\t\t\tbps_sel <= ~sign_sel; \n\t\t\t\t\t\t\tsign_sel <= ~sign_sel; \n\t\t\t\t\t\t\ttran_cnt <=  tran_cnt + 1'b1; \n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t  else begin \n\t\t\t\t\t\t  cnt <=  cnt + 1'b1; \n\t\t\t\t\t\t  bps_sel <= 1'b0; \n\t\t\t\t\t\t  end\n\t\t\t\t\tdefault: begin \n\t\t\t\t\t\t\t\tcnt <= 'h0; \n\t\t\t\t\t\t\t\ttran_cnt <=  0; \n\t\t\t\t\t\t\t\tbps_sel <= 'h0; \n\t\t\t\t\t\t\t\tsign_sel <= 'h0; \n\t\t\t\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\t\telse  begin \n\t\t\t\tcnt <= 'h0; \n\t\t\t\tsign_sel <= 'h0; \n\t\t\t\tbps_sel <= 1'b0; \n\t\t\t\ttran_cnt <= 'h0; \n\t\t\t\tbps_sel <= 1'b0; \n\t\t\t\tend\n\t\t\t\n\t\tend\n\tend\n\t\n\t\n\t\n\talways@(posedge clk or negedge rst_n)begin\n\t\tif(!rst_n)begin\n\t\t\tdata_in <= 'h0;\n\t\t\tdata_sign <= 'h0;\n\t\tend\n\t\telse begin\n\t\t\tif(bps_sel)begin\n\t\t\t\tif(tran_cnt > 2 && tran_cnt <= 18) data_in[tran_cnt[4:1] - 1] <= rs_rx;\n\t\t\t\t data_sign <= (tran_cnt == 19 ) ? 1'b1 : 1'b0;\n\t\t\tend\n\t\t\telse \tdata_sign <= 1'b0;\n\t\t\t\n\t\tend\n\tend\n\t\n\t\n\t\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplier_block_70df4e14", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiplier_block (\n    i_data0,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0;\n  output  [31:0]\n    o_data0;\n\n  //Multipliers:\n\n  wire [31:0]\n    w1,\n    w32,\n    w31,\n    w256,\n    w257,\n    w2056,\n    w2025;\n\n  assign w1 = i_data0;\n  assign w32 = w1 << 5;\n  assign w31 = w32 - w1;\n  assign w256 = w1 << 8;\n  assign w257 = w1 + w256;\n  assign w2056 = w257 << 3;\n  assign w2025 = w2056 - w31;\n\n  assign o_data0 = w2025;\n\n  //multiplier_block area estimate = 5631.59510674265;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dcr_if_4c4ee117", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule dcr_if(\n  clk,           rst,           DCR_ABus,      DCR_DBusIn,    DCR_Read,      DCR_Write,     DCR_Ack,       DCR_DBusOut,   tft_base_addr, tft_dps_reg,   tft_on_reg     );\n\ninput         clk;\n  input         rst;\n  input  [0:9]  DCR_ABus;\n  input  [0:31] DCR_DBusIn;\n  input         DCR_Read;\n  input         DCR_Write;\n  output        DCR_Ack;\n  output [0:31] DCR_DBusOut;\n  output [0:10] tft_base_addr;\n  output        tft_dps_reg;\n  output        tft_on_reg;\n  wire   [0:31] DCR_DBusOut;\n  reg           DCR_Ack;\n\nparameter C_DCR_BASE_ADDR = 10'b00_0000_0000;\n  parameter C_DEFAULT_TFT_BASE_ADDR = 31'b0000_0000_0000_0000_0000_0000_0000_0000;\n  parameter C_DPS_INIT = 1'b1;\n  parameter C_ON_INIT = 1'b1;\n\nwire        dcr_addr_hit;\n  wire [0:9]  dcr_base_addr;\n  reg         dcr_read_access;\n  reg  [0:31] read_data;\n  reg  [0:10] tft_base_addr;\n  reg         tft_dps_reg;\n  reg         tft_on_reg;\n\nassign dcr_base_addr = C_DCR_BASE_ADDR;\n  assign dcr_addr_hit  = (DCR_ABus[0:8] == dcr_base_addr[0:8]);\n\n  always @(posedge clk)\n  begin\n    dcr_read_access <=  DCR_Read              & dcr_addr_hit;\n    DCR_Ack         <= (DCR_Read | DCR_Write) & dcr_addr_hit;\n  end\n\n  always @(posedge clk)\n    if (rst)\n      tft_base_addr <= C_DEFAULT_TFT_BASE_ADDR[31:21]; \n    else if (DCR_Write & ~DCR_Ack & dcr_addr_hit & (DCR_ABus[9] == 1'b0))\n      tft_base_addr <= DCR_DBusIn[0:10];\n\n  always @(posedge clk)\n    if (rst) begin\n      tft_dps_reg <= C_DPS_INIT;\n      tft_on_reg  <= C_ON_INIT;\n    end\n    else if (DCR_Write & ~DCR_Ack & dcr_addr_hit & (DCR_ABus[9] == 1'b1)) begin\n      tft_dps_reg <= DCR_DBusIn[30];\n      tft_on_reg  <= DCR_DBusIn[31];\n    end\n\n  always @(posedge clk)\n    if (DCR_Read & dcr_addr_hit & ~DCR_Ack)\n      read_data <= (DCR_ABus[9] == 1'b0)? {tft_base_addr, 21'b0} :\n                                          {30'b0, tft_dps_reg, tft_on_reg};\n\n  assign DCR_DBusOut = (dcr_read_access)? read_data : DCR_DBusIn;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shift_3bit_reg_and_gate_f5acda99", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shift_3bit_reg_and_gate (\n    input clk,\n    input [3:0] data_in,\n    input [1:0] shift_amount,\n    input [2:0] parallel_load,\n    input shift,\n    input control,\n    output [2:0] out\n);\n\n    // 4-bit Barrel Shifter\n    reg [3:0] shifted_data;\n    always @(*) begin\n        case(shift_amount)\n            2'b00: shifted_data = data_in;\n            2'b01: shifted_data = {data_in[3], data_in[0:2]};\n            2'b10: shifted_data = {data_in[2:3], data_in[0:1]};\n            2'b11: shifted_data = {data_in[1:3], data_in[0]};\n            default: shifted_data = 4'b0000;\n        endcase\n    end\n\n    // 3-bit Shift Register\n    reg [2:0] reg_data;\n    always @(posedge clk) begin\n        if(shift) begin\n            if(control) reg_data <= {reg_data[1:0], 1'b0};\n            else reg_data <= {1'b0, reg_data[2:1]};\n        end\n        else if(parallel_load != 3'b111) begin\n            reg_data <= parallel_load;\n        end\n    end\n\n    // AND Gate\n    assign out = shifted_data & reg_data;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "debouncer_115c1999", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule debouncer (\n  input clock,\n  input signal_in,\n  output reg signal_out\n);\n\nparameter debounce_time = 10; // time (in clock cycles) to debounce input signal\n\nreg [debounce_time-1:0] stable_count; // counter to track stable input signal\n\nalways @(posedge clock) begin\n  if (signal_in == signal_out) begin\n    stable_count <= stable_count + 1;\n    if (stable_count == debounce_time) begin\n      signal_out <= signal_in;\n      stable_count <= 0;\n    end\n  end else begin\n    signal_out <= signal_in;\n    stable_count <= 0;\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "NOR4X0_8df7bf1e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule NOR4X0 (input IN1, IN2, IN3, IN4, output QN, input VDD, VSS);\n\n  wire n1, n2, n3;\n\n  assign n1 = ~(IN1 | IN2);\n  assign n2 = ~(IN3 | IN4);\n  assign n3 = ~(n1 | n2);\n\n  assign QN = n3;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_const_f37f87ae", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule xor_const(\n    input [31:0] in,\n    output [31:0] out\n);\n\nparameter CONST = 32'hAAAAAAAA;\n\nassign out = in ^ CONST;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_or_logical_or_b44b3d8a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule bitwise_or_logical_or(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    assign out_or_bitwise = a | b;\n    assign out_or_logical = (a != 0) || (b != 0);\n    assign out_not = ~{a, b};\n\nendmodule\nmodule and_or_xor(\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    wire [49:0] and_out;\n    wire [49:0] or_out;\n    wire [98:0] xor_out;\n\n    genvar i;\n    generate\n        for (i = 0; i < 50; i = i + 1) \n            and_gate and_inst(\n            .a(in[i*2]),\n            .b(in[i*2+1]),\n            .y(and_out[i])\n        );\n\n        for (i = 0; i < 50; i = i + 1) \n            or_gate or_inst(\n            .a(in[i*2]),\n            .b(in[i*2+1]),\n            .y(or_out[i])\n        );\n\n        for (i = 0; i < 99; i = i + 1) \n            xor_gate xor_inst(\n            .a(in[i]),\n            .b(in[i+1]),\n            .y(xor_out[i])\n        );\n    endgenerate\n\n    assign out_and = &and_out;\n    assign out_or = |or_out;\n    assign out_xor = ^xor_out;\n\nendmodule\nmodule top_module( \n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not,\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output [2:0] final_output\n);\n\n    bitwise_or_logical_or bitwise_or_logical_or_inst(\n        .a(a),\n        .b(b),\n        .out_or_bitwise(out_or_bitwise),\n        .out_or_logical(out_or_logical),\n        .out_not(out_not)\n    );\n\n    and_or_xor and_or_xor_inst(\n        .in(in),\n        .out_and(out_and),\n        .out_or(out_or),\n        .out_xor(out_xor)\n    );\n\n    assign final_output = out_or_bitwise + out_or_bitwise;\n\nendmodule\nmodule and_gate(\n    input a,\n    input b,\n    output y\n);\n\n    assign y = a & b;\n\nendmodule\nmodule or_gate(\n    input a,\n    input b,\n    output y\n);\n\n    assign y = a | b;\n\nendmodule\nmodule xor_gate(\n    input a,\n    input b,\n    output y\n);\n\n    assign y = a ^ b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_eb704757", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule full_adder(a, b, c_in, s, c_out);\n  input a, b, c_in;\n  output s, c_out;\n  assign s = a ^ b ^ c_in;\n  assign c_out = (a & b) | (b & c_in) | (c_in & a);\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n  input [3:0] A, B;\n  input C_in;\n  output [3:0] S;\n  output C_out;\n\n  wire c1, c2, c3;\n\n  full_adder adder0(A[0], B[0], C_in, S[0], c1);\n  full_adder adder1(A[1], B[1], c1, S[1], c2);\n  full_adder adder2(A[2], B[2], c2, S[2], c3);\n  full_adder adder3(A[3], B[3], c3, S[3], C_out);\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_e4f60940", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n  input clk,\n  input areset,\n  input enable,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (areset) begin\n      count <= 4'b0;\n    end\n    else if (enable) begin\n      count <= count + 1;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "uart_tx_3155e5ab", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule uart_tx\n  #(\n    parameter DBIT = 8,\t\t\t\t// Number of data bits to receive\n    SB_TICK = 16\t\t\t// Number of ticks for the stop bit. 16 ticks=1 stop bit, 24=1.5 and 32=2.\n  )\n  ( \n    input wire clk,\n    input wire reset,\n    input wire [7:0] data_in,\n    input wire s_tick,\n    input wire tx_start,\n    output reg tx_done_tick,\n    output wire  data_out\n  );\n\n  // state declaration for the FSM\n  localparam [1:0]\n\t\tidle  = 2'b00,\n\t\tstart = 2'b01,\n\t\tdata  = 2'b10,\n\t\tstop  = 2'b11;\n\n  //\tsignal declaration\n  reg [1:0] state_reg, state_next;\n  reg [3:0] cnt_15_reg, cnt_15_next;\n  reg [2:0] cnt_8_reg, cnt_8_next;\n  reg [7:0] shift_out_reg, shift_out_next;\n  reg tx_reg, tx_next;\n\n  //\tbody\n  //\tFSM state & data registers\n  always@(posedge clk, posedge reset)\n    if (reset)\n      begin\n        state_reg <= idle;\n        cnt_15_reg <= 0;\n        cnt_8_reg <= 0;\n        shift_out_reg <= 0;\n        tx_reg <= 0;\n      end\n  else\n    begin\n      state_reg <= state_next;\n      cnt_15_reg <= cnt_15_next;\n      cnt_8_reg <= cnt_8_next;\n      shift_out_reg <= shift_out_next;\n      tx_reg <= tx_next;\n    end\n\n  //\tFSM next-state logic\n  always@*\n    begin\n      state_next = state_reg ;\n      cnt_15_next = cnt_15_reg;\n      cnt_8_next = cnt_8_reg;\n      shift_out_next = shift_out_reg;\n      tx_next = tx_reg;\n      tx_done_tick = 1'b0;\n\t\t\n      case (state_reg)\n\t\t\n        idle:\n\t\t\t begin\n\t\t\t\t tx_next = 1'b1;\n\t\t\t\t if(tx_start)\n\t\t\t\t\tbegin\n\t\t\t\t\t  state_next = start;\n\t\t\t\t\t  cnt_15_next = 0;\n\t\t\t\t\t  shift_out_next = data_in;\n\t\t\t\t\tend\n\t\t\t end\n\t\t\t\t\n        start:\n\t\t\t begin\n\t\t\t\t tx_next = 1'b0;\n\t\t\t\t if (s_tick)\n\t\t\t\t\t if(cnt_15_reg==15)\n\t\t\t\t\t   begin\n\t\t\t\t\t\t state_next=data;\n\t\t\t\t\t\t cnt_15_next=0;\n\t\t\t\t\t\t cnt_8_next=0;\n\t\t\t\t\t   end\n\t\t\t\t\t else\n\t\t\t\t\t   cnt_15_next = cnt_15_reg+1'b1;\n\t\t\t end\n\t\t\t \n        data:\n\t\t\t begin\n\t\t\t\t tx_next = shift_out_reg[0];\n\t\t\t\t if(s_tick)\n\t\t\t\t\t if(cnt_15_reg==15)\n\t\t\t\t\t   begin\n\t\t\t\t\t\t cnt_15_next=0;\n\t\t\t\t\t\t shift_out_next = shift_out_reg >> 1;\n\t\t\t\t\t\t if(cnt_8_reg==(DBIT-1))\n\t\t\t\t\t\t\t if (SB_TICK == 16)\n\t\t\t\t\t\t\t   begin\n\t\t\t\t\t\t\t\t  state_next=stop;\n\t\t\t\t\t\t\t\t  cnt_15_next=0;\n\t\t\t\t\t\t\t   end\n\t\t\t\t\t\t\t else\n\t\t\t\t\t\t\t   state_next = idle;\n\t\t\t\t\t\t else\n\t\t\t\t\t\t\tcnt_8_next=cnt_8_reg+1'b1;\n\t\t\t\t\t   end\n\t\t\t\t\t else\n\t\t\t\t\t   cnt_15_next=cnt_15_reg+1'b1;\n\t\t\t end\n\t\t\t \n        stop:\n\t\t\t begin\n\t\t\t\t tx_next = 1'b1;\n\t\t\t\t if(s_tick)\n\t\t\t\t\t if(cnt_15_reg==(SB_TICK-1))\n\t\t\t\t\t   begin\n\t\t\t\t\t\t state_next=idle;\n\t\t\t\t\t\t tx_done_tick=1'b1;\n\t\t\t\t\t   end\n\t\t\t\t\t else\n\t\t\t\t\t   cnt_15_next = cnt_15_reg+1'b1;\n\t\t\t end\n      endcase\n    end\n\n    //output\n    assign data_out = tx_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__b55206de", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input [31:0] A,\n    input [31:0] B,\n    input [3:0] S,\n    input [2:0] OPCODE,\n    input CIN,\n    output reg COUT,\n    output reg [31:0] Y\n);\n\nreg [32:0] alu_output;\n\nalways @(*) begin\n    case(OPCODE)\n        3'b000: alu_output = A + B + CIN;\n        3'b001: alu_output = A - B - (~CIN);\n        3'b010: alu_output = A & B;\n        3'b011: alu_output = A | B;\n        3'b100: alu_output = A ^ B;\n        3'b101: alu_output = (S == 0) ? A : (A << S[3:1]);\n        3'b110: alu_output = (S == 0) ? B : (B << S[3:1]);\n        default: alu_output = 0;\n    endcase\nend\n\nalways @(*) begin\n    case(OPCODE)\n        3'b000: Y = alu_output[31:0];\n        3'b001: Y = alu_output[31:0];\n        3'b010: Y = alu_output[31:0];\n        3'b011: Y = alu_output[31:0];\n        3'b100: Y = alu_output[31:0];\n        3'b101: Y = alu_output[31:0];\n        3'b110: Y = alu_output[31:0];\n        default: Y = 0;\n    endcase\nend\n\nalways @(*) begin\n    case(OPCODE)\n        3'b000: COUT = (alu_output[32] == 1);\n        3'b001: COUT = (alu_output[32] == 0);\n        3'b010: COUT = 0;\n        3'b011: COUT = 0;\n        3'b100: COUT = 0;\n        3'b101: COUT = (S != 0) ? (B[32 - S[3:1]] == 1) : (B[S[3:1] - 1] == 1);\n        3'b110: COUT = (S != 0) ? (B[32 - S[3:1]] == 1) : (B[S[3:1] - 1] == 1);\n        default: COUT = 0;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_sub_369372eb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule add_sub (\n    input [15:0] A,\n    input [15:0] B,\n    input CTRL,\n    output [15:0] SUM_DIFF,\n    output CARRY_OUT_BORROW_OUT\n);\n\nreg [15:0] A_reg, B_reg, SUM_DIFF_reg;\nreg CTRL_reg;\nreg CARRY_IN_reg, BORROW_IN_reg;\nwire CARRY_OUT, BORROW_OUT;\n\nassign CARRY_OUT_BORROW_OUT = (CTRL == 0) ? CARRY_OUT : BORROW_OUT;\n\npipeline_stage1 stage1 (\n    .A(A),\n    .B(B),\n    .CTRL(CTRL),\n    .A_reg(A_reg),\n    .B_reg(B_reg),\n    .CTRL_reg(CTRL_reg),\n    .CARRY_IN_reg(CARRY_IN_reg),\n    .BORROW_IN_reg(BORROW_IN_reg)\n);\n\npipeline_stage2 stage2 (\n    .A_reg(A_reg),\n    .B_reg(B_reg),\n    .CTRL_reg(CTRL_reg),\n    .CARRY_IN_reg(CARRY_IN_reg),\n    .BORROW_IN_reg(BORROW_IN_reg),\n    .SUM_DIFF_reg(SUM_DIFF_reg),\n    .CARRY_OUT(CARRY_OUT),\n    .BORROW_OUT(BORROW_OUT)\n);\n\npipeline_stage3 stage3 (\n    .SUM_DIFF_reg(SUM_DIFF_reg),\n    .CARRY_OUT(CARRY_OUT),\n    .BORROW_OUT(BORROW_OUT),\n    .SUM_DIFF(SUM_DIFF)\n);\n\nendmodule\n\nmodule pipeline_stage1 (\n    input [15:0] A,\n    input [15:0] B,\n    input CTRL,\n    output reg [15:0] A_reg,\n    output reg [15:0] B_reg,\n    output reg CTRL_reg,\n    output reg CARRY_IN_reg,\n    output reg BORROW_IN_reg\n);\n\nalways @(A, B, CTRL) begin\n    A_reg <= A;\n    B_reg <= B;\n    CTRL_reg <= CTRL;\n    CARRY_IN_reg <= 1'b0;\n    BORROW_IN_reg <= 1'b0;\nend\n\nendmodule\n\nmodule pipeline_stage2 (\n    input [15:0] A_reg,\n    input [15:0] B_reg,\n    input CTRL_reg,\n    input CARRY_IN_reg,\n    input BORROW_IN_reg,\n    output reg [15:0] SUM_DIFF_reg,\n    output reg CARRY_OUT,\n    output reg BORROW_OUT\n);\n\nalways @(A_reg, B_reg, CTRL_reg, CARRY_IN_reg, BORROW_IN_reg) begin\n    if (CTRL_reg == 0) begin\n        {CARRY_OUT, SUM_DIFF_reg} <= A_reg + B_reg + CARRY_IN_reg;\n        BORROW_OUT <= (A_reg < B_reg) || ((A_reg == B_reg) && (CARRY_IN_reg == 1'b1));\n    end else begin\n        {BORROW_OUT, SUM_DIFF_reg} <= A_reg - B_reg - BORROW_IN_reg;\n        CARRY_OUT <= (A_reg >= B_reg) && ((A_reg != B_reg) || (BORROW_IN_reg == 1'b1));\n    end\nend\n\nendmodule\n\nmodule pipeline_stage3 (\n    input [15:0] SUM_DIFF_reg,\n    input CARRY_OUT,\n    input BORROW_OUT,\n    output [15:0] SUM_DIFF\n);\n\nassign SUM_DIFF = SUM_DIFF_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wb_bridge_16_32_3b7fd990", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule wb_bridge_16_32\n  #(parameter AWIDTH=16)\n    (input wb_clk, input wb_rst,\n     input A_cyc_i, input A_stb_i, input A_we_i, input [3:0] A_sel_i,\n     input [AWIDTH-1:0] A_adr_i, input [31:0] A_dat_i, output [31:0] A_dat_o, output A_ack_o,\n     output B_cyc_o, output B_stb_o, output B_we_o, output [1:0] B_sel_o,\n     output [AWIDTH-1:0] B_adr_o, output [15:0] B_dat_o, input [15:0] B_dat_i, input B_ack_i\n     );\n\n   reg [15:0] \t\t holding;\n   reg \t\t\t phase;\n   \n   assign \t\t B_adr_o = {A_adr_i[AWIDTH-1:2],phase,1'b0};\n   assign \t\t B_cyc_o = A_cyc_i;\n   assign \t\t B_stb_o = A_stb_i;\n   assign \t\t B_we_o = A_we_i;\n\n   assign \t\t B_dat_o = ~phase ? A_dat_i[15:0] : A_dat_i[31:16];\n   assign \t\t B_sel_o = ~phase ? A_sel_i[1:0] : A_sel_i[3:2];\n\n   assign \t\t A_dat_o = {B_dat_i,holding};\n   assign \t\t A_ack_o = phase & B_ack_i;\n\n   always @(posedge wb_clk)\n     if(wb_rst)\n       phase <= 0;\n     else if(B_ack_i)\n       phase <= ~phase;\n\n   always @(posedge wb_clk)\n     if(~phase & B_ack_i)\n       holding <= B_dat_i;\n   \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_aab724d8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule priority_encoder (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nalways @* begin\n    case(in)\n        8'b00000001: pos = 3'b000;\n        8'b00000010: pos = 3'b001;\n        8'b00000100: pos = 3'b010;\n        8'b00001000: pos = 3'b011;\n        8'b00010000: pos = 3'b100;\n        8'b00100000: pos = 3'b101;\n        8'b01000000: pos = 3'b110;\n        8'b10000000: pos = 3'b111;\n        default: pos = 3'b000;\n    endcase;\nend\n\nendmodule\nmodule barrel_shifter_mux (\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule\nmodule top_module (\n    input [7:0] in,\n    output [2:0] pos,\n    input wire [15:0] in2,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo,\n    input enable,\n    output reg [15:0] out_sum\n);\n\nwire [2:0] pos_wire;\n\npriority_encoder pe(\n    .in(in),\n    .pos(pos_wire)\n);\n\nbarrel_shifter_mux bsm(\n    .in(in2),\n    .out_hi(out_hi),\n    .out_lo(out_lo)\n);\n\nalways @(posedge enable) begin\n    out_sum <= {pos_wire, 3'b000} + {out_hi, out_lo};\nend\n\nassign pos = pos_wire;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "split_16bit_input_3d0b441d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule split_16bit_input(\n    input wire [15:0] in,\n    input wire clk,\n    output reg [7:0] out_hi,\n    output reg [7:0] out_lo\n);\n\n    reg [15:0] input_reg;\n    reg [7:0] upper_byte_reg;\n    reg [7:0] lower_byte_reg;\n\n    always @(posedge clk) begin\n        input_reg <= in;\n        upper_byte_reg <= input_reg[15:8];\n        lower_byte_reg <= input_reg[7:0];\n    end\n\n    always @* begin\n        out_hi = upper_byte_reg;\n        out_lo = lower_byte_reg;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__a951bb31", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] final_result\n);\n\n    // Multiplication module\n    wire [15:0] mult_result;\n    wire mult_sign;\n    multiplier_module mult_inst (\n        .a(a),\n        .b(b),\n        .result(mult_result),\n        .sign(mult_sign)\n    );\n    \n    // Ripple carry adder module\n    wire [3:0] adder_result;\n    ripple_carry_adder adder_inst (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .carry_in(1'b0),\n        .sum(adder_result)\n    );\n    \n    // Additional functional module\n    wire [4:0] sum_abs;\n    absolute_value_module abs_inst (\n        .input_sum({mult_result[15], adder_result}),\n        .output_abs(sum_abs)\n    );\n    \n    // Output final result\n    always @(*) begin\n        if (mult_sign) begin\n            final_result = -{sum_abs, 4'b0};\n        end else begin\n            final_result = {sum_abs, 4'b0};\n        end\n    end\n\nendmodule\n\n\nmodule multiplier_module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result,\n    output reg sign\n);\n\n    always @(*) begin\n        if ((a[7] == 1) && (b[7] == 1)) begin\n            result = ~(a*b) + 1;\n            sign = 1;\n        end else if ((a[7] == 0) && (b[7] == 0)) begin\n            result = a*b;\n            sign = 0;\n        end else begin\n            result = a*b;\n            sign = 1;\n        end\n    end\n\nendmodule\n\n\nmodule ripple_carry_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input carry_in,\n    output reg [3:0] sum\n);\n\n    reg carry_out;\n    \n    always @(*) begin\n        sum = a + b + carry_in;\n        carry_out = (sum > 4'b1111);\n        sum = sum & 4'b1111;\n    end\n\nendmodule\n\n\nmodule absolute_value_module (\n    input [4:0] input_sum,\n    output reg [4:0] output_abs\n);\n\n    always @(*) begin\n        if (input_sum[4] == 1) begin\n            output_abs = ~input_sum + 1;\n        end else begin\n            output_abs = input_sum;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_7485b2cf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule up_down_counter (\n    input clk,\n    input up_down,\n    output reg [3:0] count\n);\n    always @(posedge clk) begin\n        if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\nendmodule\nmodule binary_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\nmodule shift_and_sum (\n    input [3:0] A,\n    input [3:0] B,\n    input clk,\n    input up_down,\n    output [7:0] out\n);\n    wire [3:0] counter1_out;\n    wire [3:0] counter2_out;\n    wire [3:0] binary_adder_out;\n\n    up_down_counter counter1 (.clk(clk), .up_down(up_down), .count(counter1_out));\n    up_down_counter counter2 (.clk(clk), .up_down(up_down), .count(counter2_out));\n\n    binary_adder adder (.A(counter1_out), .B(counter2_out), .sum(binary_adder_out));\n\n    assign out = {A >> B, binary_adder_out};\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Multiplexer #_560808b2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Multiplexer #(parameter INIT_VALUE = 8'hB8)\n   (input ctrl,\n    input [0:0] D0,\n    input [0:0] D1,\n    output reg [0:0] S);\n\n  wire [0:0] D0_wire;\n  wire [0:0] D1_wire;\n  wire S_wire;\n\n  assign D0_wire = D0;\n  assign D1_wire = D1;\n\n  always @*\n  begin\n    case(ctrl)\n      1'b0: S = D0_wire;\n      1'b1: S = D1_wire;\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "crosshair_1b074ad9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule crosshair(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] hdmi_r,\n    input wire [7:0] hdmi_g,\n    input wire [7:0] hdmi_b,\n    input wire hdmi_de,\n    input wire hdmi_hs,\n    input wire hdmi_vs,\n    output reg [7:0] out_r,\n    output reg [7:0] out_g,\n    output reg [7:0] out_b,\n    output reg out_de,\n    output reg out_hs,\n    output reg out_vs\n);\n\nwire [9:0] centr_x;\nwire [9:0] centr_y;\n\nassign centr_x = 32;\nassign centr_y = 32;\n\nalways @ (posedge clk) begin\n    if (hdmi_de) begin\n        // Add crosshair overlay\n        if (centr_x == 32) begin\n            out_r <= 8'hFF;\n            out_g <= 8'h00;\n            out_b <= 8'h00;\n        end else if (centr_y == 32) begin\n            out_r <= 8'h00;\n            out_g <= 8'hFF;\n            out_b <= 8'h00;\n        end else begin\n            out_r <= hdmi_r;\n            out_g <= hdmi_g;\n            out_b <= hdmi_b;\n        end\n        out_de <= hdmi_de;\n        out_hs <= hdmi_hs;\n        out_vs <= hdmi_vs;\n    end else begin\n        // Blank output when DE is low\n        out_r <= 8'h00;\n        out_g <= 8'h00;\n        out_b <= 8'h00;\n        out_de <= 1'b0;\n        out_hs <= 1'b0;\n        out_vs <= 1'b0;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_2bit_fc48eaa5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator_2bit (\n    input [1:0] A,\n    input [1:0] B,\n    output [1:0] C\n);\n\n    assign C[1] = (A[1] > B[1]) ? 1 : 0; //compare MSBs\n    assign C[0] = (A[1] == B[1]) ? ((A[0] >= B[0]) ? 1 : 0) : ((C[1] == 1) ? 0 : 1); //compare LSBs\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bmu_b1242a3b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bmu (cx0, cx1, bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7);\n\n   output [1:0] bm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7;\n\n   input  \tcx0, cx1;\n\n   reg [1:0] \tbm0, bm1, bm2, bm3, bm4, bm5, bm6, bm7;\n\n   always@ (cx0 or cx1)\n\t begin\n\t    if (cx0==0 && cx1==0)\n\t      begin\n\t        bm0 <= 2'd0; bm1 <= 2'd2; bm2 <= 2'd2; bm3 <= 2'd0; bm4 <= 2'd1; bm5 <= 2'd1; bm6 <= 2'd1; bm7 <= 2'd1; end\n\t    else if (cx0==0 && cx1==1)\n\t      begin\n\t        bm0 <= 2'd1; bm1 <= 2'd1; bm2 <= 2'd1; bm3 <= 2'd1; bm4 <= 2'd2; bm5 <= 2'd0; bm6 <= 2'd0; bm7 <= 2'd2; end\n\t    else if (cx0==1 && cx1==0)\n\t      begin\n\t        bm0 <= 2'd1; bm1 <= 2'd1; bm2 <= 2'd1; bm3 <= 2'd1; bm4 <= 2'd0; bm5 <= 2'd2; bm6 <= 2'd2; bm7 <= 2'd0; end\n\t    else begin\n\t        bm0 <= 2'd2; bm1 <= 2'd0; bm2 <= 2'd0; bm3 <= 2'd2; bm4 <= 2'd1; bm5 <= 2'd1; bm6 <= 2'd1; bm7 <= 2'd1; end\n\n\t end endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_ce_clr_81f3c1ec", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule d_ff_ce_clr(clk, d, ce, clr, q);\ninput clk, d, ce, clr;\noutput q;\nreg q;\n\nalways @(posedge clk) begin\n  if (clr) begin\n    q <= 1'b0;\n  end else if (ce) begin\n    q <= d;\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_1412c61e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  input clk,\n  output [3:0] S,\n  output Cout\n);\n\n  assign S = A + B + Cin;\n  assign Cout = (A[3] & B[3]) | (A[3] & Cin) | (B[3] & Cin);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "db_lut_tc_677498a5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule db_lut_tc( qp_i,mb_type_i,tc_o );\n\ninput  [5:0] qp_i\t\t;\ninput        mb_type_i\t;\n\noutput [4:0] tc_o\t\t; \nreg    [4:0] tc_o\t\t;\n\nwire [5:0] qp_w = qp_i + {mb_type_i,1'b0};\n\nalways @(qp_w) begin\n    case(qp_w)\n\t\t'd18: tc_o  =  5'd1 ;\n        'd19: tc_o  =  5'd1 ;\n\t\t'd20: tc_o  =  5'd1;\n\t\t'd21: tc_o  =  5'd1;\n\t\t'd22: tc_o  =  5'd1;\n\t\t'd23: tc_o  =  5'd1;\n\t\t'd24: tc_o  =  5'd1;\n\t\t'd25: tc_o  =  5'd1;\n\t\t'd26: tc_o  =  5'd1;\n\t\t'd27: tc_o  =  5'd2;\n\t\t'd28: tc_o  =  5'd2;\n\t\t'd29: tc_o  =  5'd2;\t\t\n\t\t'd30: tc_o  =  5'd2;\n\t\t'd31: tc_o  =  5'd3;\n\t\t'd32: tc_o  =  5'd3;\n\t\t'd33: tc_o  =  5'd3;\n\t\t'd34: tc_o  =  5'd3;\n\t\t'd35: tc_o  =  5'd4;\n\t\t'd36: tc_o  =  5'd4;\n\t\t'd37: tc_o  =  5'd4;\n\t\t'd38: tc_o  =  5'd5;\n\t\t'd39: tc_o  =  5'd5;\t\t\n\t\t'd40: tc_o  =  5'd6;\n\t\t'd41: tc_o  =  5'd6;\n\t\t'd42: tc_o  =  5'd7;\n\t\t'd43: tc_o  =  5'd8;\n\t\t'd44: tc_o  =  5'd9;\n\t\t'd45: tc_o  =  5'd10;\n\t\t'd46: tc_o  =  5'd11;\n\t\t'd47: tc_o  =  5'd13;\n\t\t'd48: tc_o  =  5'd14;\n\t\t'd49: tc_o  =  5'd16;\n\t\t'd50: tc_o  =  5'd18;\n\t\t'd51: tc_o  =  5'd20;\n\t\t'd52: tc_o  =  5'd22;\n\t\t'd53: tc_o  =  5'd24;\n\t  default: tc_o =  5'd0 ;\n\tendcase\t\t\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_e15f043d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n    input clk,\n    input reset,\n    input enable,\n    input shift,\n    input [7:0] parallel_in,\n    output reg [7:0] parallel_out\n);\n\nreg [7:0] pipeline_reg [0:2];\n\nalways @(posedge clk) begin\n    if (reset) begin\n        pipeline_reg[0] <= 8'b0;\n        pipeline_reg[1] <= 8'b0;\n        pipeline_reg[2] <= 8'b0;\n    end\n    else begin\n        pipeline_reg[0] <= enable ? {pipeline_reg[1][6:0], pipeline_reg[2][7]} : pipeline_reg[0];\n        pipeline_reg[1] <= enable ? {pipeline_reg[2][6:0], pipeline_reg[0][7]} : pipeline_reg[1];\n        pipeline_reg[2] <= enable ? {shift ? parallel_in : pipeline_reg[1][6:0], pipeline_reg[2][7:1]} : pipeline_reg[2];\n    end\nend\n\nalways @* begin\n    parallel_out = pipeline_reg[0];\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__9f6bf957", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d,    // 8-bit input for the register\n    output [3:0] counter_out, // 4-bit output from the counter\n    output [7:0] register_out, // 8-bit output from the register\n    output [7:0] final_out // Sum of the counter and register outputs\n);\n\n    wire [3:0] counter_out_wire;\n    wire [7:0] register_out_wire;\n    wire [7:0] final_out_wire;\n\n    counter_module counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .q(counter_out_wire)\n    );\n\n    register_module register_inst (\n        .clk(clk),\n        .reset(reset),\n        .d(d),\n        .q(register_out_wire)\n    );\n\n    functional_module functional_inst (\n        .counter_in(counter_out_wire),\n        .register_in(register_out_wire),\n        .final_out(final_out_wire)\n    );\n\n    assign counter_out = counter_out_wire;\n    assign register_out = register_out_wire;\n    assign final_out = final_out_wire;\n\nendmodule\n\nmodule counter_module (\n    input clk,\n    input reset,\n    output reg [3:0] q // 4-bit output\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule\n\nmodule register_module (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output reg [7:0] q // 8-bit output\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'h34;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\n\nmodule functional_module (\n    input [3:0] counter_in,\n    input [7:0] register_in,\n    output reg [7:0] final_out // Sum of the counter and register inputs\n);\n\n    always @(*) begin\n        final_out = counter_in + register_in;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "velocityControlHdl_Reset_Delay_fe335553", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule velocityControlHdl_Reset_Delay\n(\n    CLK_IN,\n    reset,\n    enb_1_2000_0,\n    Reset_1,\n    In,\n    Out\n);\n\ninput CLK_IN;\ninput reset;\ninput enb_1_2000_0;\ninput Reset_1;\ninput signed [31:0] In;\noutput signed [31:0] Out;\n\nwire signed [31:0] Constant1_out1;\nwire signed [31:0] Reset_Switch1_out1;\nreg signed [31:0] In_Delay_out1;\nwire signed [31:0] Constant_out1;\nwire signed [31:0] Reset_Switch_out1;\n\n// Constant1\nassign Constant1_out1 = 32'sb00000000000000000000000000000000;\n\n// Reset_Switch1\nassign Reset_Switch1_out1 = (Reset_1 == 1'b0 ? In : Constant1_out1);\n\n// In_Delay\nalways @(posedge CLK_IN)\nbegin : In_Delay_process\n    if (reset == 1'b1)\n    begin\n        In_Delay_out1 <= 32'sb00000000000000000000000000000000;\n    end\n    else if (enb_1_2000_0)\n    begin\n        In_Delay_out1 <= Reset_Switch1_out1;\n    end\nend\n\n// Constant\nassign Constant_out1 = 32'sb00000000000000000000000000000000;\n\n// Reset_Switch\nassign Reset_Switch_out1 = (Reset_1 == 1'b0 ? In_Delay_out1 : Constant_out1);\n\nassign Out = Reset_Switch_out1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4_diff_9f660468", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux4_diff (\n    input [3:0] I,\n    input [1:0] S,\n    output reg O,\n    output reg OB\n);\n\n    // 4:1 MUX implementation\n    always @(*) begin\n        case (S)\n            2'b00: begin\n                O = I[0];\n                OB = ~I[0];\n            end\n            2'b01: begin\n                O = I[1];\n                OB = ~I[1];\n            end\n            2'b10: begin\n                O = I[2];\n                OB = ~I[2];\n            end\n            2'b11: begin\n                O = I[3];\n                OB = ~I[3];\n            end\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__a2bb2o_1a9f448a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_lp__a2bb2o (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    // Module ports\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    // Local signals\n    wire and0_out ;\n    wire nor0_out ;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    and and0 (and0_out , B1, B2            );\n    nor nor0 (nor0_out , A1_N, A2_N        );\n    or  or0  (or0_out_X, nor0_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_15ca33ae", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n    input CLK,\n    input LOAD,\n    input [2:0] LOAD_VAL,\n    input UP_DOWN,\n    input CARRY_IN,\n    output reg [2:0] Q\n);\n\nreg [2:0] Q_reg1, Q_reg2, Q_reg3;\n\nalways @(posedge CLK) begin\n    Q_reg1 <= Q;\nend\n\nalways @(posedge CLK) begin\n    Q_reg2 <= Q_reg1;\nend\n\nalways @(posedge CLK) begin\n    Q_reg3 <= Q_reg2;\nend\n\nalways @(posedge CLK) begin\n    if (LOAD) begin\n        Q <= LOAD_VAL;\n    end else begin\n        if (UP_DOWN) begin\n            Q <= Q_reg1 + CARRY_IN;\n        end else begin\n            Q <= Q_reg1 - CARRY_IN;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_75917128", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(clk, rst, op, a, b, result);\n   input clk, rst, op;\n   input [3:0] a, b;\n   output [3:0] result;\n\n   reg [3:0] reg_a;\n   reg [3:0] reg_b;\n   reg [3:0] reg_result;\n\n   always @(posedge clk) begin\n      if (rst) begin\n         reg_a <= 4'b0;\n         reg_b <= 4'b0;\n         reg_result <= 4'b0;\n      end else begin\n         reg_a <= a;\n         reg_b <= b;\n         case(op)\n            2'b00: reg_result <= reg_a + reg_b;\n            2'b01: reg_result <= reg_a - reg_b;\n            2'b10: reg_result <= reg_a * reg_b;\n            2'b11: reg_result <= reg_a / reg_b;\n         endcase\n      end\n   end\n\n   assign result = reg_result;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_acd7789e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shifter (\n  input clk,\n  input reset,\n  input [31:0] data,\n  input [31:0] shift_amount,\n  output reg [31:0] shifted_data\n);\n\n  always @(posedge clk) begin\n    if (reset) begin\n      shifted_data <= 0;\n    end else begin\n      if (shift_amount == 0) begin\n        shifted_data <= data;\n      end else if (shift_amount > 0) begin\n        shifted_data <= data << shift_amount;\n      end else begin\n        shifted_data <= data >> (-shift_amount);\n      end\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__lpflow_inputiso0n_e1b1563b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__lpflow_inputiso0n (\n    X      ,\n    A      ,\n    SLEEP_B\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n\n    and and0 (X     , A, SLEEP_B     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "VerificadorSentidoMovimiento_c3d98c05", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule VerificadorSentidoMovimiento(\n\t\t_clk_,\n\t\tFSM_ready_in,\n\t\tpiso_actual, \n\t\tsolicitud_ps,\n\t\tsolicitud_p1,\n\t\tsolicitud_p2,\n\t\tsolicitud_p3,\n\t\tsolicitud_p4,\n\t\taccion\n\t\t);\n\t\t\n\t\tinput [2:0] piso_actual;\n\t\tinput [1:0] solicitud_ps, solicitud_p1, solicitud_p2, solicitud_p3, solicitud_p4;\n\t\tinput _clk_, FSM_ready_in;\n\t\toutput reg [1:0] accion;\n\t\t\n\t\talways @(posedge _clk_)\n\t\t\tbegin\n\t\t\t\t//acciones para el sotano\n\t\t\t\tif (piso_actual == 3'b000)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (solicitud_ps == 2'bx1) //No realiza accion\n\t\t\t\t\t\t\taccion <= 2'b00;\n\t\t\t\t\t\tif (solicitud_ps == 2'bx0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_p1 == 2'bx0 | solicitud_p2 == 2'bx0 | solicitud_p3 == 2'bx0 | solicitud_p4 == 2'bx0)\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t//acciones para el piso1\n\t\t\t\telse if (piso_actual == 3'b001)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (solicitud_p1 == 2'bxx)\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\tif (solicitud_ps == 2'bx1)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_p2 == 2'b1x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_p3 == 2'b1x | solicitud_p4 == 2'b1x)\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\telse if (solicitud_p3 == 2'bx1 | solicitud_p4 == 2'bx1)\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\tif (solicitud_ps == 2'b0x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\t\n\t\t\t\t//acciones para el piso2\n\t\t\t\telse if (piso_actual == 3'b010)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (solicitud_p2 == 2'bxx)\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\tif (solicitud_p1 == 2'bx1)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_p3 == 2'b1x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_ps == 2'b1x | solicitud_p3 == 2'b1x)\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\telse if (solicitud_ps == 2'bx1 | solicitud_p3 == 2'bx1)\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\tif (solicitud_ps == 2'b0x | solicitud_p1 == 2'b0x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\n\t\t\t\t//acciones para el piso3\n\t\t\t\telse if (piso_actual == 3'b011)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (solicitud_p3 == 2'bxx)\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\tif (solicitud_p2 == 2'bx1)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_p4 == 2'b1x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_ps == 2'b1x | solicitud_p1 == 2'b1x)\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\telse if (solicitud_ps == 2'bx1 | solicitud_p1 == 2'bx1)\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\tif (solicitud_ps == 2'b0x | solicitud_p1 == 2'b0x | solicitud_p2 == 2'b0x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\t\n\t\t\t\t//acciones para el piso 4\n\t\t\t\telse if (piso_actual == 3'b100)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tif (solicitud_p4 == 2'b1x) //No realiza accion\n\t\t\t\t\t\t\taccion <= 2'b00;\n\t\t\t\t\t\tif (solicitud_p4 == 2'b0x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b01;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tif (solicitud_ps == 2'b0x | solicitud_p1 == 2'b0x | solicitud_p2 == 2'b0x | solicitud_p3 == 2'b0x)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\taccion <= 2'b11;\n\t\t\t\t\t\t\taccion <= 2'b10;\n\t\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\tend\n\t \n\t \n\t \n\t \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Calculator_Full_Adder_2397f55c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Calculator_Full_Adder\n#(\n\tparameter WIDTH = 4\n)\n(\n\tinput  [WIDTH-1:0] A,\n\tinput  [WIDTH-1:0] B,\n\tinput              CIN,\n\t\n\toutput [WIDTH-1:0] RES,\n\toutput             COUT\n);\n\n\twire signed [WIDTH:0] op_a; \n\twire signed [WIDTH:0] op_b;\n\t\n\t\n\tassign op_a = { A[WIDTH-1], A };\n\tassign op_b = { B[WIDTH-1], B };\n\n\t\n\tassign { COUT, RES } = op_a + op_b + CIN;\n\t\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2_to_1_96b5fcc6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2_to_1 (\n    select,\n    data_0,\n    data_1,\n    out\n);\n\n    input select;\n    input data_0;\n    input data_1;\n    output out;\n\n    assign out = select ? data_1 : data_0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "parity_generator_6c2a8c12", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule parity_generator (\n    input [7:0] data_in,\n    output reg parity_out\n);\n\n    always @(*) begin\n        case (data_in)\n            8'b00000001, 8'b00000011, 8'b00000101, 8'b00000111,\n            8'b00001001, 8'b00001011, 8'b00001101, 8'b00001111,\n            8'b00010001, 8'b00010011, 8'b00010101, 8'b00010111,\n            8'b00011001, 8'b00011011, 8'b00011101, 8'b00011111,\n            8'b00100001, 8'b00100011, 8'b00100101, 8'b00100111,\n            8'b00101001, 8'b00101011, 8'b00101101, 8'b00101111,\n            8'b00110001, 8'b00110011, 8'b00110101, 8'b00110111,\n            8'b00111001, 8'b00111011, 8'b00111101, 8'b00111111,\n            8'b01000001, 8'b01000011, 8'b01000101, 8'b01000111,\n            8'b01001001, 8'b01001011, 8'b01001101, 8'b01001111,\n            8'b01010001, 8'b01010011, 8'b01010101, 8'b01010111,\n            8'b01011001, 8'b01011011, 8'b01011101, 8'b01011111,\n            8'b01100001, 8'b01100011, 8'b01100101, 8'b01100111,\n            8'b01101001, 8'b01101011, 8'b01101101, 8'b01101111,\n            8'b01110001, 8'b01110011, 8'b01110101, 8'b01110111,\n            8'b01111001, 8'b01111011, 8'b01111101, 8'b01111111,\n            8'b10000001, 8'b10000011, 8'b10000101, 8'b10000111,\n            8'b10001001, 8'b10001011, 8'b10001101, 8'b10001111,\n            8'b10010001, 8'b10010011, 8'b10010101, 8'b10010111,\n            8'b10011001, 8'b10011011, 8'b10011101, 8'b10011111,\n            8'b10100001, 8'b10100011, 8'b10100101, 8'b10100111,\n            8'b10101001, 8'b10101011, 8'b10101101, 8'b10101111,\n            8'b10110001, 8'b10110011, 8'b10110101, 8'b10110111,\n            8'b10111001, 8'b10111011, 8'b10111101, 8'b10111111,\n            8'b11000001, 8'b11000011, 8'b11000101, 8'b11000111,\n            8'b11001001, 8'b11001011, 8'b11001101, 8'b11001111,\n            8'b11010001, 8'b11010011, 8'b11010101, 8'b11010111,\n            8'b11011001, 8'b11011011, 8'b11011101, 8'b11011111,\n            8'b11100001, 8'b11100011, 8'b11100101, 8'b11100111,\n            8'b11101001, 8'b11101011, 8'b11101101, 8'b11101111,\n            8'b11110001, 8'b11110011, 8'b11110101, 8'b11110111,\n            8'b11111001, 8'b11111011, 8'b11111101, 8'b11111111:\n                parity_out = 1;\n            default:\n                parity_out = 0;\n        endcase\n    end\n\nendmodule\n\nmodule parity_byte (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    input sel_b1,\n    input sel_b2,\n    output reg [8:0] out_byte\n);\n\n    reg [7:0] data_in;\n    wire parity_out;\n\n    // 2-to-1 mux to select between a and b\n    always @(*) begin\n        if (sel_b1 == 1 && sel_b2 == 0) begin\n            data_in = a;\n        end else if (sel_b1 == 0 && sel_b2 == 1) begin\n            data_in = b;\n        end else begin\n            data_in = 8'b0;\n        end\n    end\n\n    // Priority encoder to generate parity bit\n    parity_generator parity (\n        .data_in(data_in),\n        .parity_out(parity_out)\n    );\n\n    // Multiplexer to combine parity bit and original 8 data bits\n    always @(*) begin\n        out_byte = {parity_out, data_in};\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_decaa3e0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder (\n  input A,\n  input B,\n  input Cin,\n  output reg S,\n  output reg Cout\n);\n\n  always @ (A, B, Cin) begin\n    S = A ^ B ^ Cin;\n    Cout = (A & B) | (Cin & (A ^ B));\n  end\n\nendmodule\n\n\nmodule four_bit_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire c1, c2, c3;\n  full_adder fa1(A[0], B[0], Cin, S[0], c1);\n  full_adder fa2(A[1], B[1], c1, S[1], c2);\n  full_adder fa3(A[2], B[2], c2, S[2], c3);\n  full_adder fa4(A[3], B[3], c3, S[3], Cout);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "controllerHdl_MATLAB_Function_block3_new_bc7ab63f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule controllerHdl_MATLAB_Function_block3_new\n          (\n           CLK_IN,\n           reset,\n           enb_1_2000_0,\n           u,\n           y\n          );\n\n\n  input   CLK_IN;\n  input   reset;\n  input   enb_1_2000_0;\n  input   signed [18:0] u;  // sfix19_En14\n  output  signed [18:0] y;  // sfix19_En14\n\n  wire signed [18:0] u_n1;  // sfix19\n  assign u_n1 = {1'b0, u[18:1]};\n\n  assign y = (u + u_n1) >> 1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "jt10_adpcm_dt_ddafa320", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule jt10_adpcm_dt(\n    input           rst_n,\n    input           clk,        input           cen,        input   [3:0]   data,\n    input           chon,       output signed [15:0] pcm\n);\n\nlocalparam stepw = 15;\n\nreg signed [15:0] x1, x2, x3, x4, x5, x6;\nreg [stepw-1:0] step1, step2, step6;\nreg [stepw+1:0] step3, step4, step5;\nassign pcm = x2;\n\nreg  [18:0] d2l;\nreg  [15:0] d3,d4;\nreg  [3:0]  d2;\nreg         sign2, sign3, sign4, sign5;\nreg  [7:0]  step_val;\nreg  [22:0] step2l;\n\nalways @(*) begin\n    casez( d2[3:1] )\n        3'b0_??: step_val = 8'd57;\n        3'b1_00: step_val = 8'd77;\n        3'b1_01: step_val = 8'd102;\n        3'b1_10: step_val = 8'd128;\n        3'b1_11: step_val = 8'd153;\n    endcase d2l    = d2 * step2; step2l = step_val * step2; end\n\nreg chon2, chon3, chon4, chon5;\nreg signEqu4, signEqu5;\nreg [3:0] data2;\n\nalways @( posedge clk or negedge rst_n )\n    if( ! rst_n ) begin\n        x1 <= 'd0; step1 <= 'd127; \n        x2 <= 'd0; step2 <= 'd127;\n        x3 <= 'd0; step3 <= 'd127;\n        x4 <= 'd0; step4 <= 'd127;\n        x5 <= 'd0; step5 <= 'd127;\n        x6 <= 'd0; step6 <= 'd127;\n        d2 <= 'd0; d3 <= 'd0; d4 <= 'd0;\n        sign2 <= 'b0;\n        sign3 <= 'b0;\n        sign4 <= 'b0; sign5 <= 'b0;\n        chon2 <= 'b0;   chon3 <= 'b0;   chon4 <= 'b0; chon5 <= 1'b0;\n    end else if(cen) begin\n        d2        <= {data[2:0],1'b1};\n        sign2     <= data[3];\n        data2     <= data;\n        x2        <= x1;\n        step2     <= step1;\n        chon2     <= chon;\n        d3        <= d2l[18:3]; sign3     <= sign2;\n        x3        <= x2;\n        step3     <= step2l[22:6];\n        chon3     <= chon2;\n        d4        <= sign3 ? ~d3+16'b1 : d3;\n        sign4     <= sign3;\n        signEqu4  <= sign3 == x3[15];\n        x4        <= x3;\n        step4     <= step3;\n        chon4     <= chon3;\n        x5        <= x4+d4;\n        sign5     <= sign4;\n        signEqu5  <= signEqu4;\n        step5     <= step4;\n        chon5     <= chon4;\n        if( chon5 ) begin\n            if( signEqu5 && (sign5!=x5[15]) )\n                x6 <= sign5 ? 16'h8000 : 16'h7FFF;\n            else\n                x6 <= x5;\n\n            if( step5 < 127 )\n                step6  <= 15'd127;\n            else if( step5 > 24576 )\n                step6  <= 15'd24576;\n            else\n                step6 <= step5[14:0];\n        end else begin\n            x6      <= 'd0;\n            step6   <= 'd127;\n        end\n        x1    <= x6;\n        step1 <= step6;\n    end\n\n\nendmodule // jt10_adpcm    "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mealy_fsm_4bit_sequence_detection_8cebb570", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mealy_fsm_4bit_sequence_detection (\n  input clk,\n  input reset,\n  input data,\n  output reg match\n);\n\n  parameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\n  reg [1:0] state, next_state;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= S0;\n      match <= 1'b0;\n    end else begin\n      state <= next_state;\n      match <= 1'b0;\n      case (state)\n        S0: begin\n          if (data == 1'b1) begin\n            next_state <= S1;\n          end else begin\n            next_state <= S0;\n          end\n        end\n        S1: begin\n          if (data == 1'b0) begin\n            next_state <= S2;\n          end else begin\n            next_state <= S0;\n          end\n        end\n        S2: begin\n          if (data == 1'b1) begin\n            next_state <= S0;\n            match <= 1'b1;\n          end else begin\n            next_state <= S0;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_4to16_7430f24e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule decoder_4to16 (\n    input enable,\n    input [3:0] select,\n    output [15:0] out\n);\n\n    assign out[0] = (enable && (select == 4'b0000)) ? 1'b1 : 1'b0;\n    assign out[1] = (enable && (select == 4'b0001)) ? 1'b1 : 1'b0;\n    assign out[2] = (enable && (select == 4'b0010)) ? 1'b1 : 1'b0;\n    assign out[3] = (enable && (select == 4'b0011)) ? 1'b1 : 1'b0;\n    assign out[4] = (enable && (select == 4'b0100)) ? 1'b1 : 1'b0;\n    assign out[5] = (enable && (select == 4'b0101)) ? 1'b1 : 1'b0;\n    assign out[6] = (enable && (select == 4'b0110)) ? 1'b1 : 1'b0;\n    assign out[7] = (enable && (select == 4'b0111)) ? 1'b1 : 1'b0;\n    assign out[8] = (enable && (select == 4'b1000)) ? 1'b1 : 1'b0;\n    assign out[9] = (enable && (select == 4'b1001)) ? 1'b1 : 1'b0;\n    assign out[10] = (enable && (select == 4'b1010)) ? 1'b1 : 1'b0;\n    assign out[11] = (enable && (select == 4'b1011)) ? 1'b1 : 1'b0;\n    assign out[12] = (enable && (select == 4'b1100)) ? 1'b1 : 1'b0;\n    assign out[13] = (enable && (select == 4'b1101)) ? 1'b1 : 1'b0;\n    assign out[14] = (enable && (select == 4'b1110)) ? 1'b1 : 1'b0;\n    assign out[15] = (enable && (select == 4'b1111)) ? 1'b1 : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "start_for_CvtColowdI_shiftReg_258cba5f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule start_for_CvtColowdI_shiftReg (\n    clk,\n    data,\n    ce,\n    a,\n    q);\n\nparameter DATA_WIDTH = 32'd1;\nparameter ADDR_WIDTH = 32'd2;\nparameter DEPTH = 32'd3;\n\ninput clk;\ninput [DATA_WIDTH-1:0] data;\ninput ce;\ninput [ADDR_WIDTH-1:0] a;\noutput [DATA_WIDTH-1:0] q;\n\nreg[DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];\ninteger i;\n\nalways @ (posedge clk)\n    begin\n        if (ce)\n        begin\n            for (i=0;i<DEPTH-1;i=i+1)\n                SRL_SIG[i+1] <= SRL_SIG[i];\n            SRL_SIG[0] <= data;\n        end\n    end\n\nassign q = SRL_SIG[a];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__xor2_9cee41eb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__xor2 (\n    X,\n    A,\n    B\n);\n\n    output X;\n    input  A;\n    input  B;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire xor0_out_X;\n\n    xor xor0 (xor0_out_X, B, A           );\n    buf buf0 (X         , xor0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2_to_1_24895509", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2_to_1 (\n    output reg Y,\n    input A,\n    input B,\n    input S\n);\n\nalways @(*) begin\n    if (S == 0) begin\n        Y = A;\n    end else begin\n        Y = B;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vga_stripes_50458d0e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule vga_stripes(\n\tVIDON,\n\tHC,\n\tVC,\n\tR,\n\tG,\n\tB,\n\tSW\n\t);\n\ninput VIDON;\ninput [9:0] HC;\ninput [9:0] VC;\noutput [7:0] R;\noutput [7:0] G;\noutput [7:0] B;\n\ninput [17:0] SW;\t\n\n\n\n\nreg [7:0] Rr, Gg, Bb;\nassign R = Rr;\nassign G = Gg;\nassign B = Bb;\n\nalways @ (VIDON, VC)\nbegin\n\tRr <= 8'b00000000;\n\tGg <= 8'b00000000;\n\tBb <= 8'b00000000;\n\t\n\tif( VIDON == 1'b1 )\n\tbegin\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tGg <= VC;\n\t\tRr <= HC;\n\t\tBb <= VC;\n\tend\nend\n\t\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "encrypt_module_34427737", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule encrypt_module(\n  input [15:0] input_data,\n  output [15:0] encrypted_output\n);\n\n  wire [7:0] A;\n  wire [7:0] B;\n\n  assign A = input_data[15:8];\n  assign B = input_data[7:0];\n\n  wire [7:0] A_mult;\n  wire [7:0] B_mult;\n\n  assign A_mult = A * 3;\n  assign B_mult = B * 5;\n\n  wire [7:0] A_plus_B_mult;\n  wire [7:0] B_plus_A_mult;\n\n  assign A_plus_B_mult = A_mult + B;\n  assign B_plus_A_mult = B_mult + A;\n\n  assign encrypted_output = {A_plus_B_mult, B_plus_A_mult};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sram_byte_en_824efe13", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sram_byte_en\n#(\nparameter DATA_WIDTH    = 128,\nparameter ADDRESS_WIDTH = 7\n)\n(\n    input                           i_clk,\n    input      [DATA_WIDTH-1:0]     i_write_data,\n    input                           i_write_enable,\n    input      [ADDRESS_WIDTH-1:0]  i_address,\n    input      [DATA_WIDTH/8-1:0]   i_byte_enable,\n    output reg [DATA_WIDTH-1:0]     o_read_data\n);\n\n    reg [DATA_WIDTH-1:0]   mem  [0:2**ADDRESS_WIDTH-1];\n    integer i;\n\n    always @(posedge i_clk) begin\n        // read\n        o_read_data <= i_write_enable ? {DATA_WIDTH{1'd0}} : mem[i_address];\n\n        // write\n        if (i_write_enable) begin\n            for (i=0; i<DATA_WIDTH/8; i=i+1) begin\n                mem[i_address][i*8+0] <= i_byte_enable[i] ? i_write_data[i*8+0] : mem[i_address][i*8+0] ;\n                mem[i_address][i*8+1] <= i_byte_enable[i] ? i_write_data[i*8+1] : mem[i_address][i*8+1] ;\n                mem[i_address][i*8+2] <= i_byte_enable[i] ? i_write_data[i*8+2] : mem[i_address][i*8+2] ;\n                mem[i_address][i*8+3] <= i_byte_enable[i] ? i_write_data[i*8+3] : mem[i_address][i*8+3] ;\n                mem[i_address][i*8+4] <= i_byte_enable[i] ? i_write_data[i*8+4] : mem[i_address][i*8+4] ;\n                mem[i_address][i*8+5] <= i_byte_enable[i] ? i_write_data[i*8+5] : mem[i_address][i*8+5] ;\n                mem[i_address][i*8+6] <= i_byte_enable[i] ? i_write_data[i*8+6] : mem[i_address][i*8+6] ;\n                mem[i_address][i*8+7] <= i_byte_enable[i] ? i_write_data[i*8+7] : mem[i_address][i*8+7] ;\n            end\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "johnson_counter_72f174ca", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule johnson_counter (\n  input clk,\n  output [n-1:0] out\n);\n\n  parameter n = 4; // number of output signals\n\n  reg [n-1:0] state;\n  wire [n-1:0] next_state;\n\n  assign out = state;\n\n  always @ (posedge clk) begin\n    state <= next_state;\n  end\n\n  assign next_state[0] = state[n-1] ^ state[0];\n  assign next_state[1] = state[0] ^ state[1];\n  assign next_state[2] = state[1] ^ state[2];\n  assign next_state[3] = state[2] ^ state[3];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "assert_change_assert_b334859e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule assert_change_assert (\n  input clk, reset_n, start_event, xzcheck_enable,\n  input [width-1:0] test_expr,\n  input [31:0] window,\n  input ignore_new_start, reset_on_new_start, error_on_new_start,\n  output pass\n);\n  parameter width = 8;\n  parameter num_cks = 2;\n  reg [width-1:0] test_expr_reg;\n  reg [31:0] window_count;\n  reg [31:0] start_event_count;\n  reg [31:0] reset_event_count;\n  reg [31:0] error_event_count;\n  reg [31:0] xzcheck_event_count;\n  reg [31:0] xz_error_count;\n  reg [31:0] xz_ignore_count;\n  reg [31:0] xz_pass_count;\n  reg [31:0] xz_reset_count;\n  reg [1:0] state;\n  reg [1:0] xz_state;\n  reg [width-1:0] xz_value;\n  reg [width-1:0] xz_mask;\n  reg [width-1:0] xz_error_mask;\n  reg [width-1:0] xz_ignore_mask;\n  reg [width-1:0] xz_pass_mask;\n  reg [width-1:0] xz_reset_mask;\n  assign pass = (state == 2'b10);\n  \n  always @(posedge clk) begin\n    if (!reset_n) begin\n      state <= 2'b00;\n      xz_state <= 2'b00;\n      test_expr_reg <= 0;\n      window_count <= 0;\n      start_event_count <= 0;\n      reset_event_count <= 0;\n      error_event_count <= 0;\n      xzcheck_event_count <= 0;\n      xz_error_count <= 0;\n      xz_ignore_count <= 0;\n      xz_pass_count <= 0;\n      xz_reset_count <= 0;\n      xz_value <= 0;\n      xz_mask <= 0;\n      xz_error_mask <= 0;\n      xz_ignore_mask <= 0;\n      xz_pass_mask <= 0;\n      xz_reset_mask <= 0;\n    end else begin\n      case (state)\n        2'b00: begin // IDLE\n          test_expr_reg <= test_expr;\n          if (start_event) begin\n            start_event_count <= start_event_count + 1;\n            if (ignore_new_start) begin\n              state <= 2'b01; // IGNORE\n            end else begin\n              state <= 2'b10; // CHECK\n            end\n          end\n        end\n        2'b01: begin // IGNORE\n          if (start_event) begin\n            start_event_count <= start_event_count + 1;\n            if (reset_on_new_start) begin\n              reset_event_count <= reset_event_count + 1;\n              state <= 2'b00; // IDLE\n            end else if (error_on_new_start) begin\n              error_event_count <= error_event_count + 1;\n              state <= 2'b11; // ERROR\n            end\n          end else begin\n            window_count <= window_count + 1;\n            if (window_count >= window) begin\n              state <= 2'b00; // IDLE\n            end\n          end\n        end\n        2'b10: begin // CHECK\n          if (start_event) begin\n            start_event_count <= start_event_count + 1;\n            if (reset_on_new_start) begin\n              reset_event_count <= reset_event_count + 1;\n              state <= 2'b00; // IDLE\n            end else if (error_on_new_start) begin\n              error_event_count <= error_event_count + 1;\n              state <= 2'b11; // ERROR\n            end\n          end else begin\n            window_count <= window_count + 1;\n            if (window_count >= window) begin\n              state <= 2'b00; // IDLE\n            end else begin\n              if (xzcheck_enable) begin\n                case (xz_state)\n                  2'b00: begin // IDLE\n                    if (test_expr_reg[xzcheck_event_count]) begin\n                      xz_value <= test_expr_reg;\n                      xz_mask <= (1 << xzcheck_event_count);\n                      xz_state <= 2'b01; // ERROR_MASK\n                    end else begin\n                      xz_state <= 2'b00; // IDLE\n                      xzcheck_event_count <= xzcheck_event_count + 1;\n                      if (xzcheck_event_count >= width) begin\n                        xz_pass_count <= xz_pass_count + 1;\n                        xz_state <= 2'b10; // PASS\n                      end\n                    end\n                  end\n                  2'b01: begin // ERROR_MASK\n                    if (test_expr_reg[xzcheck_event_count]) begin\n                      xz_error_mask <= xz_error_mask | (1 << xzcheck_event_count);\n                    end else begin\n                      xz_ignore_mask <= xz_ignore_mask | (1 << xzcheck_event_count);\n                    end\n                    xzcheck_event_count <= xzcheck_event_count + 1;\n                    if (xzcheck_event_count >= width) begin\n                      xz_state <= 2'b10; // PASS\n                    end else if (test_expr_reg[xzcheck_event_count]) begin\n                      xz_value <= test_expr_reg;\n                      xz_mask <= (1 << xzcheck_event_count);\n                      xz_state <= 2'b01; // ERROR_MASK\n                    end else begin\n                      xz_state <= 2'b00; // IDLE\n                    end\n                  end\n                  2'b10: begin // PASS\n                    if (test_expr_reg[xzcheck_event_count]) begin\n                      if (xz_value[xzcheck_event_count] !== test_expr_reg[xzcheck_event_count]) begin\n                        xz_error_count <= xz_error_count + 1;\n                        xz_error_mask <= xz_error_mask | (1 << xzcheck_event_count);\n                      end else begin\n                        xz_pass_mask <= xz_pass_mask | (1 << xzcheck_event_count);\n                      end\n                      xz_reset_mask <= xz_reset_mask | (1 << xzcheck_event_count);\n                      xz_reset_count <= xz_reset_count + 1;\n                      xz_state <= 2'b00; // IDLE\n                      xzcheck_event_count <= xzcheck_event_count + 1;\n                      if (xzcheck_event_count >= width) begin\n                        xz_pass_count <= xz_pass_count + 1;\n                        xz_state <= 2'b10; // PASS\n                      end\n                    end else begin\n                      xz_state <= 2'b00; // IDLE\n                      xzcheck_event_count <= xzcheck_event_count + 1;\n                      if (xzcheck_event_count >= width) begin\n                        xz_pass_count <= xz_pass_count + 1;\n                        xz_state <= 2'b10; // PASS\n                      end\n                    end\n                  end\n                endcase\n              end else begin\n                if (test_expr_reg === 0) begin\n                  state <= 2'b11; // ERROR\n                end\n              end\n            end\n          end\n        end\n        2'b11: begin // ERROR\n          if (start_event) begin\n            start_event_count <= start_event_count + 1;\n            if (reset_on_new_start) begin\n              reset_event_count <= reset_event_count + 1;\n              state <= 2'b00; // IDLE\n            end else if (error_on_new_start) begin\n              error_event_count <= error_event_count + 1;\n              state <= 2'b11; // ERROR\n            end\n          end else begin\n            window_count <= window_count + 1;\n            if (window_count >= window) begin\n              state <= 2'b00; // IDLE\n            end\n          end\n        end\n      endcase\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fourBitAdder_2460be75", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fourBitAdder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [4:0] temp_sum;\n\n    assign temp_sum = A + B + Cin;\n    assign Sum = temp_sum[3:0];\n    assign Cout = temp_sum[4];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tfr_mem_6f90f1f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule tfr_mem ( \n\tinput wire memclk_i,\n\toutput reg [23:0]\tbus_A_o,\n\toutput reg [7:0] bus_D_o,\n\toutput reg [31:0] romflags_o,\n\tinput busclk_i,\tinput nreset_i,\n\tinput [3:0] A_i,\tinput [7:0] D_i,\n\toutput reg [7:0] D_o,\n\tinput nWR_i,\n\tinput nRD_i\t\n\t);\n\n\treg [23:0] addr_io;\n\t\n\tfunction [7:0] lookup_register( input [3:0] a );\n\t\tcase( a )\n\t\t\t4'h0: lookup_register = addr_io[7:0];\n\t\t\t4'h1: lookup_register = addr_io[15:8];\n\t\t\t4'h2: lookup_register = addr_io[23:16];\n\t\t\t4'h4: lookup_register = romflags_o[7:0];\n\t\t\t4'h5: lookup_register = romflags_o[15:8];\n\t\t\t4'h6: lookup_register = romflags_o[23:16];\n\t\t\t4'h7: lookup_register = romflags_o[31:24];\n\t\t\tdefault: lookup_register = 8'hff;\n\t\tendcase\n\tendfunction\n\t\n\ttask write_register(\n\t\tinput [3:0] a,\n\t\tinput [7:0] d\n\t);\t\t\n\t\tcase( a )\n\t\t\t4'h0: addr_io[7:0] <= d;\n\t\t\t4'h1: addr_io[15:8] <= d;\n\t\t\t4'h2: addr_io[23:16] <= d;\n\t\t\t4'h4: romflags_o[d[4:0]] <= d[7];\n\t\t\t4'hf: bus_D_o <= d;\n\t\t\tdefault: ;\n\t\tendcase\n\tendtask\n\t\n\talways @(posedge busclk_i)\n\tbegin\n\t\tif( !nreset_i ) begin\n\t\t\taddr_io <= 24'd0;\n\t\t\tbus_D_o <= 8'd0;\n\t\t\tromflags_o <= 32'd0;\n\t\tend\n\t\telse begin\n\t\t\tif( !nRD_i ) D_o <= lookup_register(A_i);\n\t\t\tif( !nWR_i ) begin\n\t\t\t\twrite_register(A_i,D_i);\n\t\t\t\tif( A_i == 4'hf ) addr_io <= addr_io + 1'b1;\n\t\t\tend\n\t\tend\n\tend\n\t\n\talways @(posedge memclk_i)\n\tbegin\n\t\tbus_A_o <= (addr_io -1'b1);\tend\n\t\nendmodule\n\t\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RAM_65ebb8f1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RAM(\n    input wire clka,\n    input wire wea,\n    input wire [6:0] addra,\n    input wire [31:0] dina,\n    output reg [31:0] douta\n);\n\nreg [31:0] memory[0:127];\n\nalways @(posedge clka) begin\n    if(wea) begin\n        memory[addra] <= dina;\n    end\n    douta <= memory[addra];\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "anteconmutador_9e571a59", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule anteconmutador (\n    input clk,\n    input [7:0] count,\n    input calculate,\n    output reg [3:0] centenas,\n    output reg [3:0] decenas,\n    output reg [3:0] unidades,\n    output reg C,\n    output reg De,\n    output reg U\n);\n\n    reg [7:0] digitT;\n    reg i;\n\n    always @(posedge clk) begin\n        if (calculate) begin\n            if (i) begin\n                digitT = count;\n                i = 0;\n            end\n            if (digitT > 7'b1100011) begin\n                digitT = digitT - 7'b1100100;\n                centenas = centenas + 1;\n            end\n            else begin\n                if (digitT > 7'b0001001) begin\n                    digitT = digitT - 7'b0001010;\n                    decenas = decenas + 1;\n                end\n                else begin\n                    unidades = {digitT[3:0]};\n                    if (centenas >= 1) begin\n                        C = 1;\n                    end\n                    if (decenas >= 1) begin\n                        De = 1;\n                    end\n                    if (unidades >= 1) begin\n                        U = 1;\n                    end\n                end\n            end\n        end\n        else begin\n            digitT = 0;\n            C = 0;\n            De = 0;\n            U = 0;\n            i = 1;\n            centenas = 0;\n            decenas = 0;\n            unidades = 0;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_addsub_ef8f153a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ripple_addsub (\n    input [7:0] A,\n    input [7:0] B,\n    input SUB,\n    input CLK,\n    output reg [7:0] SUM,\n    output reg CARRY_OUT\n);\n\n    reg [7:0] temp_sum;\n    reg carry_in;\n\n    always @(posedge CLK) begin\n        if(SUB) begin\n            temp_sum <= A - B - carry_in;\n            CARRY_OUT <= ~((~A[7] & B[7]) | (~B[7] & temp_sum[6]) | (temp_sum[6] & ~A[7]));\n        end else begin\n            temp_sum <= A + B + carry_in;\n            CARRY_OUT <= (temp_sum[7] == 1);\n        end\n        SUM <= temp_sum[7:0];\n        carry_in <= CARRY_OUT;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "debouncer_d848b498", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule debouncer(clk, signal_in, debounce_time, signal_out);\n  input clk;\n  input signal_in;\n  input [31:0] debounce_time;\n  output signal_out;\n\n  reg [31:0] debounce_counter;\n  reg signal_out_reg;\n  reg signal_in_reg;\n\n  always @(posedge clk) begin\n    if (signal_in != signal_in_reg) begin\n      debounce_counter <= debounce_time;\n      signal_in_reg <= signal_in;\n    end else if (debounce_counter > 0) begin\n      debounce_counter <= debounce_counter - 1;\n    end else begin\n      debounce_counter <= debounce_time;\n      signal_out_reg <= signal_in;\n    end\n  end\n\n  assign signal_out = signal_out_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "square_wave_generator_fac2c546", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule square_wave_generator (\n    input clk,\n    output reg square_wave\n);\n\n    reg [31:0] counter;\n\n    always @(posedge clk) begin\n        counter <= counter + 1;\n        if (counter == 499_999) begin\n            counter <= 0;\n            square_wave <= ~square_wave;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axis_alex_c1f7584f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule axis_alex\n(\n  input  wire        aclk,\n  input  wire        aresetn,\n\n  output wire [3:0]  alex_data,\n\n  output wire        s_axis_tready,\n  input  wire [31:0] s_axis_tdata,\n  input  wire        s_axis_tvalid\n);\n\n  reg [15:0] int_data_reg, int_data_next;\n  reg [11:0] int_cntr_reg, int_cntr_next;\n  reg [1:0] int_load_reg, int_load_next;\n  reg int_enbl_reg, int_enbl_next;\n  reg int_tready_reg, int_tready_next;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_data_reg <= 16'd0;\n      int_cntr_reg <= 12'd0;\n      int_load_reg <= 2'd0;\n      int_enbl_reg <= 1'b0;\n      int_tready_reg <= 1'b0;\n    end\n    else\n    begin\n      int_data_reg <= int_data_next;\n      int_cntr_reg <= int_cntr_next;\n      int_load_reg <= int_load_next;\n      int_enbl_reg <= int_enbl_next;\n      int_tready_reg <= int_tready_next;\n    end\n  end\n\n  always @*\n  begin\n    int_data_next = int_data_reg;\n    int_cntr_next = int_cntr_reg;\n    int_load_next = int_load_reg;\n    int_enbl_next = int_enbl_reg;\n    int_tready_next = int_tready_reg;\n\n    if(s_axis_tvalid & ~int_enbl_reg)\n    begin\n      int_data_next = s_axis_tdata[15:0];\n      int_load_next = s_axis_tdata[17:16];\n      int_enbl_next = 1'b1;\n      int_tready_next = 1'b1;\n    end\n\n    if(int_tready_reg)\n    begin\n      int_tready_next = 1'b0;\n    end\n\n    if(int_enbl_reg)\n    begin\n      int_cntr_next = int_cntr_reg + 1'b1;\n    end\n\n    if(&int_cntr_reg[6:0])\n    begin\n      int_data_next = {int_data_reg[14:0], 1'b0};\n    end\n\n    if(int_cntr_reg[7] & int_cntr_reg[11])\n    begin\n      int_cntr_next = 12'd0;\n      int_load_next = 2'd0;\n      int_enbl_next = 1'b0;\n    end\n\n  end\n\n  assign s_axis_tready = int_tready_reg;\n\n  assign alex_data[0] = int_data_reg[15];\n  assign alex_data[1] = int_cntr_reg[6] & ~int_cntr_reg[11];\n  assign alex_data[2] = int_load_reg[0] & int_cntr_reg[6] & int_cntr_reg[11];\n  assign alex_data[3] = int_load_reg[1] & int_cntr_reg[6] & int_cntr_reg[11];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mag_comp_d4f19ce2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mag_comp(\n    input [3:0] A,\n    input [3:0] B,\n    output EQ,\n    output GT,\n    output LT\n);\n\n    reg EQ, GT, LT;\n\n    always @(*) begin\n        case(A > B)\n            1'b0: begin\n                EQ = (A == B);\n                GT = 1'b0;\n                LT = 1'b1;\n            end\n            1'b1: begin\n                EQ = 1'b0;\n                GT = 1'b1;\n                LT = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "joypad_controller_142cb3dd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule joypad_controller(\n  input  wire        clock,\n  input  wire        reset,\n  input  wire        int_ack,  \n  output reg         int_req,\n  input  wire [15:0] A,\n  input  wire  [7:0] Di,\n  output wire  [7:0] Do,\n  input  wire        rd_n,\n  input  wire        wr_n,\n  input  wire        cs,\n  output reg   [1:0] button_sel,\n  input  wire  [3:0] button_data\n);\n  \n  always @(posedge clock) begin\n    if (reset)\n      int_req <= 0;\n    else begin\n      if (!wr_n) begin\n        if (A == 16'hFF00)\n          button_sel <= Di[5:4];\n      end\n    end\n  end\n\n  assign Do = (cs) ? { 2'b11, button_sel[1:0], button_data[3:0] } : 8'hFF;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "AregInexactSlice_c58c3731", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule AregInexactSlice (\ninput [31:0] AM,\noutput notAM31_3,\noutput notAM2_0\n);\n\nwire [11:4] notAORed;\n\nnand (notAM31_3, AM[31], AM[30], AM[29], AM[28], AM[27], AM[26], AM[25], AM[24], AM[23], AM[22], AM[21], AM[20], AM[19]); // Fixed AM[19], AM[20], AM[21], AM[22], AM[23], AM[24], AM[25], AM[26], AM[27], AM[28], AM[29], AM[30], AM[31] to AM[31], AM[30], AM[29], AM[28], AM[27], AM[26], AM[25], AM[24], AM[23], AM[22], AM[21], AM[20], AM[19] //\nnand (notAM2_0, AM[2], AM[1], AM[0]); // Fixed AM[1], AM[2], AM[0] to AM[2], AM[1], AM[0] //\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "small_fifo_cntr_a581fc60", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule small_fifo_cntr (\n    input aclr,       // Asynchronous clear input\n    input clock,      // Clock input\n    input cnt_en,     // Counter enable input\n    input updown,     // Up/down counter select input\n    output [2:0] q,   // Counter output\n    input sclr        // Synchronous clear input\n);\n\n    // Internal registers\n    reg [2:0] q_reg;\n\n    // Counter logic\n    always @ (posedge clock or posedge aclr) begin\n        if (aclr) begin\n            q_reg <= 3'b0;\n        end else if (sclr) begin\n            q_reg <= 3'b0;\n        end else if (cnt_en) begin\n            if (updown) begin\n                q_reg <= q_reg + 1'b1;\n            end else begin\n                q_reg <= q_reg - 1'b1;\n            end\n        end\n    end\n\n    // Output assignment\n    assign q = q_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_buffer_ee46e342", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fifo_buffer (\n    input clk,\n    input reset,\n    output reg if_empty_n,\n    input if_read_ce,\n    input if_read,\n    output reg [7:0] if_dout,\n    output reg if_full_n,\n    input if_write_ce,\n    input if_write,\n    input [7:0] if_din\n);\n\nparameter ADDR_WIDTH = 1;\nparameter DEPTH = 2;\n\nreg [ADDR_WIDTH:0] wr_ptr = 0;\nreg [ADDR_WIDTH:0] rd_ptr = 0;\nreg [7:0] mem [0:DEPTH-1];\nreg [ADDR_WIDTH:0] count = 0;\n\nalways @(posedge clk) begin\n    if (reset == 1) begin\n        wr_ptr <= 0;\n        rd_ptr <= 0;\n        count <= 0;\n    end else begin\n        if (if_write & if_write_ce & if_full_n) begin\n            mem[wr_ptr] <= if_din;\n            wr_ptr <= wr_ptr + 1;\n            count <= count + 1;\n            if (wr_ptr == DEPTH) begin\n                wr_ptr <= 0;\n            end\n        end\n        if (if_read & if_read_ce & if_empty_n) begin\n            if_dout <= mem[rd_ptr];\n            rd_ptr <= rd_ptr + 1;\n            count <= count - 1;\n            if (rd_ptr == DEPTH) begin\n                rd_ptr <= 0;\n            end\n        end\n    end\n    if_empty_n <= (count > 0);\n    if_full_n <= (count < DEPTH);\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_or_8bab9e5e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule bitwise_or (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out\n);\n\n// Stage 1\nwire [3:0] stage1_out;\nassign stage1_out = a | b;\n\n// Stage 2\nalways @(*) begin\n    out <= stage1_out;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_inverter_0503aeaf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule xor_inverter (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output [7:0] out\n);\n\n    assign out = ctrl ? ~(a ^ b) : (a ^ b);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_5e014959", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo(\n  input clk,\n  input rst,\n  input [7:0] din,\n  input wr_en,\n  input rd_en,\n  output reg [7:0] dout,\n  output reg full,\n  output reg empty\n);\n\nparameter DEPTH = 16;\n\nreg [7:0] mem [0:DEPTH-1];\nreg [3:0] wr_ptr = 0;\nreg [3:0] rd_ptr = 0;\nreg [3:0] count = 0;\n\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    wr_ptr <= 0;\n    rd_ptr <= 0;\n    count <= 0;\n  end else begin\n    if (wr_en && !full) begin\n      mem[wr_ptr] <= din;\n      wr_ptr <= wr_ptr + 1;\n      count <= count + 1;\n    end\n    if (rd_en && !empty) begin\n      dout <= mem[rd_ptr];\n      rd_ptr <= rd_ptr + 1;\n      count <= count - 1;\n    end\n  end\nend\n\nalways @* begin\n  full = (count == DEPTH);\n  empty = (count == 0);\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__8a9e8138", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,          // Synchronous active-high reset\n    input [9:0] d,        // 10-bit input for the shift register\n    output [9:0] q,       // 10-bit output from the active module\n    output [9:0] count_out // 10-bit output from the binary counter\n);\n\n    // Shift register using ring counter architecture\n    reg [9:0] shift_reg [0:9];\n    reg [3:0] shift_sel = 4'b0001;\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_sel <= 4'b0001;\n        end\n        else begin\n            shift_reg[shift_sel] <= d;\n            shift_sel <= (shift_sel == 4'b1000) ? 4'b0001 : (shift_sel + 1);\n        end\n    end\n    assign q = shift_reg[shift_sel];\n\n    // Binary counter\n    reg [9:0] binary_counter = 10'b0;\n    always @(posedge clk) begin\n        if (reset) begin\n            binary_counter <= 10'b0;\n        end\n        else begin\n            binary_counter <= (binary_counter == 10'b1111111111) ? 10'b0 : binary_counter + 1;\n        end\n    end\n    assign count_out = binary_counter;\n\n    // Functional unit\n    reg [19:0] mult_out = 20'b0;\n    reg select = 1'b0;\n    always @(posedge clk) begin\n        if(reset) begin\n            mult_out <= 20'b0;\n            select <= 1'b0;\n        end\n        else begin\n            if(select)begin\n                mult_out <= shift_reg[shift_sel] * count_out;\n            end\n            else begin\n                mult_out <= count_out * shift_reg[shift_sel];\n            end\n        end\n    end\n\n    // Control logic\n    always @(posedge clk) begin\n        if(reset) begin\n            select <= 1'b0;\n        end\n        else begin\n            select <= (binary_counter == 10'b1111111111) ? 1'b1 : select;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__8e0e969f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [7:0] in,\n    output reg [7:0] anyedge,\n    output [7:0] final_out\n); // RTL will be here\n\n    reg [7:0] last_in;\n    wire [7:0] xor_out;\n    \n    xor_detector u1 (\n        .in(in),\n        .last_in(last_in),\n        .anyedge(xor_out)\n    );\n    \n    always @(posedge clk or posedge reset) begin // RTL will be here\n        if (reset) begin\n            last_in <= 8'b0;\n            anyedge <= 8'b0;\n        end else begin\n            last_in <= in;\n            anyedge <= xor_out;\n        end\n    end\n    \n    assign final_out = xor_out | anyedge;\n    \nendmodule\nmodule xor_detector (\n    input [7:0] in,\n    input [7:0] last_in,\n    output [7:0] anyedge\n);\n    \n    assign anyedge = in ^ last_in;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_2af8bb4b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n    input clk,\n    input reset,            // Asynchronous reset\n    input [3:0] d,\n    input enable,\n    output [3:0] q\n);\n\nreg [3:0] q_reg1, q_reg2, q_reg3, q_reg4;\n\nalways @(posedge clk, negedge reset) begin\n    if (!reset) begin\n        q_reg1 <= 1'b0;\n        q_reg2 <= 1'b0;\n        q_reg3 <= 1'b0;\n        q_reg4 <= 1'b0;\n    end else begin\n        q_reg1 <= enable ? d[0] : q_reg1;\n        q_reg2 <= enable ? q_reg1 : q_reg2;\n        q_reg3 <= enable ? q_reg2 : q_reg3;\n        q_reg4 <= enable ? q_reg3 : q_reg4;\n    end\nend\n\nassign q = q_reg4;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rcn_filter_8c2be3eb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule rcn_filter\n(\n    input clk,\n    input rst,\n\n    input [68:0] rcn_in,\n    output [68:0] rcn_out,\n    \n    output reg filtered\n);\n    parameter START_0 = 1;\n    parameter END_0 = 0;\n    parameter START_1 = 1;\n    parameter END_1 = 0;\n    parameter START_2 = 1;\n    parameter END_2 = 0;\n    parameter START_3 = 1;\n    parameter END_3 = 0;\n\n    reg [68:0] rin;\n    reg [68:0] rout;\n    \n    assign rcn_out = rout;\n    \n    wire [23:0] addr_start_0 = START_0;\n    wire [23:0] addr_end_0 = END_0;\n    wire filter_0 = (rin[55:34] >= addr_start_0) && (rin[55:34] <= addr_end_0);\n    \n    wire [23:0] addr_start_1 = START_1;\n    wire [23:0] addr_end_1 = END_1;\n    wire filter_1 = (rin[55:34] >= addr_start_1) && (rin[55:34] <= addr_end_1);\n    \n    wire [23:0] addr_start_2 = START_2;\n    wire [23:0] addr_end_2 = END_2;\n    wire filter_2 = (rin[55:34] >= addr_start_2) && (rin[55:34] <= addr_end_2);\n    \n    wire [23:0] addr_start_3 = START_3;\n    wire [23:0] addr_end_3 = END_3;\n    wire filter_3 = (rin[55:34] >= addr_start_3) && (rin[55:34] <= addr_end_3);\n    \n    always @ (posedge clk or posedge rst)\n        if (rst)\n        begin\n            rin <= 69'd0;\n            rout <= 69'd0;\n            filtered <= 1'b0;\n        end\n        else\n        begin\n            rin <= rcn_in;\n            rout <= (filter_0 || filter_1 || filter_2 || filter_3) ? 69'd0 : rcn_in;\n            filtered <= (filter_0 || filter_1 || filter_2 || filter_3);\n        end\n    \n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_AXI_CTRL_s_axi_3371b9fa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule adder_AXI_CTRL_s_axi\n#(parameter\n    C_ADDR_WIDTH = 6,\n    C_DATA_WIDTH = 32\n)(\n    input  wire                      ACLK,\n    input  wire                      ARESET,\n    input  wire                      ACLK_EN,\n    input  wire [C_ADDR_WIDTH-1:0]   AWADDR,\n    input  wire                      AWVALID,\n    output wire                      AWREADY,\n    input  wire [C_DATA_WIDTH-1:0]   WDATA,\n    input  wire [C_DATA_WIDTH/8-1:0] WSTRB,\n    input  wire                      WVALID,\n    output wire                      WREADY,\n    output wire [1:0]                BRESP,\n    output wire                      BVALID,\n    input  wire                      BREADY,\n    input  wire [C_ADDR_WIDTH-1:0]   ARADDR,\n    input  wire                      ARVALID,\n    output wire                      ARREADY,\n    output wire [C_DATA_WIDTH-1:0]   RDATA,\n    output wire [1:0]                RRESP,\n    output wire                      RVALID,\n    input  wire                      RREADY,\n    output wire                      interrupt,\n    output wire                      ap_start,\n    input  wire                      ap_done,\n    input  wire                      ap_ready,\n    input  wire                      ap_idle,\n    output wire [31:0]               a,\n    output wire [31:0]               b,\n    input  wire [31:0]               c,\n    input  wire                      c_ap_vld\n);\nlocalparam\n    ADDR_BITS = 6;\n\nlocalparam\n    ADDR_AP_CTRL  = 6'h00,\n    ADDR_GIE      = 6'h04,\n    ADDR_IER      = 6'h08,\n    ADDR_ISR      = 6'h0c,\n    ADDR_A_DATA_0 = 6'h10,\n    ADDR_A_CTRL   = 6'h14,\n    ADDR_B_DATA_0 = 6'h18,\n    ADDR_B_CTRL   = 6'h1c,\n    ADDR_C_DATA_0 = 6'h20,\n    ADDR_C_CTRL   = 6'h24;\n\nlocalparam\n    WRIDLE = 2'd0,\n    WRDATA = 2'd1,\n    WRRESP = 2'd2;\n\nlocalparam\n    RDIDLE = 2'd0,\n    RDDATA = 2'd1;\n\nreg  [1:0]           wstate;\nreg  [1:0]           wnext;\nreg  [ADDR_BITS-1:0] waddr;\nwire [31:0]          wmask;\nwire                 aw_hs;\nwire                 w_hs;\nreg  [1:0]           rstate;\nreg  [1:0]           rnext;\nreg  [31:0]          rdata;\nwire                 ar_hs;\nwire [ADDR_BITS-1:0] raddr;\nwire                 int_ap_idle;\nwire                 int_ap_ready;\nreg                  int_ap_done;\nreg                  int_ap_start;\nreg                  int_auto_restart;\nreg                  int_gie;\nreg                  int_ier;\nreg                  int_isr;\nreg  [31:0]          int_a;\nreg  [31:0]          int_b;\nreg  [31:0]          int_c;\nreg                  int_c_ap_vld;\n\nassign AWREADY = (wstate == WRIDLE);\nassign WREADY  = (wstate == WRDATA);\nassign BRESP   = 2'b00;  assign BVALID  = (wstate == WRRESP);\nassign wmask   = { {8{WSTRB[3]}}, {8{WSTRB[2]}}, {8{WSTRB[1]}}, {8{WSTRB[0]}} };\nassign aw_hs   = AWVALID & AWREADY;\nassign w_hs    = WVALID & WREADY;\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (ARESET)\n            wstate <= WRIDLE;\n        else\n            wstate <= wnext;\n    end\nend\n\nalways @(*) begin\n    case (wstate)\n        WRIDLE:\n            if (AWVALID)\n                wnext = WRDATA;\n            else\n                wnext = WRIDLE;\n        WRDATA:\n            if (WVALID)\n                wnext = WRRESP;\n            else\n                wnext = WRDATA;\n        WRRESP:\n            if (BREADY)\n                wnext = WRIDLE;\n            else\n                wnext = WRRESP;\n        default:\n            wnext = WRIDLE;\n    endcase\nend\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (aw_hs)\n            waddr <= AWADDR[ADDR_BITS-1:0];\n    end\nend\nassign ARREADY = (rstate == RDIDLE);\nassign RDATA   = rdata;\nassign RRESP   = 2'b00;  assign RVALID  = (rstate == RDDATA);\nassign ar_hs   = ARVALID & ARREADY;\nassign raddr   = ARADDR[ADDR_BITS-1:0];\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (ARESET)\n            rstate <= RDIDLE;\n        else\n            rstate <= rnext;\n    end\nend\n\nalways @(*) begin\n    case (rstate)\n        RDIDLE:\n            if (ARVALID)\n                rnext = RDDATA;\n            else\n                rnext = RDIDLE;\n        RDDATA:\n            if (RREADY & RVALID)\n                rnext = RDIDLE;\n            else\n                rnext = RDDATA;\n        default:\n            rnext = RDIDLE;\n    endcase\nend\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (ar_hs) begin\n            rdata <= 1'b0;\n            case (raddr)\n                ADDR_AP_CTRL: begin\n                    rdata[0] <= int_ap_start;\n                    rdata[1] <= int_ap_done;\n                    rdata[2] <= int_ap_idle;\n                    rdata[3] <= int_ap_ready;\n                    rdata[7] <= int_auto_restart;\n                end\n                ADDR_GIE: begin\n                    rdata <= int_gie;\n                end\n                ADDR_IER: begin\n                    rdata <= int_ier;\n                end\n                ADDR_ISR: begin\n                    rdata <= int_isr;\n                end\n                ADDR_A_DATA_0: begin\n                    rdata <= int_a[31:0];\n                end\n                ADDR_B_DATA_0: begin\n                    rdata <= int_b[31:0];\n                end\n                ADDR_C_DATA_0: begin\n                    rdata <= int_c[31:0];\n                end\n                ADDR_C_CTRL: begin\n                    rdata[0] <= int_c_ap_vld;\n                end\n            endcase\n        end\n    end\nend\nassign interrupt    = int_gie & (|int_isr);\nassign ap_start     = int_ap_start;\nassign int_ap_idle  = ap_idle;\nassign int_ap_ready = ap_ready;\nassign a            = int_a;\nassign b            = int_b;\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ap_start <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0] && WDATA[0])\n            int_ap_start <= 1'b1;\n        else if (ap_done & int_auto_restart)\n            int_ap_start <= 1'b1; else\n            int_ap_start <= 1'b0; end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ap_done <= 1'b0;\n    else if (ACLK_EN) begin\n        if (ap_done)\n            int_ap_done <= 1'b1;\n        else if (ar_hs && raddr == ADDR_AP_CTRL)\n            int_ap_done <= 1'b0; end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_auto_restart <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_AP_CTRL && WSTRB[0])\n            int_auto_restart <=  WDATA[7];\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_gie <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_GIE && WSTRB[0])\n            int_gie <= WDATA[0];\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_ier <= 1'b0;\n    else if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_IER && WSTRB[0])\n            int_ier <= WDATA[0];\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_isr <= 1'b0;\n    else if (ACLK_EN) begin\n        if (int_ier & ap_done)\n            int_isr <= 1'b1;\n        else if (w_hs && waddr == ADDR_ISR && WSTRB[0])\n            int_isr <= int_isr ^ WDATA[0]; end\nend\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_A_DATA_0)\n            int_a[31:0] <= (WDATA[31:0] & wmask) | (int_a[31:0] & ~wmask);\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ACLK_EN) begin\n        if (w_hs && waddr == ADDR_B_DATA_0)\n            int_b[31:0] <= (WDATA[31:0] & wmask) | (int_b[31:0] & ~wmask);\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_c <= 0;\n    else if (ACLK_EN) begin\n        if (c_ap_vld)\n            int_c <= c;\n    end\nend\n\nalways @(posedge ACLK) begin\n    if (ARESET)\n        int_c_ap_vld <= 1'b0;\n    else if (ACLK_EN) begin\n        if (c_ap_vld)\n            int_c_ap_vld <= 1'b1;\n        else if (ar_hs && raddr == ADDR_C_CTRL)\n            int_c_ap_vld <= 1'b0; end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_flip_flop_2e450d9d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule d_flip_flop(input D, VPWR, VGND, VPB, VNB, CLK, output Q, Q_N);\n  // Create a set/reset latch for Q and Q_N\n  reg Q_SR, Q_N_SR;\n  assign Q = Q_SR;\n  assign Q_N = Q_N_SR;\n\n  // Create a clocked SR latch for Q and Q_N\n  reg Q_SR_CLK, Q_N_SR_CLK;\n  always @(posedge CLK)\n  begin\n    Q_SR_CLK <= Q_SR;\n    Q_N_SR_CLK <= Q_N_SR;\n    Q_SR <= D;\n    Q_N_SR <= D;\n  end\n\n  // Ensure that the outputs are initially x\n  initial\n  begin\n    Q_SR = 1'bX;\n    Q_N_SR = 1'bX;\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_sub_mux_976a3485", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule add_sub_mux(\n    input [31:0] a,\n    input [31:0] b,\n    input sub,\n    output [31:0] result\n);\n\n    wire [31:0] adder_out;\n    wire mux_out;\n    \n    adder adder_inst(\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .sum(adder_out[31:16])\n    );\n    \n    assign adder_out[15:0] = a[15:0] + b[15:0];\n    \n    assign mux_out = sub ? ~adder_out[0] : adder_out[0];\n    \n    assign result[31:16] = adder_out[31:16] + mux_out;\n    assign result[15:0] = a[15:0] + b[15:0];\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] sum\n);\n\n    always @ (a or b) begin\n        sum <= a + b;\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_7ac2acf3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register ( input clk, input d, output q );\n  reg [2:0] reg_q;\n  always @(posedge clk) begin\n    reg_q <= {reg_q[1:0], d};\n  end\n  assign q = reg_q[2];\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_70290513", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule and_gate (\n    input A, B,\n    output Y\n);\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    and (Y, A, B); // gate output\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__c895c625", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    input enable,     // Asynchronous counter enable\n    input [3:0] A,    // 4-bit input for the adder-subtractor circuit\n    input [3:0] B,    // 4-bit input for the adder-subtractor circuit\n    input sub,        // Selects between addition and subtraction\n    input select,     // Selects between counter and adder-subtractor circuit output\n    output [3:0] Q    // Final output from the active module\n);\n\n    // Counter module with asynchronous reset and enable\n    reg [3:0] counter;\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            counter <= 4'b0000;\n        end else if (enable) begin\n            counter <= counter + 1;\n        end\n    end\n    \n    // Adder-subtractor module\n    wire [3:0] sum;\n    assign sum = sub ? A - B : A + B;\n    \n    // Functional module to select maximum value\n    reg [3:0] max_value;\n    always @(*) begin\n        if (select) begin\n            max_value = counter > sum ? counter : sum;\n        end else begin\n            max_value = counter;\n        end\n    end\n    \n    // Output\n    assign Q = max_value;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff__76d4aa61", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_module (\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(negedge clk) begin\n    q <= d;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    output [7:0] q\n);\n\nwire [7:0] q_internal;\n\ndff_module dff0(clk, d[0], q_internal[0]);\ndff_module dff1(clk, d[1], q_internal[1]);\ndff_module dff2(clk, d[2], q_internal[2]);\ndff_module dff3(clk, d[3], q_internal[3]);\ndff_module dff4(clk, d[4], q_internal[4]);\ndff_module dff5(clk, d[5], q_internal[5]);\ndff_module dff6(clk, d[6], q_internal[6]);\ndff_module dff7(clk, d[7], q_internal[7]);\n\nassign q = q_internal;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_9559b1ef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(input [7:0] a, input [7:0] b, input [2:0] op, output reg [15:0] res);\n\n    always @(*) begin\n        case(op)\n            3'b000: res = a + b; // Addition\n            3'b001: res = a - b; // Subtraction\n            3'b010: res = a * b; // Multiplication\n            3'b011: res = a / b; // Division\n            default: res = 16'b0; // Default value\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "EXMEMreg_897ab87c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule EXMEMreg(clk,Rtin,Rdin,PCplusin,ALUresultin,DatabusBin,RegDstin,RegWrin,MemWrin,MemRdin,MemtoRegin,\nRtout,Rdout,PCplusout,ALUresultout,DatabusBout,RegDstout,RegWrout,MemWrout,MemRdout,MemtoRegout);\n\ninput clk;\ninput [4:0] Rtin;\ninput [4:0] Rdin;\ninput [31:0] PCplusin;\ninput [31:0] ALUresultin;\ninput [31:0] DatabusBin;\ninput [1:0] RegDstin;\ninput RegWrin;\ninput MemWrin;\ninput MemRdin;\ninput [1:0] MemtoRegin;\noutput [4:0] Rtout;\nreg [4:0] Rtout;\noutput [4:0] Rdout;\nreg [4:0] Rdout;\noutput [31:0] PCplusout;\nreg [31:0] PCplusout;\noutput [31:0] ALUresultout;\nreg [31:0] ALUresultout;\noutput [31:0] DatabusBout;\nreg [31:0] DatabusBout;\noutput [1:0] RegDstout;\nreg [1:0] RegDstout;\noutput RegWrout;\nreg RegWrout;\noutput MemWrout;\nreg MemWrout;\noutput MemRdout;\nreg MemRdout;\noutput [1:0] MemtoRegout;\nreg [1:0] MemtoRegout;\n\nalways @(posedge clk)\nbegin\n  Rtout <= Rtin;\n  Rdout <= Rdin;\n  PCplusout <= PCplusin;\n  ALUresultout <= ALUresultin;\n  DatabusBout <= DatabusBin;\n  RegDstout <= RegDstin;\n  RegWrout <= RegWrin;\n  MemWrout <= MemWrin;\n  MemRdout <= MemRdin;\n  MemtoRegout <= MemtoRegin;\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "unknown_module_4f8a1ae8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule\tprefetch(i_clk, i_rst, i_new_pc, i_clear_cache, i_stalled_n, i_pc,\n\t\t\to_i, o_pc, o_valid, o_illegal,\n\t\to_wb_cyc, o_wb_stb, o_wb_we, o_wb_addr, o_wb_data,\n\t\t\ti_wb_ack, i_wb_stall, i_wb_err, i_wb_data);\n\tparameter\t\tADDRESS_WIDTH=32;\n\tlocalparam\t\tAW=ADDRESS_WIDTH;\n\tinput\twire\t\t\ti_clk, i_rst, i_new_pc, i_clear_cache,\n\t\t\t\t\ti_stalled_n;\n\tinput\twire\t[(AW-1):0]\ti_pc;\n\toutput\treg\t[31:0]\t\to_i;\n\toutput\twire\t[(AW-1):0]\to_pc;\n\toutput\treg\t\t\to_valid;\n\toutput\treg\t\t\to_wb_cyc, o_wb_stb;\n\toutput\twire\t\t\to_wb_we;\n\toutput\treg\t[(AW-1):0]\to_wb_addr;\n\toutput\twire\t[31:0]\t\to_wb_data;\n\tinput\twire\t\t\ti_wb_ack, i_wb_stall, i_wb_err;\n\tinput\twire\t[31:0]\t\ti_wb_data;\n\toutput\treg\t\t\to_illegal;\n\n\tassign\to_wb_we = 1'b0;\n\tassign\to_wb_data = 32'h0000;\n\n\tinitial\to_wb_cyc = 1'b0;\n\tinitial\to_wb_stb = 1'b0;\n\tinitial\to_wb_addr= 0;\n\talways @(posedge i_clk)\n\t\tif ((i_rst)||(i_wb_ack)||(i_wb_err))\n\t\tbegin\n\t\t\to_wb_cyc <= 1'b0;\n\t\t\to_wb_stb <= 1'b0;\n\t\tend else if ((!o_wb_cyc)&&((i_stalled_n)||(!o_valid)||(i_new_pc)))\n\t\tbegin o_wb_cyc <= 1'b1;\n\t\t\to_wb_stb <= 1'b1;\n\t\tend else if (o_wb_cyc) begin\n\t\t\tif (!i_wb_stall)\n\t\t\t\to_wb_stb <= 1'b0;\n\t\tend\n\n\treg\tinvalid;\n\tinitial\tinvalid = 1'b0;\n\talways @(posedge i_clk)\n\t\tif (!o_wb_cyc)\n\t\t\tinvalid <= 1'b0;\n\t\telse if ((i_new_pc)||(i_clear_cache))\n\t\t\tinvalid <= 1'b1;\n\n\talways @(posedge i_clk)\n\t\tif (i_new_pc)\n\t\t\to_wb_addr <= i_pc;\n\t\telse if ((!o_wb_cyc)&&(i_stalled_n)&&(!invalid))\n\t\t\to_wb_addr <= o_wb_addr + 1'b1;\n\n\talways @(posedge i_clk)\n\t\tif ((o_wb_cyc)&&(i_wb_ack))\n\t\t\to_i <= i_wb_data;\n\n\tinitial o_valid   = 1'b0;\n\tinitial o_illegal = 1'b0;\n\talways @(posedge i_clk)\n\t\tif ((i_rst)||(i_new_pc))\n\t\tbegin\n\t\t\to_valid   <= 1'b0;\n\t\t\to_illegal <= 1'b0;\n\t\tend else if ((o_wb_cyc)&&((i_wb_ack)||(i_wb_err)))\n\t\tbegin\n\t\t\to_valid   <= (!invalid);\n\t\t\to_illegal <= ( i_wb_err)&&(!invalid);\n\t\tend else if ((i_stalled_n)||(i_clear_cache)||(i_new_pc))\n\t\tbegin\n\t\t\to_valid <= 1'b0;\n\t\t\to_illegal <= 1'b0;\n\t\tend\n\n\tassign\to_pc = o_wb_addr;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dffe_bce037d1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule dffe (\n   Q,\n   CLK,\n   ENA,\n   D,\n   CLRN,\n   PRN\n);\n   input D;\n   input CLK;\n   input CLRN, PRN;\n   input ENA;\n   output Q;\n\n   reg Q_reg = 1'b0;\n\n   always @(posedge CLK) begin\n      if (CLRN == 1'b0) begin\n         Q_reg <= 1'b0;\n      end\n      else if (PRN == 1'b0) begin\n         Q_reg <= 1'b1;\n      end\n      else if (ENA) begin\n         Q_reg <= D;\n      end\n   end\n\n   assign Q = Q_reg;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gate_d3bed2fb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_gate(\n    input CLK,\n    input EN,\n    input TE,\n    output reg ENCLK\n);\n\nreg gated_clk;\n\nalways @ (posedge CLK) begin\n    if (EN & !TE) begin\n        gated_clk <= 1'b1;\n    end else begin\n        gated_clk <= 1'b0;\n    end\nend\n\nalways @ (*) begin\n    if (TE) begin\n        ENCLK = CLK;\n    end else begin\n        ENCLK = gated_clk ? CLK : ENCLK;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hdll__and4_009b1791", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hdll__and4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, A, B, C, D     );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_max_9f95a0f7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_max (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    output reg [3:0] max,\n    output reg max_sel\n);\n\nalways @(posedge clk) begin\n    if (A > B) begin\n        max <= A;\n        max_sel <= 1;\n    end else begin\n        max <= B;\n        max_sel <= 0;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tg68_ram #_869f481c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule tg68_ram #(\n  parameter MS = 512\n)(\n  input  wire           clk,\n  input  wire           tg68_as,\n  input  wire [ 32-1:0] tg68_adr,\n  input  wire           tg68_rw,\n  input  wire           tg68_lds,\n  input  wire           tg68_uds,\n  input  wire [ 16-1:0] tg68_dat_out,\n  output wire [ 16-1:0] tg68_dat_in,\n  output wire           tg68_dtack\n);\n\nreg  [8-1:0] mem0 [0:MS-1];\nreg  [8-1:0] mem1 [0:MS-1];\n\nreg  [16-1:0] mem_do = 0;\nreg           trn = 1;\nreg           ack = 1;\n\ninteger i;\ninitial begin\n  for (i=0; i<MS; i=i+1) begin\n    mem1[i] = 0;\n    mem0[i] = 0;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (!tg68_as && tg68_rw) mem_do <= #1 {mem1[tg68_adr[31:1]], mem0[tg68_adr[31:1]]};\nend\n\nalways @ (posedge clk) begin\n  if (!tg68_as && !tg68_rw) begin\n    if (!tg68_uds) mem1[tg68_adr[31:1]] <= #1 tg68_dat_out[15:8];\n    if (!tg68_lds) mem0[tg68_adr[31:1]] <= #1 tg68_dat_out[7:0];\n  end\nend\n\nalways @ (posedge clk) begin\n  trn <= #1 tg68_as;\n  ack <= #1 trn;\nend\n\nassign tg68_dat_in = mem_do;\nassign tg68_dtack = ack || tg68_as; task load;\n  input [1024*8-1:0] file;\n  reg [16-1:0] memory[0:MS-1];\n  reg [16-1:0] dat;\n  integer i;\nbegin\n  $readmemh(file, memory);\n  for (i=0; i<MS; i=i+1) begin\n    dat = memory[i];\n    mem1[i] = dat[15:8];\n    mem0[i] = dat[7:0];\n  end\nend\nendtask\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__28ab274b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input Clk,\n    input reset,\n    input [3:0] a,\n    input [3:0] b,\n    output reg gt,\n    output reg lt,\n    output reg eq\n);\n\n    reg [7:0] johnson_out;\n    wire [2:0] comp_out;\n\n    comparator comp(.a(a), .b(b), .gt(comp_out[2]), .lt(comp_out[1]), .eq(comp_out[0]));\n    johnson_counter johnson(.Clk(Clk), .Y(johnson_out));\n\n    always @(posedge Clk) begin\n        if (reset) begin\n            gt <= 0;\n            lt <= 0;\n            eq <= 0;\n            johnson_out <= 8'b00000001;\n        end else begin\n            case (comp_out)\n                3'b000: begin // a < Y < b\n                    gt <= 0;\n                    lt <= 0;\n                    eq <= 0;\n                end\n                3'b001: begin // Y = b\n                    gt <= 0;\n                    lt <= 0;\n                    eq <= 1;\n                end\n                3'b010: begin // a < Y\n                    gt <= 1;\n                    lt <= 0;\n                    eq <= 0;\n                end\n                3'b011: begin // Y > b\n                    gt <= 1;\n                    lt <= 0;\n                    eq <= 1;\n                end\n                3'b100: begin // Y = a\n                    gt <= 0;\n                    lt <= 1;\n                    eq <= 0;\n                end\n                3'b101: begin // Y < a\n                    gt <= 0;\n                    lt <= 1;\n                    eq <= 1;\n                end\n                3'b110: begin // Y < a or Y > b\n                    gt <= 1;\n                    lt <= 1;\n                    eq <= 0;\n                end\n                3'b111: begin // Y < a or Y > b or Y = b\n                    gt <= 1;\n                    lt <= 1;\n                    eq <= 1;\n                end\n            endcase\n\n            if (johnson_out == 8'b10000000) begin\n                johnson_out <= 8'b00000001;\n            end else begin\n                johnson_out <= johnson_out << 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule comparator (\n    input [3:0] a,\n    input [3:0] b,\n    output reg gt,\n    output reg lt,\n    output reg eq\n);\n\n    always @(*) begin\n        if (a > b) begin\n            gt = 1;\n            lt = 0;\n            eq = 0;\n        end else if (a < b) begin\n            gt = 0;\n            lt = 1;\n            eq = 0;\n        end else begin\n            gt = 0;\n            lt = 0;\n            eq = 1;\n        end\n    end\n\nendmodule\n\nmodule johnson_counter (\n    input Clk,\n    output reg [7:0] Y\n);\n\n    always @(posedge Clk) begin\n        if (Y == 8'b10000000) begin\n            Y <= 8'b00000001;\n        end else begin\n            Y <= Y << 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "floating_point_arithmetic_cc2100f5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule floating_point_arithmetic (\n  input [31:0] a,\n  input [31:0] b,\n  input [1:0] ctrl,\n  output reg [31:0] result\n);\n\nparameter EXPONENT_WIDTH = 8;\nparameter MANTISSA_WIDTH = 23;\n\n// Define input and output formats as per IEEE 754 standard\nwire [EXPONENT_WIDTH-1:0] a_exp, b_exp;\nwire [MANTISSA_WIDTH-1:0] a_mant, b_mant;\nwire a_sign, b_sign;\nassign a_sign = a[31];\nassign a_exp = a[30:23];\nassign a_mant = a[22:0];\nassign b_sign = b[31];\nassign b_exp = b[30:23];\nassign b_mant = b[22:0];\n\n// Implement addition, subtraction, multiplication, and division using Verilog code\nwire [31:0] add_result, sub_result, mul_result, div_result;\nadder add(.a(a), .b(b), .result(add_result));\nsubtractor sub(.a(a), .b(b), .result(sub_result));\nmultiplier mul(.a(a), .b(b), .result(mul_result));\ndivider div(.a(a), .b(b), .result(div_result));\n\n// Select the operation based on the control signal\nalways @(*) begin\n  case (ctrl)\n    2'b00: result <= add_result;\n    2'b01: result <= sub_result;\n    2'b10: result <= mul_result;\n    2'b11: result <= div_result;\n    default: result <= 32'b0;\n  endcase\nend\n\nendmodule\n\nmodule adder (\n  input [31:0] a,\n  input [31:0] b,\n  output reg [31:0] result\n);\nalways @* begin\n  result = a + b;\nend\nendmodule\n\nmodule subtractor (\n  input [31:0] a,\n  input [31:0] b,\n  output reg [31:0] result\n);\nalways @* begin\n  result = a - b;\nend\nendmodule\n\nmodule multiplier (\n  input [31:0] a,\n  input [31:0] b,\n  output reg [31:0] result\n);\nalways @* begin\n  result = a * b;\nend\nendmodule\n\nmodule divider (\n  input [31:0] a,\n  input [31:0] b,\n  output reg [31:0] result\n);\nalways @* begin\n  result = a / b;\nend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_e917d6f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_register (\n    input clk,\n    input reset,\n    input data_in,\n    output reg [2:0] q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 3'b0;\n        end else begin\n            q <= {q[1:0], data_in};\n        end\n    end\n\nendmodule\nmodule d_flip_flop (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\nmodule functional_module (\n    input [2:0] shift_register_out,\n    input d_flip_flop_out,\n    output reg [2:0] or_out\n);\n\n    always @(*) begin\n        or_out = shift_register_out | d_flip_flop_out;\n    end\n\nendmodule\nmodule control_logic (\n    input select,\n    input [2:0] shift_register_out,\n    input d_flip_flop_out,\n    input [2:0] functional_out,\n    output reg [2:0] q\n);\n\n    always @(*) begin\n        if (select) begin\n            q = functional_out;\n        end else begin\n            q = shift_register_out;\n        end\n    end\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input d,\n    input select,\n    output q\n);\n\n    wire [2:0] shift_register_out;\n    wire d_flip_flop_out;\n    wire [2:0] functional_out;\n    wire [2:0] ctrl_logic_out;\n\n    shift_register shift_reg(clk, reset, d, shift_register_out);\n    d_flip_flop d_ff(clk, reset, d, d_flip_flop_out);\n    functional_module func_mod(shift_register_out, d_flip_flop_out, functional_out);\n    control_logic ctrl_logic(select, shift_register_out, d_flip_flop_out, functional_out, ctrl_logic_out);\n    assign q = ctrl_logic_out[2];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
