{"custom_id": "decoder_4to16_5c9a71da", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule decoder_4to16 (\n    input [3:0] in, // Input to the decoder\n    output [15:0] out // Output from the decoder\n);\n\n// Internal wires\nwire [15:0] temp;\n\n// Decoder logic\nassign temp[0] = ~in[3] & ~in[2] & ~in[1] & ~in[0];\nassign temp[1] = ~in[3] & ~in[2] & ~in[1] & in[0];\nassign temp[2] = ~in[3] & ~in[2] & in[1] & ~in[0];\nassign temp[3] = ~in[3] & ~in[2] & in[1] & in[0];\nassign temp[4] = ~in[3] & in[2] & ~in[1] & ~in[0];\nassign temp[5] = ~in[3] & in[2] & ~in[1] & in[0];\nassign temp[6] = ~in[3] & in[2] & in[1] & ~in[0];\nassign temp[7] = ~in[3] & in[2] & in[1] & in[0];\nassign temp[8] = in[3] & ~in[2] & ~in[1] & ~in[0];\nassign temp[9] = in[3] & ~in[2] & ~in[1] & in[0];\nassign temp[10] = in[3] & ~in[2] & in[1] & ~in[0];\nassign temp[11] = in[3] & ~in[2] & in[1] & in[0];\nassign temp[12] = in[3] & in[2] & ~in[1] & ~in[0];\nassign temp[13] = in[3] & in[2] & ~in[1] & in[0];\nassign temp[14] = in[3] & in[2] & in[1] & ~in[0];\nassign temp[15] = in[3] & in[2] & in[1] & in[0];\n\n// Output logic\nassign out = temp;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_3ab863f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter (\n  input clock,\n  input reset,\n  output reg [3:0] count\n);\n\n  always @(posedge clock) begin\n    if (reset) begin\n      count <= 4'b0000;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mydff_b6ed5736", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mydff (\n    input D ,\n    input CLK ,\n    input R ,\n    output Q\n);\nwire Qbar ;\nreg Q ; // Use blocking assignments\nalways @(posedge CLK or negedge R) begin\n    if (!R) \n        Q <= 1'b0 ;\n    else \n        Q <= D ;\nend\nassign Qbar = ~Q ; // Assign Qbar to the complement of Q\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "splitter_9491c415", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule splitter (\n    input wire [2:0] in,\n    output wire o2,\n    output wire o1,\n    output wire o0\n);\n    assign {o2, o1, o0} = in;\nendmodule\n\nmodule barrel_shifter (\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n    assign {out_hi, out_lo} = in >> 8;\nendmodule\n\nmodule top_module (\n    input wire [18:0] in,\n    input wire select,\n    output wire [18:0] out,\n    output wire o2,\n    output wire o1,\n    output wire o0,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n    wire [2:0] splitter_out;\n    wire [7:0] barrel_out_hi;\n    wire [7:0] barrel_out_lo;\n\n    splitter splitter_inst (\n        .in(in[2:0]),\n        .o2(o2),\n        .o1(o1),\n        .o0(o0)\n    );\n\n    barrel_shifter barrel_inst (\n        .in(in[18:3]),\n        .out_hi(barrel_out_hi),\n        .out_lo(barrel_out_lo)\n    );\n\n    assign out = select ? {barrel_out_hi, {splitter_out, barrel_out_lo}} : {barrel_out_hi, barrel_out_lo};\n    assign splitter_out = {o2, o1, o0};\n    assign out_hi = barrel_out_hi;\n    assign out_lo = select ? {splitter_out, barrel_out_lo} : barrel_out_lo;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "div_clk_96dd4381", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule div_clk (\n    input clk_in,\n    input clk_type,\n    input reset,\n    output reg clk_out\n);\n\nreg clock_div2;\nreg [2:0] rst_reg;\n\nalways @(posedge clk_in or posedge reset) begin\n    if (reset == 1'b1) begin\n        rst_reg[0] <= 1'b1;\n        rst_reg[1] <= 1'b1;\n        rst_reg[2] <= 1'b1;\n    end else begin\n        rst_reg[0] <= reset;\n        rst_reg[1] <= rst_reg[0] & reset;\n        rst_reg[2] <= rst_reg[1] & rst_reg[0] & reset;\n    end\nend\n\nalways @(posedge clk_in) \n    clock_div2 <= ~clock_div2;\n\nalways @(posedge clk_in or posedge rst_reg[2]) begin\n    if (rst_reg[2] == 1'b1)\n        clk_out <= 1'b0;\n    else if (clk_type == 1'b1)\n        clk_out <= clock_div2;\n    else\n        clk_out <= clk_in;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_adder_32_abccc57d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ripple_adder_32(a, b, cin, sum, cout);\n  input [31:0] a;\n  input [31:0] b;\n  input cin;\n  output [31:0] sum;\n  output cout;\n  \n  wire [31:0] c;\n  wire [31:0] s;\n  \n  full_adder fa0(a[0], b[0], cin, s[0], c[0]);\n  full_adder fa1(a[1], b[1], c[0], s[1], c[1]);\n  full_adder fa2(a[2], b[2], c[1], s[2], c[2]);\n  full_adder fa3(a[3], b[3], c[2], s[3], c[3]);\n  full_adder fa4(a[4], b[4], c[3], s[4], c[4]);\n  full_adder fa5(a[5], b[5], c[4], s[5], c[5]);\n  full_adder fa6(a[6], b[6], c[5], s[6], c[6]);\n  full_adder fa7(a[7], b[7], c[6], s[7], c[7]);\n  full_adder fa8(a[8], b[8], c[7], s[8], c[8]);\n  full_adder fa9(a[9], b[9], c[8], s[9], c[9]);\n  full_adder fa10(a[10], b[10], c[9], s[10], c[10]);\n  full_adder fa11(a[11], b[11], c[10], s[11], c[11]);\n  full_adder fa12(a[12], b[12], c[11], s[12], c[12]);\n  full_adder fa13(a[13], b[13], c[12], s[13], c[13]);\n  full_adder fa14(a[14], b[14], c[13], s[14], c[14]);\n  full_adder fa15(a[15], b[15], c[14], s[15], c[15]);\n  full_adder fa16(a[16], b[16], c[15], s[16], c[16]);\n  full_adder fa17(a[17], b[17], c[16], s[17], c[17]);\n  full_adder fa18(a[18], b[18], c[17], s[18], c[18]);\n  full_adder fa19(a[19], b[19], c[18], s[19], c[19]);\n  full_adder fa20(a[20], b[20], c[19], s[20], c[20]);\n  full_adder fa21(a[21], b[21], c[20], s[21], c[21]);\n  full_adder fa22(a[22], b[22], c[21], s[22], c[22]);\n  full_adder fa23(a[23], b[23], c[22], s[23], c[23]);\n  full_adder fa24(a[24], b[24], c[23], s[24], c[24]);\n  full_adder fa25(a[25], b[25], c[24], s[25], c[25]);\n  full_adder fa26(a[26], b[26], c[25], s[26], c[26]);\n  full_adder fa27(a[27], b[27], c[26], s[27], c[27]);\n  full_adder fa28(a[28], b[28], c[27], s[28], c[28]);\n  full_adder fa29(a[29], b[29], c[28], s[29], c[29]);\n  full_adder fa30(a[30], b[30], c[29], s[30], c[30]);\n  full_adder fa31(a[31], b[31], c[30], s[31], cout);\n  \n  assign sum = s;\n  \nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n  input a;\n  input b;\n  input cin;\n  output sum;\n  output cout;\n  \n  assign sum = a ^ b ^ cin;\n  assign cout = (a & b) | (a & cin) | (b & cin);\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DAC_607e4b6d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule DAC (\n  input clk,\n  input rst,\n  input [n-1:0] din,\n  output analog_out\n);\n\nparameter n = 8; // number of bits in the digital input signal\nparameter v_ref_int = 32'd1000; // reference voltage for the DAC in mV\nparameter v_ref = v_ref_int / 1000.0; // reference voltage for the DAC in V\n\nreg [n-1:0] binary_value;\nwire [n-1:0] resistor_values;\nwire [31:0] analog_voltage;\n\nassign resistor_values = {v_ref_int, v_ref_int>>1, v_ref_int>>2, v_ref_int>>3, v_ref_int>>4, v_ref_int>>5, v_ref_int>>6, v_ref_int>>7}; // weighted resistor values\n\nassign analog_voltage = binary_value * resistor_values; // digital-to-analog conversion\n\nalways @(posedge clk) begin\n  if (rst) begin\n    binary_value <= 0; // reset to zero volts\n  end else begin\n    binary_value <= din; // update binary value\n  end\nend\n\nassign analog_out = analog_voltage;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adler_checksum #_aa974840", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adler_checksum #(\n  parameter data_width = 8,\n  parameter prime = 65521\n\n)(\n  input clk,\n  input reset,\n  input [data_width-1:0] data_in,\n  input valid_in,\n  input start,\n  input [data_width-1:0] checksum_in, // Only for checker\n  output [data_width-1:0] data_out,\n  output valid_out,\n  output [data_width-1:0] checksum_out, // Only for generator\n  output checksum_match\n);\n\n\nreg [data_width-1:0] data_reg;\nreg [data_width-1:0] checksum_reg;\nreg [data_width-1:0] sum_reg;\nreg [data_width-1:0] sum_of_squares_reg;\nreg [data_width-1:0] checksum_calc;\nreg [data_width-1:0] checksum_match_reg;\n\nassign data_out = data_reg;\nassign valid_out = valid_in;\nassign checksum_out = checksum_reg;\nassign checksum_match = checksum_match_reg;\n\nalways @(posedge clk) begin\n  if (reset) begin\n    data_reg <= 0;\n    checksum_reg <= 0;\n    sum_reg <= 0;\n    sum_of_squares_reg <= 0;\n    checksum_calc <= 0;\n    checksum_match_reg <= 0;\n  end else begin\n    if (valid_in) begin\n      data_reg <= data_in;\n      sum_reg <= sum_reg + data_in;\n      sum_of_squares_reg <= sum_of_squares_reg + (data_in * data_in);\n    end\n    if (start) begin\n      checksum_reg <= (sum_of_squares_reg * 65536) + sum_reg;\n      checksum_reg <= checksum_reg % prime;\n      if (checksum_in != 0) begin // Checker mode\n        if (checksum_in == checksum_reg) begin\n          checksum_match_reg <= 1;\n        end else begin\n          checksum_match_reg <= 0;\n        end\n      end else begin // Generator mode\n        checksum_calc <= checksum_reg;\n      end\n    end\n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "alu_82ba5502", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule alu\n#(parameter WIDTH = 8)\n( input wire [WIDTH-1:0] in_a,\n  input wire [WIDTH-1:0] in_b,\n  input wire [2:0] opcode,\n  output reg [WIDTH-1:0] alu_out,\n  output wire a_is_zero );\n\n  assign a_is_zero = in_a ? 1'b0: 1'b1;\n\n  always @ ( * )\n  begin\n      if ( opcode == 3'b000 )\n        begin\n          alu_out = in_a;\n        end\n      else if ( opcode == 3'b001 )\n        begin\n          alu_out = in_a;\n        end\n      else if ( opcode == 3'b010 )\n        begin\n          alu_out = in_a + in_b;\n        end\n      else if ( opcode == 3'b011 )\n        begin\n          alu_out = in_a & in_b;\n        end\n      else if ( opcode == 3'b100 )\n        begin\n          alu_out = in_a ^ in_b;\n        end\n      else if ( opcode == 3'b101 )\n        begin\n          alu_out = in_b;\n        end\n      else if ( opcode == 3'b110 )\n        begin\n          alu_out = in_a;\n        end\n      else if ( opcode == 3'b111 )\n        begin\n          alu_out = in_a;\n        end\n      else\n        begin\n          alu_out = in_a;\n        end\n  end\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_3bit_b660616b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter_3bit (\n  input clk,\n  input reset,\n  input inc_dec,\n  output reg [2:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    count <= 0;\n  end else begin\n    if (inc_dec) begin\n      if (count == 7) begin\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n    end else begin\n      if (count == 0) begin\n        count <= 7;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_block_88c566b9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_block (\n    i_data0,\n    i_data1,\n    o_data0\n);\n\n  // Port mode declarations:\n  input   [31:0] i_data0, i_data1;\n  output  [31:0] o_data0;\n\n  //Adder:\n  wire [31:0] w1;\n  assign w1 = i_data0 + i_data1;\n  assign o_data0 = w1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "macc_simple_ena_09bb817a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule macc_simple_ena (\n    input  wire        clk,\n    input  wire        ena,\n    input  wire [ 7:0] A,\n    input  wire [ 7:0] B,\n    output reg  [15:0] Z\n);\n\n    always @(posedge clk)\n        if (ena) Z <= Z + (A * B);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "NPM_Toggle_POR_ddd47855", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule NPM_Toggle_POR\n(\n    iSystemClock            ,\n    iReset                  ,\n    oReady                  ,\n    oLastStep               ,\n    iStart                  ,\n    oPO_Reset                       \n);\n    input                           iSystemClock            ;\n    input                           iReset                  ;\n    output                          oReady                  ;\n    output                          oLastStep               ;\n    input                           iStart                  ;\n    output                          oPO_Reset               ;\n    \n    parameter POR_FSM_BIT = 4;\n    parameter POR_RESET = 4'b0001;\n    parameter POR_READY = 4'b0010;\n    parameter POR_RFRST = 4'b0100; parameter POR_RLOOP = 4'b1000; reg     [POR_FSM_BIT-1:0]       rPOR_cur_state          ;\n    reg     [POR_FSM_BIT-1:0]       rPOR_nxt_state          ;\n    \n    \n    \n    reg                             rReady                  ;\n    \n    reg     [3:0]                   rTimer                  ;\n    \n    wire                            wJOBDone                ;\n    \n    reg                             rPO_Reset               ;\n    \n    \n    \n    assign wJOBDone = (4'b1001 == rTimer[3:0]); always @ (posedge iSystemClock, posedge iReset) begin\n        if (iReset) begin\n            rPOR_cur_state <= POR_RESET;\n        end else begin\n            rPOR_cur_state <= rPOR_nxt_state;\n        end\n    end\n    \n    always @ ( * ) begin\n        case (rPOR_cur_state)\n            POR_RESET: begin\n                rPOR_nxt_state <= POR_READY;\n            end\n            POR_READY: begin\n                rPOR_nxt_state <= (iStart)? POR_RFRST:POR_READY;\n            end\n            POR_RFRST: begin\n                rPOR_nxt_state <= POR_RLOOP;\n            end\n            POR_RLOOP: begin\n                rPOR_nxt_state <= (wJOBDone)? ((iStart)? POR_RFRST:POR_READY):POR_RLOOP;\n            end\n            default:\n                rPOR_nxt_state <= POR_READY;\n        endcase\n    end\n    \n    always @ (posedge iSystemClock, posedge iReset) begin\n        if (iReset) begin\n            rReady          <= 0;\n            rTimer[3:0]     <= 0;\n            rPO_Reset       <= 0;\n        end else begin\n            case (rPOR_nxt_state)\n                POR_RESET: begin\n                    rReady          <= 0;\n                    rTimer[3:0]     <= 0;\n                    rPO_Reset       <= 0;\n                end\n                POR_READY: begin\n                    rReady          <= 1;\n                    rTimer[3:0]     <= 0;\n                    rPO_Reset       <= 0;\n                end\n                POR_RFRST: begin\n                    rReady          <= 0;\n                    rTimer[3:0]     <= 4'b0000;\n                    rPO_Reset       <= 1;\n                end\n                POR_RLOOP: begin\n                    rReady          <= 0;\n                    rTimer[3:0]     <= rTimer[3:0] + 1'b1;\n                    rPO_Reset       <= 1;\n                end\n            endcase\n        end\n    end\n    \n    \n    \n    assign oReady               = rReady | wJOBDone     ;\n    assign oLastStep            = wJOBDone              ;\n    \n    assign oPO_Reset            = rPO_Reset              ;\n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "AXI_Master_831638ef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule AXI_Master\n(\n    input axi_clk,\n    input axi_rst,\n    input [31:0] axi_araddr,\n    input axi_arvalid,\n    output axi_arready,\n    output [31:0] axi_rdata,\n    output axi_rvalid,\n    input axi_rready,\n    input [31:0] axi_awaddr,\n    input axi_awvalid,\n    output axi_awready,\n    input [31:0] axi_wdata,\n    input axi_wvalid,\n    output axi_wready,\n    output [1:0] axi_bresp,\n    output axi_bvalid,\n    input axi_bready\n);\n\n// Internal registers\nreg [31:0] addr_reg;\nreg [31:0] data_reg;\nreg [1:0] resp_reg;\nreg [1:0] state_reg;\n\n// Constants\nlocalparam IDLE = 2'b00;\nlocalparam READ = 2'b01;\nlocalparam WRITE = 2'b10;\n\n// RTL Code\n\n// Output logic\nassign axi_arready = (state_reg == IDLE) ? 1'b1 : 1'b0;\nassign axi_awready = (state_reg == IDLE) ? 1'b1 : 1'b0;\nassign axi_wready = (state_reg == IDLE) ? 1'b1 : 1'b0;\nassign axi_bresp = resp_reg;\nassign axi_bvalid = (state_reg == WRITE) ? 1'b1 : 1'b0;\nassign axi_rdata = (state_reg == READ) ? mem[addr_reg] : 32'h0;\nassign axi_rvalid = (state_reg == READ) ? 1'b1 : 1'b0;\n\n// State machine\nalways @(posedge axi_clk) begin\n    if (axi_rst) begin\n        state_reg <= IDLE;\n        addr_reg <= 32'h00000000;\n        data_reg <= 32'h00000000;\n        resp_reg <= 2'b00;\n    end else begin\n        case (state_reg)\n            IDLE: begin\n                if (axi_arvalid) begin\n                    state_reg <= READ;\n                    addr_reg <= axi_araddr;\n                end else if (axi_awvalid) begin\n                    state_reg <= WRITE;\n                    addr_reg <= axi_awaddr;\n                    data_reg <= axi_wdata;\n                end\n            end\n            READ: begin\n                if (axi_rready) begin\n                    resp_reg <= 2'b00;\n                    state_reg <= IDLE;\n                end\n            end\n            WRITE: begin\n                if (axi_bready) begin\n                    resp_reg <= 2'b00;\n                    state_reg <= IDLE;\n                end\n            end\n        endcase\n    end\nend\n\n// Memory\nreg [31:0] mem [0:1023];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4x1 #_f11fb52a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4x1 #(parameter SIZE=32) (\n    input wire [SIZE-1:0] iInput0,\n    input wire [SIZE-1:0] iInput1,\n    input wire [SIZE-1:0] iInput2,\n    input wire [SIZE-1:0] iInput3,\n    input wire [1:0] iSelect,\n    output reg [SIZE-1:0] oOutput\n);\n\n    always @(*) begin\n        case (iSelect)\n            2'b00: oOutput = iInput0;\n            2'b01: oOutput = iInput1;\n            2'b10: oOutput = iInput2;\n            2'b11: oOutput = iInput3;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "synchronous_counter_4544de3f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule synchronous_counter(CLK, RST, LOAD, EN, DATA_IN, DATA_OUT);\n\ninput CLK, RST, LOAD, EN;\ninput [3:0] DATA_IN;\noutput reg [3:0] DATA_OUT;\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        DATA_OUT <= 4'b0;\n    end else if (LOAD) begin\n        DATA_OUT <= DATA_IN;\n    end else if (EN) begin\n        if (DATA_OUT == 4'b1111) begin\n            DATA_OUT <= 4'b0;\n        end else begin\n            DATA_OUT <= DATA_OUT + 1;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gray_code_state_machine_501843aa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule gray_code_state_machine (\n  input clk,\n  input rst,\n  output [n-1:0] out\n);\n\nparameter n = 4; // number of output signals\n\nreg [n-1:0] state;\nreg [n-1:0] gray_code;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    state <= 0;\n  end else begin\n    state <= gray_code;\n  end\nend\n\nalways @* begin\n  case (state)\n    0: gray_code = 0;\n    1: gray_code = 1;\n    2: gray_code = 3;\n    3: gray_code = 2;\n    4: gray_code = 6;\n    5: gray_code = 7;\n    6: gray_code = 5;\n    7: gray_code = 4;\n    default: gray_code = 0;\n  endcase\nend\n\nassign out = gray_code;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplier_4bit_e102f7c2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule multiplier_4bit (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    output [7:0] S\n);\n\nreg [7:0] reg_file [0:15]; // Register file with 16 registers\n\n// Fetch stage\nreg [3:0] addr1, addr2;\nalways @ (posedge clk) begin\n    addr1 <= A;\n    addr2 <= B;\nend\n\n// Execute stage\nreg [7:0] data1, data2;\nreg [15:0] result;\nalways @ (posedge clk) begin\n    data1 <= reg_file[addr1];\n    data2 <= reg_file[addr2];\n    result <= data1 * data2;\nend\n\n// Write back stage\nalways @ (posedge clk) begin\n    reg_file[addr1] <= result[7:0];\n    reg_file[addr2] <= result[15:8];\nend\n\n// Output stage\nassign S = reg_file[addr1]; // Output is the result in the first register\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo2_5b834410", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`ifndef _inc_fifo_\n`define _inc_fifo_\n\nmodule fifo2 (clk, reset, full, empty, item_in, item_out, write, read);\n\n\tparameter SIZE = 2;\n\tparameter DEPTH_LOG2 = 1;\n\n\tlocalparam DEPTH = 2 ** DEPTH_LOG2;\n\n\tinput clk, reset, write, read;\n\tinput [SIZE-1:0] item_in;\n\toutput [SIZE-1:0] item_out;\n\toutput full, empty;\n\n\treg full, empty;\n\treg [SIZE-1:0] memory [DEPTH-1:0];\n\treg [DEPTH_LOG2-1:0] read_ptr;\n\treg [DEPTH_LOG2-1:0] write_ptr;\n\twire [DEPTH_LOG2-1:0] read_ptr_p1 = read_ptr + 1;\n\twire [DEPTH_LOG2-1:0] write_ptr_p1 = write_ptr + 1;\n\n\tassign item_out = memory[read_ptr];\n\n\tinteger i;\n\n\twire do_read = read & !empty;\n\twire do_write = write & !full;\n\n\talways @(posedge clk or posedge reset) begin\n\n\t\tif (reset) begin\n\n\t\t\tread_ptr <= 0;\n\t\t\twrite_ptr <= 0;\n\t\t\tempty <= 1;\n\t\t\tfull <= 0;\n\t\t\tfor (i=0; i<DEPTH; i=i+1) memory[i] <= 0;\n\n\t\tend else begin\n\n\t\t\tif (do_read & do_write) begin\n\n\t\t\t\tread_ptr <= read_ptr_p1;\n\t\t\t\twrite_ptr <= write_ptr_p1;\n\t\t\t\tmemory[write_ptr] <= item_in;\n\n\t\t\tend else if (do_read) begin\n\n\t\t\t\tfull <= 0;\n\t\t\t\tread_ptr <= read_ptr_p1;\n\t\t\t\tempty <= (read_ptr_p1 == write_ptr);\n\n\t\t\tend else if (do_write) begin\n\n\t\t\t\tmemory[write_ptr] <= item_in;\n\t\t\t\tempty <= 0;\n\t\t\t\twrite_ptr <= write_ptr_p1;\n\t\t\t\tfull <= (read_ptr == write_ptr_p1);\n\n\t\t\tend\n\n\t\tend\n\n\tend\n\nendmodule\n\n`endif\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_addsub_580b9803", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_addsub (\n    input clk,\n    input reset,\n    input SER,\n    input [3:0] A,\n    input [3:0] B,\n    input sub,\n    output [3:0] result\n);\n\n    reg [3:0] Q;\n    wire [3:0] shifted_Q;\n    wire [3:0] added_A;\n    wire [3:0] subbed_A;\n\n    shift_register shift_reg (\n        .clk(clk),\n        .reset(reset),\n        .SER(SER),\n        .SHIFT(shifted_Q),\n        .LOAD(Q)\n    );\n\n    adder_subtractor addsub (\n        .A(A),\n        .B(shifted_Q),\n        .sub(sub),\n        .result(added_A),\n        .sub_result(subbed_A)\n    );\n\n    always @(posedge clk or posedge reset)\n    begin\n        if (reset)\n            Q <= 4'b0;\n        else\n            Q <= subbed_A;\n    end\n\n    assign result = (sub) ? subbed_A : added_A;\n\nendmodule\nmodule shift_register (\n    input clk,\n    input reset,\n    input SER,\n    output reg [3:0] SHIFT,\n    input [3:0] LOAD\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            SHIFT <= 4'b0;\n        end else begin\n            SHIFT <= LOAD;\n        end\n    end\n\nendmodule\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input sub,\n    output [3:0] result,\n    output [3:0] sub_result\n);\n\n    wire [3:0] subbed_A;\n    wire [3:0] subtracted_result;\n\n    assign subbed_A = (~A) + 1;\n    assign subtracted_result = subbed_A + B;\n\n    assign sub_result = subtracted_result[3:0];\n    assign result = sub ? subtracted_result[3:0] : A + B;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_shifter_b7160311", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_shifter (\n    input [7:0] A,\n    input [7:0] B,\n    input carry_in,\n    input sub,\n    input [1:0] shift_amount,\n    input shift_direction,\n    output reg [7:0] sum,\n    output reg borrow_out,\n    output reg [7:0] shifted_output\n);\n\nreg [8:0] temp_sum;\nreg [7:0] temp_shifted_output;\n\nalways @(*) begin\n    if (sub) begin\n        temp_sum = {A, 1'b0} - {B, 1'b0} - carry_in;\n        borrow_out = temp_sum[8];\n    end else begin\n        temp_sum = {A, 1'b0} + {B, 1'b0} + carry_in;\n        borrow_out = temp_sum[8];\n    end\nend\n\nalways @(*) begin\n    case (shift_direction)\n        2'b00: temp_shifted_output = temp_sum << shift_amount;\n        2'b01: temp_shifted_output = temp_sum >> shift_amount;\n        default: temp_shifted_output = 8'b0;\n    endcase\nend\n\nalways @(*) begin\n    sum <= temp_sum[7:0];\n    shifted_output <= temp_shifted_output;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_with_adder_subtractor_4e109288", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule counter_with_adder_subtractor (\n    input [3:0] A,   // 4-bit input for adder/subtractor\n    input [3:0] B,   // 4-bit input for adder/subtractor\n    input sub,       // Input for adder/subtractor to choose between addition and subtraction\n    input RST,       // Asynchronous active-low reset input for counter\n    input clk,       // Clock input for counter\n    output [3:0] Q,  // 4-bit output from counter\n    output [3:0] sum, // 4-bit output from adder/subtractor\n    output overflow,  // Output from adder/subtractor to indicate overflow\n    output [3:0] final_output // 4-bit output from functional module\n);\n\nreg [3:0] counter;\nwire [3:0] adder_output;\n\n// Counter module\nalways @(posedge clk or negedge RST) begin\n    if (!RST) begin\n        counter <= 4'b0000;\n    end else begin\n        counter <= counter + 4'b0001;\n    end\nend\n\n// Adder/subtractor module\nassign sum = sub ? A - B : A + B;\nassign overflow = (sum[3] == 1 && sub == 0) || (sum[3] == 0 && sub == 1);\n\n// Functional module\nassign final_output = counter + adder_output;\n\n// Output assignments\nassign Q = counter;\nassign adder_output = sum;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "flip_flop_5be9ed26", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule flip_flop (\n    Q      ,\n    Q_N    ,\n    D      ,\n    SCD    ,\n    SCE    ,\n    CLK    ,\n    SET_B  ,\n    RESET_B,\n    VPWR   ,\n    VGND   ,\n    VPB    ,\n    VNB\n);\n\n    output Q      ;\n    output Q_N    ;\n    input  D      ;\n    input  SCD    ;\n    input  SCE    ;\n    input  CLK    ;\n    input  SET_B  ;\n    input  RESET_B;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n    \n    reg Q;\n    assign Q_N = ~Q;\n    \n    always @(posedge CLK) begin\n        if (SET_B == 0) begin\n            Q <= 1;\n        end else if (RESET_B == 0) begin\n            Q <= 0;\n        end else if (SCD == 0) begin\n            Q <= 0;\n        end else if (SCE == 1) begin\n            Q <= D;\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shift_3bit_reg_and_gate_f5acda99", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shift_3bit_reg_and_gate (\n    input clk,\n    input [3:0] data_in,\n    input [1:0] shift_amount,\n    input [2:0] parallel_load,\n    input shift,\n    input control,\n    output [2:0] out\n);\n\n    // 4-bit Barrel Shifter\n    reg [3:0] shifted_data;\n    always @(*) begin\n        case(shift_amount)\n            2'b00: shifted_data = data_in;\n            2'b01: shifted_data = {data_in[3], data_in[0:2]};\n            2'b10: shifted_data = {data_in[2:3], data_in[0:1]};\n            2'b11: shifted_data = {data_in[1:3], data_in[0]};\n            default: shifted_data = 4'b0000;\n        endcase\n    end\n\n    // 3-bit Shift Register\n    reg [2:0] reg_data;\n    always @(posedge clk) begin\n        if(shift) begin\n            if(control) reg_data <= {reg_data[1:0], 1'b0};\n            else reg_data <= {1'b0, reg_data[2:1]};\n        end\n        else if(parallel_load != 3'b111) begin\n            reg_data <= parallel_load;\n        end\n    end\n\n    // AND Gate\n    assign out = shifted_data & reg_data;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux5 #_ca083ce6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux5 #(parameter WIREWIDTH = 1) (input wire [2:0] s,\n\t\t\t\t\tinput wire [WIREWIDTH:0] d0, d1, d2,d3, d4,\n\t\t\t\t\toutput reg [WIREWIDTH:0] o);\n\n   always @* begin\n      case(s)\n\t0: o = d0;\n\t1: o = d1;\n        2: o = d2;\n        3: o = d3;\n        default: o = d4;\n      endcase\n   end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_4bit_66f39994", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter_4bit (\n    input clk,\n    input rst,\n    output reg [3:0] count\n);\n\nalways @(posedge clk or negedge rst) begin\n    if (~rst) begin\n        count <= 4'b0000;\n    end else begin\n        if (count == 4'b1111) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "font_decoder_44ccc857", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule font_decoder(\n    input wire [31:0] font_data_in,\n    output reg [27:0] seg_out\n);\n\n    always @(*) begin\n        case(font_data_in)\n            4'b0000_0000_0000_0000_0000_0000_0000_0001: seg_out = {7'b0111111, 7'b0000110, 7'b1011011, 7'b1001111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0010: seg_out = {7'b0000110, 7'b0000110, 7'b1111101, 7'b0000111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0011: seg_out = {7'b1011011, 7'b0000110, 7'b1101101, 7'b1001111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0100: seg_out = {7'b1001110, 7'b1100110, 7'b0000110, 7'b0000111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0101: seg_out = {7'b1111101, 7'b1101101, 7'b0000110, 7'b1001111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0110: seg_out = {7'b1111111, 7'b1101101, 7'b0000110, 7'b1001111};\n            4'b0000_0000_0000_0000_0000_0000_0000_0111: seg_out = {7'b0000111, 7'b0000110, 7'b1011011, 7'b0000111};\n            4'b0000_0000_0000_0000_0000_0000_0000_1000: seg_out = {7'b1111111, 7'b1101111, 7'b0000110, 7'b1001111};\n            4'b0000_0000_0000_0000_0000_0000_0000_1001: seg_out = {7'b1111101, 7'b1101101, 7'b0000110, 7'b1001111};\n            default: seg_out = 28'b0;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_adder_4e8251b6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_adder (\n    A,\n    B,\n    C_in,\n    S,\n    C_out\n);\n\n    input [3:0] A;\n    input [3:0] B;\n    input C_in;\n    output [3:0] S;\n    output C_out;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire [4:0] sum; // Changed the range of the wire to [4:0]\n    wire carry;\n\n    assign sum = A + B + C_in;\n    assign S = sum[3:0];\n    assign carry = sum[4];\n\n    assign C_out = carry;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hvl__lsbuflv2hv_clkiso_hlkg_880698ab", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hvl__lsbuflv2hv_clkiso_hlkg (\n    X      ,\n    A      ,\n    SLEEP_B\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n\n    wire SLEEP     ;\n    wire and0_out_X;\n\n    not not0 (SLEEP     , SLEEP_B        );\n    and and0 (and0_out_X, SLEEP_B, A     );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xnor_gate_d18ad108", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule xnor_gate(\n    input a,\n    input b,\n    output out\n);\n\nwire nand_out, nor_out;\n\nnand_gate nand1(a, b, nand_out);\nnor_gate nor1(a, b, nor_out);\nnand_gate nand2(nand_out, nor_out, out);\n\nendmodule\nmodule nand_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = ~(a & b);\n\nendmodule\nmodule nor_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\nmodule top_module( \n    input [3:0] in,\n    output out\n);\n\nwire xnor_out1, xnor_out2;\n\nxnor_gate xnor1(in[0], in[1], xnor_out1);\nxnor_gate xnor2(in[2], in[3], xnor_out2);\nxnor_gate xnor3(xnor_out1, xnor_out2, out);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_carry_adder_5830f5c0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ripple_carry_adder (\n  input [3:0] a, b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire [3:0] c;\n  \n  assign c[0] = cin;\n  assign c[1] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\n  assign c[2] = (a[1] & b[1]) | (a[1] & c[1]) | (b[1] & c[1]);\n  assign c[3] = (a[2] & b[2]) | (a[2] & c[2]) | (b[2] & c[2]);\n  \n  assign sum = a + b + cin;\n  assign cout = c[3];\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiply_by_3_df44605a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiply_by_3 (\n    input [3:0] a,\n    output reg [5:0] out\n);\n\nalways @ (a) begin\n    out = a << 1; // left shift by 1 is equivalent to multiplication by 2\n    out = out + a; // add the original number to get multiplication by 3\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__iso1n_4c9a5db0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__iso1n (\n    X      ,\n    A      ,\n    SLEEP_B\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n\n    wire SLEEP;\n\n    not not0 (SLEEP , SLEEP_B        );\n    or  or0  (X     , A, SLEEP       );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "count_even_01c35132", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule count_even(\n    input [255:0] in,\n    output reg [3:0] out\n);\n\n    integer i;\n    reg [7:0] even_count;\n\n    always @(*) begin\n        even_count = 0;\n        for (i = 0; i < 256; i = i + 2) begin\n            if (in[i]) begin\n                even_count = even_count + 1;\n            end\n        end\n        out = even_count[3:0];\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bytewrite_ram_32bits_f375262c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule bytewrite_ram_32bits (\n    input clk,\n    input [3:0] we,\n    input [11:0] addr,\n    input [31:0] din,\n    output [31:0] dout\n);\n\n    parameter SIZE = 1024;\n    parameter ADDR_WIDTH = 12;\n    parameter filename = \"code.hex\";\n    \n    localparam COL_WIDTH = 8;\n    localparam NB_COL = 4;\n    \n    reg [31:0] RAM [SIZE-1:0];\n    \n    integer _i;\n    \n    wire [11:0] addr_dly;\n    reg [31:0] dout_int;\n    \n    initial begin\n        for(_i=0; _i<SIZE; _i=(_i+1)) begin\n            RAM[_i] = 32'd0;\n        end\n    end\n    \n    always @(posedge clk) begin\n        dout_int <= RAM[addr];\n    end\n    \n    assign dout = dout_int;\n    \n    always @(posedge clk) begin\n        if (we[0]) begin\n            RAM[addr][7:0] <= din[7:0];\n        end\n        if (we[1]) begin\n            RAM[addr][15:8] <= din[15:8];\n        end\n        if (we[2]) begin\n            RAM[addr][23:16] <= din[23:16];\n        end\n        if (we[3]) begin\n            RAM[addr][31:24] <= din[31:24];\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_gate_1236fd10", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule xor_gate(\n    input a,\n    input b,\n    output out\n);\n\nwire w1, w2, w3;\n\nand_gate and1(.a(a), .b(~b), .out(w1));\nand_gate and2(.a(~a), .b(b), .out(w2));\nor_gate or1(.a(w1), .b(w2), .out(w3));\nnot_gate not1(.a(w3), .out(out));\n\nendmodule\n\nmodule and_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n\nmodule or_gate(\n    input a,\n    input b,\n    output out\n);\n\nassign out = a | b;\n\nendmodule\n\nmodule not_gate(\n    input a,\n    output out\n);\n\nassign out = ~a;\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input a,\n    input b,\n    output out_always_ff\n);\n\nreg a_ff, b_ff;\n\nalways @(posedge clk) begin\n    a_ff <= a;\n    b_ff <= b;\nend\n\nxor_gate xor1(.a(a_ff), .b(b_ff), .out(out_always_ff));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__and2b_721eb73a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__and2b (\n    X  ,\n    A_N,\n    B\n);\n\n    output X  ;\n    input  A_N;\n    input  B  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire not0_out  ;\n    wire and0_out_X;\n\n    not not0 (not0_out  , A_N            );\n    and and0 (and0_out_X, not0_out, B    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_alu_840b6574", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_alu(\n    input [3:0] ctl,\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] out,\n    output zero\n);\n\nwire [3:0] add_ab;\nwire [3:0] sub_ab;\nwire [3:0] and_ab;\nwire [3:0] or_ab;\nwire [3:0] xor_ab;\nwire [3:0] not_a;\nwire [3:0] shl_a;\nwire [3:0] shr_a;\nwire ovf;\n\nassign add_ab = a + b;\nassign sub_ab = a - b;\nassign and_ab = a & b;\nassign or_ab = a | b;\nassign xor_ab = a ^ b;\nassign not_a = ~a;\nassign shl_a = {a[2:0], 1'b0};\nassign shr_a = {1'b0, a[3:1]};\n\nassign zero = (out == 4'b0000);\n\nassign ovf = (ctl == 4'b0000 || ctl == 4'b0001) ? (a[3] == b[3] && out[3] != a[3]) : 1'b0;\n\nalways @(*) begin\n    case (ctl)\n        4'b0000: out <= add_ab; // Addition\n        4'b0001: out <= sub_ab; // Subtraction\n        4'b0010: out <= and_ab; // Bitwise AND\n        4'b0011: out <= or_ab; // Bitwise OR\n        4'b0100: out <= xor_ab; // Bitwise XOR\n        4'b0101: out <= not_a; // Bitwise NOT\n        4'b0110: out <= shl_a; // Shift left\n        4'b0111: out <= shr_a; // Shift right\n        default: out <= 4'b0000;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Adder_ba3c459c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule Adder(din_a, din_b, din_c, dout);\n\n\t\n\tinput wire[3:0] din_a;\n\n\t\n\tinput wire[3:0] din_b;\n\n\t\n\tinput wire[3:0] din_c;\n\n\t\n\toutput wire[3:0] dout;\n\n\t\n\n\tassign dout = din_a + din_b;\n\tendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ring_ce9d22d8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule ring\n#(parameter WIDTH = 32, ALARM_STEP = 24)\n(\n    input [(WIDTH-1):0] clk_src,\n    input power,\n    input weight_ch,\n    input mode_ch,\n    input [2:0] w_r_d_end,\n    output reg alarm\n);\n\n    reg [(WIDTH-1):0] count;\n    \n    reg [1:0] state, next_state;\n    parameter NO_ALARM = 0, BTN_ALARM = 1, PHASE_ALARM = 2;\n    \n    initial begin\n        alarm <= 0;\n        count <= 0;\n        state <= NO_ALARM;\n        next_state <= NO_ALARM;\n    end\n    \n    always @(clk_src[0]) begin\n        if (power) begin\n            state = next_state;\n        end else if (!power) begin\n            state = NO_ALARM;\n        end\n    end\n    \n    always @(mode_ch or weight_ch or w_r_d_end or count) begin\n        if (power) begin\n            case(state)\n                NO_ALARM: begin\n                    if (mode_ch || weight_ch) begin\n                        next_state = BTN_ALARM;\n                    end else if (w_r_d_end) begin\n                        next_state = PHASE_ALARM;\n                    end else begin\n                        next_state = NO_ALARM;\n                    end\n                end\n                BTN_ALARM: begin\n                    if (w_r_d_end) begin\n                        next_state = PHASE_ALARM;\n                    end else if (count >= 2) begin\n                        next_state = NO_ALARM;\n                    end else begin\n                        next_state = BTN_ALARM;\n                    end\n                end\n                PHASE_ALARM: begin\n                    if (mode_ch || weight_ch) begin\n                        next_state = BTN_ALARM;\n                    end\n                    else if (count >= 6) begin\n                        next_state = NO_ALARM;\n                    end else begin\n                    next_state = PHASE_ALARM;\n                    end\n                end\n            endcase\n        end else begin\n            next_state = NO_ALARM;\n        end\n    end\n    \n    always @(posedge clk_src[ALARM_STEP]) begin\n        case(state)\n            NO_ALARM: begin\n                count = 0;\n                alarm = 0;\n            end\n            BTN_ALARM: begin\n                count = count + 1;\n                alarm = ~alarm;\n            end\n            PHASE_ALARM: begin\n                count = count + 1;\n                alarm = ~alarm;\n            end\n       endcase\n   end\n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipeline_register_20ad209c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipeline_register (\n  input CLK,\n  input EN,\n  input [31:0] DATA_IN,\n  output [31:0] DATA_OUT_1,\n  output [31:0] DATA_OUT_2,\n  output [31:0] DATA_OUT_3\n);\n\n  reg [31:0] data_reg_1, data_reg_2, data_reg_3;\n\n  always @(posedge CLK) begin\n    if (EN) begin\n      data_reg_3 <= data_reg_2;\n      data_reg_2 <= data_reg_1;\n      data_reg_1 <= DATA_IN;\n    end\n  end\n\n  assign DATA_OUT_1 = data_reg_2;\n  assign DATA_OUT_2 = data_reg_3;\n  assign DATA_OUT_3 = DATA_IN;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_a143f705", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n  input [7:0] num1,\n  input [7:0] num2,\n  input [1:0] op,\n  output reg [7:0] result\n);\n\nalways @(*)\nbegin\n  case(op)\n    2'b00: result = num1 + num2;\n    2'b01: result = num1 - num2;\n    2'b10: result = num1 * num2;\n    2'b11: result = num1 / num2;\n  endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "aurora_201_STANDARD_CC_MODULE_41e8cb53", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule aurora_201_STANDARD_CC_MODULE\n(\n    WARN_CC,\n    DO_CC,\n    \n    \n    DCM_NOT_LOCKED,\n    USER_CLK,\n    CHANNEL_UP\n\n);\n\n`define DLY #1\n\n\noutput      WARN_CC;\n    output      DO_CC;\n    \n    \n    input       DCM_NOT_LOCKED;\n    input       USER_CLK;\n    input       CHANNEL_UP;\n    \n    \nreg             WARN_CC;\n    reg             DO_CC;\n    \n\nreg     [0:9]   prepare_count_r;\n    reg     [0:5]   cc_count_r;\n    reg             reset_r;\n    \n    reg     [0:11]  count_13d_srl_r;\n    reg             count_13d_flop_r;\n    reg     [0:14]  count_16d_srl_r;\n    reg             count_16d_flop_r;\n    reg     [0:22]  count_24d_srl_r;\n    reg             count_24d_flop_r;    \n\n\n\nwire    start_cc_c;\n    wire    inner_count_done_r;\n    wire    middle_count_done_c;\n    wire    cc_idle_count_done_c;\n    \n   \nalways @(posedge USER_CLK)\n        count_13d_srl_r     <=  `DLY    {count_13d_flop_r, count_13d_srl_r[0:10]};\n        \n    \n    assign  inner_count_done_r  =  count_13d_srl_r[11];\n \n \n    always @(posedge USER_CLK)\n        if(~CHANNEL_UP)\n            count_13d_flop_r    <=  `DLY    1'b0;\n        else if(CHANNEL_UP && reset_r)\n            count_13d_flop_r    <=  `DLY    1'b1;\n        else\n            count_13d_flop_r    <=  `DLY    inner_count_done_r;\n            \n \n  \n \n \n \n \n    always @(posedge USER_CLK)\n        if(inner_count_done_r|| !CHANNEL_UP)\n            count_16d_srl_r     <=  `DLY    {count_16d_flop_r, count_16d_srl_r[0:13]};\n            \n    \n    assign  middle_count_done_c =   inner_count_done_r && count_16d_srl_r[14];     \n \n \n    \n    always @(posedge USER_CLK)\n        if(~CHANNEL_UP)\n            count_16d_flop_r    <=  `DLY    1'b0;\n        else if(CHANNEL_UP && reset_r)\n            count_16d_flop_r    <=  `DLY    1'b1;\n        else if(inner_count_done_r)    \n            count_16d_flop_r    <=  `DLY    middle_count_done_c;\n \n\n  \n \n \n    always @(posedge USER_CLK)\n        if(middle_count_done_c || !CHANNEL_UP)\n            count_24d_srl_r     <=  `DLY    {count_24d_flop_r, count_24d_srl_r[0:21]};\n            \n            \n    assign  cc_idle_count_done_c    =   middle_count_done_c & count_24d_srl_r[22];\n    \n    always @(posedge USER_CLK)\n        if(~CHANNEL_UP)\n            count_24d_flop_r    <=  `DLY    1'b0;\n        else if(CHANNEL_UP && reset_r)\n            count_24d_flop_r    <=  `DLY    1'b1;\n        else if(middle_count_done_c)\n            count_24d_flop_r    <=  `DLY    cc_idle_count_done_c;   \n \n    \n    \n    initial\n        prepare_count_r = 10'b0000000000;\n \n \n \n     always @(posedge USER_CLK)\n         prepare_count_r <=  `DLY    {cc_idle_count_done_c,prepare_count_r[0:8]};\n \n\n \n \n    always @(posedge USER_CLK)\n         if(!CHANNEL_UP)                            WARN_CC    <=  `DLY    1'b0;\n         else if(cc_idle_count_done_c)              WARN_CC    <=  `DLY    1'b1;\n         else if(prepare_count_r[9])                WARN_CC    <=  `DLY    1'b0;\n \n\n\n    initial\n         cc_count_r = 6'b000000;\n \n \n \n    always @(posedge USER_CLK)\n        reset_r <=  `DLY    !CHANNEL_UP;\n \n \n \n    assign start_cc_c   =   prepare_count_r[9] || (CHANNEL_UP && reset_r);\n \n \n     always @(posedge USER_CLK)\n         cc_count_r      <=  `DLY    {(!CHANNEL_UP|prepare_count_r[9]),cc_count_r[0:4]};\n        \n        \n        \n     always @(posedge USER_CLK)\n         if(!CHANNEL_UP)                 DO_CC <=  `DLY    1'b0;\n         else if(start_cc_c)             DO_CC <=  `DLY    1'b1;\n         else if(cc_count_r[5])          DO_CC <=  `DLY    1'b0;         \n         \nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "compression_decompression_b83af55c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule compression_decompression (\n  input [7:0] data_in,\n  output [3:0] data_out\n);\n\n  wire [1:0] code;\n  assign code = (data_in[7:4] == 4'b0000) ? 2'b10 : \n                (data_in[7:4] == 4'b1111) ? 2'b11 :\n                (data_in[7:4] == data_in[3:0]) ? 2'b01 : \n                2'b00;\n\n  assign data_out = {code, (code == 2'b10 || code == 2'b11) ? data_in[7:6] : data_in[1:0]};\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DLL_c44b0d5b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule DLL (\n  input ref_clk,\n  input data_in,\n  output reg data_out\n);\n\nparameter delay = 5; // amount of delay to be added to the reference clock signal\n\nreg delayed_ref_clk;\nreg [1:0] phase_difference;\nreg [1:0] loop_filter_output;\nreg [1:0] loop_filter_state;\n\nalways @(posedge ref_clk) begin\n  delayed_ref_clk <= #delay ref_clk;\n  phase_difference <= {phase_difference[0], data_in} ^ {delayed_ref_clk, delayed_ref_clk};\n  loop_filter_output <= loop_filter_state + phase_difference;\n  loop_filter_state <= loop_filter_output;\n  data_out <= #delayed_ref_clk data_in;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cart_81723705", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule cart\n(\n  input  wire           clk,\n  input  wire           clk7_en,\n  input  wire           clk7n_en,\n  input  wire           cpu_rst,\n  input  wire [ 24-1:1] cpu_address,\n  input  wire [ 24-1:1] cpu_address_in,\n  input  wire           _cpu_as,\n  input  wire           cpu_rd,\n  input  wire           cpu_hwr,\n  input  wire           cpu_lwr,\n  input  wire [ 32-1:0] cpu_vbr,\n  input  wire [  9-1:1] reg_address_in,\n  input  wire [ 16-1:0] reg_data_in,\n  input  wire           dbr,\n  input  wire           ovl,\n  input  wire           freeze,\n  output wire [ 16-1:0] cart_data_out,\n  output reg            int7 = 1'b0,\n  output wire           sel_cart,\n  output wire           ovr,\noutput wire           aron\n);\n\n\nreg  [32-1:0] nmi_vec_adr=0;\nreg           freeze_d=0;\nwire          freeze_req;\nwire          int7_req;\nwire          int7_ack;\nreg           l_int7_req=0;\nreg           l_int7_ack=0;\nreg           l_int7=0;\nreg           active=0;\nwire          sel_custom_mirror;\nwire [16-1:0] nmi_adr_out;\nreg  [16-1:0] custom_mirror_q;\nwire [16-1:0] custom_mirror_out;\nreg  [16-1:0] custom_mirror [0:256-1];\n\n\n`define ARON_HACK\n`ifndef ARON_HACK\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (cpu_rst && (cpu_address_in[23:19]==5'b1010_0) && cpu_lwr && !aron)\n      aron <= 1'b1;\n  end\nend\n`else\nassign aron = 1'b1;\n`endif\n\nassign sel_cart = ~dbr && (cpu_address_in[23:19]==5'b1010_0); always @ (posedge clk) begin\n  if (clk7_en) begin\n    nmi_vec_adr <= #1 cpu_vbr + 32'h0000007c; end\nend\n\nassign ovr = active && ~dbr && ~ovl && cpu_rd && (cpu_address_in[23:2] == nmi_vec_adr[23:2]);\n\nassign nmi_adr_out = ovr ? (!cpu_address_in[1] ? 16'h00a1 : 16'h000c) : 16'h0000;\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    freeze_d <= freeze;\n  end\nend\n\nassign freeze_req = freeze && ~freeze_d;\n\nassign int7_req =  freeze_req;\n\nassign int7_ack = &cpu_address_in && ~_cpu_as;\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (cpu_rst)\n      int7 <= 1'b0;\n    else if (int7_req)\n      int7 <= 1'b1;\n    else if (int7_ack)\n      int7 <= 1'b0;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    l_int7_req <= int7_req;\n    l_int7_ack <= int7_ack;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (cpu_rst)\n      l_int7 <= 1'b0;\n    else if (l_int7_req)\n      l_int7 <= 1'b1;\n    else if (l_int7_ack && cpu_rd)\n      l_int7 <= 1'b0;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (clk7_en) begin\n    if (cpu_rst)\n      active <= #1 1'b0;\n    else if ( l_int7 && l_int7_ack && cpu_rd)\n      active <= #1 1'b1;\n    else if (sel_cart && cpu_rd)\n      active <= #1 1'b0;\n  end\nend\n\nassign sel_custom_mirror = ~dbr && cpu_rd && (cpu_address_in[23:12]==12'b1010_1001_1111); always @ (posedge clk) begin\n  if (clk7_en) begin\n    custom_mirror[reg_address_in] <= #1 reg_data_in;\n  end\n  custom_mirror_q <= #1 custom_mirror[cpu_address_in[8:1]];\nend\n\nassign custom_mirror_out = sel_custom_mirror ? custom_mirror_q : 16'h0000;\n\nassign cart_data_out = custom_mirror_out | nmi_adr_out;\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_gate_d_ff_en_W32_0_11_e6f46b4f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clock_gate_d_ff_en_W32_0_11 (\n  input CLK,\n  input EN,\n  input TE,\n  input [31:0] d,\n  output reg ENCLK\n);\n\n  TLALATCH clock_gating_cell (\n    .CLK(CLK),\n    .EN(EN),\n    .TE(TE),\n    .GATED_CLK(ENCLK)\n  );\n\n\nendmodule\n\n// Clock gating cell (simplified example)\nmodule TLALATCH(\n  input CLK,\n  input EN,\n  input TE,\n  output GATED_CLK\n);\n\n  // Simple clock gating logic\n  assign GATED_CLK = CLK & (EN | ~TE);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_right #_9ae9f15a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_right #(parameter A_SIGNED = 0, A_WIDTH = 32, Y_WIDTH = 32) (\n    input [A_WIDTH-1:0] A,\n    input [4:0] B,\n    output [A_WIDTH-1:0] Y\n);\n\n    wire [A_WIDTH-1:0] shifted;\n    assign shifted = A >> B;\n\n    assign Y = shifted;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__a2111o_c8e4b91c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_ms__a2111o (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    C1  ,\n    D1  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  C1  ;\n    input  D1  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    assign X = (A1 && !A2) ? 1 :\n               (!A1 && A2) ? 0 :\n               (A1 && A2) ? 0 :\n               (!A1 && !A2) ? 1 :\n               (B1) ? 0 :\n               (C1) ? 1 :\n               (D1) ? 0 :\n               (VPWR) ? 1 :\n               (VGND) ? 0 :\n               (VPB) ? 0 :\n               (VNB) ? 1 :\n               0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_0301bfab", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder (\n    input [3:0] ABCD,\n    output reg [15:0] out\n);\n\nalways @(*) begin\n    case (ABCD)\n        4'b0000: out = 16'b0000_0000_0000_0001;\n        4'b0001: out = 16'b0000_0000_0000_0010;\n        4'b0010: out = 16'b0000_0000_0000_0100;\n        4'b0011: out = 16'b0000_0000_0000_1000;\n        4'b0100: out = 16'b0000_0000_0001_0000;\n        4'b0101: out = 16'b0000_0000_0010_0000;\n        4'b0110: out = 16'b0000_0000_0100_0000;\n        4'b0111: out = 16'b0000_0000_1000_0000;\n        4'b1000: out = 16'b0000_0001_0000_0000;\n        4'b1001: out = 16'b0000_0010_0000_0000;\n        4'b1010: out = 16'b0000_0100_0000_0000;\n        4'b1011: out = 16'b0000_1000_0000_0000;\n        4'b1100: out = 16'b0001_0000_0000_0000;\n        4'b1101: out = 16'b0010_0000_0000_0000;\n        4'b1110: out = 16'b0100_0000_0000_0000;\n        4'b1111: out = 16'b1000_0000_0000_0000;\n        default: out = 16'b0000_0000_0000_0000;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_0f8e2565", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule memory (\n    input [9:0] address,\n    input clock,\n    input [11:0] data_in,\n    input write_en,\n    output reg [11:0] data_out\n);\n\n    reg [11:0] mem[1023:0];\n\n    always @(posedge clock) begin\n        if (write_en) begin\n            mem[address] <= data_in;\n        end\n        data_out <= mem[address];\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "unknown_module_51e85de7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define\tOPT_DUMBECHO\n`ifndef\tVERILATOR\n`define OPT_STANDALONE\n`endif\nmodule\techotest(\n\t\tinput\t\ti_clk,\n`ifndef\tOPT_STANDALONE\n\t\tinput\t[30:0]\ti_setup,\n`endif\n\t\tinput\t\ti_uart_rx,\n\t\toutput\twire\to_uart_tx\n\t\t);\n\n`ifdef\tOPT_DUMBECHO\n\treg\tr_uart_tx;\n\n\tinitial\tr_uart_tx = 1'b1;\n\talways @(posedge i_clk)\n\t\tr_uart_tx <= i_uart_rx;\n\tassign\to_uart_tx = r_uart_tx;\n\t`else\n\t`ifdef\tOPT_STANDALONE\n\twire\t[30:0]\ti_setup;\n\tassign\t\ti_setup = 31'd868;\t`endif\n\treg\tpwr_reset;\n\tinitial\tpwr_reset = 1'b1;\n\talways @(posedge i_clk)\n\t\tpwr_reset = 1'b0;\n\twire\trx_stb, rx_break, rx_perr, rx_ferr, rx_ignored;\n\twire\t[7:0]\trx_data;\n\n`ifdef\tUSE_LITE_UART\n\trxuartlite\t#(24'd868)\n\t\treceiver(i_clk, i_uart_rx, rx_stb, rx_data);\n`else\n\trxuart\treceiver(i_clk, pwr_reset, i_setup, i_uart_rx, rx_stb, rx_data,\n\t\t\trx_break, rx_perr, rx_ferr, rx_ignored);\n`endif\n\twire\tcts_n;\n\tassign cts_n = 1'b0;\n\n\twire\ttx_busy;\n`ifdef\tUSE_LITE_UART\n\ttxuartlite #(24'd868)\n\t\ttransmitter(i_clk, rx_stb, rx_data, o_uart_tx, tx_busy);\n`else\n\ttxuart\ttransmitter(i_clk, pwr_reset, i_setup, rx_break,\n\t\t\trx_stb, rx_data, rts, o_uart_tx, tx_busy);\n`endif\n\t`endif\tendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "any_edge_detector_e711b03e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule any_edge_detector (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    anyedge <= (in ^ prev_in) & in;\n    prev_in <= in;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output [7:0] anyedge\n);\n\nany_edge_detector detector (\n    .clk(clk),\n    .in(in),\n    .anyedge(anyedge)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "regfile_7e893e30", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule regfile (regA, regB, RegWrite, regTEST,Wdat,regW, clk, Adat, Bdat,resetn,TESTdat);\n    input clk,RegWrite,resetn;\t\tinput [4:0] regA, regB, regW,regTEST;\tinput [31:0] Wdat;\t\t\toutput wire [31:0] Adat, Bdat,TESTdat;\t\treg [31:0] regfile [0:31];\n\t reg [5:0] i;\n\t assign  Adat=regfile[regA];\n\t assign  Bdat=regfile[regB];\n\t assign  TESTdat=regfile[regTEST];\n\t always @(posedge clk) begin\n        if (resetn) for (i=0;i<32;i=i+1) regfile[i]=0; else\n\t\tif(RegWrite) regfile[regW]=(regW==0)?32'b0:Wdat;\n\tend\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "omsp_clock_mux_f8e87f14", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule  omsp_clock_mux (\n\nclk_out,                   clk_in0,                   clk_in1,                   reset,                     scan_mode,                 select_in                  );\n\noutput         clk_out;        input          clk_in0;        input          clk_in1;        input          reset;          input          scan_mode;      input          select_in;      wire in0_select;\nreg  in0_select_s;\nreg  in0_select_ss;\nwire in0_enable;\n\nwire in1_select;\nreg  in1_select_s;\nreg  in1_select_ss;\nwire in1_enable;\n\nwire clk_in0_inv;\nwire clk_in1_inv;\nwire clk_in0_scan_fix_inv;\nwire clk_in1_scan_fix_inv;\nwire gated_clk_in0;\nwire gated_clk_in1;\n\n`ifdef SCAN_REPAIR_INV_CLOCKS\n   omsp_scan_mux scan_mux_repair_clk_in0_inv (.scan_mode(scan_mode), .data_in_scan(clk_in0), .data_in_func(~clk_in0), .data_out(clk_in0_scan_fix_inv));\n   omsp_scan_mux scan_mux_repair_clk_in1_inv (.scan_mode(scan_mode), .data_in_scan(clk_in1), .data_in_func(~clk_in1), .data_out(clk_in1_scan_fix_inv));\n`else\n   assign clk_in0_scan_fix_inv = ~clk_in0;\n   assign clk_in1_scan_fix_inv = ~clk_in1;\n`endif\n\nassign in0_select = ~select_in & ~in1_select_ss;\n\nalways @ (posedge clk_in0_scan_fix_inv or posedge reset)\n  if (reset) in0_select_s  <=  1'b1;\n  else       in0_select_s  <=  in0_select;\n\nalways @ (posedge clk_in0              or posedge reset)\n  if (reset) in0_select_ss <=  1'b1;\n  else       in0_select_ss <=  in0_select_s;\n\nassign in0_enable = in0_select_ss | scan_mode;\n\n\nassign in1_select =  select_in & ~in0_select_ss;\n\nalways @ (posedge clk_in1_scan_fix_inv or posedge reset)\n  if (reset) in1_select_s  <=  1'b0;\n  else       in1_select_s  <=  in1_select;\n\nalways @ (posedge clk_in1     or posedge reset)\n  if (reset) in1_select_ss <=  1'b0;\n  else       in1_select_ss <=  in1_select_s;\n\nassign in1_enable = in1_select_ss & ~scan_mode;\n\n\nassign clk_in0_inv   = ~clk_in0;\nassign clk_in1_inv   = ~clk_in1;\n\nassign gated_clk_in0 = ~(clk_in0_inv & in0_enable);\nassign gated_clk_in1 = ~(clk_in1_inv & in1_enable);\n\n\nassign clk_out       =  (gated_clk_in0 & gated_clk_in1);\n\n\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shift_and_separate_99b1d286", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shift_and_separate(\n    input wire [15:0] in,\n    input wire [3:0] shift_amt,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n\n    // 16-bit barrel shifter\n    reg [15:0] shifted_in;\n    always @(*) begin\n        shifted_in = (shift_amt == 0) ? in :\n                     (shift_amt == 1) ? {in[14:0], 1'b0} :\n                     (shift_amt == 2) ? {in[13:0], 2'b00} :\n                     (shift_amt == 3) ? {in[12:0], 3'b000} :\n                     (shift_amt == 4) ? {in[11:0], 4'b0000} :\n                     (shift_amt == 5) ? {in[10:0], 5'b00000} :\n                     (shift_amt == 6) ? {in[9:0], 6'b000000} :\n                     (shift_amt == 7) ? {in[8:0], 7'b0000000} :\n                     (shift_amt == 8) ? {in[7:0], 8'b00000000} :\n                     (shift_amt == 9) ? {in[6:0], 9'b000000000} :\n                     (shift_amt == 10) ? {in[5:0], 10'b0000000000} :\n                     (shift_amt == 11) ? {in[4:0], 11'b00000000000} :\n                     (shift_amt == 12) ? {in[3:0], 12'b000000000000} :\n                     (shift_amt == 13) ? {in[2:0], 13'b0000000000000} :\n                     (shift_amt == 14) ? {in[1:0], 14'b00000000000000} :\n                     {in[0], 15'b000000000000000};\n    end\n\n    // Separate 16-bit input into two 8-bit outputs\n    assign out_hi = shifted_in[15:8];\n    assign out_lo = shifted_in[7:0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_4fcd8d97", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder (\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n    // Implementing full adder using structural verilog\n    wire w1, w2, w3;\n    xor x1(w1, A, B);\n    xor x2(S, w1, Cin);\n    and a1(w2, A, B);\n    and a2(w3, w1, Cin);\n    or o1(Cout, w2, w3);\nendmodule\n\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n    wire c0, c1, c2;\n    full_adder fa0(A[0], B[0], Cin, S[0], c0);\n    full_adder fa1(A[1], B[1], c0, S[1], c1);\n    full_adder fa2(A[2], B[2], c1, S[2], c2);\n    full_adder fa3(A[3], B[3], c2, S[3], Cout);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "driver_b7312272", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule driver (clk, state, enable);\n\n\ninput clk;\ninput [6:0] state; output enable; reg enableReg; reg [2:0] settleTimeCntr;\nreg [4:0] enableOnCntr;\n\nreg settleTimeFlag; reg enableOnFlag; reg [6:0] stateLast; parameter SETTLE_TIME=3'b111;\nparameter ENABLE_ON_TIME=5'b11111;\n\ninitial begin\n\tstateLast=7'b0; settleTimeCntr=3'b0; enableOnCntr=5'b0; settleTimeFlag=1'b0; enableOnFlag=1'b0; enableReg=1'b0; end\n\nalways @(posedge clk) begin\n\tif(|(stateLast - state)) begin settleTimeCntr=3'b0;\n\t\t\n\t\tsettleTimeFlag=1'b1;\n\t\t\n\t\tstateLast=state; end\n\t\n\tif(settleTimeFlag) begin\n\t\tif(settleTimeCntr==SETTLE_TIME) begin\n\t\t\tsettleTimeFlag=1'b0; enableOnFlag=1'b1; settleTimeCntr=3'b0; enableOnCntr=5'b0;\n\t\tend else settleTimeCntr=settleTimeCntr+3'b1; end\n\t\n\tif(enableOnFlag) begin\n\t\tif(enableOnCntr==ENABLE_ON_TIME) begin\n\t\t\tenableReg=1'b0; enableOnFlag=1'b0; enableOnCntr=5'b0; end else begin\n\t\t\tenableReg=1'b1; enableOnCntr=enableOnCntr+5'b1; end\n\tend\nend\n\nassign enable=enableReg; endmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sequence_counter_5e93a107", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sequence_counter (\n  input clk,\n  input reset,\n  input [9:0] data,\n  output [3:0] count\n);\n\n  reg [2:0] seq;\n  reg [3:0] cnt;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      seq <= 3'b0;\n      cnt <= 4'b0;\n    end else begin\n      seq <= {seq[1:0], data[0]};\n      if (seq == 3'b101) begin\n        cnt <= cnt + 1;\n      end\n    end\n  end\n  \n  assign count = cnt;    // Remove the semicolon here\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add16_996fdc8c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule add16 (\n    input [15:0] a,\n    input [15:0] b,\n    input cin,\n    output [15:0] sum,\n    output cout\n);\n\n    wire [16:0] temp_sum;\n    wire carry_out;\n\n    assign {carry_out, temp_sum} = a + b + cin;\n    assign sum = {1'b0, temp_sum[15:1]};\n    assign cout = carry_out;\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [15:0] in1,\n    input [15:0] in2,\n    input enable_mult,\n    output reg [31:0] out\n);\n\n    wire [15:0] adder1_out;\n    wire [15:0] adder2_out;\n    wire [31:0] mult_out = { {16{1'b0}}, in1 & in2 };\n\n    wire adder1_cout;\n    wire adder2_cout;\n\n    add16 adder1(.a(in1), .b(in2), .cin(1'b0), .sum(adder1_out), .cout(adder1_cout));\n    add16 adder2(.a(adder1_out), .b(in2), .cin(adder1_cout), .sum(adder2_out), .cout(adder2_cout));\n\n    always @ (posedge clk) begin\n        if (reset) begin\n            out <= 0;\n        end else begin\n            if (enable_mult) begin\n                out <= mult_out;\n            end else begin\n                out <= { adder2_out, adder2_cout };\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_to_bcd_420d67d2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_to_bcd (\n    input [3:0] binary_in,\n    output reg [15:0] bcd_out\n);\n\nreg [3:0] bcd_temp;\nreg [3:0] binary_temp;\nreg [2:0] bcd_count;\n\nalways @ (*) begin\n    bcd_temp = 0;\n    bcd_count = 0;\n    binary_temp = binary_in;\n    for (bcd_count = 0; bcd_count < 4; bcd_count = bcd_count + 1) begin\n        if (binary_temp >= 4'b1010) begin\n            bcd_temp = bcd_temp + 4'b0001;\n            binary_temp = binary_temp - 4'b1010;\n        end\n        else if (binary_temp >= 4'b1000) begin\n            bcd_temp = bcd_temp + 4'b0001;\n            binary_temp = binary_temp - 4'b1000;\n        end\n        else if (binary_temp >= 4'b0100) begin\n            bcd_temp = bcd_temp + 4'b0010;\n            binary_temp = binary_temp - 4'b0100;\n        end\n        else if (binary_temp >= 4'b0010) begin\n            bcd_temp = bcd_temp + 4'b0010;\n            binary_temp = binary_temp - 4'b0010;\n        end\n        else if (binary_temp >= 4'b0001) begin\n            bcd_temp = bcd_temp + 4'b0100;\n            binary_temp = binary_temp - 4'b0001;\n        end\n    end\nend\n\nalways @ (bcd_count) begin\n    case (bcd_count)\n        3'b000: bcd_out = {8'b0, bcd_temp};\n        3'b001: bcd_out = {7'b0, bcd_temp};\n        3'b010: bcd_out = {6'b0, bcd_temp};\n        3'b011: bcd_out = {5'b0, bcd_temp};\n        3'b100: bcd_out = {4'b0, bcd_temp};\n        default: bcd_out = 16'b0;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "signed_multiplier_6cd75317", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule signed_multiplier(\n    input clk, // clock input\n    input rst, // reset input\n    input load_b_i, // load input\n    input signed [25:0] Data_A_i, // input A\n    input signed [25:0] Data_B_i, // input B\n    output signed [51:0] sgf_result_o // output result\n);\n\n    reg signed [25:0] reg_Data_B_i; // register to store input B\n    reg signed [51:0] reg_sgf_result_o; // register to store result\n\n    always @(posedge clk) begin\n        if (rst) begin\n            reg_Data_B_i <= 0;\n            reg_sgf_result_o <= 0;\n        end else begin\n            if (load_b_i) begin\n                reg_Data_B_i <= Data_B_i;\n            end\n            reg_sgf_result_o <= $signed(Data_A_i) * $signed(reg_Data_B_i);\n        end\n    end\n\n    assign sgf_result_o = reg_sgf_result_o;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_805ac8cc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4to1(\n    input [3:0] data_in,\n    input [1:0] sel,\n    output reg data_out\n);\n\nalways @(*) begin\n    case (sel)\n        2'b00: data_out = data_in[0];\n        2'b01: data_out = data_in[1];\n        2'b10: data_out = data_in[2];\n        2'b11: data_out = data_in[3];\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sha256_W_6a3db12f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule sha256_W (\n    input clk,\n    input load_i,\n\t input busy_i,\n\t input [511:0] data_i,\n    output [31:0] W_o\n);\n\n`define DATA_IDX(x) data_i[512 - (x * 32) - 1:512 - (x * 32) - 32]\n\nreg [31:0] W[15:0];\nreg [31:0] W_new00, W_new01, W_new02, W_new03, W_new04, W_new05, W_new06, W_new07;\nreg [31:0] W_new08, W_new09, W_new10, W_new11, W_new12, W_new13, W_new14, W_new15;\nreg [31:0] W_new;\nreg [31:0] h0, h1, h0_new, h1_new;\n\nalways @(posedge clk)\nbegin\t\n\tW[ 0] <= W_new00;\n\tW[ 1] <= W_new01;\n\tW[ 2] <= W_new02;\n\tW[ 3] <= W_new03;\n\tW[ 4] <= W_new04;\n\tW[ 5] <= W_new05;\n\tW[ 6] <= W_new06;\n\tW[ 7] <= W_new07;\n\tW[ 8] <= W_new08;\n\tW[ 9] <= W_new09;\n\tW[10] <= W_new10;\n\tW[11] <= W_new11;\n\tW[12] <= W_new12;\n\tW[13] <= W_new13;\n\tW[14] <= W_new14;\n\tW[15] <= W_new15;\n\t\t\n\th0 <= h0_new;\n\th1 <= h1_new;\nend\n\nassign W_o = W[0];\n\nalways @*\nbegin : W_update\n\treg [31:0] w_0, w_1, w_9, w_14, d0, d1;\n\t\n\tW_new00 = 0;\n\tW_new01 = 0;\n\tW_new02 = 0;\n\tW_new03 = 0;\n\tW_new04 = 0;\n\tW_new05 = 0;\n\tW_new06 = 0;\n\tW_new07 = 0;\n\tW_new08 = 0;\n\tW_new09 = 0;\n\tW_new10 = 0;\n\tW_new11 = 0;\n\tW_new12 = 0;\n\tW_new13 = 0;\n\tW_new14 = 0;\n\tW_new15 = 0;\n\n\tw_0 = W[1];\n\tw_1 = W[2];\n\tw_9 = W[10];\n\tw_14 = W[15];\n\t\n\tW_new = h0 + h1;\n\n\tif(load_i)\n\tbegin\n\t\tW_new00 = `DATA_IDX( 0);\n\t\tW_new01 = `DATA_IDX( 1);\n\t\tW_new02 = `DATA_IDX( 2);\n\t\tW_new03 = `DATA_IDX( 3);\n\t\tW_new04 = `DATA_IDX( 4);\n\t\tW_new05 = `DATA_IDX( 5);\n\t\tW_new06 = `DATA_IDX( 6);\n\t\tW_new07 = `DATA_IDX( 7);\n\t\tW_new08 = `DATA_IDX( 8);\n\t\tW_new09 = `DATA_IDX( 9);\n\t\tW_new10 = `DATA_IDX(10);\n\t\tW_new11 = `DATA_IDX(11);\n\t\tW_new12 = `DATA_IDX(12);\n\t\tW_new13 = `DATA_IDX(13);\n\t\tW_new14 = `DATA_IDX(14);\n\t\tW_new15 = `DATA_IDX(15);\n\t\t\n\t\tw_0 = `DATA_IDX(0);\n\t\tw_1 = `DATA_IDX(1);\n\t\tw_9 = `DATA_IDX(9);\n\t\tw_14 = `DATA_IDX(14);\n\tend\n\telse if(busy_i)\n\tbegin\n\t\tW_new00 = W[ 1];\n\t\tW_new01 = W[ 2];\n\t\tW_new02 = W[ 3];\n\t\tW_new03 = W[ 4];\n\t\tW_new04 = W[ 5];\n\t\tW_new05 = W[ 6];\n\t\tW_new06 = W[ 7];\n\t\tW_new07 = W[ 8];\n\t\tW_new08 = W[ 9];\n\t\tW_new09 = W[10];\n\t\tW_new10 = W[11];\n\t\tW_new11 = W[12];\n\t\tW_new12 = W[13];\n\t\tW_new13 = W[14];\n\t\tW_new14 = W[15];\n\t\tW_new15 = W_new;\n\tend\n\t\n\td0 = {w_1[ 6: 0], w_1[31: 7]} ^ {w_1[17: 0], w_1[31:18]} ^ {3'h0, w_1[31: 3]};\n\td1 = {w_14[16: 0], w_14[31:17]} ^ {w_14[18: 0], w_14[31:19]} ^ {10'h0, w_14[31:10]};\n\t\n\th0_new = d0 + w_0;\n\th1_new = d1 + w_9;\nend\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux2to1_4d82fcdd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux2to1 (in0, in1, ctrl, out);\n  input [3:0] in0;\n  input [3:0] in1;\n  input ctrl;\n  output [3:0] out;\n\n  assign out = (ctrl == 1'b0) ? in0 : in1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__o32ai_14168a4a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__o32ai (\n    Y ,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out ;\n    wire nor1_out ;\n    wire or0_out_Y;\n\n    nor nor0 (nor0_out , A3, A1, A2        );\n    nor nor1 (nor1_out , B1, B2            );\n    or  or0  (or0_out_Y, nor1_out, nor0_out);\n    buf buf0 (Y        , or0_out_Y         );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__nor2_1_0991d5f5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_ms__nor2_1 (\n    output Y,\n    input A,\n    input B,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    wire w1;\n    sky130_fd_sc_ms__a211oi_1 U1 (\n        .Y(w1),\n        .A1(A),\n        .A2(B),\n        .B1(VPWR),\n        .C1(VNB),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n    sky130_fd_sc_ms__inv_1 U2 (\n        .Y(Y),\n        .A(w1),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\n\nmodule sky130_fd_sc_ms__inv_1 (\n    output Y,\n    input A,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    sky130_fd_sc_ms__a211oi_1 U1 (\n        .Y(Y),\n        .A1(A),\n        .A2(VPWR),\n        .B1(VGND),\n        .C1(VNB),\n        .VPWR(VPWR),\n        .VGND(VGND),\n        .VPB(VPB),\n        .VNB(VNB)\n    );\n\nendmodule\n\nmodule sky130_fd_sc_ms__a211oi_1 (\n    output Y,\n    input A1,\n    input A2,\n    input B1,\n    input C1,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB\n);\n\n    wire NMOS_TB;\n    wire NMOS_BA;\n    wire NMOS_AB;\n    wire PMOS_BC;\n\n    assign NMOS_TB = B1 & C1;\n    assign NMOS_BA = A1 & B1;\n    assign NMOS_AB = A1 & A2;\n    assign PMOS_BC = B1 & C1;\n\n    assign Y = (NMOS_AB | (NMOS_BA & ~PMOS_BC)) | (NMOS_TB & ~A2);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__5a5a67de", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_module (\n    X   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    assign X = (A1 & A2) | ~B1_N;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "start_for_CvtColowdI_shiftReg_258cba5f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule start_for_CvtColowdI_shiftReg (\n    clk,\n    data,\n    ce,\n    a,\n    q);\n\nparameter DATA_WIDTH = 32'd1;\nparameter ADDR_WIDTH = 32'd2;\nparameter DEPTH = 32'd3;\n\ninput clk;\ninput [DATA_WIDTH-1:0] data;\ninput ce;\ninput [ADDR_WIDTH-1:0] a;\noutput [DATA_WIDTH-1:0] q;\n\nreg[DATA_WIDTH-1:0] SRL_SIG [0:DEPTH-1];\ninteger i;\n\nalways @ (posedge clk)\n    begin\n        if (ce)\n        begin\n            for (i=0;i<DEPTH-1;i=i+1)\n                SRL_SIG[i+1] <= SRL_SIG[i];\n            SRL_SIG[0] <= data;\n        end\n    end\n\nassign q = SRL_SIG[a];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axi_basic_tx_pipeline #_280cb2c5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule axi_basic_tx_pipeline #(\n  parameter C_DATA_WIDTH = 128,           parameter C_PM_PRIORITY = \"FALSE\",      parameter TCQ = 1,                      parameter REM_WIDTH  = (C_DATA_WIDTH == 128) ? 2 : 1, parameter STRB_WIDTH = C_DATA_WIDTH / 8               ) (\n  input      [C_DATA_WIDTH-1:0] s_axis_tx_tdata,     input                         s_axis_tx_tvalid,    output                        s_axis_tx_tready,    input        [STRB_WIDTH-1:0] s_axis_tx_tstrb,     input                         s_axis_tx_tlast,     input                   [3:0] s_axis_tx_tuser,     output     [C_DATA_WIDTH-1:0] trn_td,              output                        trn_tsof,            output                        trn_teof,            output                        trn_tsrc_rdy,        input                         trn_tdst_rdy,        output                        trn_tsrc_dsc,        output        [REM_WIDTH-1:0] trn_trem,            output                        trn_terrfwd,         output                        trn_tstr,            output                        trn_tecrc_gen,       input                         trn_lnk_up,          input                         tready_thrtl,        input                         user_clk,            input                         user_rst             );\n\n\nreg  [C_DATA_WIDTH-1:0] reg_tdata;\nreg                     reg_tvalid;\nreg    [STRB_WIDTH-1:0] reg_tstrb;\nreg               [3:0] reg_tuser;\nreg                     reg_tlast;\nreg                     reg_tready;\n\nreg                     trn_in_packet;\nreg                     axi_in_packet;\nreg                     flush_axi;\nwire                    disable_trn;\nreg                     reg_disable_trn;\n\nwire                    axi_beat_live  = s_axis_tx_tvalid && s_axis_tx_tready;\nwire                    axi_end_packet = axi_beat_live && s_axis_tx_tlast;\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : td_DW_swap_128\n    assign trn_td = {reg_tdata[31:0],\n                     reg_tdata[63:32],\n                     reg_tdata[95:64],\n                     reg_tdata[127:96]};\n  end\n  else if(C_DATA_WIDTH == 64) begin : td_DW_swap_64\n    assign trn_td = {reg_tdata[31:0], reg_tdata[63:32]};\n  end\n  else begin : td_DW_swap_32\n    assign trn_td = reg_tdata;\n  end\nendgenerate\n\n\nassign trn_tsof = reg_tvalid && !trn_in_packet;\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    trn_in_packet <= #TCQ 1'b0;\n  end\n  else begin\n    if(trn_tsof && trn_tsrc_rdy && trn_tdst_rdy && !trn_teof) begin\n      trn_in_packet <= #TCQ 1'b1;\n    end\n    else if((trn_in_packet && trn_teof && trn_tsrc_rdy) || !trn_lnk_up) begin\n      trn_in_packet <= #TCQ 1'b0;\n    end\n  end\nend\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    axi_in_packet <= #TCQ 1'b0;\n  end\n  else begin\n    if(axi_beat_live && !s_axis_tx_tlast) begin\n      axi_in_packet <= #TCQ 1'b1;\n    end\n    else if(axi_beat_live) begin\n      axi_in_packet <= #TCQ 1'b0;\n    end\n  end\nend\n\n\ngenerate\n  if(C_PM_PRIORITY == \"TRUE\") begin : pm_priority_trn_flush\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_disable_trn    <= #TCQ 1'b1;\n      end\n      else begin\n        if(!trn_lnk_up)\n        begin\n          reg_disable_trn  <= #TCQ 1'b1;\n        end\n\n        else if(!flush_axi && s_axis_tx_tready) begin\n          reg_disable_trn <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign disable_trn = reg_disable_trn;\n  end\n\n  else begin : thrtl_ctl_trn_flush\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_disable_trn    <= #TCQ 1'b0;\n      end\n      else begin\n        if(axi_in_packet && !trn_lnk_up && !axi_end_packet)\n        begin\n          reg_disable_trn  <= #TCQ 1'b1;\n        end\n\n        else if(axi_end_packet) begin\n          reg_disable_trn <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign disable_trn = reg_disable_trn || !trn_lnk_up;\n  end\nendgenerate\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : tstrb_to_trem_128\n    wire   axi_DW_1    = reg_tstrb[7];\n    wire   axi_DW_2    = reg_tstrb[11];\n    wire   axi_DW_3    = reg_tstrb[15];\n    assign trn_trem[1] = axi_DW_2;\n    assign trn_trem[0] = axi_DW_3 || (axi_DW_1 && !axi_DW_2);\n  end\n  else if(C_DATA_WIDTH == 64) begin : tstrb_to_trem_64\n    assign trn_trem    = reg_tstrb[7];\n  end\n  else begin : tstrb_to_trem_32\n    assign trn_trem    = 1'b0;\n  end\nendgenerate\n\n\nassign trn_teof      = reg_tlast;\nassign trn_tecrc_gen = reg_tuser[0];\nassign trn_terrfwd   = reg_tuser[1];\nassign trn_tstr      = reg_tuser[2];\nassign trn_tsrc_dsc  = reg_tuser[3];\n\n\ngenerate\n  reg reg_tsrc_rdy;\n\n  if(C_PM_PRIORITY == \"FALSE\") begin : throttle_ctl_pipeline\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tdata        <= #TCQ {C_DATA_WIDTH{1'b0}};\n        reg_tvalid       <= #TCQ 1'b0;\n        reg_tstrb        <= #TCQ {STRB_WIDTH{1'b0}};\n        reg_tlast        <= #TCQ 1'b0;\n        reg_tuser        <= #TCQ 4'h0;\n        reg_tsrc_rdy     <= #TCQ 1'b0;\n      end\n      else begin\n        reg_tdata        <= #TCQ s_axis_tx_tdata;\n        reg_tvalid       <= #TCQ s_axis_tx_tvalid;\n        reg_tstrb        <= #TCQ s_axis_tx_tstrb;\n        reg_tlast        <= #TCQ s_axis_tx_tlast;\n        reg_tuser        <= #TCQ s_axis_tx_tuser;\n\n        reg_tsrc_rdy     <= #TCQ axi_beat_live && !disable_trn;\n      end\n    end\n\n    assign trn_tsrc_rdy = reg_tsrc_rdy;\n\n    assign s_axis_tx_tready = tready_thrtl;\n  end\n\n  else begin : pm_prioity_pipeline\n    reg  [C_DATA_WIDTH-1:0] tdata_prev;\n    reg                     tvalid_prev;\n    reg    [STRB_WIDTH-1:0] tstrb_prev;\n    reg                     tlast_prev;\n    reg               [3:0] tuser_prev;\n    reg                     reg_tdst_rdy;\n\n    wire                    data_hold;\n    reg                     data_prev;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        tdata_prev   <= #TCQ {C_DATA_WIDTH{1'b0}};\n        tvalid_prev  <= #TCQ 1'b0;\n        tstrb_prev   <= #TCQ {STRB_WIDTH{1'b0}};\n        tlast_prev   <= #TCQ 1'b0;\n        tuser_prev   <= #TCQ 4'h 0;\n      end\n      else begin\n        if(!s_axis_tx_tready) begin\n          tdata_prev   <= #TCQ tdata_prev;\n          tvalid_prev  <= #TCQ tvalid_prev;\n          tstrb_prev   <= #TCQ tstrb_prev;\n          tlast_prev   <= #TCQ tlast_prev;\n          tuser_prev   <= #TCQ tuser_prev;\n        end\n        else begin\n          tdata_prev   <= #TCQ s_axis_tx_tdata;\n          tvalid_prev  <= #TCQ s_axis_tx_tvalid;\n          tstrb_prev   <= #TCQ s_axis_tx_tstrb;\n          tlast_prev   <= #TCQ s_axis_tx_tlast;\n          tuser_prev   <= #TCQ s_axis_tx_tuser;\n        end\n      end\n    end\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tdata  <= #TCQ {C_DATA_WIDTH{1'b0}};\n        reg_tvalid <= #TCQ 1'b0;\n        reg_tstrb  <= #TCQ {STRB_WIDTH{1'b0}};\n        reg_tlast  <= #TCQ 1'b0;\n        reg_tuser  <= #TCQ 4'h0;\n\n        reg_tdst_rdy <= #TCQ 1'b0;\n      end\n      else begin\n        reg_tdst_rdy <= #TCQ trn_tdst_rdy;\n\n        if(!data_hold) begin\n          if(data_prev) begin\n            reg_tdata  <= #TCQ tdata_prev;\n            reg_tvalid <= #TCQ tvalid_prev;\n            reg_tstrb  <= #TCQ tstrb_prev;\n            reg_tlast  <= #TCQ tlast_prev;\n            reg_tuser  <= #TCQ tuser_prev;\n          end\n\n          else begin\n            reg_tdata  <= #TCQ s_axis_tx_tdata;\n            reg_tvalid <= #TCQ s_axis_tx_tvalid;\n            reg_tstrb  <= #TCQ s_axis_tx_tstrb;\n            reg_tlast  <= #TCQ s_axis_tx_tlast;\n            reg_tuser  <= #TCQ s_axis_tx_tuser;\n          end\n        end\n        end\n    end\n\n\n    assign data_hold = trn_tsrc_rdy && !trn_tdst_rdy;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        data_prev <= #TCQ 1'b0;\n      end\n      else begin\n        data_prev <= #TCQ data_hold;\n      end\n    end\n\n\n    assign trn_tsrc_rdy = reg_tvalid && !disable_trn;\n\n\n    always @(posedge user_clk) begin\n      if(user_rst) begin\n        reg_tready <= #TCQ 1'b0;\n      end\n      else begin\n        if(flush_axi && !axi_end_packet) begin\n          reg_tready <= #TCQ 1'b1;\n        end\n\n        else if(trn_lnk_up) begin\n          reg_tready <= #TCQ trn_tdst_rdy || !trn_tsrc_rdy;\n        end\n\n        else begin\n          reg_tready <= #TCQ 1'b0;\n        end\n      end\n    end\n\n    assign s_axis_tx_tready = reg_tready;\n  end\n\n\n  always @(posedge user_clk) begin\n    if(user_rst) begin\n      flush_axi    <= #TCQ 1'b0;\n    end\n    else begin\n      if(axi_in_packet && !trn_lnk_up && !axi_end_packet) begin\n        flush_axi <= #TCQ 1'b1;\n      end\n\n      else if(axi_end_packet) begin\n        flush_axi <= #TCQ 1'b0;\n      end\n    end\n  end\nendgenerate\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "WDT_e9c75eec", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule WDT (\n  input clk, rst,\n  output wdt\n);\n\n  parameter t = 10; // timeout period in clock cycles\n  \n  reg [31:0] counter;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      counter <= 0;\n    end\n    else begin\n      counter <= counter + 1;\n    end\n  end\n  \n  assign wdt = (counter >= t) ? 1'b1 : 1'b0;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rcn_filter_8c2be3eb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule rcn_filter\n(\n    input clk,\n    input rst,\n\n    input [68:0] rcn_in,\n    output [68:0] rcn_out,\n    \n    output reg filtered\n);\n    parameter START_0 = 1;\n    parameter END_0 = 0;\n    parameter START_1 = 1;\n    parameter END_1 = 0;\n    parameter START_2 = 1;\n    parameter END_2 = 0;\n    parameter START_3 = 1;\n    parameter END_3 = 0;\n\n    reg [68:0] rin;\n    reg [68:0] rout;\n    \n    assign rcn_out = rout;\n    \n    wire [23:0] addr_start_0 = START_0;\n    wire [23:0] addr_end_0 = END_0;\n    wire filter_0 = (rin[55:34] >= addr_start_0) && (rin[55:34] <= addr_end_0);\n    \n    wire [23:0] addr_start_1 = START_1;\n    wire [23:0] addr_end_1 = END_1;\n    wire filter_1 = (rin[55:34] >= addr_start_1) && (rin[55:34] <= addr_end_1);\n    \n    wire [23:0] addr_start_2 = START_2;\n    wire [23:0] addr_end_2 = END_2;\n    wire filter_2 = (rin[55:34] >= addr_start_2) && (rin[55:34] <= addr_end_2);\n    \n    wire [23:0] addr_start_3 = START_3;\n    wire [23:0] addr_end_3 = END_3;\n    wire filter_3 = (rin[55:34] >= addr_start_3) && (rin[55:34] <= addr_end_3);\n    \n    always @ (posedge clk or posedge rst)\n        if (rst)\n        begin\n            rin <= 69'd0;\n            rout <= 69'd0;\n            filtered <= 1'b0;\n        end\n        else\n        begin\n            rin <= rcn_in;\n            rout <= (filter_0 || filter_1 || filter_2 || filter_3) ? 69'd0 : rcn_in;\n            filtered <= (filter_0 || filter_1 || filter_2 || filter_3);\n        end\n    \n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "register_4bit_2ca7c6cc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule register_4bit (\n    input clk,\n    input reset,\n    input enable,\n    input [3:0] data_in,\n    output reg [3:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            data_out <= 4'b0;\n        end else if (enable) begin\n            data_out <= data_in;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_912b39ab", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1 (\n    input A,\n    input B,\n    input Sel,\n    output Y\n);\n\n    wire and_out, or_out;\n\n    // Implement the AND gate\n    and_gate and_gate_inst (\n        .A(A),\n        .B(Sel),\n        .Z(and_out)\n    );\n\n    // Implement the OR gate\n    or_gate or_gate_inst (\n        .A(B),\n        .B(and_out),\n        .Z(or_out)\n    );\n\n    // Assign the output\n    assign Y = or_out;\n\nendmodule\n\nmodule and_gate (\n    input A,\n    input B,\n    output Z\n);\n\n    assign Z = A & B;\n\nendmodule\n\nmodule or_gate (\n    input A,\n    input B,\n    output Z\n);\n\n    assign Z = A | B;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand4_pwrgood_39e8f7fb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule nand4_pwrgood (\n    Y,\n    A,\n    B,\n    C,\n    VDD,\n    VSS\n);\n\n    // Module ports\n    output  Y   ;\n    input   A   ;\n    input   B   ;\n    input   C   ;\n    input   VDD ;\n    input   VSS ;\n\n    // Local signals\n    wire nand0_out_Y      ;\n    wire nand1_out_Y      ;\n    wire nand2_out_Y      ;\n\n    //                                 Name         Output             Other arguments\n    nand                               nand0       (nand0_out_Y      , B, A, C                );\n    nand                               nand1       (nand1_out_Y      , nand0_out_Y, nand0_out_Y);\n    nand                               nand2       (nand2_out_Y      , nand1_out_Y, nand1_out_Y);\n    not                                inv0         (Y                , nand2_out_Y);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_fca8dc26", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter(\n    input clk,\n    input reset,\n    output reg [3:0] q\n    );\n\n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            q <= 4'b0000;\n        end else begin\n            q <= q + 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sub_8f0029e7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sub (\n    // Outputs\n    outy_w92, outz_w22,\n    // Inputs\n    clk, inw_w31, inx_w11\n    );\n\n    input clk;\n    input        inw_w31;\n    input [60:0] inx_w11;\n    output [91:0] outy_w92;\n    output [21:0] outz_w22;\n\n    wire [29:0] outc_w30;\n    wire [72:0] outd_w73;\nendmodule\n\nmodule t (\n    // Outputs\n    outc_w30,\n    outd_w73,\n    // Inputs\n    clk,\n    ina_w1,\n    inb_w61\n    );\n\n    input clk;\n    input ina_w1;\n    input [60:0] inb_w61;\n    output [29:0] outc_w30;\n    output [72:0] outd_w73;\n\n    assign outc_w30 = ina_w1 - inb_w61[30:0];\n    assign outd_w73 = ina_w1 * inb_w61;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_74a1a1a0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n\n    wire c0, c1, c2;\n\n    full_adder U0(\n        .a(A[0]),\n        .b(B[0]),\n        .cin(Cin),\n        .sum(S[0]),\n        .cout(c0)\n    );\n\n    full_adder U1(\n        .a(A[1]),\n        .b(B[1]),\n        .cin(c0),\n        .sum(S[1]),\n        .cout(c1)\n    );\n\n    full_adder U2(\n        .a(A[2]),\n        .b(B[2]),\n        .cin(c1),\n        .sum(S[2]),\n        .cout(c2)\n    );\n\n    full_adder U3(\n        .a(A[3]),\n        .b(B[3]),\n        .cin(c2),\n        .sum(S[3]),\n        .cout(Cout)\n    );\n\nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a^b^cin;\n    assign cout = (a&b) | (a&cin) | (b&cin);\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_6b6b905f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder(\n    input clk,\n    input [63:0] probe0,\n    input [63:0] probe1,\n    input [0:0] probe2,\n    input [0:0] probe3,\n    input [0:0] probe4,\n    input [0:0] probe5,\n    input [0:0] probe6,\n    input [63:0] probe7,\n    input [0:0] probe8,\n    input [0:0] probe9,\n    input [0:0] probe10,\n    input [0:0] probe11,\n    input [63:0] probe12,\n    input [0:0] probe13,\n    input [0:0] probe14,\n    input [0:0] probe15,\n    input [0:0] probe16,\n    input [0:0] probe17,\n    input [7:0] probe18,\n    input [8:0] probe19,\n    input [0:0] probe20,\n    input [2:0] probe21,\n    input [2:0] probe22,\n    input [0:0] probe23,\n    input [7:0] probe24,\n    output reg [63:0] output0,\n    output reg output1,\n    output reg [63:0] output2,\n    output reg [7:0] output3,\n    output reg [8:0] output4\n);\n\nalways @(posedge clk) begin\n    output0 <= {probe0, probe1};\n    output1 <= &{probe2, probe3, probe4, probe5, probe6};\n    output2 <= {probe7, probe12};\n    output3 <= {probe18, probe24};\n    output4 <= {probe19, probe21, probe22};\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "piso_shift_register_7732df1e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule piso_shift_register (\n    input [3:0] parallel_in,\n    input clk,\n    input shift_enable,\n    input reset,\n    output serial_out\n);\n\n    reg [3:0] shift_reg;\n    reg serial_out_reg;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 4'b0000;\n            serial_out_reg <= 1'b0;\n        end else if (shift_enable) begin\n            shift_reg <= {shift_reg[2:0], parallel_in[0]};\n            serial_out_reg <= shift_reg[3];\n        end else begin\n            shift_reg <= shift_reg;\n            serial_out_reg <= shift_reg[3];\n        end\n    end\n    \n    assign serial_out = serial_out_reg;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vga_linear_fml_dab690fd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule vga_linear_fml (\n    input clk,\n    input rst,\n    \n    input enable,\n\n    output [17:1] fml_adr_o,\n    input  [15:0] fml_dat_i,\n    output        fml_stb_o,\n\n    input [9:0] h_count,\n    input [9:0] v_count,\n    input       horiz_sync_i,\n    input       video_on_h_i,\n    output      video_on_h_o,\n\n    output [7:0] color,\n    output       horiz_sync_o\n  );\n\n  reg [ 9:0] row_addr;\n  reg [ 6:0] col_addr;\n  reg [14:1] word_offset;\n  reg [ 1:0] plane_addr;\n  reg [ 1:0] plane_addr0;\n  reg [ 7:0] color_l;\n  \n  reg  [ 15:0] fml1_dat;\n  reg  [ 15:0] fml2_dat;\n  reg  [ 15:0] fml3_dat;\n  reg  [ 15:0] fml4_dat;\n  reg  [ 15:0] fml5_dat;\n  reg  [ 15:0] fml6_dat;\n  reg  [ 15:0] fml7_dat;\n  \n  reg [4:0] video_on_h;\n  reg [4:0] horiz_sync;\n  reg [18:0] pipe;  \n\n  assign fml_adr_o = { 1'b0, word_offset, plane_addr };\n  assign fml_stb_o = pipe[1];\n  \n  assign color = pipe[4] ? fml_dat_i[7:0] : color_l;    \n  \n  assign video_on_h_o = video_on_h[4];\n  assign horiz_sync_o = horiz_sync[4];\n\n  always @(posedge clk)\n    if (rst)\n      begin\n        pipe <= 18'b0;    \n      end\n    else\n      if (enable)\n        begin\n          pipe <= { pipe[17:0], (h_count[3:0]==4'h0) };\n        end\n\n  always @(posedge clk)\n    if (enable)\n      begin\n        fml1_dat <= pipe[5]  ? fml_dat_i[15:0] : fml1_dat;\n        fml2_dat <= pipe[6]  ? fml_dat_i[15:0] : fml2_dat;\n        fml3_dat <= pipe[7]  ? fml_dat_i[15:0] : fml3_dat;\n        fml4_dat <= pipe[8]  ? fml_dat_i[15:0] : fml4_dat;\n        fml5_dat <= pipe[9]  ? fml_dat_i[15:0] : fml5_dat;\n        fml6_dat <= pipe[10] ? fml_dat_i[15:0] : fml6_dat;\n        fml7_dat <= pipe[11] ? fml_dat_i[15:0] : fml7_dat;\n      end\n\n  always @(posedge clk)\n    if (rst)\n      begin\n        video_on_h <= 5'b0;\n      end\n    else\n      if (enable)\n        begin\n          video_on_h <= { video_on_h[3:0], video_on_h_i };\n        end\n\n  always @(posedge clk)\n    if (rst)\n      begin\n        horiz_sync <= 5'b0;\n      end\n    else\n      if (enable)\n        begin\n          horiz_sync <= { horiz_sync[3:0], horiz_sync_i };\n        end\n\n  always @(posedge clk)\n    if (rst)\n      begin\n        row_addr    <= 10'h0;\n        col_addr    <= 7'h0;\n        plane_addr0 <= 2'b00;\n        word_offset <= 14'h0;\n        plane_addr  <= 2'b00;\n      end\n    else\n      if (enable)\n        begin\n          row_addr    <= { v_count[8:1], 2'b00 } + v_count[8:1];\n          col_addr    <= h_count[9:3];\n          plane_addr0 <= h_count[2:1];\n\n          word_offset <= { row_addr + col_addr[6:4], col_addr[3:0] };\n          plane_addr  <= plane_addr0;\n        end\n \n always @(posedge clk)\n    if (rst)\n      begin\n        color_l <= 8'h0;\n      end\n    else\n      if (enable)\n        begin\n          if (pipe[4])\n            color_l <= fml_dat_i[7:0];\n          else\n          if (pipe[5])\n            color_l <= fml_dat_i[7:0];\n          else\n          if (pipe[7])\n            color_l <= fml2_dat[7:0];\n          else\n          if (pipe[9])\n            color_l <= fml3_dat[7:0];\n          else\n          if (pipe[11])\n            color_l <= fml4_dat[7:0];\n          else\n          if (pipe[13])\n            color_l <= fml5_dat[7:0];\n          else\n          if (pipe[15])\n            color_l <= fml6_dat[7:0];\n          else\n          if (pipe[17])\n            color_l <= fml7_dat[7:0];\n        end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_3to8_2d6c0fee", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_3to8 (\n    input [2:0] A, B, C,\n    input EN,\n    output reg [7:0] Y\n);\n    \n    always @(*) begin\n        if (EN == 1'b0) begin\n            Y <= 8'b00000000;\n        end\n        else begin\n            case ({A, B, C})\n                3'b000: Y <= 8'b00000001;\n                3'b001: Y <= 8'b00000010;\n                3'b010: Y <= 8'b00000100;\n                3'b011: Y <= 8'b00001000;\n                3'b100: Y <= 8'b00010000;\n                3'b101: Y <= 8'b00100000;\n                3'b110: Y <= 8'b01000000;\n                3'b111: Y <= 8'b10000000;\n                default: Y <= 8'b00000000;\n            endcase\n        end\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nvme_cq_check #_f3236443", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule nvme_cq_check # (\n\tparameter\tC_PCIE_DATA_WIDTH\t\t\t= 128,\n\tparameter\tC_PCIE_ADDR_WIDTH\t\t\t= 36\n)\n(\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_clk,\n\tinput\t\t\t\t\t\t\t\t\tpcie_user_rst_n,\n\n\tinput\t\t\t\t\t\t\t\t\tpcie_msi_en,\n\n\tinput\t\t\t\t\t\t\t\t\tcq_rst_n,\n\tinput\t\t\t\t\t\t\t\t\tcq_valid,\n\tinput\t\t\t\t\t\t\t\t\tio_cq_irq_en,\n\t\n\tinput\t[7:0]\t\t\t\t\t\t\tcq_tail_ptr,\n\tinput\t[7:0]\t\t\t\t\t\t\tcq_head_ptr,\n\tinput\t\t\t\t\t\t\t\t\tcq_head_update,\n\n\toutput\t\t\t\t\t\t\t\t\tcq_legacy_irq_req,\n\toutput\t\t\t\t\t\t\t\t\tcq_msi_irq_req,\n\tinput\t\t\t\t\t\t\t\t\tcq_msi_irq_ack\n\t\n);\n\nlocalparam\tLP_CQ_IRQ_DELAY_TIME\t\t\t= 8'h01;\n\n\nlocalparam\tS_IDLE\t\t\t\t\t\t\t= 4'b0001;\nlocalparam\tS_CQ_MSI_IRQ_REQ\t\t\t\t= 4'b0010;\nlocalparam\tS_CQ_MSI_HEAD_SET\t\t\t\t= 4'b0100;\nlocalparam\tS_CQ_MSI_IRQ_TIMER\t\t\t\t= 4'b1000;\n\nreg\t\t[3:0]\t\t\t\t\t\t\t\tcur_state;\nreg\t\t[3:0]\t\t\t\t\t\t\t\tnext_state;\n\nreg\t\t[7:0]\t\t\t\t\t\t\t\tr_cq_tail_ptr;\nreg\t\t[7:0]\t\t\t\t\t\t\t\tr_cq_msi_irq_head_ptr;\nreg\t\t[7:0]\t\t\t\t\t\t\t\tr_irq_timer;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cq_legacy_irq_req;\nreg\t\t\t\t\t\t\t\t\t\t\tr_cq_msi_irq_req;\n\nwire\t\t\t\t\t\t\t\t\t\tw_cq_rst_n;\n\nassign cq_legacy_irq_req = r_cq_legacy_irq_req;\nassign cq_msi_irq_req = r_cq_msi_irq_req;\n\nassign w_cq_rst_n = pcie_user_rst_n & cq_rst_n;\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tr_cq_tail_ptr <= cq_tail_ptr;\n\tr_cq_legacy_irq_req <= ((cq_head_ptr != r_cq_tail_ptr) && ((cq_valid & io_cq_irq_en) == 1));\nend\n\nalways @ (posedge pcie_user_clk or negedge w_cq_rst_n)\nbegin\n\tif(w_cq_rst_n == 0)\n\t\tcur_state <= S_IDLE;\n\telse\n\t\tcur_state <= next_state;\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\t\t\tif(((r_cq_msi_irq_head_ptr != r_cq_tail_ptr) & (pcie_msi_en & cq_valid & io_cq_irq_en)) == 1)\n\t\t\t\tnext_state <= S_CQ_MSI_IRQ_REQ;\n\t\t\telse\n\t\t\t\tnext_state <= S_IDLE;\n\t\tend\n\t\tS_CQ_MSI_IRQ_REQ: begin\n\t\t\tif(cq_msi_irq_ack == 1)\n\t\t\t\tnext_state <= S_CQ_MSI_HEAD_SET;\n\t\t\telse\n\t\t\t\tnext_state <= S_CQ_MSI_IRQ_REQ;\n\t\tend\n\t\tS_CQ_MSI_HEAD_SET: begin\n\n\t\t\tnext_state <= S_CQ_MSI_IRQ_TIMER;\n\t\tend\n\t\tS_CQ_MSI_IRQ_TIMER: begin\n\t\t\tif(r_irq_timer == 0)\n\t\t\t\tnext_state <= S_IDLE;\n\t\t\telse\n\t\t\t\tnext_state <= S_CQ_MSI_IRQ_TIMER;\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state <= S_IDLE;\n\t\tend\n\tendcase\nend\n\n\nalways @ (posedge pcie_user_clk)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\n\t\tend\n\t\tS_CQ_MSI_IRQ_REQ: begin\n\n\t\tend\n\t\tS_CQ_MSI_HEAD_SET: begin\n\t\t\tr_irq_timer <= LP_CQ_IRQ_DELAY_TIME;\n\t\tend\n\t\tS_CQ_MSI_IRQ_TIMER: begin\n\t\t\tr_irq_timer <= r_irq_timer - 1;\n\t\tend\n\t\tdefault: begin\n\n\t\tend\n\tendcase\nend\n\nalways @ (posedge pcie_user_clk or negedge w_cq_rst_n)\nbegin\n\tif(w_cq_rst_n == 0) begin\n\t\tr_cq_msi_irq_head_ptr <= 0;\n\tend\n\telse begin\n\t\tcase(cur_state)\n\t\t\tS_IDLE: begin\n\t\t\t\tif((pcie_msi_en & cq_valid & io_cq_irq_en) == 0)\n\t\t\t\t\tr_cq_msi_irq_head_ptr <= r_cq_tail_ptr;\n\t\t\tend\n\t\t\tS_CQ_MSI_IRQ_REQ: begin\n\n\t\t\tend\n\t\t\tS_CQ_MSI_HEAD_SET: begin\n\t\t\t\tr_cq_msi_irq_head_ptr <= r_cq_tail_ptr;\n\t\t\tend\n\t\t\tS_CQ_MSI_IRQ_TIMER: begin\n\n\t\t\tend\n\t\t\tdefault: begin\n\n\t\t\tend\n\t\tendcase\n\tend\n\n\nend\n\nalways @ (*)\nbegin\n\tcase(cur_state)\n\t\tS_IDLE: begin\n\t\t\tr_cq_msi_irq_req <= 0;\n\t\tend\n\t\tS_CQ_MSI_IRQ_REQ: begin\n\t\t\tr_cq_msi_irq_req <= 1;\n\t\tend\n\t\tS_CQ_MSI_HEAD_SET: begin\n\t\t\tr_cq_msi_irq_req <= 0;\n\t\tend\n\t\tS_CQ_MSI_IRQ_TIMER: begin\n\t\t\tr_cq_msi_irq_req <= 0;\n\t\tend\n\t\tdefault: begin\n\t\t\tr_cq_msi_irq_req <= 0;\n\t\tend\n\tendcase\nend\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "block_memory_generator_30080f36", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule block_memory_generator (\n  input ENA,\n  input clka,\n  input ENB,\n  input clkb,\n  input [9:0] addra,\n  input [9:0] addrb,\n  input  dina,\n  output reg  DOUTB\n);\n\n  reg mem [0:1023]; // 2^16 bits of memory\n\n  always @(posedge clka) begin\n    if (ENA) begin\n      mem[addra] <= dina;\n    end\n  end\n\n  always @(posedge clkb) begin\n    if (ENB) begin\n      DOUTB <= mem[addrb];\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add8bit_62c5121d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule add8bit (\n    input [7:0] in1,\n    input [7:0] in2,\n    output [7:0] sum\n    );\n\n    // The sum of two 8-bit unsigned integers can be calculated by simply adding them together.\n    // We can use the \"+\" operator to perform the addition.\n    // Since we are using unsigned integers, the output will automatically wrap around if it exceeds 8 bits.\n\n    assign sum = in1 + in2;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__and4bb_b717ef05", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__and4bb (\n    X  ,\n    A_N,\n    B_N,\n    C  ,\n    D\n);\n\n    output X  ;\n    input  A_N;\n    input  B_N;\n    input  C  ;\n    input  D  ;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out  ;\n    wire and0_out_X;\n\n    nor nor0 (nor0_out  , A_N, B_N       );\n    and and0 (and0_out_X, nor0_out, C, D );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ram16k_dualport_5e0f7b84", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ram16k_dualport(\n    input CLK,\n    input [9:0] A1ADDR, B1ADDR,\n    input [31:0] B1DATA,\n    input A1EN, B1EN,\n    output reg [31:0] A1DATA\n);\n\n     reg [31:0] mem [0:4095];\n\n    always @(posedge CLK) begin\n        if (B1EN) begin\n            mem[B1ADDR] <= B1DATA;\n        end\n        if (A1EN) begin\n            A1DATA <= mem[A1ADDR];\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "video_sys_jtag_uart_0_sim_scfifo_r_2763508b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule video_sys_jtag_uart_0_sim_scfifo_r (\n    // inputs:\n    clk,\n    fifo_rd,\n    rst_n,\n\n    // outputs:\n    fifo_EF,\n    fifo_rdata,\n    rfifo_full,\n    rfifo_used\n);\n    output fifo_EF;\n    output [7:0] fifo_rdata;\n    output rfifo_full;\n    output [5:0] rfifo_used;\n\n    input clk;\n    input fifo_rd;\n    input rst_n;\n\n    reg [63:0] fifo;\n    reg [5:0] rfifo_used;\n    reg [7:0] fifo_rdata_r;\n\n    assign fifo_EF = (rfifo_used == 0);\n    assign rfifo_full = (rfifo_used == 64);\n\n    always @(posedge clk) begin\n        if (rst_n == 0) begin\n            fifo <= 64'h0;\n            rfifo_used <= 6'h0;\n        end else if (fifo_rd) begin\n            fifo_rdata_r <= fifo[7:0];\n            rfifo_used <= rfifo_used - 1;\n            fifo <= {fifo[55:0], 8'h00};\n        end else begin\n            if (rfifo_used < 64) begin\n                fifo <= {fifo[55:0], 8'h00};\n                rfifo_used <= rfifo_used + 1;\n            end\n        end\n    end\n\n    assign fifo_rdata = fifo_rdata_r;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcieCore_axi_basic_rx_null_gen #_513f0174", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule pcieCore_axi_basic_rx_null_gen # (\n  parameter C_DATA_WIDTH = 128,           parameter TCQ = 1,                      parameter KEEP_WIDTH = C_DATA_WIDTH / 8            ) (\n\n  input      [C_DATA_WIDTH-1:0] m_axis_rx_tdata,     input                         m_axis_rx_tvalid,    input                         m_axis_rx_tready,    input                         m_axis_rx_tlast,     input                  [21:0] m_axis_rx_tuser,     output                        null_rx_tvalid,      output                        null_rx_tlast,       output       [KEEP_WIDTH-1:0] null_rx_tkeep,       output                        null_rdst_rdy,       output reg              [4:0] null_is_eof,         input                         user_clk,            input                         user_rst             );\n\n\nlocalparam INTERFACE_WIDTH_DWORDS = (C_DATA_WIDTH == 128) ? 11'd4 :\n                                           (C_DATA_WIDTH == 64) ? 11'd2 : 11'd1;\n\nlocalparam            IDLE      = 0;\nlocalparam            IN_PACKET = 1;\nreg                   cur_state;\nreg                   next_state;\n\nreg            [11:0] reg_pkt_len_counter;\nreg            [11:0] pkt_len_counter;\nwire           [11:0] pkt_len_counter_dec;\nwire                  pkt_done;\n\nwire           [11:0] new_pkt_len;\nwire            [9:0] payload_len;\nwire            [1:0] packet_fmt;\nwire                  packet_td;\nreg             [3:0] packet_overhead;\n\nwire [KEEP_WIDTH-1:0] eof_tkeep;\nwire                  straddle_sof;\nwire                  eof;\n\n\nassign eof = m_axis_rx_tuser[21];\ngenerate\n  if(C_DATA_WIDTH == 128) begin : sof_eof_128\n    assign straddle_sof = (m_axis_rx_tuser[14:13] == 2'b11);\n  end\n  else begin : sof_eof_64_32\n    assign straddle_sof = 1'b0;\n  end\nendgenerate\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : len_calc_128\n    assign packet_fmt  = straddle_sof ?\n                                m_axis_rx_tdata[94:93] : m_axis_rx_tdata[30:29];\n    assign packet_td   = straddle_sof ?\n                                      m_axis_rx_tdata[79] : m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ?\n         (straddle_sof ? m_axis_rx_tdata[73:64] : m_axis_rx_tdata[9:0]) : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td, straddle_sof})\n        3'b0_0_0: packet_overhead = 4'd3 + 4'd0 - 4'd4;\n        3'b0_0_1: packet_overhead = 4'd3 + 4'd0 - 4'd2;\n        3'b0_1_0: packet_overhead = 4'd3 + 4'd1 - 4'd4;\n        3'b0_1_1: packet_overhead = 4'd3 + 4'd1 - 4'd2;\n        3'b1_0_0: packet_overhead = 4'd4 + 4'd0 - 4'd4;\n        3'b1_0_1: packet_overhead = 4'd4 + 4'd0 - 4'd2;\n        3'b1_1_0: packet_overhead = 4'd4 + 4'd1 - 4'd4;\n        3'b1_1_1: packet_overhead = 4'd4 + 4'd1 - 4'd2;\n      endcase\n    end\n  end\n  else if(C_DATA_WIDTH == 64) begin : len_calc_64\n    assign packet_fmt  = m_axis_rx_tdata[30:29];\n    assign packet_td   = m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ? m_axis_rx_tdata[9:0] : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td})\n        2'b0_0: packet_overhead = 4'd3 + 4'd0 - 4'd2;\n        2'b0_1: packet_overhead = 4'd3 + 4'd1 - 4'd2;\n        2'b1_0: packet_overhead = 4'd4 + 4'd0 - 4'd2;\n        2'b1_1: packet_overhead = 4'd4 + 4'd1 - 4'd2;\n      endcase\n    end\n  end\n  else begin : len_calc_32\n    assign packet_fmt  = m_axis_rx_tdata[30:29];\n    assign packet_td   = m_axis_rx_tdata[15];\n    assign payload_len = packet_fmt[1] ? m_axis_rx_tdata[9:0] : 10'h0;\n\n    always @(*) begin\n      case({packet_fmt[0], packet_td})\n        2'b0_0: packet_overhead = 4'd3 + 4'd0 - 4'd1;\n        2'b0_1: packet_overhead = 4'd3 + 4'd1 - 4'd1;\n        2'b1_0: packet_overhead = 4'd4 + 4'd0 - 4'd1;\n        2'b1_1: packet_overhead = 4'd4 + 4'd1 - 4'd1;\n      endcase\n    end\n  end\nendgenerate\n\nassign new_pkt_len =\n         {{9{packet_overhead[3]}}, packet_overhead[2:0]} + {2'b0, payload_len};\n\n\nassign pkt_len_counter_dec = reg_pkt_len_counter - INTERFACE_WIDTH_DWORDS;\nassign pkt_done = (reg_pkt_len_counter <= INTERFACE_WIDTH_DWORDS);\n\nalways @(*) begin\n  case (cur_state)\n\n    IDLE: begin\n      if(m_axis_rx_tvalid && m_axis_rx_tready && !eof) begin\n        next_state = IN_PACKET;\n      end\n      else begin\n        next_state = IDLE;\n      end\n\n      pkt_len_counter = new_pkt_len;\n    end\n\n    IN_PACKET: begin\n      if((C_DATA_WIDTH == 128) && straddle_sof && m_axis_rx_tvalid) begin\n        pkt_len_counter = new_pkt_len;\n        next_state = IN_PACKET;\n      end\n\n      else if(m_axis_rx_tready && pkt_done)\n      begin\n        pkt_len_counter = new_pkt_len;\n        next_state      = IDLE;\n      end\n\n      else begin\n        if(m_axis_rx_tready) begin\n          pkt_len_counter = pkt_len_counter_dec;\n        end\n        else begin\n          pkt_len_counter = reg_pkt_len_counter;\n        end\n\n        next_state = IN_PACKET;\n      end\n    end\n\n    default: begin\n      pkt_len_counter = reg_pkt_len_counter;\n      next_state      = IDLE;\n    end\n  endcase\nend\n\n\nalways @(posedge user_clk) begin\n  if(user_rst) begin\n    cur_state           <= #TCQ IDLE;\n    reg_pkt_len_counter <= #TCQ 12'h0;\n  end\n  else begin\n    cur_state           <= #TCQ next_state;\n    reg_pkt_len_counter <= #TCQ pkt_len_counter;\n  end\nend\n\n\ngenerate\n  if(C_DATA_WIDTH == 128) begin : strb_calc_128\n    always @(*) begin\n      case(pkt_len_counter)\n        10'd1:   null_is_eof = 5'b10011;\n        10'd2:   null_is_eof = 5'b10111;\n        10'd3:   null_is_eof = 5'b11011;\n        10'd4:   null_is_eof = 5'b11111;\n        default: null_is_eof = 5'b00011;\n      endcase\n    end\n\n    assign eof_tkeep = {KEEP_WIDTH{1'b0}};\n  end\n  else if(C_DATA_WIDTH == 64) begin : strb_calc_64\n    always @(*) begin\n      case(pkt_len_counter)\n        10'd1:   null_is_eof = 5'b10011;\n        10'd2:   null_is_eof = 5'b10111;\n        default: null_is_eof = 5'b00011;\n      endcase\n    end\n\n    assign eof_tkeep = { ((pkt_len_counter == 12'd2) ? 4'hF:4'h0), 4'hF };\n  end\n  else begin : strb_calc_32\n    always @(*) begin\n      if(pkt_len_counter == 12'd1) begin\n        null_is_eof = 5'b10011;\n      end\n      else begin\n        null_is_eof = 5'b00011;\n      end\n    end\n\n    assign eof_tkeep = 4'hF;\n  end\nendgenerate\n\n\nassign null_rx_tvalid = 1'b1;\nassign null_rx_tlast  = (pkt_len_counter <= INTERFACE_WIDTH_DWORDS);\nassign null_rx_tkeep  = null_rx_tlast ? eof_tkeep : {KEEP_WIDTH{1'b1}};\nassign null_rdst_rdy  = null_rx_tlast;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplier_c396f73f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiplier (\n  input [n-1:0] A,\n  input [n-1:0] B,\n  input mode,\n  output reg [n-1:0] P\n);\n\nparameter n = 8; // number of bits in A and B\n\nreg [n-1:0] partial_product;\nreg [2*n-1:0] shifted_A;\nreg [n:0] extended_A, extended_B;\ninteger i;\n\nalways @(*) begin\n  if (mode == 0) begin // Unsigned multiplication\n    partial_product = 0;\n    for (i = 0; i < n; i = i + 1) begin\n      if (B[i]) begin\n        shifted_A = A << i;\n        partial_product = partial_product + shifted_A[n-1:0];\n      end\n    end\n  end else begin // Signed multiplication\n    partial_product = 0;\n    extended_A = {A[n-1], A};\n    extended_B = {B[n-1], B};\n    for (i = 0; i < n; i = i + 1) begin\n      case ({extended_B[i+1], extended_B[i]})\n        2'b01: partial_product <= partial_product - extended_A[n-1:0];\n        2'b10: partial_product <= partial_product + extended_A[n-1:0];\n        default: ; // do nothing\n      endcase\n      extended_A = extended_A << 1;\n    end\n  end\n  P <= partial_product;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "byte_reversal_03dca645", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule byte_reversal (\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nalways @(*) begin\n    out[7:0] = in[31:24];\n    out[15:8] = in[23:16];\n    out[23:16] = in[15:8];\n    out[31:24] = in[7:0];\nend\n\nendmodule\n\nmodule priority_encoder (\n    input [31:0] in,\n    output reg [4:0] pos // Position of the first high bit in the input\n);\n\nalways @(*) begin\n    case(in)\n        32'b00000000000000000000000000000000: pos = 5'b00000;\n        32'b00000000000000000000000000000001: pos = 5'b00001;\n        32'b00000000000000000000000000000011: pos = 5'b00010;\n        32'b00000000000000000000000000000111: pos = 5'b00011;\n        32'b00000000000000000000000000001111: pos = 5'b00100;\n        32'b00000000000000000000000000011111: pos = 5'b00101;\n        32'b00000000000000000000000000111111: pos = 5'b00110;\n        32'b00000000000000000000000001111111: pos = 5'b00111;\n        32'b00000000000000000000000011111111: pos = 5'b01000;\n        32'b00000000000000000000000111111111: pos = 5'b01001;\n        32'b00000000000000000000001111111111: pos = 5'b01010;\n        32'b00000000000000000000011111111111: pos = 5'b01011;\n        default: pos = 5'b01111;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_bcd_adder_570efa78", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ripple_bcd_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input select,\n    output [3:0] binary_sum,\n    output reg [3:0] BCD0,\n    output reg [3:0] BCD1\n);\n\nreg [3:0] sum;\nwire [7:0] bcd_sum;\n\n// Ripple carry adder\nassign binary_sum = A + B;\n\n// Binary to BCD converter\nbinary_to_bcd_converter bcd_converter(\n    .binary_in(binary_sum),\n    .bcd_out(bcd_sum)\n);\n\n// Output select\nalways @(*) begin\n    if (select) begin\n        BCD0 = bcd_sum[3:0];\n        BCD1 = bcd_sum[7:4];\n    end\n    else begin\n        BCD0 = 4'b0000;\n        BCD1 = 4'b0000;\n    end\nend\n\nendmodule\n\nmodule binary_to_bcd_converter (\n    input [3:0] binary_in,\n    output reg [7:0] bcd_out\n);\n\nalways @(*) begin\n    case (binary_in)\n        4'b0000: bcd_out = 8'b00000001;\n        4'b0001: bcd_out = 8'b00000010;\n        4'b0010: bcd_out = 8'b00000100;\n        4'b0011: bcd_out = 8'b00000110;\n        4'b0100: bcd_out = 8'b00001000;\n        4'b0101: bcd_out = 8'b00001010;\n        4'b0110: bcd_out = 8'b00001100;\n        4'b0111: bcd_out = 8'b00001110;\n        4'b1000: bcd_out = 8'b00010000;\n        4'b1001: bcd_out = 8'b00010001;\n        4'b1010: bcd_out = 8'b00010010;\n        4'b1011: bcd_out = 8'b00010011;\n        4'b1100: bcd_out = 8'b00010100;\n        4'b1101: bcd_out = 8'b00010101;\n        4'b1110: bcd_out = 8'b00010110;\n        4'b1111: bcd_out = 8'b00010111;\n        default: bcd_out = 8'b00000000;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axis_lfsr #_bfd810ed", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule axis_lfsr #\n(\n  parameter integer AXIS_TDATA_WIDTH = 64\n)\n(\n  input  wire                        aclk,\n  input  wire                        aresetn,\n\n  input  wire                        m_axis_tready,\n  output wire [AXIS_TDATA_WIDTH-1:0] m_axis_tdata,\n  output wire                        m_axis_tvalid\n);\n\n  reg [AXIS_TDATA_WIDTH-1:0] int_lfsr_reg, int_lfsr_next;\n  reg int_enbl_reg, int_enbl_next;\n\n  always @(posedge aclk)\n  begin\n    if(~aresetn)\n    begin\n      int_lfsr_reg <= 64'h5555555555555555;\n      int_enbl_reg <= 1'b0;\n    end\n    else\n    begin\n      int_lfsr_reg <= int_lfsr_next;\n      int_enbl_reg <= int_enbl_next;\n    end\n  end\n\n  always @*\n  begin\n    int_lfsr_next = int_lfsr_reg;\n    int_enbl_next = int_enbl_reg;\n\n    if(~int_enbl_reg)\n    begin\n      int_enbl_next = 1'b1;\n    end\n\n    if(int_enbl_reg & m_axis_tready)\n    begin\n      int_lfsr_next = {int_lfsr_reg[62:0], int_lfsr_reg[62] ~^ int_lfsr_reg[61]}; \n    end\n  end\n\n  assign m_axis_tdata = int_lfsr_reg;\n  assign m_axis_tvalid = int_enbl_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_f55b1ff9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_register (\n    input clk,\n    input load,\n    input [3:0] in,\n    output [3:0] out,\n    output [3:0] out_next\n);\n    \n    reg [3:0] stage1, stage2, stage3, stage4;\n    \n    always @(posedge clk) begin\n        if (load) begin\n            stage1 <= in;\n        end else begin\n            stage1 <= stage2;\n        end\n        \n        stage2 <= stage3;\n        stage3 <= stage4;\n        stage4 <= out_next;\n    end\n    \n    assign out = stage1;\n    assign out_next = stage2;\n    \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lights_switches_28ff8321", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule lights_switches (\n                         // inputs:\n                          address,\n                          clk,\n                          in_port,\n                          reset_n,\n\n                         // outputs:\n                          readdata\n                       )\n;\n\n  output  [ 31: 0] readdata;\n  input   [  1: 0] address;\n  input            clk;\n  input   [  7: 0] in_port;\n  input            reset_n;\n\n\n  wire             clk_en;\n  wire    [  7: 0] data_in;\n  wire    [  7: 0] read_mux_out;\n  reg     [ 31: 0] readdata;\n\n  assign clk_en = 1;\n\n  //s1, which is an e_avalon_slave\n  assign read_mux_out = {8 {(address == 0)}} & data_in;\n\n  always @(posedge clk or negedge reset_n)\n    begin\n      if (reset_n == 0)\n          readdata <= 0;\n      else if (clk_en)\n          readdata <= {32'b0 | read_mux_out};\n    end\n\n  assign data_in = in_port;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_gate_057684fe", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule xor_gate (\n    input A,\n    input B,\n    output X,\n    input VPWR,\n    input VGND\n);\n\n    wire not_A;\n    wire not_B;\n    wire A_and_not_B;\n    wire not_A_and_B;\n\n    not (not_A, A);\n    not (not_B, B);\n    and (A_and_not_B, A, not_B);\n    and (not_A_and_B, not_A, B);\n\n    or (X, A_and_not_B, not_A_and_B);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wait_generator_84228197", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule wait_generator(\n    input clk, nreset, WAIT,\n    output reg wait_random\n);\n\n    reg [8:0] wait_counter;\n\n    always @(posedge clk or negedge nreset) begin\n        if (!nreset) begin\n            wait_counter <= 9'b0;\n        end else begin\n            wait_counter <= wait_counter + 1'b1;\n        end\n    end\n\n    always @* begin\n        if (WAIT) begin\n            if (wait_counter[5:0] != 6'b0) begin\n                wait_random = 1'b1;\n            end else begin\n                wait_random = 1'b0;\n            end\n        end else begin\n            wait_random = 1'b0;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "EHRU_8_a2e623b2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule EHRU_8 (\n    CLK,\n    read_0,\n    write_0,\n    EN_write_0,\n    read_1,\n    write_1,\n    EN_write_1,\n    read_2,\n    write_2,\n    EN_write_2,\n    read_3,\n    write_3,\n    EN_write_3,\n    read_4,\n    write_4,\n    EN_write_4,\n    read_5,\n    write_5,\n    EN_write_5,\n    read_6,\n    write_6,\n    EN_write_6,\n    read_7,\n    write_7,\n    EN_write_7\n);\n    parameter            DATA_SZ = 1;\n    parameter            RESET_VAL = 0;\n\n    input                CLK;\n    output [DATA_SZ-1:0] read_0;\n    input  [DATA_SZ-1:0] write_0;\n    input                EN_write_0;\n    output [DATA_SZ-1:0] read_1;\n    input  [DATA_SZ-1:0] write_1;\n    input                EN_write_1;\n    output [DATA_SZ-1:0] read_2;\n    input  [DATA_SZ-1:0] write_2;\n    input                EN_write_2;\n    output [DATA_SZ-1:0] read_3;\n    input  [DATA_SZ-1:0] write_3;\n    input                EN_write_3;\n    output [DATA_SZ-1:0] read_4;\n    input  [DATA_SZ-1:0] write_4;\n    input                EN_write_4;\n    output [DATA_SZ-1:0] read_5;\n    input  [DATA_SZ-1:0] write_5;\n    input                EN_write_5;\n    output [DATA_SZ-1:0] read_6;\n    input  [DATA_SZ-1:0] write_6;\n    input                EN_write_6;\n    output [DATA_SZ-1:0] read_7;\n    input  [DATA_SZ-1:0] write_7;\n    input                EN_write_7;\n\n    reg    [DATA_SZ-1:0] r;\n    wire   [DATA_SZ-1:0] wire_0;\n    wire   [DATA_SZ-1:0] wire_1;\n    wire   [DATA_SZ-1:0] wire_2;\n    wire   [DATA_SZ-1:0] wire_3;\n    wire   [DATA_SZ-1:0] wire_4;\n    wire   [DATA_SZ-1:0] wire_5;\n    wire   [DATA_SZ-1:0] wire_6;\n    wire   [DATA_SZ-1:0] wire_7;\n    wire   [DATA_SZ-1:0] wire_8;\n\n    assign wire_0 = r;\n    assign wire_1 = EN_write_0 ? write_0 : wire_0;\n    assign wire_2 = EN_write_1 ? write_1 : wire_1;\n    assign wire_3 = EN_write_2 ? write_2 : wire_2;\n    assign wire_4 = EN_write_3 ? write_3 : wire_3;\n    assign wire_5 = EN_write_4 ? write_4 : wire_4;\n    assign wire_6 = EN_write_5 ? write_5 : wire_5;\n    assign wire_7 = EN_write_6 ? write_6 : wire_6;\n    assign wire_8 = EN_write_7 ? write_7 : wire_7;\n\n    assign read_0 = wire_0;\n    assign read_1 = wire_1;\n    assign read_2 = wire_2;\n    assign read_3 = wire_3;\n    assign read_4 = wire_4;\n    assign read_5 = wire_5;\n    assign read_6 = wire_6;\n    assign read_7 = wire_7;\n\n    always @(posedge CLK) begin\n        r <= wire_8;\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_d_ff_6531e61c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_register_d_ff (\n    input clk,\n    input d,\n    output [2:0] shift_register_out,\n    output q\n);\n\nreg [2:0] shift_register;\n\nassign shift_register_out = shift_register[2];\nassign q = shift_register[0];\n\nalways @(posedge clk) begin\n    shift_register <= {shift_register[1], shift_register[2], shift_register[0] ^ shift_register[2]};\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__275c0994", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input CLK,\n    input UP_DOWN,\n    input RESET,\n    input [3:0] gray,\n    output reg [3:0] OUT\n);\n\nwire [3:0] binary;\nwire [3:0] counter;\nwire [3:0] sum;\n\ngray_to_binary gray_to_binary_inst (\n    .gray(gray),\n    .binary(binary)\n);\n\nup_down_counter up_down_counter_inst (\n    .CLK(CLK),\n    .UP_DOWN(UP_DOWN),\n    .RESET(RESET),\n    .OUT(counter)\n);\n\nfunctional_module functional_module_inst (\n    .binary(binary),\n    .counter(counter),\n    .sum(sum)\n);\n\nalways @ (posedge CLK) begin\n    if (RESET) begin\n        OUT <= 4'b0000;\n    end else begin\n        if (UP_DOWN) begin\n            OUT <= OUT + 4'b0001;\n        end else begin\n            OUT <= OUT - 4'b0001;\n        end\n    end\nend\n\nendmodule\nmodule gray_to_binary (\n    input [3:0] gray,\n    output reg [3:0] binary\n);\n\nalways @* begin\n    binary[3] = gray[3];\n    binary[2] = binary[3] ^ gray[2];\n    binary[1] = binary[2] ^ gray[1];\n    binary[0] = binary[1] ^ gray[0];\nend\n\nendmodule\nmodule up_down_counter (\n    input CLK,\n    input UP_DOWN,\n    input RESET,\n    output reg [3:0] OUT\n);\n\nalways @ (posedge CLK) begin\n    if (RESET) begin\n        OUT <= 4'b0000;\n    end else begin\n        if (UP_DOWN) begin\n            OUT <= OUT + 4'b0001;\n        end else begin\n            OUT <= OUT - 4'b0001;\n        end\n    end\nend\n\nendmodule\nmodule functional_module (\n    input [3:0] binary,\n    input [3:0] counter,\n    output reg [3:0] sum\n);\n\nalways @* begin\n    sum = binary + counter;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ChooseModule_b0438985", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ChooseModule(\n    input  io_valid_0,\n    input  io_ready,\n    output io_chosen\n);\n\n  assign io_chosen = io_ready ? ~io_valid_0 : 1'b1; \n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "memory_64bit_4bank_ef14777c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule memory_64bit_4bank(\n    input clk,\n    input [63:0] din,\n    input wr_en,\n    input [1:0] wr_addr,\n    input rd_en,\n    input [1:0] rd_addr,\n    output [63:0] dout,\n    output full\n);\nreg [15:0] mem [0:1023];\nreg [63:0] dout_tmp;       // declare dout_tmp as a register\nassign full = 0; \n\nalways @(posedge clk) begin\n    if (wr_en) begin\n        case (wr_addr)\n            2'b00: begin\n                mem[wr_addr*4+3] <= din[15:0];\n                mem[wr_addr*4+2] <= din[31:16];\n                mem[wr_addr*4+1] <= din[47:32];\n                mem[wr_addr*4+0] <= din[63:48];\n            end\n            2'b01: begin\n                mem[wr_addr*4+3] <= din[15:0];\n                mem[wr_addr*4+2] <= din[31:16];\n                mem[wr_addr*4+1] <= din[47:32];\n                mem[wr_addr*4+0] <= din[63:48];\n            end\n            2'b10: begin\n                mem[wr_addr*4+3] <= din[15:0];\n                mem[wr_addr*4+2] <= din[31:16];\n                mem[wr_addr*4+1] <= din[47:32];\n                mem[wr_addr*4+0] <= din[63:48];\n            end\n            2'b11: begin\n                mem[wr_addr*4+3] <= din[15:0];\n                mem[wr_addr*4+2] <= din[31:16];\n                mem[wr_addr*4+1] <= din[47:32];\n                mem[wr_addr*4+0] <= din[63:48];\n            end\n        endcase\n    end\n    if (rd_en) begin\n        case (rd_addr)\n            2'b00: dout_tmp <= {mem[rd_addr*4+3], mem[rd_addr*4+2], mem[rd_addr*4+1], mem[rd_addr*4+0]};\n            2'b01: dout_tmp <= {mem[rd_addr*4+3], mem[rd_addr*4+2], mem[rd_addr*4+1], mem[rd_addr*4+0]};\n            2'b10: dout_tmp <= {mem[rd_addr*4+3], mem[rd_addr*4+2], mem[rd_addr*4+1], mem[rd_addr*4+0]};\n            2'b11: dout_tmp <= {mem[rd_addr*4+3], mem[rd_addr*4+2], mem[rd_addr*4+1], mem[rd_addr*4+0]};\n        endcase\n    end\nend\nassign dout = dout_tmp;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "twos_complement_267bcd4c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule twos_complement(clk, rst, in, out);\n    input clk, rst;\n    input [3:0] in;\n    output reg [7:0] out;\n    reg [3:0] in_reg;\n    reg valid;\n\n    always @(posedge clk, posedge rst) begin\n        if (rst) begin\n            in_reg <= 4'b0;\n            valid <= 0;\n            out <= 8'b0;\n        end\n        else begin\n            in_reg <= in;\n            if (in_reg == in && valid) begin\n                out <= $signed({6'b0, in_reg}) + 1'b1;\n            end\n            else begin\n                valid <= 1;\n            end\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FSM #_6342a00b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule FSM #(\n  parameter n = 4, // number of input signals\n  parameter m = 2 // number of output signals\n)(\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk\n);\n\n\nparameter s = 8; // number of states in the FSM\n\nreg [s-1:0] state;\nreg [m-1:0] output_reg;\n\nalways @ (posedge clk) begin\n  case(state)\n    3'b000: begin // state 0\n      if (in[0] && !in[1]) begin\n        state <= 3'b001;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b000;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b001: begin // state 1\n      if (in[0] && !in[1]) begin\n        state <= 3'b011;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b000;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b001;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b010: begin // state 2\n      if (in[0] && !in[1]) begin\n        state <= 3'b000;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b110;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b010;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b011: begin // state 3\n      if (in[0] && !in[1]) begin\n        state <= 3'b111;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b100;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b011;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b100: begin // state 4\n      if (in[0] && !in[1]) begin\n        state <= 3'b101;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b100;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b101: begin // state 5\n      if (in[0] && !in[1]) begin\n        state <= 3'b110;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b001;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b101;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b110: begin // state 6\n      if (in[0] && !in[1]) begin\n        state <= 3'b100;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b011;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b110;\n        output_reg <= 2'b00;\n      end\n    end\n    3'b111: begin // state 7\n      if (in[0] && !in[1]) begin\n        state <= 3'b010;\n        output_reg <= 2'b10;\n      end else if (!in[0] && in[1]) begin\n        state <= 3'b101;\n        output_reg <= 2'b01;\n      end else begin\n        state <= 3'b111;\n        output_reg <= 2'b00;\n      end\n    end\n  endcase\nend\n\nassign out = output_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_392d24d7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(output reg [7:0] result, input [7:0] num1, input [7:0] num2, input [2:0] op);\n\n    always @ (*)\n    begin\n        case (op)\n            3'b000: result = num1 + num2; // addition\n            3'b001: result = num1 - num2; // subtraction\n            3'b010: result = num1 * num2; // multiplication\n            3'b011: result = num1 / num2; // division\n            default: result = 8'b0; // default case\n        endcase\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__fd5b0328", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input areset,\n    input load,\n    input up_down,\n    input select,\n    output reg [4:0] counter4,\n    output reg [2:0] counter3,\n    output reg [5:0] sum\n);\n\nreg [4:0] counter4_next;\nreg [2:0] counter3_next;\n\nalways @(posedge clk or negedge areset) begin\n    if (areset == 0) begin\n        counter4 <= 0;\n        counter3 <= 0;\n    end else begin\n        if (load) begin\n            if (select) begin\n                counter4 <= counter4_next;\n            end else begin\n                counter3 <= counter3_next;\n            end\n        end else begin\n            if (up_down) begin\n                if (select) begin\n                    if (counter4 == 15) begin\n                        counter4_next <= 0;\n                    end else begin\n                        counter4_next <= counter4 + 1;\n                    end\n                end else begin\n                    if (counter3 == 7) begin\n                        counter3_next <= 0;\n                    end else begin\n                        counter3_next <= counter3 + 1;\n                    end\n                end\n            end else begin\n                if (select) begin\n                    if (counter4 == 0) begin\n                        counter4_next <= 15;\n                    end else begin\n                        counter4_next <= counter4 - 1;\n                    end\n                end else begin\n                    if (counter3 == 0) begin\n                        counter3_next <= 7;\n                    end else begin\n                        counter3_next <= counter3 - 1;\n                    end\n                end\n            end\n        end\n    end\nend\n\nalways @(counter4 or counter3) begin\n    sum = counter4 + counter3;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "control_2ffa5658", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule control (\n    input [5:0] op,\n    output [1:0] alu_op,\n    output regDst, aluSrc, memToReg, regWrite,\n    output memRead, memWrite, branch\n  );\n\nwire int0, op0_bar, op1_bar, op2_bar, op3_bar, op4_bar, op5_bar;\n\nnot (op0_bar, op[0]);\nnot (op1_bar, op[1]);\nnot (op2_bar, op[2]);\nnot (op3_bar, op[3]);\nnot (op4_bar, op[4]);\nnot (op5_bar, op[5]);\n\nand (alu_op[0], op5_bar, op4_bar, op3_bar, op[2]  , op1_bar, op0_bar); \nand (alu_op[1], op5_bar, op4_bar, op3_bar, op2_bar, op1_bar, op0_bar); \nand (regDst   , op5_bar, op4_bar, op3_bar, op2_bar, op1_bar, op0_bar); \nand (memToReg , op[5]  , op4_bar, op3_bar, op2_bar, op[1]  , op[0]  );\nand (memRead  , op[5]  , op4_bar, op3_bar, op2_bar, op[1]  , op[0]  ); \nand (memWrite , op[5]  , op4_bar, op[3]  , op2_bar, op[1]  , op[0]  ); \nand (branch   , op5_bar, op4_bar, op3_bar, op[2]  , op1_bar, op0_bar); \nand (int0     , op[5]  , op4_bar, op3_bar, op2_bar, op[1]  , op[0]  );\nand (aluSrc   , op[5]  , op4_bar, op2_bar, op[1]  , op[0] ); \nor  (regWrite , int0   , alu_op[1]);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rotator_bf4612d3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule rotator (\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nreg [99:0] shift_reg;\nreg [99:0] shifted_out;\nreg [1:0] rotate_mode;\n\nalways @(posedge clk) begin\n    if (load) begin\n        shift_reg <= data;\n    end else if (ena[0] == 1) begin\n        // Rotate right by one bit\n        shift_reg <= {shift_reg[0], shift_reg[99:1]};\n    end else if (ena[1] == 1) begin\n        // Rotate left by one bit\n        shift_reg <= {shift_reg[98:0], shift_reg[99]};\n    end else if (ena == 2'b11) begin\n        // Rotate right by two bits\n        shift_reg <= {shift_reg[0], shift_reg[99:2]};\n    end\nend\n\nassign q = shift_reg;\n\nendmodule\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nrotator rotator_inst (\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data(data),\n    .q(q)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "logic_unit_8242acfb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule logic_unit (\n    input a,\n    input b,\n    input c,\n    output x\n);\n\n    wire ab = a & b;\n    wire ac = a & c;\n    wire bc = b & c;\n    \n    assign x = ab | ac | bc;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "openhmc_ram #_f1123b09", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule openhmc_ram #(\n        parameter DATASIZE  = 78,   parameter ADDRSIZE  = 9,    parameter PIPELINED = 0     \n    ) (\n        input wire                  clk,\n\n        input wire                  wen,\n        input wire [DATASIZE-1:0]   wdata,\n        input wire [ADDRSIZE-1:0]   waddr,\n        input wire                  ren,\n        input wire [ADDRSIZE-1:0]   raddr,\n        output wire [DATASIZE-1:0]  rdata\n    );\n\nwire [DATASIZE-1:0] rdata_ram;\n\n    generate\n        if (PIPELINED == 0)\n        begin\n            assign rdata    = rdata_ram;\n        end\n        else\n        begin\n            reg [DATASIZE-1:0]  rdata_dly;\n            reg                 ren_dly;\n\n            assign rdata    = rdata_dly;\n\n            always @(posedge clk)\n            begin\n                ren_dly         <= ren;\n\n                if (ren_dly)\n                    rdata_dly   <= rdata_ram;\n            end\n        end\n    endgenerate\n\n    reg [DATASIZE-1:0]  MEM [0:(2**ADDRSIZE)-1];\n\n    reg [DATASIZE-1:0]  data_out;\n\n    assign rdata_ram = data_out;\n\n    always @(posedge clk)\n    begin\n        if (wen)\n            MEM[waddr]  <= wdata;\n    end\n\n    always @(posedge clk)\n    begin\n        if (ren)\n            data_out    <= MEM[raddr];\n    end\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder4 #_09ea1154", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule adder4 #(parameter WIDTH = 4)(\n    input [WIDTH-1:0] A,\n    input [WIDTH-1:0] B,\n    input Cin,\n    output [WIDTH-1:0] S,\n    output Cout\n);\n\n    wire [WIDTH:0] C;\n\n    assign C[0] = Cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < WIDTH; i = i + 1) begin : adder\n            full_adder FA(\n                .A(A[i]),\n                .B(B[i]),\n                .Cin(C[i]),\n                .S(S[i]),\n                .Cout(C[i+1])\n            );\n        end\n    endgenerate\n\n    assign Cout = C[WIDTH];\n\nendmodule\nmodule full_adder(\n    input A,\n    input B,\n    input Cin,\n    output S,\n    output Cout\n);\n\n    wire w1, w2, w3;\n\n    assign w1 = A ^ B;\n    assign w2 = A & B;\n    assign w3 = w1 & Cin;\n    assign S = w1 ^ Cin;\n    assign Cout = w2 | w3;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "queue_8x9_6b63bc90", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule queue_8x9(\n\tinput\t\tclk,\n\tinput\t\treset,\n\tinput\t\tnchar,\n\tinput\t\tlchar,\n\tinput\t[7:0]\tchar_i,\n\tinput\t\tstb_i,\n\toutput\t\tack_o,\n\toutput\t[8:0]\tdat_o,\n\toutput\t\tfull_o,\n\toutput\t\tempty_o,\n\n\toutput\t[7:0]\toccupied_tb,\toutput\t[2:0]\trp_tb,\n\toutput\t[2:0]\twp_tb,\n\toutput\t\twe_tb\n);\n\treg [8:0] queue[0:7];\n\treg [7:0] occupied;\treg [2:0] rp, wp;\treg oe_r;\n\n\tassign ack_o = oe_r;\n\tassign dat_o = queue[rp];\n\tassign full_o = occupied[wp];\n\tassign empty_o = ~occupied[rp];\n\n\twire is_eop = (char_i[1:0] == 2'b01) | (char_i[1:0] == 2'b10);\n\twire we = (nchar | (lchar & is_eop));\n\twire ptrs_eq = (wp == rp);\n\n\talways @(posedge clk) begin\n\t\toe_r <= oe_r;\n\n\t\tif(reset) begin\n\t\t\toe_r <= 0;\n\t\tend\n\t\telse if(stb_i) begin\n\t\t\toe_r <= 1;\n\t\tend\n\t\telse if(oe_r) begin\n\t\t\toe_r <= 0;\n\t\tend\n\tend\n\n\twire should_set_occupied_flag = (~ack_o & we & ~occupied[wp]);\n\twire read_write_concurrently = (ack_o & we & ptrs_eq);\n\twire should_store = should_set_occupied_flag | read_write_concurrently;\n\twire should_pop_queue = ack_o & occupied[rp];\n\n\talways @(posedge clk) begin\n\t\toccupied <= occupied;\n\t\trp <= rp;\n\t\twp <= wp;\n\n\t\tif(reset) begin\n\t\t\toccupied <= 8'h00;\n\t\t\trp <= 3'd0;\n\t\t\twp <= 3'd0;\n\t\tend\n\t\telse begin\n\t\t\tif(should_store) begin\n\t\t\t\tqueue[wp] <= {lchar, char_i};\n\t\t\t\twp <= wp + 1;\n\t\t\tend\n\t\t\tif(should_set_occupied_flag) begin\n\t\t\t\toccupied[wp] <= 1;\n\t\t\tend\n\t\t\tif(should_pop_queue) begin\n\t\t\t\tif(~read_write_concurrently) begin\n\t\t\t\t\toccupied[rp] <= 0;\n\t\t\t\tend\n\t\t\t\trp <= rp + 1;\n\t\t\tend\n\t\tend\n\tend\n\n\tassign occupied_tb = occupied;\n\tassign rp_tb = rp;\n\tassign wp_tb = wp;\n\tassign we_tb = we;\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bin2gray_4ad81465", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bin2gray(\n    input clk,\n    input [3:0] bin,\n    output reg [3:0] gray,\n    output reg valid\n);\n\n    reg [3:0] prev_gray;\n\n    always@(posedge clk) begin\n        // Set valid to 0 by default\n        valid <= 0;\n\n        // Calculate MSB of gray\n        gray[3] <= bin[3];\n\n        // Calculate remaining bits of gray\n        gray[2] <= bin[3] ^ bin[2];\n        gray[1] <= bin[2] ^ bin[1];\n        gray[0] <= bin[1] ^ bin[0];\n\n        // Check if gray has changed from previous cycle\n        if (gray != prev_gray) begin\n            valid <= 1;\n        end\n\n        // Store current gray as previous gray\n        prev_gray <= gray;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__ec196bf5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    input select,\n    output reg [7:0] sum,\n    output reg [7:0] min,\n    output [15:0] product\n);\n\n    wire [7:0] min_value;\n    wire [7:0] adder_sum;\n    \n    find_min min_module(\n        .a(a),\n        .b(b),\n        .c(8'h0),\n        .d(8'h0),\n        .min(min_value)\n    );\n    \n    adder adder_module(\n        .a(a),\n        .b(b),\n        .sum(adder_sum)\n    );\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            sum <= 8'h0;\n            min <= 8'h0;\n        end else begin\n            if (select) begin\n                sum <= adder_sum;\n                min <= min_value;\n            end else begin\n                sum <= min_value;\n                min <= adder_sum;\n            end\n        end\n    end\n    \n    assign product = {adder_sum, min_value};\n    \nendmodule\n\nmodule find_min (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output [7:0] min\n);\n    wire [7:0] ab_min;\n    wire [7:0] cd_min;\n    \n    assign ab_min = (a < b) ? a : b;\n    assign cd_min = (c < d) ? c : d;\n    \n    assign min = (ab_min < cd_min) ? ab_min : cd_min;\n    \nendmodule\n\nmodule adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_4to1_e26b1753", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_4to1 (\n    output reg Y,\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1\n);\n\nalways @(*) begin\n    case({S1, S0})\n        2'b00: Y = A;\n        2'b01: Y = B;\n        2'b10: Y = C;\n        2'b11: Y = D;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pixel_reader_71f69b56", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule pixel_reader (\n  input                     clk,\n  input                     rst,\n\n  input                     i_read_rdy,\n  output  reg               o_read_act,\n  input           [23:0]    i_read_size,\n  input           [24:0]    i_read_data,\n  output  reg               o_read_stb,\n\n  output  reg     [7:0]     o_red,\n  output  reg     [7:0]     o_green,\n  output  reg     [7:0]     o_blue,\n\n  output  reg               o_pixel_rdy,\n  input                     i_pixel_stb,\n\n  input                     i_tp_red,\n  input                     i_tp_blue,\n  input                     i_tp_green,\n\n  output  reg               o_last\n);\nreg               [7:0]     r_next_red;\nreg               [7:0]     r_next_green;\nreg               [7:0]     r_next_blue;\nreg               [31:0]    r_read_count;\nreg                         r_tp_green;\nreg                         r_tp_blue;\nalways @ (posedge clk) begin\n  o_read_stb                <=  0;\n  o_pixel_rdy               <=  0;\n  if (rst) begin\n    o_read_act              <=  0;\n\n    o_red                   <=  0;\n    o_green                 <=  0;\n    o_blue                  <=  0;\n\n    r_next_red              <=  0;\n    r_next_green            <=  0;\n    r_next_blue             <=  0;\n\n    o_last                  <=  0;\n  end\n  else begin\n\n    if (i_read_rdy && !o_read_act) begin\n      r_read_count              <=  0;\n      o_read_act                <=  1;\n    end\n\n    if (o_pixel_rdy) begin\n      if (i_pixel_stb) begin\n        o_pixel_rdy             <=  0;\n        o_red                   <=  i_read_data[23:16];\n        o_green                 <=  i_read_data[15:8];\n        o_blue                  <=  i_read_data[7:0];\n        o_last                  <=  i_read_data[24];\n      end\n    end\n\n    if (o_read_act) begin\n      o_pixel_rdy               <=  1;\n      if (r_read_count < i_read_size) begin\n        if (i_pixel_stb) begin\n          r_read_count          <=  r_read_count + 1;\n          o_read_stb            <=  1;\n        end\n      end\n      else begin\n        o_read_act              <=  0;\n      end\n    end\n  end\nend\n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__a221oi_b12c103e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__a221oi (\n    Y ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n\n    wire and0_out  ;\n    wire and1_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , B1, B2                );\n    and and1 (and1_out  , A1, A2                );\n    nor nor0 (nor0_out_Y, and0_out, C1, and1_out);\n    buf buf0 (Y         , nor0_out_Y            );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__and4_12d56e21", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__and4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, A, B, C, D     );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and__2f63068b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule and_module (\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule decoder_module (\n    input [1:0] sel,\n    output [3:0] out\n);\n    assign out = (sel == 2'b00) ? 4'b1110 :\n                  (sel == 2'b01) ? 4'b1101 :\n                  (sel == 2'b10) ? 4'b1011 :\n                  (sel == 2'b11) ? 4'b0111 : 4'b0000;\nendmodule\n\nmodule mux_module (\n    input [3:0] a,\n    input [3:0] b,\n    input A,\n    input B,\n    output out\n);\n    wire [3:0] and_out;\n    wire [3:0] decoder_out;\n    \n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .out(and_out)\n    );\n    \n    decoder_module decoder_inst (\n        .sel({A, B}),\n        .out(decoder_out)\n    );\n    \n    assign out = (decoder_out == 4'b1110) ? and_out[0] :\n                  (decoder_out == 4'b1101) ? and_out[1] :\n                  (decoder_out == 4'b1011) ? and_out[2] :\n                  (decoder_out == 4'b0111) ? and_out[3] : 1'b0;\nendmodule\n\nmodule top_module (\n    input [3:0] a,\n    input [3:0] b,\n    input A,\n    input B,\n    output out\n);\n    wire mux_out;\n    mux_module mux_inst (\n        .a(a),\n        .b(b),\n        .A(A),\n        .B(B),\n        .out(mux_out)\n    );\n    \n    assign out = ~mux_out;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ps2_mouse_datain_f6c70d10", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule ps2_mouse_datain (\n    input            clk,\n    input            reset,\n    input            wait_for_incoming_data,\n    input            start_receiving_data,\n    input            ps2_clk_posedge,\n    input            ps2_clk_negedge,\n    input            ps2_data,\n    output reg [7:0] received_data,\n    output reg       received_data_en );\n\n  localparam PS2_STATE_0_IDLE          = 3'h0,\n             PS2_STATE_1_WAIT_FOR_DATA = 3'h1,\n             PS2_STATE_2_DATA_IN       = 3'h2,\n             PS2_STATE_3_PARITY_IN     = 3'h3,\n             PS2_STATE_4_STOP_IN       = 3'h4;\n\n  reg [3:0] data_count;\n  reg [7:0] data_shift_reg;\n\n  reg [2:0] ns_ps2_receiver;\n  reg [2:0] s_ps2_receiver;\n\n  always @(posedge clk) begin\n    if (reset == 1'b1) s_ps2_receiver <= PS2_STATE_0_IDLE;\n    else               s_ps2_receiver <= ns_ps2_receiver;\n  end\n\n  always @(*) begin     ns_ps2_receiver = PS2_STATE_0_IDLE;\n\n    case (s_ps2_receiver)\n    PS2_STATE_0_IDLE:\n        begin\n            if((wait_for_incoming_data == 1'b1) && (received_data_en == 1'b0))\n                ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA;\n            else if ((start_receiving_data == 1'b1) && (received_data_en == 1'b0))\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n            else ns_ps2_receiver = PS2_STATE_0_IDLE;\n        end\n    PS2_STATE_1_WAIT_FOR_DATA:\n        begin\n            if((ps2_data == 1'b0) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n            else if (wait_for_incoming_data == 1'b0)\n                ns_ps2_receiver = PS2_STATE_0_IDLE;\n            else\n                ns_ps2_receiver = PS2_STATE_1_WAIT_FOR_DATA;\n        end\n    PS2_STATE_2_DATA_IN:\n        begin\n            if((data_count == 3'h7) && (ps2_clk_posedge == 1'b1))\n                ns_ps2_receiver = PS2_STATE_3_PARITY_IN;\n            else\n                ns_ps2_receiver = PS2_STATE_2_DATA_IN;\n        end\n    PS2_STATE_3_PARITY_IN:\n        begin\n            if (ps2_clk_posedge == 1'b1)\n                ns_ps2_receiver = PS2_STATE_4_STOP_IN;\n            else\n                ns_ps2_receiver = PS2_STATE_3_PARITY_IN;\n        end\n    PS2_STATE_4_STOP_IN:\n        begin\n            if (ps2_clk_posedge == 1'b1)\n                ns_ps2_receiver = PS2_STATE_0_IDLE;\n            else\n                ns_ps2_receiver = PS2_STATE_4_STOP_IN;\n        end\n    default:\n        begin\n            ns_ps2_receiver = PS2_STATE_0_IDLE;\n        end\n    endcase\n  end\n\n  always @(posedge clk) begin\n    if (reset == 1'b1)     data_count <= 3'h0;\n    else if((s_ps2_receiver == PS2_STATE_2_DATA_IN) && (ps2_clk_posedge == 1'b1))\n        data_count    <= data_count + 3'h1;\n    else if(s_ps2_receiver != PS2_STATE_2_DATA_IN)\n        data_count    <= 3'h0;\n  end\n\n  always @(posedge clk) begin\n    if(reset == 1'b1)     data_shift_reg <= 8'h00;\n    else if((s_ps2_receiver == PS2_STATE_2_DATA_IN) && (ps2_clk_posedge == 1'b1))\n        data_shift_reg    <= {ps2_data, data_shift_reg[7:1]};\n  end\n\n  always @(posedge clk) begin\n    if(reset == 1'b1) received_data <= 8'h00;\n    else if(s_ps2_receiver == PS2_STATE_4_STOP_IN)\n        received_data    <= data_shift_reg;\n  end\n\n  always @(posedge clk) begin\n    if(reset == 1'b1) received_data_en <= 1'b0;\n    else if((s_ps2_receiver == PS2_STATE_4_STOP_IN) && (ps2_clk_posedge == 1'b1))\n        received_data_en    <= 1'b1;\n    else\n        received_data_en    <= 1'b0;\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_subtractor_0285f351", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_subtractor(\n  input [3:0] A,\n  input [3:0] B,\n  input SUB,\n  output reg [3:0] S,\n  output reg OVF\n);\n\n  reg [3:0] B_neg;\n  reg C_in;\n  \n  always @ (A or B or SUB) begin\n    if (SUB == 1) begin\n      B_neg = ~B + 1;\n    end else begin\n      B_neg = B;\n    end\n  end\n  \n  always @ (A or B or SUB) begin\n    C_in = SUB & (A < B_neg);\n  end\n  \n  always @ (A or B or SUB) begin\n    if (SUB == 1) begin\n      S = A - B_neg;\n    end else begin\n      S = A + B;\n    end\n  end\n  \n  always @ (A or B or SUB) begin\n    OVF = C_in ^ (S[3] ^ A[3]);\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_carry_adder_1aeb436b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ripple_carry_adder (\n    input wire [3:0] a, b,\n    output wire [3:0] sum,\n    output wire cout,\n    output wire overflow\n);\n\n    wire [4:0] c;\n    assign c[0] = 1'b0;\n\n    genvar i;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : adder\n            full_adder fa(\n                .a(a[i]),\n                .b(b[i]),\n                .cin(c[i]),\n                .sum(sum[i]),\n                .cout(c[i+1])\n            );\n        end\n    endgenerate\n\n    assign cout = c[4];\n    assign overflow = (a[3] & b[3] & ~sum[3]) | (~a[3] & ~b[3] & sum[3]);\n\nendmodule\n\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule\n\nmodule greater_than_9 (\n    input wire [3:0] sum,\n    output wire greater_than_9\n);\n\n    assign greater_than_9 = (sum > 4'b1001);\n\nendmodule\n\nmodule top_module (\n    input wire [3:0] a, b,\n    output wire [3:0] sum,\n    output wire cout,\n    output wire overflow,\n    output wire greater_than_9\n);\n\n    ripple_carry_adder rca(\n        .a(a),\n        .b(b),\n        .sum(sum),\n        .cout(cout),\n        .overflow(overflow)\n    );\n\n    greater_than_9 gto9(\n        .sum(sum),\n        .greater_than_9(greater_than_9)\n    );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_6b3d8218", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n    input clk,\n    input rst,\n    input [3:0] shift_in,\n    output reg [3:0] shift_out\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        shift_out <= 4'b0000;\n    end else begin\n        shift_out <= {shift_out[2:0], shift_in};\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DataMemory_7fda27e8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule DataMemory(\n    output reg [31:0] ReadData,\n\t output reg [31:0] DATO1,\n\t output reg [31:0] DATO2,\n\t output reg [31:0] RESULTADO,\n    input [31:0] Address,\n    input [31:0] WriteData,\n\t input [31:0] MouseData,\n\t input MouseEnable,\n    input WriteEnable,\n    input CLK\n    );\n\n\treg [31:0] block [0:9];\n\n\talways @ (*) begin\n\t\tDATO1 = block[4];\n\t\tDATO2 = block[5];\n\t\tRESULTADO = block[7];\n\t\tif (CLK) begin\n\t\t\tcase (Address)\n\t\t\t\t32'h00000000: ReadData = block[0];\n\t\t\t\t32'h00000004: ReadData = block[1];\n\t\t\t\t32'h00000008: ReadData = block[2];\n\t\t\t\t32'h0000000c: ReadData = block[3];\n\t\t\t\t32'h00000010: ReadData = block[4];\n\t\t\t\t32'h00000014: ReadData = block[5];\n\t\t\t\t32'h00000018: ReadData = block[6];\n\t\t\t\t32'h0000001c: ReadData = block[7];\n\t\t\t\t32'h00000020: ReadData = block[8];\n\t\t\t\t32'h00000024: ReadData = block[9];\n\t\t\t\tdefault: ReadData = 32'b0;\n\t\t\tendcase\n\t\tend\n\t\telse begin\n\t\t\tif (MouseEnable) begin\n\t\t\t\tblock[1] = MouseData;\n\t\t\tend\n\t\t\tif (WriteEnable)\n\t\t\t\tcase (Address)\n\t\t\t\t\t32'h00000000: block[0] = WriteData;\n\t\t\t\t\t32'h00000004: block[1] = WriteData;\n\t\t\t\t\t32'h00000008: block[2] = WriteData;\n\t\t\t\t\t32'h0000000c: block[3] = WriteData;\n\t\t\t\t\t32'h00000010: block[4] = WriteData;\n\t\t\t\t\t32'h00000014: block[5] = WriteData;\n\t\t\t\t\t32'h00000018: block[6] = WriteData;\n\t\t\t\t\t32'h0000001c: block[7] = WriteData;\n\t\t\t\t\t32'h00000020: block[8] = WriteData;\n\t\t\t\t\t32'h00000024: block[9] = WriteData;\n\t\t\t\tendcase\n\t\tend\n\tend\n\t\n\tinteger i = 0;\n\tinitial begin \n\t\tfor (i=0;i<10;i=i+1)\n\t\t\tblock[i] = 32'b0;\n\t\tblock[1] = 2;\n\t\tblock[4] = 2;\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "key_Processor_f05ae95e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule key_Processor(\n    input select,\n    input [63:0] key,\n    output [28:1] lefto,\n    output [28:1] righto\n);\n\nreg [63:0] temp;\n\nalways @ (select or key) begin\n    // Perform permutation if select is 1, else pass input key as is\n    temp = (select == 1) ? { key[58:57], key[50:49], key[42:41], key[34:33], key[26:25], key[18:17], key[10:9], key[2:1] } : key;\nend\n\n// Split the key into left and right halves\nassign lefto = temp[63:36];\nassign righto = temp[35:2];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spm_16a8f043", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule spm(clk, rst, x, y, ld, p);\n    parameter size = 32;\n    input clk, rst;\n    input y;\n    input[size-1:0] x;\n    input ld;\n    output p;\n\n    wire[size-1:1] pp;\n    wire[size-1:0] xy;\n\n    genvar i;\n\n    CSADD csa0 (.clk(clk), .rst(rst), .x(x[0]&y), .y(pp[1]), .ld(ld), .sum(p));\n    generate for(i=1; i<size-1; i=i+1) begin\n        CSADD csa (.clk(clk), .rst(rst), .x(x[i]&y), .y(pp[i+1]), .ld(ld), .sum(pp[i]));\n    end endgenerate\n    TCMP tcmp (.clk(clk), .rst(rst), .a(x[size-1]&y), .ld(ld), .s(pp[size-1]));\n\nendmodule\n\nmodule TCMP(clk, rst, a, ld, s);\n    input clk, rst;\n    input a;\n    input ld;\n    output reg s;\n    \n    reg z;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            //Reset logic goes here.\n            s <= 1'b0;\n            z <= 1'b0;\n        end\n        else  if (ld) begin              // idle state reset before each input word\n            s  <= 1'b0;\n            z  <= 1'b0;\n        end\n        else begin\n            //Sequential logic goes here.\n            z <= a | z;\n            s <= a ^ z;\n        end\n    end\nendmodule\n\nmodule CSADD(clk, rst, x, y, ld, sum);\n    input clk, rst;\n    input x, y;\n    input ld;\n    output reg sum;\n\n    reg sc;\n\n    // Half Adders logic\n    wire hsum1, hco1;\n    assign hsum1 = y ^ sc;\n    assign hco1 = y & sc;\n\n    wire hsum2, hco2;\n    assign hsum2 = x ^ hsum1;\n    assign hco2 = x & hsum1;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            //Reset logic goes here.\n            sum <= 1'b0;\n            sc <= 1'b0;\n        end\n        else if (ld) begin\n             sum <= 1'b0;\n             sc  <= 1'b0;\n        end\n        else begin\n            //Sequential logic goes here.\n            sum <= hsum2;\n            sc <= hco1 ^ hco2;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "random_gen_e2e84ec9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule random_gen (\n   input clk,      // clock signal\n   input nreset,   // asynchronous reset\n   input WAIT,     // enable signal\n   output reg ready_random // random signal\n   );\n\n   // Generate a random signal when WAIT is asserted\n   reg [8:0] ready_counter;  // Declare the counter register\n\n   // Counter increments on every clock edge\n   always @ (posedge clk or negedge nreset) begin\n      if (!nreset) begin\n         ready_counter <= 9'b0;   // Reset the counter on reset\n      end else begin\n         if (WAIT) begin\n            ready_counter <= ready_counter + 1'b1;  // Increment the counter if WAIT is asserted\n         end\n      end\n   end\n\n   // Generate the random signal based on the counter value\n   always @(*) begin\n      ready_random = ready_counter[5] ^ ready_counter[4];\n   end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_c767656e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder (\n    input [3:0] in,\n    output [15:0] out\n);\n\nassign out = ~(1 << in);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__cddf7b5e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_module (\n    input A1,\n    input A2,\n    input B1,\n    input B2,\n    output X\n);\n\n    wire and1_out;\n    wire and2_out;\n    wire not1_out;\n\n    and and1 (and1_out, A1, A2);\n    and and2 (and2_out, B1, B2);\n    not not1 (not1_out, and2_out);\n\n    assign X = and1_out & not1_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dat_i_arbiter_276b5301", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule dat_i_arbiter(\n\t\tinput wire clock_i,\n\n\t\toutput wire [7:0] D,\n\t\t\n\t\tinput [7:0] l_rom,\n\t\tinput l_rom_e,\n\t\t\n\t\tinput [7:0] u_rom,\n\t\tinput u_rom_e,\n\n\t\tinput [7:0] ram,\n\t\tinput ram_e,\n\n\t\tinput [7:0] eram,\n\t\tinput u_ram_e,\n\t\t\n\t\tinput [7:0] pio8255,\n\t\tinput pio8255_e,\n\t\t\n\t\tinput [7:0] io,\n\t\tinput io_e,\n\t\t\n\t\tinput [7:0] fdc,\n\t\tinput fdc_e\n\t);\n\n\tassign D =\t(l_rom_e) ? l_rom :\n\t\t\t\t\t(u_rom_e) ? u_rom :\n\t\t\t\t\t(u_ram_e) ? eram :\n\t\t\t\t\t(ram_e) ? ram :\n\t\t\t\t\t(pio8255_e) ? pio8255 :\n\t\t\t\t\t(io_e) ? io :\n\t\t\t\t\t(fdc_e) ? fdc :\n\t\t\t\t\t8'd255;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "m_4to1_2bit_mux_93ad9d06", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule m_4to1_2bit_mux (w_bus_mux_out, w_bus_mux_in_0, w_bus_mux_in_1, w_bus_mux_in_2, w_bus_mux_in_3, w_channel);\n\toutput [1:0] w_bus_mux_out;\n\tinput [1:0] w_bus_mux_in_0, w_bus_mux_in_1, w_bus_mux_in_2, w_bus_mux_in_3;\n\tinput [1:0] w_channel;\n\n\tassign w_bus_mux_out = (w_channel == 2'b00) ? w_bus_mux_in_0 :\n\t                       (w_channel == 2'b01) ? w_bus_mux_in_1 :\n\t                       (w_channel == 2'b10) ? w_bus_mux_in_2 :\n\t                                             w_bus_mux_in_3;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_4bit_b2a71183", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shifter_4bit (\n    input clk, // Correctly included clock input in the module's port list\n    input [3:0] A,\n    input load,\n    input reset,\n    input [1:0] shift,\n    input shift_dir, // 0 for left shift, 1 for right shift\n    output reg [3:0] Q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        Q <= 4'b0; // Reset the output Q to 0\n    end else if (load) begin\n        Q <= A; // Load the input A into Q\n    end else begin\n        case (shift)\n            2'b00: Q <= Q; // No shift\n            2'b01: begin\n                // Shift once, direction based on shift_dir\n                if (shift_dir) begin\n                    // Right shift\n                    Q <= {1'b0, Q[3:1]};\n                end else begin\n                    // Left shift\n                    Q <= {Q[2:0], 1'b0};\n                end\n            end\n            2'b10: begin\n                // Shift twice, direction based on shift_dir\n                if (shift_dir) begin\n                    // Right shift\n                    Q <= {2'b00, Q[3:2]};\n                end else begin\n                    // Left shift\n                    Q <= {Q[1:0], 2'b00};\n                end\n            end\n            2'b11: begin\n                if (shift_dir) begin\n                    // Right rotate\n                    Q <= {Q[0], Q[3:1]};\n                end else begin\n                    // Left rotate\n                    Q <= {Q[2:0], Q[3]};\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "emesh_if_fb96e861", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule emesh_if (\n   // Outputs\n   cmesh_ready_out, cmesh_access_out, cmesh_packet_out,\n   rmesh_ready_out, rmesh_access_out, rmesh_packet_out,\n   xmesh_ready_out, xmesh_access_out, xmesh_packet_out,\n   emesh_ready_out, emesh_access_out, emesh_packet_out,\n   // Inputs\n   cmesh_access_in, cmesh_packet_in, cmesh_ready_in, rmesh_access_in,\n   rmesh_packet_in, rmesh_ready_in, xmesh_access_in, xmesh_packet_in,\n   xmesh_ready_in, emesh_access_in, emesh_packet_in, emesh_ready_in\n   );\n\n   parameter AW   = 32;   \n   parameter PW   = 2*AW+40; \n\n   //##Cmesh##    \n   input \t   cmesh_access_in;\n   input [PW-1:0]  cmesh_packet_in;\n   output \t   cmesh_ready_out;\n   output \t   cmesh_access_out;\n   output [PW-1:0] cmesh_packet_out;\n   input \t   cmesh_ready_in;\n      \n   //##Rmesh## \n   input \t   rmesh_access_in;\n   input [PW-1:0]  rmesh_packet_in;\n   output \t   rmesh_ready_out;\n   output \t   rmesh_access_out;\n   output [PW-1:0] rmesh_packet_out;\n   input \t   rmesh_ready_in;\n   \n   //##Xmesh## \n   input \t   xmesh_access_in;\n   input [PW-1:0]  xmesh_packet_in;\n   output \t   xmesh_ready_out;  \n   output \t   xmesh_access_out;\n   output [PW-1:0] xmesh_packet_out;\n   input \t   xmesh_ready_in;\n   \n   //##Emesh##\n   input \t   emesh_access_in;\n   input [PW-1:0]  emesh_packet_in;\n   output \t   emesh_ready_out;\n   output \t   emesh_access_out;\n   output [PW-1:0] emesh_packet_out;\n   input \t   emesh_ready_in;\n      \n   //#####################################################\n   //# EMESH-->(RMESH/XMESH/CMESH)\n   //#####################################################\n      \n   assign cmesh_access_out = emesh_access_in & emesh_packet_in[0];\n\n   assign rmesh_access_out = emesh_access_in & ~emesh_packet_in[0];\n\n   //Don't drive on xmesh for now\n   assign xmesh_access_out = 1'b0;\n      \n   //Distribute emesh to xmesh,cmesh, rmesh\n   assign cmesh_packet_out = emesh_packet_in;\t \n   assign rmesh_packet_out = emesh_packet_in;\t \n   assign xmesh_packet_out = emesh_packet_in;\n\n   assign emesh_ready_out = cmesh_ready_in &\n\t\t\t    rmesh_ready_in &\n\t\t\t    xmesh_ready_in;\n  \t \t \n   //#####################################################\n   //# (RMESH/XMESH/CMESH)-->EMESH\n   //#####################################################\n\n   assign emesh_access_out = cmesh_access_in &\n\t\t\t     rmesh_access_in &\n\t\t\t     xmesh_access_in;\n   \n   //Choose the module to send packet to in a round-robin fashion\n   reg [1:0] round_robin;\n   always @(posedge emesh_ready_in) begin\n      if (cmesh_access_in) round_robin <= 2'b01;\n      else if (rmesh_access_in) round_robin <= 2'b10;\n      else if (xmesh_access_in) round_robin <= 2'b00;\n   end\n   \n   wire [PW-1:0] sel_packet;\n   assign sel_packet = (round_robin == 2'b01) ? cmesh_packet_in :\n                                     ((round_robin == 2'b10) ? rmesh_packet_in : xmesh_packet_in);\n   \n   assign cmesh_ready_out = ~(cmesh_access_in & ~emesh_ready_in);\n   \n   assign rmesh_ready_out = ~(rmesh_access_in & \n\t\t\t    (~emesh_ready_in | ~cmesh_ready_in));\n\n   assign xmesh_ready_out = ~(xmesh_access_in & \n\t\t\t      (~emesh_ready_in | ~cmesh_access_in | ~rmesh_access_in));\n   \n   assign emesh_packet_out = sel_packet;\n\t\t\t\t     \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_xfer_cntrl_a7b86a45", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule up_xfer_cntrl (\n\n  up_rstn,\n  up_clk,\n  up_data_cntrl,\n  up_xfer_done,\n\n  d_rst,\n  d_clk,\n  d_data_cntrl);\n\n  parameter     DATA_WIDTH = 8;\n  localparam    DW = DATA_WIDTH - 1;\n\n  input           up_rstn;\n  input           up_clk;\n  input   [DW:0]  up_data_cntrl;\n  output          up_xfer_done;\n\n  input           d_rst;\n  input           d_clk;\n  output  [DW:0]  d_data_cntrl;\n\n  reg             up_xfer_state_m1 = 'd0;\n  reg             up_xfer_state_m2 = 'd0;\n  reg             up_xfer_state = 'd0;\n  reg     [ 5:0]  up_xfer_count = 'd0;\n  reg             up_xfer_done = 'd0;\n  reg             up_xfer_toggle = 'd0;\n  reg     [DW:0]  up_xfer_data = 'd0;\n  reg             d_xfer_toggle_m1 = 'd0;\n  reg             d_xfer_toggle_m2 = 'd0;\n  reg             d_xfer_toggle_m3 = 'd0;\n  reg             d_xfer_toggle = 'd0;\n  reg     [DW:0]  d_data_cntrl = 'd0;\n\n  wire            up_xfer_enable_s;\n  wire            d_xfer_toggle_s;\n\n  assign up_xfer_enable_s = up_xfer_state ^ up_xfer_toggle;\n\n  always @(negedge up_rstn or posedge up_clk) begin\n    if (up_rstn == 1'b0) begin\n      up_xfer_state_m1 <= 'd0;\n      up_xfer_state_m2 <= 'd0;\n      up_xfer_state <= 'd0;\n      up_xfer_count <= 'd0;\n      up_xfer_done <= 'd0;\n      up_xfer_toggle <= 'd0;\n      up_xfer_data <= 'd0;\n    end else begin\n      up_xfer_state_m1 <= d_xfer_toggle;\n      up_xfer_state_m2 <= up_xfer_state_m1;\n      up_xfer_state <= up_xfer_state_m2;\n      up_xfer_count <= up_xfer_count + 1'd1;\n      up_xfer_done <= (up_xfer_count == 6'd1) ? ~up_xfer_enable_s : 1'b0;\n      if ((up_xfer_count == 6'd1) && (up_xfer_enable_s == 1'b0)) begin\n        up_xfer_toggle <= ~up_xfer_toggle;\n        up_xfer_data <= up_data_cntrl;\n      end\n    end\n  end\n\n  assign d_xfer_toggle_s = d_xfer_toggle_m3 ^ d_xfer_toggle_m2;\n\n  always @(posedge d_clk or posedge d_rst) begin\n    if (d_rst == 1'b1) begin\n      d_xfer_toggle_m1 <= 'd0;\n      d_xfer_toggle_m2 <= 'd0;\n      d_xfer_toggle_m3 <= 'd0;\n      d_xfer_toggle <= 'd0;\n      d_data_cntrl <= 'd0;\n    end else begin\n      d_xfer_toggle_m1 <= up_xfer_toggle;\n      d_xfer_toggle_m2 <= d_xfer_toggle_m1;\n      d_xfer_toggle_m3 <= d_xfer_toggle_m2;\n      d_xfer_toggle <= d_xfer_toggle_m3;\n      if (d_xfer_toggle_s == 1'b1) begin\n        d_data_cntrl <= up_xfer_data;\n      end\n    end\n  end\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_ff_72753969", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux_ff(\n    input clk,\n    input [3:0] in,\n    input [1:0] sel,\n    output reg q\n);\n\n    reg selected_signal;\n\n    // Register initialization\n    initial begin\n        q <= 0;\n    end\n\n    always @(*) begin\n        case (sel)\n            2'b00: selected_signal = in[0];\n            2'b01: selected_signal = in[1];\n            2'b10: selected_signal = in[2];\n            2'b11: selected_signal = in[3];\n        endcase\n    end\n\n    always @(posedge clk) begin\n        q <= selected_signal;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_c0d1f613", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_counter (\n  input clk,\n  input rst,\n  output reg [2:0] count\n);\n\n  // Define the states\n  parameter IDLE = 2'b00;\n  parameter COUNTING = 2'b01;\n  parameter RESET = 2'b10;\n\n  // Define the current state and next state variables\n  reg [1:0] current_state, next_state;\n\n  // Define the counter variable\n  reg [2:0] counter;\n\n  // Assign the initial state to idle and the counter to 0\n  initial begin\n    current_state = IDLE;\n    counter = 3'b000;\n  end\n\n  // Define the state machine\n  always @ (posedge clk) begin\n    // Set the next state based on the current state and inputs\n    case (current_state)\n      IDLE: begin\n        if (rst) begin\n          next_state = RESET;\n        end else begin\n          next_state = COUNTING;\n        end\n      end\n      COUNTING: begin\n        if (counter == 3'b111) begin\n          next_state = IDLE;\n        end else begin\n          next_state = COUNTING;\n        end\n      end\n      RESET: begin\n        next_state = IDLE;\n      end\n    endcase\n\n    // Set the current state to the next state\n    current_state <= next_state;\n\n    // Update the counter based on the current state\n    case (current_state)\n      COUNTING: begin\n        count <= count + 1;\n      end\n      RESET: begin\n        count <= 3'b000;\n      end\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "synchronizer_be8cb949", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule synchronizer (\n  input async_in,\n  input clk_in,\n  output reg sync_out\n);\n\n  reg async_sync;\n  reg async_sync_prev;\n  \n  always @(posedge clk_in) begin\n    async_sync_prev <= async_sync;\n    async_sync <= async_in;\n  end\n  \n  always @(posedge clk_in) begin\n    if (clk_in) begin\n      sync_out <= async_sync;\n    end else begin\n      sync_out <= async_sync_prev;\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__f7245901", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-high reset\n    input [7:0] data_in,    // 8-bit input data\n    input [2:0] sel,        // 3-bit select input for choosing operation\n    output wire [3:0] q          // 4-bit final output\n);\n\n    // Declare internal wires for intermediate values\n    wire [3:0] q_shifted;      // Result of barrel shift operation\n    wire [3:0] q_decoded;      // Result of decoder with enable operation\n\n    // Barrel shift module\n    // Shift amount is determined by sel[2] and sel[1:0]\n    // (1, 2, or no shift)\n    wire [2:0] shift_amount = {sel[2], sel[1:0]}; // Added braces for clarity\n\n    // Barrel Shifter module `bs`\n    // Connect the wires to the module ports\n    barrel_shifter bs (\n        .clk(clk),\n        .reset(reset),\n        .data_in(data_in),\n        .shift_sel(sel[2:1]), // sel[2:1] is used for shift_sel\n        .shift_amt(shift_amount),\n        .shift_out(q_shifted)\n    );\n\n    // Decoder with enable module\n    // Enable is determined by sel[2], and data_in is the decoded value\n    decoder_with_enable dwen (\n        .data_in(data_in),\n        .enable(sel[2]),\n        .decode_out(q_decoded)\n    );\n\n    // Bitwise OR module\n    // `a` is the result of the barrel shift operation(`q_shifted`),\n    // and `b` is the result of the decoder with enable operation(`q_decoded`)\n    bitwise_or bo (\n        .a(q_shifted),\n        .b(q_decoded),\n        .or_out(q)\n    );\n\nendmodule\n\nmodule barrel_shifter (\n    input clk,              // Clock input\n    input reset,            // Synchronous active-high reset\n    input [7:0] data_in,    // 8-bit input data\n    input [1:0] shift_sel,  // 2-bit select input for choosing shift direction\n    input [2:0] shift_amt,  // 3-bit select input for choosing shift amount\n    output reg [3:0] shift_out  // 4-bit shifted output\n);\n\n    reg [7:0] shift_reg;    // Shift register\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 8'b0;\n        end else begin\n            case (shift_sel)\n                2'b00: shift_reg <= shift_reg; // No shift\n                2'b01: shift_reg <= {shift_reg[6:0], 1'b0}; // Shift left by 1\n                2'b10: shift_reg <= {1'b0, shift_reg[7:1]}; // Shift right by 1\n                2'b11: begin // Shift right by 2\n                    shift_reg <= {2'b00, shift_reg[7:2]};\n                end\n            endcase\n\n            case (shift_amt)\n                3'b000: shift_out <= shift_reg[3:0]; // No shift\n                3'b001: shift_out <= shift_reg[4:1]; // Shift left by 1\n                3'b010: shift_out <= shift_reg[5:2]; // Shift right by 1\n                3'b011: shift_out <= shift_reg[6:3]; // Shift right by 2\n                default: shift_out <= 4'bxxxx; // Invalid shift amount\n            endcase\n        end\n    end\n\nendmodule\n\nmodule decoder_with_enable (\n    input [7:0] data_in,    // 8-bit input data\n    input enable,            // Enable input\n    output reg [3:0] decode_out  // 4-bit decoded output\n);\n\n    always @(data_in, enable) begin\n        if (enable) begin\n            case (data_in[7:6])\n                2'b00: decode_out <= 4'b0000;\n                2'b01: decode_out <= 4'b0001;\n                2'b10: decode_out <= 4'b0010;\n                2'b11: decode_out <= 4'b0011;\n            endcase\n        end else begin\n            case (data_in[5:4])\n                2'b00: decode_out <= 4'b0100;\n                2'b01: decode_out <= 4'b0101;\n                2'b10: decode_out <= 4'b0110;\n                2'b11: decode_out <= 4'b0111;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule bitwise_or (\n    input [3:0] a,          // 4-bit input a\n    input [3:0] b,          // 4-bit input b\n    output wire [3:0] or_out // 4-bit bitwise OR output\n);\n\n    assign or_out = a | b;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipeline_registers #_eee5f41e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule pipeline_registers #(\n  parameter n = 4, // number of input signals\n  parameter m = 2, // number of output signals\n  parameter s = 3 // number of pipeline stages\n)(\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk  // Clock signal\n);\n\n\nreg [n-1:0] stage1_reg;\nreg [n-1:0] stage2_reg;\nreg [n-1:0] stage3_reg;\n\nalways @ (posedge clk) begin\n  stage1_reg <= in;\n  stage2_reg <= stage1_reg;\n  stage3_reg <= stage2_reg;\nend\n\n\nassign out = stage3_reg;\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_18cefc2a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output Cout\n);\n\n    wire [3:0] C;\n\n    assign S = A + B;\n    assign C = (A + B) > 4'b1111;\n\n    assign Cout = C[3];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_4to1_and_084253a8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux_4to1_and(input [3:0] a, b, c, d, input [1:0] sel, output [3:0] y);\n  wire [3:0] mux1_out, mux2_out;\n\n  // First 2-to-1 MUX\n  mux2to1 mux1(.a(a), .b(b), .sel(sel[0]), .y(mux1_out));\n  \n  // Second 2-to-1 MUX\n  mux2to1 mux2(.a(c), .b(d), .sel(sel[0]), .y(mux2_out));\n  \n  // Final 2-to-1 MUX\n  mux2to1 mux3(.a(mux1_out), .b(mux2_out), .sel(sel[1]), .y(y));\n  \n  // Bitwise AND gate\n  // assign y = y & 4'b1010;\nendmodule\nmodule mux2to1(input [3:0] a, b, input sel, output [3:0] y);\n  assign y = sel ? b : a;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fsm_using_always_013454dd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fsm_using_always (\nclock      , reset      , req_0      , req_1      , gnt_0      , gnt_1      \n);\ninput   clock,reset,req_0,req_1;\n output  gnt_0,gnt_1;\nwire    clock,reset,req_0,req_1;\nreg     gnt_0,gnt_1;\nparameter SIZE = 3           ;\nparameter IDLE  = 3'b001,GNT0 = 3'b010,GNT1 = 3'b100 ;\nreg   [SIZE-1:0]          state        ;reg   [SIZE-1:0]          next_state   ;always @ (state or req_0 or req_1)\nbegin : FSM_COMBO\n next_state = 3'b000;\n case(state)\n   IDLE : if (req_0 == 1'b1) begin\n                next_state = GNT0;\n              end else if (req_1 == 1'b1) begin\n                next_state= GNT1;\n              end else begin\n                next_state = IDLE;\n              end\n   GNT0 : if (req_0 == 1'b1) begin\n                next_state = GNT0;\n              end else begin\n                next_state = IDLE;\n              end\n   GNT1 : if (req_1 == 1'b1) begin\n                next_state = GNT1;\n              end else begin\n                next_state = IDLE;\n              end\n   default : next_state = IDLE;\n  endcase\nend\nalways @ (posedge clock)\nbegin : FSM_SEQ\n  if (reset == 1'b1) begin\n    state <= #1 IDLE;\n  end else begin\n    state <= #1 next_state;\n  end\nend\nalways @ (posedge clock)\nbegin : OUTPUT_LOGIC\nif (reset == 1'b1) begin\n  gnt_0 <= #1 1'b0;\n  gnt_1 <= #1 1'b0;\nend\nelse begin\n  case(state)\n    IDLE : begin\n                  gnt_0 <= #1 1'b0;\n                  gnt_1 <= #1 1'b0;\n               end\n   GNT0 : begin\n                   gnt_0 <= #1 1'b1;\n                   gnt_1 <= #1 1'b0;\n                end\n   GNT1 : begin\n                   gnt_0 <= #1 1'b0;\n                   gnt_1 <= #1 1'b1;\n                end\n   default : begin\n                    gnt_0 <= #1 1'b0;\n                    gnt_1 <= #1 1'b0;\n                  end\n  endcase\nend\nend endmodule // End of Module arbiter"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_9f4ee20d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1 (\n    input wire D0, \n    input wire D1,\n    input wire S,\n    input wire RST,\n    input wire CLK,\n    output reg Y\n);\n\n    always @(posedge CLK) begin\n        if (RST) begin\n            Y <= 0;\n        end else begin\n            if (S) begin\n                Y <= D1;\n            end else begin\n                Y <= D0;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "complement_concat_e5e4abe4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule complement_concat (\n    input clk,\n    input [15:0] data_in,\n    output reg [31:0] comp_concat_out\n);\n\nreg [7:0] data_out1;\nreg [23:0] data_out2;\n\nalways @ (posedge clk) begin\n    data_out1 <= data_in[7:0];\nend\n\nalways @ (posedge clk) begin\n    data_out2 <= ~data_in[15:8];\nend\n\nalways @ (posedge clk) begin\n    comp_concat_out <= {data_out1, data_out2};\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_subtractor_418ff124", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_subtractor (\n    input clk,\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    output reg [3:0] out\n);\n\nalways @(posedge clk) begin\n    if (mode == 1'b1) // Addition\n        out <= A + B;\n    else // Subtraction\n        out <= A - B;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Latch_96d8e50a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Latch(\n    input D, CLK,\n    output Q, Q_bar\n);\n\nreg Q, Q_bar, D_prev;\n\nalways @(posedge CLK) begin\n    Q <= D_prev;\n    Q_bar <= ~D_prev;\n    D_prev <= D;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "erx_remap_062afcf0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule erx_remap (\n   emesh_access_out, emesh_packet_out,\n   clk, emesh_access_in, emesh_packet_in, remap_mode, remap_sel,\n   remap_pattern, remap_base\n   );\n\n   parameter AW = 32;\n   parameter DW = 32;\n   parameter PW = 104;\n   parameter ID = 12'h808;\n   \n   input          clk;\n   \n   input          emesh_access_in;\n   input [PW-1:0] emesh_packet_in;\n   \n   input [1:0] \t  remap_mode;    input [11:0]   remap_sel;     input [11:0]   remap_pattern; input [31:0]   remap_base;    output \t   emesh_access_out;\n   output [PW-1:0] emesh_packet_out;\n\n   wire [31:0] \t   static_remap;\n   wire [31:0] \t   dynamic_remap;\n   wire [31:0] \t   remap_mux;\n   wire [31:0] \t   addr_in;\n   wire [31:0] \t   addr_out;\n   wire \t   remap_en;\n   \n   reg \t\t   emesh_access_out;\n   reg [PW-1:0]    emesh_packet_out;\n\n   parameter[5:0]  colid = ID[5:0];\n   \n   assign addr_in[31:0]  =  emesh_packet_in[39:8];\n \n   \n   assign static_remap[31:20] = (remap_sel[11:0] & remap_pattern[11:0]) |\n\t\t\t        (~remap_sel[11:0] & addr_in[31:20]);\n\n   assign static_remap[19:0]  = addr_in[19:0];\n    \n   assign dynamic_remap[31:0] = addr_in[31:0]    - (colid << 20)     + remap_base[31:0]  - (addr_in[31:26]<<$clog2(colid));\n     \t\t\t     \n   assign remap_mux[31:0]  = (addr_in[31:20]==ID)     ? addr_in[31:0] : (remap_mode[1:0]==2'b00) ? addr_in[31:0] :\n\t\t\t     (remap_mode[1:0]==2'b01) ? static_remap[31:0] :\n\t  \t\t                                dynamic_remap[31:0];\n\n   always @ (posedge clk)\n       emesh_access_out <= emesh_access_in;\n\n   always @ (posedge clk)    \n       emesh_packet_out[PW-1:0] <= {emesh_packet_in[103:40],\n                                    remap_mux[31:0],\n                                    emesh_packet_in[7:0]\n\t\t\t\t    };\n   \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lfsr_counter_37ce4ed7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule lfsr_counter(\n  input clk, reset,\n  output reg [SIZE-1:0] out\n);\n\n  parameter SIZE = 4;\n\n  reg [SIZE-1:0] state;\n\n  always @(posedge clk or posedge reset)\n    begin\n      if (reset) begin\n        state <= 0;\n        out <= 0;\n      end\n      else begin\n        state <= {state[SIZE-2:0], state[SIZE-1] ^ state[SIZE-2] ^ 1'b1};\n        out <= state;\n      end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cordic_stage_17cd47a0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule cordic_stage( clock, reset, enable, xi,yi,zi,constant,xo,yo,zo);\n   parameter bitwidth = 16;\n   parameter zwidth = 16;\n   parameter shift = 1;\n   \n   input     clock;\n   input     reset;\n   input     enable;\n   input [bitwidth-1:0] xi,yi;\n   input [zwidth-1:0] zi;\n   input [zwidth-1:0] constant;\n   output [bitwidth-1:0] xo,yo;\n   output [zwidth-1:0] zo;\n   \n   wire z_is_pos = ~zi[zwidth-1];\n\n   reg [bitwidth-1:0] \t xo,yo;\n   reg [zwidth-1:0] zo;\n   \n   always @(posedge clock)\n     if(reset)\n       begin\n\t  xo <= 0;\n\t  yo <= 0;\n\t  zo <= 0;\n       end\n     else begin\n\t  xo <= z_is_pos ?   \n\t\txi - {{shift+1{yi[bitwidth-1]}},yi[bitwidth-2:shift]} :\n\t\txi + {{shift+1{yi[bitwidth-1]}},yi[bitwidth-2:shift]};\n\t  yo <= z_is_pos ?   \n\t\tyi + {{shift+1{xi[bitwidth-1]}},xi[bitwidth-2:shift]} :\n\t\tyi - {{shift+1{xi[bitwidth-1]}},xi[bitwidth-2:shift]};\n\t  zo <= z_is_pos ?   \n\t\tzi - constant :\n\t\tzi + constant;\n       end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "matrix_multiplier_4d1f3307", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule matrix_multiplier(in1, in2, enable, out);\n  input [3:0] in1;\n  input [3:0] in2;\n  input enable;\n  output [3:0] out;\n  \n  wire [3:0] result;\n  \n  assign result = in1 * in2; // multiply the two input vectors\n  \n  assign out = enable ? result : 4'b0; // output the result if enable is high, otherwise output 0\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "spi_engine_interconnect_fbe89adf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule spi_engine_interconnect (\n\tinput clk,\n\tinput resetn,\n\n\toutput m_cmd_valid,\n\tinput m_cmd_ready,\n\toutput [15:0] m_cmd_data,\n\n\toutput m_sdo_valid,\n\tinput m_sdo_ready,\n\toutput [7:0] m_sdo_data,\n\n\tinput m_sdi_valid,\n\toutput m_sdi_ready,\n\tinput [7:0] m_sdi_data,\n\n\tinput m_sync_valid,\n\toutput m_sync_ready,\n\tinput [7:0] m_sync,\n\n\n\tinput s0_cmd_valid,\n\toutput s0_cmd_ready,\n\tinput [15:0] s0_cmd_data,\n\n\tinput s0_sdo_valid,\n\toutput s0_sdo_ready,\n\tinput [7:0] s0_sdo_data,\n\n\toutput s0_sdi_valid,\n\tinput s0_sdi_ready,\n\toutput [7:0] s0_sdi_data,\n\n\toutput s0_sync_valid,\n\tinput s0_sync_ready,\n\toutput [7:0] s0_sync,\n\n\n\tinput s1_cmd_valid,\n\toutput s1_cmd_ready,\n\tinput [15:0] s1_cmd_data,\n\n\tinput s1_sdo_valid,\n\toutput s1_sdo_ready,\n\tinput [7:0] s1_sdo_data,\n\n\toutput s1_sdi_valid,\n\tinput s1_sdi_ready,\n\toutput [7:0] s1_sdi_data,\n\n\toutput s1_sync_valid,\n\tinput s1_sync_ready,\n\toutput [7:0] s1_sync\n);\n\nreg s_active = 1'b0;\n\nreg idle = 1'b1;\n\n`define spi_engine_interconnect_mux(s0, s1) (idle == 1'b1 ? 1'b0 : (s_active == 1'b0 ? s0 : s1))\n\nassign m_cmd_data   = s_active == 1'b0 ? s0_cmd_data : s1_cmd_data;\nassign m_cmd_valid  = `spi_engine_interconnect_mux(s0_cmd_valid, s1_cmd_valid);\nassign s0_cmd_ready = `spi_engine_interconnect_mux(m_cmd_ready, 1'b0);\nassign s1_cmd_ready = `spi_engine_interconnect_mux(1'b0, m_cmd_ready);\n\nassign m_sdo_data   = s_active == 1'b0 ? s0_sdo_data : s1_sdo_data;\nassign m_sdo_valid  = `spi_engine_interconnect_mux(s0_sdo_valid, s1_sdo_valid);\nassign s0_sdo_ready = `spi_engine_interconnect_mux(m_sdo_ready, 1'b0);\nassign s1_sdo_ready = `spi_engine_interconnect_mux(1'b0, m_sdo_ready);\n\nassign s0_sdi_data  = m_sdi_data;\nassign s1_sdi_data  = m_sdi_data;\nassign m_sdi_ready  = `spi_engine_interconnect_mux(s0_sdi_ready, s1_sdi_ready);\nassign s0_sdi_valid = `spi_engine_interconnect_mux(m_sdi_valid, 1'b0);\nassign s1_sdi_valid = `spi_engine_interconnect_mux(1'b0, m_sdi_valid);\n\nassign s0_sync       = m_sync;\nassign s1_sync       = m_sync;\nassign m_sync_ready  = `spi_engine_interconnect_mux(s0_sync_ready, s1_sync_ready);\nassign s0_sync_valid = `spi_engine_interconnect_mux(m_sync_valid, 1'b0);\nassign s1_sync_valid = `spi_engine_interconnect_mux(1'b0, m_sync_valid);\n\nalways @(posedge clk) begin\n\tif (idle == 1'b1) begin\n\t\tif (s0_cmd_valid)\n\t\t\ts_active <= 1'b0;\n\t\telse if (s1_cmd_valid)\n\t\t\ts_active <= 1'b1;\n\tend\nend\n\nalways @(posedge clk) begin\n\tif (resetn == 1'b0) begin\n\t\tidle = 1'b1;\n\tend else begin\n\t\tif (m_sync_valid == 1'b1 && m_sync_ready == 1'b1) begin\n\t\t\tidle <= 1'b1;\n\t\tend else if (s0_cmd_valid == 1'b1 || s1_cmd_valid == 1'b1) begin\n\t\t\tidle <= 1'b0;\n\t\tend\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rotator_97701d85", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rotator(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nreg [99:0] pipeline_reg [2:0];\n\nalways @(posedge clk) begin\n    if (load) begin\n        pipeline_reg[0] <= data;\n        pipeline_reg[1] <= 100'b0;\n        pipeline_reg[2] <= 100'b0;\n    end else if (ena == 2'b01) begin\n        pipeline_reg[0] <= {pipeline_reg[0][98:0], pipeline_reg[2][0]};\n        pipeline_reg[1] <= pipeline_reg[0];\n        pipeline_reg[2] <= {pipeline_reg[2][98:0], pipeline_reg[0][0]};\n    end else if (ena == 2'b10) begin\n        pipeline_reg[0] <= {pipeline_reg[1][98:1], pipeline_reg[0][0]};\n        pipeline_reg[1] <= {pipeline_reg[2][98:1], pipeline_reg[1][0]};\n        pipeline_reg[2] <= pipeline_reg[2];\n    end else begin\n        pipeline_reg[0] <= pipeline_reg[0];\n        pipeline_reg[1] <= pipeline_reg[1];\n        pipeline_reg[2] <= pipeline_reg[2];\n    end\nend\n\nassign q = pipeline_reg[0];\n\nendmodule\n\nmodule top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output [99:0] q\n);\n\nrotator rotator_inst(\n    .clk(clk),\n    .load(load),\n    .ena(ena),\n    .data(data),\n    .q(q)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dualport_RAM_3ff56869", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dualport_RAM(clk, d_in_1, d_out_1, addr_1, rd_1, wr_1, d_in_2, d_out_2, addr_2, rd_2, wr_2);\n  \n  input clk;\n\n  input [15:0]d_in_1;\n  output reg [15:0]d_out_1=0;\n  input [7:0]addr_1; input rd_1;\n  input wr_1;\n\n  input [15:0]d_in_2;\n  output reg [15:0]d_out_2=0;\n  input [7:0]addr_2; input rd_2;\n  input wr_2;\n\n\n  reg [7:0] ram [0:31]; always @(negedge clk)\nbegin\n\nif (rd_1) begin\n\t\td_out_1[7:0] <= ram[addr_1];\n\t\td_out_1[15:8] <= ram[addr_1+1];\n\tend\n\telse if(wr_1) begin\n\t\tram[addr_1] <= d_in_1[7:0];\n\t\tram[addr_1+1] <= d_in_1[15:8];\n\tend\n\nelse if (rd_2) begin\n\t\td_out_2[7:0] <= ram[addr_2];\n\t\td_out_2[15:8] <= ram[addr_2+1];\n\tend\n\telse if(wr_2) begin\n\t\tram[addr_2] <= d_in_2[7:0];\n\t\tram[addr_2+1] <= d_in_2[15:8];\n\tend\nend\n\n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "comparator_4bit_8f4c32d8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule comparator_4bit (\n  input [3:0] A,\n  input [3:0] B,\n  output reg EQ\n);\n\n  always @(*) begin\n    if (A == B) begin\n      EQ = 1;\n    end else begin\n      EQ = 0;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PAD_BANK2_e22dc3d9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule PAD_BANK2(PAD, PADIN, PADOUT, PADOEN);\n  inout PAD;\n  output PADIN;\n  input PADOEN;\n  input PADOUT;\n\n  reg PAD_drv_reg;\n  assign PAD = (PADOEN & ~PADOUT) ? PAD_drv_reg : 1'b1;\n  assign PADIN = PAD_drv_reg;\n\n  always @(*) begin\n    PAD_drv_reg = PADOUT;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_op_635c92df", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_op(input [7:0] A, input [7:0] B, input [1:0] C, output reg [7:0] out);\n    always @(*) begin\n        case(C)\n            2'b00: out = A & B;\n            2'b01: out = A | B;\n            2'b10: out = A ^ B;\n            2'b11: out = ~(A ^ B);\n        endcase\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_to_gray_aaa06383", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_to_gray(\n    input [3:0] bin_in,\n    output [3:0] gray_out\n);\n\n    assign gray_out[3] = bin_in[3];\n    assign gray_out[2] = bin_in[3] ^ bin_in[2];\n    assign gray_out[1] = bin_in[2] ^ bin_in[1];\n    assign gray_out[0] = bin_in[1] ^ bin_in[0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "encodeBcd10to4_c8b7a060", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule encodeBcd10to4(in, out);\n\tinput [0:8]in;\n\toutput [0:3]out;\n\twire and0out, and1out, and2out, and3out, and4out, and5out, and6out, and7out, and8out, and9out, and10out, and11out, and12out, nor0out;\n\t\n\tand\n\tandGate0(and0out, ~in[0], in[1], in[3], in[5], nor0out),\n\tandGate1(and1out, ~in[2], in[3], in[5], nor0out),\n\tandGate2(and2out, ~in[4], in[5], nor0out),\n\tandGate3(and3out, ~in[6], nor0out),\n\tandGate4(and4out, ~in[8]),\n\tandGate5(and5out, ~in[1], in[3], in[4], nor0out),\n\tandGate6(and6out, ~in[2], in[3], in[4], nor0out),\n\tandGate7(and7out, ~in[5], nor0out),\n\tandGate8(and8out, ~in[6], nor0out),\n\tandGate9(and9out, ~in[3], nor0out),\n\tandGate10(and10out, ~in[4], nor0out),\n\tandGate11(and11out, ~in[5], nor0out),\n\tandGate12(and12out, ~in[6], nor0out);\n\t\n\tnor\n\tnorGate0(nor0out, ~in[7], ~in[8]),\n\tnorGate1(out[0], and0out, and1out, and2out, and3out, and4out),\n\tnorGate2(out[1], and5out, and6out, and7out, and8out),\n\tnorGate3(out[2], and9out, and10out, and11out, and12out);\n\t\n\tassign out[3] = nor0out;\n\t\n\tendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RoundSaturation #_ea6cb59a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RoundSaturation #(\n  parameter integer IB = 4, // Number of integer bits\n  parameter integer FB = 8 // Number of fractional bits\n)(\n  input signed [IB + FB - 1:0] in,\n  output signed [IB + FB - 1:0] out\n);\n\n\nwire signed [IB + FB - 1:0] in_val;\nwire signed [IB + FB - 1:0] round_val;\nwire signed [IB + FB - 1:0] max_val;\nwire signed [IB + FB - 1:0] min_val;\n\nassign in_val = in * (2 ** FB); // Shift input to left by fb bits to convert to integer\n\nassign round_val = (in_val >= 0) ? ((in_val + (2 ** (FB - 1))) >> FB) : ((in_val - (2 ** (FB - 1))) >> FB); // Round up/down based on fractional part\n\nassign max_val = (2 ** (IB + FB - 1)) - 1; // Calculate maximum representable value\nassign min_val = -(2 ** (IB + FB - 1)); // Calculate minimum representable value\n\nassign out = (round_val > max_val) ? max_val : ((round_val < min_val) ? min_val : round_val); // Saturation: Output rounded value or max/min if out of range\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "cic_filter #_06b23247", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule cic_filter #(\n  parameter N = 3, // order of filter\n  parameter R = 4, // decimation or interpolation factor\n  parameter M = 16 // number of bits in input signal\n) (\n  input [M-1:0] in,\n  input clk,\n  input rst,\n  output [M-1:0] out\n);\n\nreg [M-1:0] integrator_reg = 0; // accumulator for integrator\nreg [M-1:0] comb_reg [0:N-1]; // shift register for comb filter\nreg [M-1:0] decimator_reg = 0; // register for decimator\nreg [M-1:0] interpolator_reg = 0; // register for interpolator\nreg [M-1:0] out_reg = 0; // register for output\n\ninteger i;\n\nalways @(posedge clk) begin\n  if (rst) begin\n    integrator_reg <= 0;\n    for (i = 0; i < N; i = i + 1) begin\n      comb_reg[i] <= 0;\n    end\n    decimator_reg <= 0;\n    interpolator_reg <= 0;\n    out_reg <= 0;\n  end else begin\n    // integrator\n    integrator_reg <= integrator_reg + in;\n    \n    // comb filter\n    comb_reg[0] <= integrator_reg;\n    for (i = 1; i < N; i = i + 1) begin\n      comb_reg[i] <= comb_reg[i-1];\n    end\n    \n    // decimator or interpolator\n    if (R > 1) begin\n      decimator_reg <= decimator_reg + 1;\n      if (decimator_reg == R-1) begin\n        out_reg <= comb_reg[N-1];\n        decimator_reg <= 0;\n      end\n    end else begin\n      interpolator_reg <= interpolator_reg + 1;\n      if (interpolator_reg == R-1) begin\n        out_reg <= comb_reg[N-1];\n        interpolator_reg <= 0;\n      end\n    end\n  end\nend\n\nassign out = out_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_input_and_bc55c67e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_input_and (\n    A1,\n    A2,\n    B1_N,\n    C1,\n    X\n);\n\n    input A1;\n    input A2;\n    input B1_N;\n    input C1;\n    output X;\n\n    wire and1_out;\n    wire and2_out;\n\n    o21ba and1 (\n        .A1(A1),\n        .A2(A2),\n        .B1_N(B1_N),\n        .X(and1_out)\n    );\n\n    o21ba and2 (\n        .A1(A1),\n        .A2(A2),\n        .B1_N(C1),\n        .X(and2_out)\n    );\n\n    assign X = and1_out & and2_out;\n\nendmodule\n\nmodule o21ba (\n    input A1,\n    input A2,\n    input B1_N,\n    output X\n);\n\n    // Implementing the logic: X = A1 & A2 & ~B1_N\n    assign X = A1 & A2 & ~B1_N;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "data_storage_5a32a6f1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule data_storage(\n    input clk,\n    input reset,\n    input [31:0] in_data,\n    input in_valid,\n    output reg [31:0] out_data,\n    output reg out_valid\n);\n\nreg [31:0] stored_data;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        stored_data <= 0;\n        out_valid <= 0;\n    end else if (in_valid) begin\n        stored_data <= in_data;\n        out_valid <= 1;\n    end else begin\n        out_valid <= 0;\n    end\nend\n\nalways @* begin\n    out_data = stored_data;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__95ca43f3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] a,\n    input [7:0] b,\n    input [2:0] sel,\n    output [3:0] out,\n    output parity,\n    output overflow\n);\n\n    wire [7:0] sum;\n    wire add_overflow;\n    add_overflow_detection adder(a, b, sum, add_overflow);\n\n    wire [3:0] data0;\n    wire [3:0] data1;\n    wire [3:0] data2;\n    wire [3:0] data3;\n    wire [3:0] data4;\n    wire [3:0] data5;\n\n    assign data0 = a[3:0];\n    assign data1 = b[3:0];\n    assign data2 = sum[3:0];\n    assign data3 = 4'b0;\n    assign data4 = 4'b0;\n    assign data5 = 4'b0;\n\n    reg [3:0] out_reg;\n    reg overflow_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out_reg <= 4'b0;\n            overflow_reg <= 1'b0;\n        end else begin\n            case (sel)\n                3'b000: begin\n                    out_reg <= data0;\n                end\n                3'b001: begin\n                    out_reg <= data1;\n                end\n                3'b010: begin\n                    out_reg <= data2;\n                    overflow_reg <= add_overflow;\n                end\n                default: begin\n                    out_reg <= 4'b0;\n                    overflow_reg <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    mux mux_parity(sel, data0, data1, data2, data3, data4, data5, parity);\n\n    assign out = out_reg;\n    assign overflow = overflow_reg;\n\nendmodule\n\nmodule add_overflow_detection (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\nendmodule\n\nmodule mux (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg parity\n);\n\n    always @(*) begin\n        case (sel)\n            3'b000: parity = ^data0;\n            3'b001: parity = ^data1;\n            3'b010: parity = ^data2;\n            3'b011: parity = ^data3;\n            3'b100: parity = ^data4;\n            3'b101: parity = ^data5;\n            default: parity = 1'b0;\n        endcase\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "oam_7772401c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule oam (\n  input [7:0] data_a,\n  input [7:0] data_b,\n  input [7:0] address_a,\n  input [7:0] address_b,\n  input clock,\n  input wren_a,\n  input wren_b,\n  output reg [7:0] q_a,\n  output reg [7:0] q_b\n);\n\n  // Memory for port A\n  reg [7:0] memory_a[255:0];\n\n  // Memory for port B\n  reg [7:0] memory_b[255:0];\n\n  // Read and write logic for port A\n  always @(posedge clock) begin\n    if (wren_a)\n      memory_a[address_a] <= data_a;\n    q_a <= memory_a[address_a];\n  end\n\n  // Read and write logic for port B\n  always @(posedge clock) begin\n    if (wren_b)\n      memory_b[address_b] <= data_b;\n    q_b <= memory_b[address_b];\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_36b95011", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1 (\n    input in0,\n    input in1,\n    input sel,\n    output reg out\n);\n\n    always @(*) begin\n        if (sel == 1'b0) begin\n            out = in0;\n        end else begin\n            out = in1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nonrestore_div #_8b54af9b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nonrestore_div #(\n\tparameter\tNUMERATOR_WIDTH\t\t= 64,\n\tparameter\tDENOMINATOR_WIDTH\t= 64\n)(\n\tinput\t\t\t\t\t\t\t\t\t\tclk,\n\tinput\t\t\t\t\t\t\t\t\t\tclr,\n\tinput\t\t[NUMERATOR_WIDTH\t- 1\t: 0]\tnumer_in,\n\tinput\t\t[DENOMINATOR_WIDTH\t- 1\t: 0]\tdenom_in,\n\toutput\treg\t[NUMERATOR_WIDTH\t- 1\t: 0]\tquot_out,\n\toutput\treg\t[DENOMINATOR_WIDTH\t- 1\t: 0]\trem_out,\n\toutput\treg\t\t\t\t\t\t\t\t\trdy_out\n);\nlocalparam\ts0 = 4'b0001;\nlocalparam\ts1 = 4'b0010;\nlocalparam\ts2 = 4'b0100;\nlocalparam\ts3 = 4'b1000;\n\nlocalparam\tTMPVAR_WIDTH\t\t= NUMERATOR_WIDTH + DENOMINATOR_WIDTH;\nlocalparam\tREM_ITER_MSB\t\t= DENOMINATOR_WIDTH;\nlocalparam\tQUOT_MSB\t\t\t= NUMERATOR_WIDTH - 1;\n\nreg\t\t\t[3\t\t\t\t\t\t: 0]\tstate;\nreg\t\t\t[NUMERATOR_WIDTH\t- 1\t: 0]\tnumer;\nreg\t\t\t[DENOMINATOR_WIDTH\t- 1\t: 0]\tdenom;\nreg\t\t\t[DENOMINATOR_WIDTH\t\t: 0]\tdenom_neg;\nreg\t\t\t[NUMERATOR_WIDTH\t- 1\t: 0]\tquot;\nreg\t\t\t[DENOMINATOR_WIDTH\t- 1 : 0]\trem;\nreg\t\t\t[DENOMINATOR_WIDTH\t\t: 0]\trem_iter;\nreg\t\t\t[7\t\t\t\t\t\t: 0]\tcount;\n\nwire\t\t[DENOMINATOR_WIDTH\t\t: 0]\trem_iter_shift;\nwire\t\t[NUMERATOR_WIDTH\t- 1 : 0]\tquot_shift;\nwire\t\t[DENOMINATOR_WIDTH\t\t: 0]\trem_iter_sum;\n\nassign\t\t{rem_iter_shift, quot_shift} = {rem_iter, quot} << 1;\nassign\t\trem_iter_sum = rem_iter_shift + (rem_iter[REM_ITER_MSB]) ? denom : denom_neg;\n\nalways @ (posedge clk or posedge clr)\nbegin\n\tif (clr) begin\n\t\tstate\t\t<= s0;\n\t\trdy_out\t\t<= 1'b0;\n\t\tnumer\t\t<= 0;\n\t\tdenom\t\t<= 0;\n\t\tdenom_neg\t<= 0;\n\t\tquot\t\t<= 0;\n\t\trem_iter\t<= 0;\n\t\trem\t\t\t<= 0;\n\t\tcount\t\t<= 0;\n\tend\n\telse begin\n\t\tcase (state)\n\t\t\ts0\t: begin\n\t\t\t\tnumer\t\t<= numer_in;\n\t\t\t\tdenom\t\t<= denom_in;\n\t\t\t\tdenom_neg\t<= {1'b1,~denom_in} + 1;\n\t\t\t\tquot\t\t<= numer_in;\n\t\t\t\trem_iter\t<= 0;\n\t\t\t\tcount\t\t<= 0;\n\t\t\t\tstate\t\t<= s1;\n\t\t\tend\n\t\t\ts1\t: begin\n\t\t\t\tcount\t\t<= count + 1;\n\t\t\t\tquot[QUOT_MSB : 1]\t<= quot_shift[QUOT_MSB : 1];\n\t\t\t\trem_iter\t<= rem_iter_sum;\n\t\t\t\tif (rem_iter_sum[REM_ITER_MSB]) begin\n\t\t\t\t\tquot[0] <= 0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tquot[0] <= 1;\n\t\t\t\tend\n\t\t\t\tif (count == NUMERATOR_WIDTH - 1) begin\n\t\t\t\t\tstate\t<= s2;\n\t\t\t\tend\n\t\t\tend\n\t\t\ts2\t: begin\n\t\t\t\tif (rem_iter[REM_ITER_MSB]) begin\trem \t<= rem_iter + denom;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\trem \t<= rem_iter;\n\t\t\t\tend\n\t\t\t\tstate \t\t<= s3;\n\t\t\tend\n\t\t\ts3\t: begin\n\t\t\t\tquot_out\t<= quot;\n\t\t\t\trem_out\t\t<= rem;\n\t\t\t\trdy_out\t\t<= 1'b1;\n\t\t\tend\n\t\t\tdefault : begin\n\t\t\t\tstate \t\t<= s0;\n\t\t\tend\n\t\tendcase\n\tend\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "instruction_fetch_490a4334", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule instruction_fetch(\n    input wire clk,\n    input wire nrst,\n    input wire [31:0] addr,\n    input wire rd_cmd,\n    output wire [31:0] instr_dat,\n    output wire busy,\n    output wire err_align,\n    output wire err_bus,\n    output reg [31:0] o_IAddr,\n    output reg o_IRdC,\n    input wire [31:0] i_IData,\n    input wire i_IRdy,\n    input wire i_IErr\n);\n\n    localparam IDLE = 1'b0;\n    localparam WAIT = 1'b1;\n\n    reg [31:0] lch_idata;\n    reg state;\n\n    assign err_align = (rd_cmd == 1'b1 && addr[1:0] != 2'b00);\n\n    wire active = (!err_align && !i_IErr && rd_cmd == 1'b1);\n\n    assign busy = ((active || (state == WAIT)) && !i_IRdy);\n\n    assign err_bus = i_IErr;\n\n    always @(*) begin\n        o_IAddr = 32'b0;\n        o_IRdC = 1'b0;\n\n        if(active) begin\n            o_IAddr = addr;\n            o_IRdC = 1'b1;\n        end\n    end\n\n    always @(posedge clk or negedge nrst) begin\n        if(!nrst) begin\n            state <= IDLE;\n            lch_idata <= {32{1'b0}};\n        end\n        else begin\n            if(state == IDLE && (active && i_IRdy)) begin\n                lch_idata <= i_IData;\n            end\n            else if(state == IDLE && (active && !i_IRdy)) begin\n                state <= !i_IErr ? WAIT : IDLE;\n            end\n            else if(state == WAIT && i_IRdy) begin\n                state <= IDLE;\n                lch_idata <= i_IData;\n            end\n        end\n    end\n\n    assign instr_dat = (active || state == WAIT) ? i_IData : lch_idata;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__clkdlyinv3sd3_c67f077e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__clkdlyinv3sd3 (\n    Y,\n    A\n);\n\n    output Y;\n    input  A;\n\n    wire not0_out_Y;\n\n    not not0 (not0_out_Y, A              );\n    buf buf0 (Y         , not0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pace_catcher_0c6c0239", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule pace_catcher\n          (\n           clk_fast,\n\t\t\t  clk_slow,\n\t\t\t  signal_i,\n\t\t\t  signal_o\n          );\n\t\t\t \ninput clk_fast;\ninput clk_slow;\ninput signal_i;\noutput signal_o;\n\t\t\t \nparameter COUNT = 15; parameter s_idle = 0;\nparameter s_out = 1;\n\n\nreg[15:0] cnt = 0;\nreg state = 0;\n\nalways @(posedge clk_fast) begin\n\t\tcase(state)\n\t\t\ts_idle:\n\t\t\tbegin\n\t\t\t\tstate <= (signal_i) ? s_out : s_idle;\n\t\t\tend\n\t\t\ts_out:\n\t\t\tbegin\n\t\t\t\tstate <= (cnt >= COUNT) ? s_idle : s_out;\n\t\t\tend\n\t\tendcase\nend\n\nalways @(posedge clk_slow) begin\n\t\tif (state == s_out) cnt <= cnt + 8'b1;\n\t\telse if (state == s_idle) cnt  <= 8'b0;\nend\n\nassign signal_o = (state == s_out);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "or4_68907dfb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule or4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Internal wires\n    wire AB;\n    wire CD;\n    wire ABCD;\n\n    // Implement OR gate logic\n    assign AB = A | B;\n    assign CD = C | D;\n    assign ABCD = AB | CD;\n    assign X = ABCD;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DFF_SR_GATED_6d09ddc8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule DFF_SR_GATED (D, S, R, G, Q, QN);\ninput  D ;\ninput  S ;\ninput  R ;\ninput  G ;\noutput Q ;\noutput QN ;\nreg Q;\n\nalways @(posedge G)\nbegin\n    if (R == 1'b1)\n        Q <= 1'b0;\n    else if (S == 1'b1)\n        Q <= 1'b1;\n    else\n        Q <= D;\nend\n\nassign QN = ~Q;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_4to1_eeed726b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_4to1(\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1,\n    output reg Y\n);\n\nalways @ (S1 or S0 or A or B or C or D)\nbegin\n    case ({S1, S0})\n        2'b00: Y = A;\n        2'b01: Y = B;\n        2'b10: Y = C;\n        2'b11: Y = D;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "byte_reversal_3ac9957c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule byte_reversal (\n    input [31:0] input_word,\n    output [31:0] output_word\n);\n\n    assign output_word[7:0] = input_word[31:24];\n    assign output_word[15:8] = input_word[23:16];\n    assign output_word[23:16] = input_word[15:8];\n    assign output_word[31:24] = input_word[7:0];\n\nendmodule\nmodule reg_with_reset (\n    input clk,\n    input reset,\n    input [7:0] input_data,\n    output reg [7:0] output_data\n);\n\n    always @(posedge clk) begin\n        if (reset == 0) begin\n            output_data <= 8'h34;\n        end else begin\n            output_data <= input_data;\n        end\n    end\n\nendmodule\nmodule bitwise_or (\n    input [7:0] input_a,\n    input [7:0] input_b,\n    output [7:0] output_data\n);\n\n    assign output_data = input_a | input_b;\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] reg_input,\n    input [31:0] byte_input,\n    output [7:0] func_output\n);\n\n    wire [7:0] reg_output;\n    wire [31:0] byte_output;\n\n    reg_with_reset reg_inst (\n        .clk(clk),\n        .reset(reset),\n        .input_data(reg_input),\n        .output_data(reg_output)\n    );\n\n    byte_reversal byte_inst (\n        .input_word(byte_input),\n        .output_word(byte_output)\n    );\n\n    bitwise_or or_inst (\n        .input_a(reg_output),\n        .input_b(byte_output[31:24]),\n        .output_data(func_output)\n    );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rfid_1c5db08e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule rfid (\n  input clk,\n  input [7:0] tx_data,\n  input tx_en,\n  input rx_en,\n  output [7:0] rx_data\n);\n\n  // Define modulation scheme used by transmitter block\n  // For simplicity, we will use amplitude shift keying (ASK)\n  reg [1:0] tx_mod;\n  always @ (posedge clk) begin\n    if (tx_en) begin\n      if (tx_data[0]) begin\n        tx_mod <= 2'b11; // High amplitude\n      end else begin\n        tx_mod <= 2'b01; // Low amplitude\n      end\n    end else begin\n      tx_mod <= 2'b00; // No transmission\n    end\n  end\n  \n  // Define decoding algorithm used by receiver block\n  // For simplicity, we will use amplitude detection for ASK\n  reg [7:0] rx_data_reg;\n  always @ (posedge clk) begin\n    if (rx_en) begin\n      if (tx_mod == 2'b11) begin\n        rx_data_reg <= 8'b11111111; // High amplitude detected, set all bits to 1\n      end else begin\n        rx_data_reg <= tx_data; // Low amplitude detected, retrieve original data\n      end\n    end\n  end\n  \n  // Connect inputs to transmitter and receiver blocks\n  assign rx_data = rx_data_reg;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_circuit_a2a20c57", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_circuit (\n    Y,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    wire A_and = A1 & A2 & A3;\n    wire A_or = A1 | A2 | A3;\n\n    assign Y = (B1 == 1'b1) ? 1'b1 : ((A_and == 1'b1) || ((A_or - A_and) >= 2'b10));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_adder_5fc94162", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_adder (\n  input [3:0] A,\n  input [3:0] B,\n  input C_in,\n  output [3:0] S\n);\n\n  wire [3:0] sum_wire;\n\n  assign sum_wire = A + B + C_in;\n\n  assign S = sum_wire;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hdll__isobufsrc_28963a2f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hdll__isobufsrc (\n    X    ,\n    SLEEP,\n    A\n);\n\n    output X    ;\n    input  SLEEP;\n    input  A    ;\n\n    wire not0_out  ;\n    wire and0_out_X;\n\n    not not0 (not0_out  , SLEEP          );\n    and and0 (and0_out_X, not0_out, A    );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Pipeline #_3509dd06", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Pipeline #(\n  parameter n = 4, // number of input signals\n  parameter m = 2, // number of output signals\n  parameter p = 3  // number of pipeline stages\n) (\n  input [n-1:0] in,\n  output [m-1:0] out,\n  input clk\n);\n\n  wire [n-1:0] stage0_out; // output of stage 0\n  wire [n-1:0] stage1_out; // output of stage 1\n  wire [n-1:0] stage2_out; // output of stage 2\n\n  // instantiate pipeline stages\n  Stage0 #(.n(n)) stage0(\n    .in(in),\n    .out(stage0_out),\n    .clk(clk)\n  );\n\n  Stage1 #(.n(n)) stage1(\n    .in(stage0_out),\n    .out(stage1_out),\n    .clk(clk)\n  );\n\n  Stage2 #(.n(n)) stage2(\n    .in(stage1_out),\n    .out(stage2_out),\n    .clk(clk)\n  );\n\n\n  // output signals are the final output of the last stage of the pipeline\n  assign out = stage2_out[m-1:0];\n\nendmodule\nmodule Stage0 #(\n  parameter n = 4\n) (\n  input [n-1:0] in,\n  output [n-1:0] out,\n  input clk\n);\n\n  reg [n-1:0] reg_out; // pipeline register\n\n  // perform computation in this stage\n  assign out = in + 1;\n\n  // store output in pipeline register\n  always @(posedge clk) begin\n    reg_out <= out;\n  end\n\nendmodule\nmodule Stage1 #(\n  parameter n = 4\n) (\n  input [n-1:0] in,\n  output [n-1:0] out,\n  input clk\n);\n\n  reg [n-1:0] reg_out; // pipeline register\n\n  // perform computation in this stage\n  assign out = in + 2;\n\n  // store output in pipeline register\n  always @(posedge clk) begin\n    reg_out <= out;\n  end\n\nendmodule\nmodule Stage2 #(\n  parameter n = 4\n) (\n  input [n-1:0] in,\n  output [n-1:0] out,\n  input clk\n);\n\n  reg [n-1:0] reg_out; // pipeline register\n\n  // perform computation in this stage\n  assign out = in + 3;\n\n  // store output in pipeline register\n  always @(posedge clk) begin\n    reg_out <= out;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "add_sub_shift_e033ff6b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule add_sub_shift (\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    input DIR,\n    input [1:0] AMT,\n    output [3:0] Q\n);\n\nreg [3:0] shifted_A;\nwire [3:0] shifted_B;\n\n// Barrel shifter module\nbarrel_shifter bs(\n    .A(A),\n    .B(B),\n    .DIR(DIR),\n    .AMT(AMT),\n    .Q(shifted_A),\n    .fill(shifted_B)\n);\n\n// Adder-subtractor module\nadder_subtractor as(\n    .A(shifted_A),\n    .B(shifted_B),\n    .mode(mode),\n    .Q(Q)\n);\n\nendmodule\nmodule barrel_shifter (\n    input [3:0] A,\n    input [3:0] B,\n    input DIR,\n    input [1:0] AMT,\n    output [3:0] Q,\n    output [3:0] fill\n);\n\nwire [3:0] shifted_A;\n\nassign shifted_A = (DIR) ? {B[3-AMT[1:0]:0], A[3:AMT[1:0]]} : {A[AMT[1:0]-1:0], B[3:AMT[1:0]]};\n\nassign Q = shifted_A;\nassign fill = (DIR) ? {B[3:AMT[1:0]], shifted_A[AMT[1:0]-1:0]} : {A[AMT[1:0]-1:0], shifted_A[AMT[1:0]-1:0]};\n\nendmodule\nmodule adder_subtractor (\n    input [3:0] A,\n    input [3:0] B,\n    input mode,\n    output [3:0] Q\n);\n\nassign Q = (mode) ? A - B : A + B;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "audio_codec_d9fed97c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule audio_codec (\n  input clk,\n  input rst,\n  input [15:0] audio_in,\n  input [7:0] config_data,\n  input config_en,\n  output [15:0] audio_out,\n  output valid_out\n);\n\nparameter sample_rate = 44100;\nparameter bit_rate = 128;\nparameter channels = 2;\nparameter format = \"MP3\";\n\n// Define internal signals\nreg [15:0] audio_compressed;\nreg [15:0] audio_decompressed;\nreg valid_out;\n\nalways @ (posedge clk) begin\n  if (rst) begin\n    audio_compressed <= 0;\n    audio_decompressed <= 0;\n    valid_out <= 0;\n  end else begin\n    if (config_en) begin\n      // Parse configuration data to determine codec settings\n      // For the purpose of this example, we will simply ignore the configuration data\n    end else begin\n      // Apply compression or decompression algorithm to input audio stream\n      // For the purpose of this example, we will simply pass the audio through without compression or decompression\n      audio_compressed <= audio_in;\n      audio_decompressed <= audio_in;\n      valid_out <= 1;\n    end\n  end\nend\n\n// Output compressed or decompressed audio stream\nassign audio_out = (format == \"MP3\") ? audio_compressed : audio_decompressed;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "verilog_mult_32bit_92225527", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule verilog_mult_32bit\n#(parameter\n    ID         = 1,\n    NUM_STAGE  = 4,\n    din0_WIDTH = 32,\n    din1_WIDTH = 32,\n    dout_WIDTH = 32\n)(\n    input  wire                  clk,\n    input  wire                  reset,\n    input  wire                  ce,\n    input  wire [din0_WIDTH-1:0] din0,\n    input  wire [din1_WIDTH-1:0] din1,\n    output wire [dout_WIDTH-1:0] dout\n);\n\nwire                  aclk;\nwire                  aclken;\nwire                  a_tvalid;\nwire [31:0]           a_tdata;\nwire                  b_tvalid;\nwire [31:0]           b_tdata;\nwire                  r_tvalid;\nwire [31:0]           r_tdata;\nreg  [din0_WIDTH-1:0] din0_buf1;\nreg  [din1_WIDTH-1:0] din1_buf1;\n\nHLS_accel_fmul_32ns_32ns_32_4_max_dsp #(\n    .ID(ID),\n    .NUM_STAGE(NUM_STAGE),\n    .din0_WIDTH(din0_WIDTH),\n    .din1_WIDTH(din1_WIDTH),\n    .dout_WIDTH(dout_WIDTH)\n) HLS_accel_fmul_32ns_32ns_32_4_max_dsp_u (\n    .aclk(aclk),\n    .aclken(aclken),\n    .a_tvalid(a_tvalid),\n    .a_tdata(a_tdata),\n    .b_tvalid(b_tvalid),\n    .b_tdata(b_tdata),\n    .r_tvalid(r_tvalid),\n    .r_tdata(r_tdata)\n);\n\nassign aclk     = clk;\nassign aclken   = ce;\nassign a_tvalid = 1'b1;\nassign a_tdata  = din0_buf1;\nassign b_tvalid = 1'b1;\nassign b_tdata  = din1_buf1;\nassign dout     = r_tdata;\n\nalways @(posedge clk) begin\n    if (ce) begin\n        din0_buf1 <= din0;\n        din1_buf1 <= din1;\n    end\nend\n\nendmodule\nmodule HLS_accel_fmul_32ns_32ns_32_4_max_dsp\n#(parameter\n    ID         = 1,\n    NUM_STAGE  = 4,\n    din0_WIDTH = 32,\n    din1_WIDTH = 32,\n    dout_WIDTH = 32\n)(\n    input  wire                  aclk,\n    input  wire                  aclken,\n    input  wire                  a_tvalid,\n    input  wire [din0_WIDTH-1:0] a_tdata,\n    input  wire                  b_tvalid,\n    input  wire [din1_WIDTH-1:0] b_tdata,\n    output wire                  r_tvalid,\n    output wire [dout_WIDTH-1:0] r_tdata\n);\n\nreg                   a_tvalid_1;\nreg  [din0_WIDTH-1:0] a_tdata_1;\nreg                   b_tvalid_1;\nreg  [din1_WIDTH-1:0] b_tdata_1;\nreg  [dout_WIDTH-1:0] r_tdata;\nwire                  ap_ce_reg;\n\nalways @(*) begin\n    if (aclken) begin\n        a_tvalid_1  <= a_tvalid;\n        a_tdata_1   <= a_tdata;\n        b_tvalid_1  <= b_tvalid;\n        b_tdata_1   <= b_tdata;\n    end\nend\n\nalways @(posedge aclk) begin\n    if (aclken) begin\n        r_tdata <= a_tdata_1 * b_tdata_1;\n    end\nend\n\nassign ap_ce_reg = 1'b1;\n\nassign r_tvalid = a_tvalid_1 & b_tvalid_1;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_f15a0c2b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter(\n  input clk,\n  input reset,\n  output reg [3:0] out\n);\n\n  always @(posedge clk) begin\n    if (!reset) begin\n      out <= 4'b0000;\n    end else begin\n      out <= out + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "serdes_fc_rx_27d84bfd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule serdes_fc_rx\n  #(parameter LWMARK = 64,\n    parameter HWMARK = 320)\n    (input clk, input rst,\n     input [15:0] fifo_space, \n     output reg send_xon,\n     output reg send_xoff,\n     input sent);\n    \n   reg [15:0] \t  countdown;\n   reg \t\t  send_xon_int, send_xoff_int;\n   \n   always @(posedge clk)\n     if(rst)\n       begin\n\t  send_xon_int <= 0;\n\t  send_xoff_int <= 0;\n\t  countdown <= 0;\n       end\n     else \n       begin\n\t  send_xon_int <= 0;\n\t  send_xoff_int <= 0;\n\t  if(countdown == 0)\n\t    if(fifo_space < LWMARK)\n\t      begin\n\t\t send_xoff_int <= 1;\n\t\t countdown <= 240;\n\t      end\n\t    else\n\t      ;\n\t  else\n\t    if(fifo_space > HWMARK)\n\t      begin\n\t\t send_xon_int <= 1;\n\t\t countdown <= 0;\n\t      end\n\t    else\n\t      countdown <= countdown - 1;\n       end always @(posedge clk)\n     if(rst)\n       send_xon <= 0;\n     else if(send_xon_int)\n       send_xon <= 1;\n     else if(sent)\n       send_xon <= 0;\n\n   always @(posedge clk)\n     if(rst)\n       send_xoff <= 0;\n     else if(send_xoff_int)\n       send_xoff <= 1;\n     else if(sent)\n       send_xoff <= 0;\n   \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__o21ai_2_3874012e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_ls__o21ai_2 (\n    Y,\n    A1,\n    A2,\n    B1,\n    VPWR,\n    VGND,\n    VPB,\n    VNB\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input B1;\n    input VPWR;\n    input VGND;\n    input VPB;\n    input VNB;\n\nendmodule\n\nmodule my_module(\n    out_wire,\n    in_wire1,\n    in_wire2,\n    in_wire3,\n    power,\n    ground,\n    power_bond,\n    ground_bond\n);\n\n    output out_wire;\n    input in_wire1;\n    input in_wire2;\n    input in_wire3;\n    input power;\n    input ground;\n    input power_bond;\n    input ground_bond;\n\n    wire Y;\n    sky130_fd_sc_ls__o21ai_2 base (\n        .Y(Y),\n        .A1(in_wire1),\n        .A2(in_wire2),\n        .B1(in_wire3),\n        .VPWR(power),\n        .VGND(ground),\n        .VPB(power_bond),\n        .VNB(ground_bond)\n    );\n\n    assign out_wire = (in_wire1 & ~in_wire2 & ~in_wire3) |\n                      (~in_wire1 & in_wire2 & ~in_wire3) |\n                      (~in_wire1 & in_wire2 & in_wire3) |\n                      (~in_wire1 & ~in_wire2 & in_wire3);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "timer_e54ebea0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule timer (\n    input clk,\n    input rst,\n    input start,\n    input stop,\n    input reset,\n    input load,\n    input [31:0] value,\n    output interrupt\n);\n\n    reg [31:0] counter;\n    reg [31:0] load_value;\n    reg [1:0] state;\n    reg interrupt_reg;\n\n    parameter IDLE = 2'b00;\n    parameter RUNNING = 2'b01;\n    parameter STOPPED = 2'b10;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            counter <= 0;\n            state <= IDLE;\n            interrupt_reg <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counter <= value;\n                    if (load) begin\n                        load_value <= value;\n                        state <= IDLE;\n                    end else if (start) begin\n                        state <= RUNNING;\n                    end else begin\n                        state <= IDLE;\n                    end\n                end\n                RUNNING: begin\n                    if (stop) begin\n                        state <= STOPPED;\n                    end else if (counter == 0) begin\n                        interrupt_reg <= 1;\n                        state <= IDLE;\n                    end else begin\n                        counter <= counter - 1;\n                        state <= RUNNING;\n                    end\n                end\n                STOPPED: begin\n                    if (start) begin\n                        state <= RUNNING;\n                    end else if (reset) begin\n                        counter <= 0;\n                        state <= IDLE;\n                    end else begin\n                        state <= STOPPED;\n                    end\n                end\n            endcase\n        end\n    end\n\n    assign interrupt = interrupt_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axi_protocol_converter_v2_1_7_decerr_slave #_6ae04900", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n \nmodule axi_protocol_converter_v2_1_7_decerr_slave #\n  (\n   parameter integer C_AXI_ID_WIDTH           = 1,\n   parameter integer C_AXI_DATA_WIDTH         = 32,\n   parameter integer C_AXI_BUSER_WIDTH        = 1,\n   parameter integer C_AXI_RUSER_WIDTH        = 1,\n   parameter integer C_AXI_PROTOCOL           = 0,\n   parameter integer C_RESP                   = 2'b11,\n   parameter integer C_IGNORE_ID              = 0\n   )\n  (\n   input   wire                                         ACLK,\n   input   wire                                         ARESETN,\n   input   wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_AWID,\n   input   wire                                         S_AXI_AWVALID,\n   output  wire                                         S_AXI_AWREADY,\n   input   wire                                         S_AXI_WLAST,\n   input   wire                                         S_AXI_WVALID,\n   output  wire                                         S_AXI_WREADY,\n   output  wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_BID,\n   output  wire [1:0]                                   S_AXI_BRESP,\n   output  wire [C_AXI_BUSER_WIDTH-1:0]                 S_AXI_BUSER,\n   output  wire                                         S_AXI_BVALID,\n   input   wire                                         S_AXI_BREADY,\n   input   wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_ARID,\n   input   wire [((C_AXI_PROTOCOL == 1) ? 4 : 8)-1:0]   S_AXI_ARLEN,\n   input   wire                                         S_AXI_ARVALID,\n   output  wire                                         S_AXI_ARREADY,\n   output  wire [(C_AXI_ID_WIDTH-1):0]                  S_AXI_RID,\n   output  wire [(C_AXI_DATA_WIDTH-1):0]                S_AXI_RDATA,\n   output  wire [1:0]                                   S_AXI_RRESP,\n   output  wire [C_AXI_RUSER_WIDTH-1:0]                 S_AXI_RUSER,\n   output  wire                                         S_AXI_RLAST,\n   output  wire                                         S_AXI_RVALID,\n   input   wire                                         S_AXI_RREADY\n   );\n   \n  reg s_axi_awready_i;\n  reg s_axi_wready_i;\n  reg s_axi_bvalid_i;\n  reg s_axi_arready_i;\n  reg s_axi_rvalid_i;\n  \n  localparam P_WRITE_IDLE = 2'b00;\n  localparam P_WRITE_DATA = 2'b01;\n  localparam P_WRITE_RESP = 2'b10;\n  localparam P_READ_IDLE  = 2'b00;\n  localparam P_READ_START = 2'b01;\n  localparam P_READ_DATA  = 2'b10;\n  localparam integer  P_AXI4 = 0;\n  localparam integer  P_AXI3 = 1;\n  localparam integer  P_AXILITE = 2;\n   \n  assign S_AXI_BRESP = C_RESP;\n  assign S_AXI_RRESP = C_RESP;\n  assign S_AXI_RDATA = {C_AXI_DATA_WIDTH{1'b0}};\n  assign S_AXI_BUSER = {C_AXI_BUSER_WIDTH{1'b0}};\n  assign S_AXI_RUSER = {C_AXI_RUSER_WIDTH{1'b0}};\n  assign S_AXI_AWREADY = s_axi_awready_i;\n  assign S_AXI_WREADY = s_axi_wready_i;\n  assign S_AXI_BVALID = s_axi_bvalid_i;\n  assign S_AXI_ARREADY = s_axi_arready_i;\n  assign S_AXI_RVALID = s_axi_rvalid_i;\n  \n  generate\n  if (C_AXI_PROTOCOL == P_AXILITE) begin : gen_axilite\n    \n    reg s_axi_rvalid_en;\n    assign S_AXI_RLAST = 1'b1;\n    assign S_AXI_BID = 0;\n    assign S_AXI_RID = 0;\n    \n    always @(posedge ACLK) begin\n      if (~ARESETN) begin\n        s_axi_awready_i <= 1'b0;\n        s_axi_wready_i <= 1'b0;\n        s_axi_bvalid_i <= 1'b0;\n      end else begin\n        if (s_axi_bvalid_i) begin\n          if (S_AXI_BREADY) begin\n            s_axi_bvalid_i <= 1'b0;\n            s_axi_awready_i <= 1'b1;\n          end\n        end else if (S_AXI_WVALID & s_axi_wready_i) begin\n            s_axi_wready_i <= 1'b0;\n            s_axi_bvalid_i <= 1'b1;\n        end else if (S_AXI_AWVALID & s_axi_awready_i) begin\n          s_axi_awready_i <= 1'b0;\n          s_axi_wready_i <= 1'b1;\n        end else begin\n          s_axi_awready_i <= 1'b1;\n        end\n      end\n    end\n           \n    always @(posedge ACLK) begin\n      if (~ARESETN) begin\n        s_axi_arready_i <= 1'b0;\n        s_axi_rvalid_i <= 1'b0;\n        s_axi_rvalid_en <= 1'b0;\n      end else begin\n        if (s_axi_rvalid_i) begin\n          if (S_AXI_RREADY) begin\n            s_axi_rvalid_i <= 1'b0;\n            s_axi_arready_i <= 1'b1;\n          end\n        end else if (s_axi_rvalid_en) begin\n          s_axi_rvalid_en <= 1'b0;\n          s_axi_rvalid_i <= 1'b1;\n        end else if (S_AXI_ARVALID & s_axi_arready_i) begin\n          s_axi_arready_i <= 1'b0;\n          s_axi_rvalid_en <= 1'b1;\n        end else begin\n          s_axi_arready_i <= 1'b1;\n        end\n      end\n    end\n        \n  end else begin : gen_axi\n  \n    reg s_axi_rlast_i;\n    reg [(C_AXI_ID_WIDTH-1):0] s_axi_bid_i;\n    reg [(C_AXI_ID_WIDTH-1):0] s_axi_rid_i;\n    reg [((C_AXI_PROTOCOL == 1) ? 4 : 8)-1:0] read_cnt;\n    reg [1:0] write_cs;\n    reg [1:0] read_cs;\n  \n    assign S_AXI_RLAST = s_axi_rlast_i;\n    assign S_AXI_BID = C_IGNORE_ID ? 0 : s_axi_bid_i;\n    assign S_AXI_RID = C_IGNORE_ID ? 0 : s_axi_rid_i;\n  \n    always @(posedge ACLK) begin\n      if (~ARESETN) begin\n        write_cs <= P_WRITE_IDLE;\n        s_axi_awready_i <= 1'b0;\n        s_axi_wready_i <= 1'b0;\n        s_axi_bvalid_i <= 1'b0;\n        s_axi_bid_i <= 0;\n      end else begin\n        case (write_cs) \n          P_WRITE_IDLE: \n            begin\n              if (S_AXI_AWVALID & s_axi_awready_i) begin\n                s_axi_awready_i <= 1'b0;\n                if (C_IGNORE_ID == 0) s_axi_bid_i <= S_AXI_AWID;\n                s_axi_wready_i <= 1'b1;\n                write_cs <= P_WRITE_DATA;\n              end else begin\n                s_axi_awready_i <= 1'b1;\n              end\n            end\n          P_WRITE_DATA:\n            begin\n              if (S_AXI_WVALID & S_AXI_WLAST) begin\n                s_axi_wready_i <= 1'b0;\n                s_axi_bvalid_i <= 1'b1;\n                write_cs <= P_WRITE_RESP;\n              end\n            end\n          P_WRITE_RESP:\n            begin\n              if (S_AXI_BREADY) begin\n                s_axi_bvalid_i <= 1'b0;\n                s_axi_awready_i <= 1'b1;\n                write_cs <= P_WRITE_IDLE;\n              end\n            end\n        endcase\n      end\n    end\n  \n    always @(posedge ACLK) begin\n      if (~ARESETN) begin\n        read_cs <= P_READ_IDLE;\n        s_axi_arready_i <= 1'b0;\n        s_axi_rvalid_i <= 1'b0;\n        s_axi_rlast_i <= 1'b0;\n        s_axi_rid_i <= 0;\n        read_cnt <= 0;\n      end else begin\n        case (read_cs) \n          P_READ_IDLE: \n            begin\n              if (S_AXI_ARVALID & s_axi_arready_i) begin\n                s_axi_arready_i <= 1'b0;\n                if (C_IGNORE_ID == 0) s_axi_rid_i <= S_AXI_ARID;\n                read_cnt <= S_AXI_ARLEN;\n                s_axi_rlast_i <= (S_AXI_ARLEN == 0);\n                read_cs <= P_READ_START;\n              end else begin\n                s_axi_arready_i <= 1'b1;\n              end\n            end\n          P_READ_START:\n            begin\n              s_axi_rvalid_i <= 1'b1;\n              read_cs <= P_READ_DATA;\n            end\n          P_READ_DATA:\n            begin\n              if (S_AXI_RREADY) begin\n                if (read_cnt == 0) begin\n                  s_axi_rvalid_i <= 1'b0;\n                  s_axi_rlast_i <= 1'b0;\n                  s_axi_arready_i <= 1'b1;\n                  read_cs <= P_READ_IDLE;\n                end else begin\n                  if (read_cnt == 1) begin\n                    s_axi_rlast_i <= 1'b1;\n                  end\n                  read_cnt <= read_cnt - 1;\n                end\n              end\n            end\n        endcase\n      end\n    end\n  \n  end  \n  endgenerate\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand3_011c4fd1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nand3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    assign Y = ~(A & B & C);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clkgate_15f01913", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule clkgate (\n  input   clk_in,\n  input   test_mode,\n  input   clock_en,\n  input   FPGA_SOURCE,\n  output  clk_out\n);\n\nwire clk_enb;\n\n`ifdef FPGA_SOURCE\nassign clk_enb = 1'b1;\n`else\nassign clk_enb = (clk_in & (clock_en | test_mode));\n`endif\n\nassign clk_out = clk_in & clk_enb;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipeline_register_3bc69630", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipeline_register\n    (\n    input clock,\n    input clrn,\n    input d,\n    input ena,\n    output q\n    );\n\n    reg [2:0] stage_data;\n\n    always @(posedge clock) begin\n        if (clrn == 1'b0) begin\n            stage_data <= 3'b0;\n        end else if (ena == 1'b1) begin\n            stage_data[2] <= d;\n            stage_data[1] <= stage_data[2];\n            stage_data[0] <= stage_data[1];\n        end\n    end\n\n    assign q = stage_data[0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_42f1c617", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder(\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [3:0] c;\n    assign c[0] = cin;\n    \n    full_adder fa0(a[0], b[0], c[0], sum[0], c[1]);\n    full_adder fa1(a[1], b[1], c[1], sum[1], c[2]);\n    full_adder fa2(a[2], b[2], c[2], sum[2], c[3]);\n    full_adder fa3(a[3], b[3], c[3], sum[3], cout);\n\nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Control_Register_Block #_8ce8468d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Control_Register_Block #(\n  parameter n = 4, // number of control signals\n  parameter m = 2 // number of enable signals\n\n) (\n  input [n-1:0] ctrl,\n  output [m-1:0] en\n);\n\n\n// Define subsets of control signals for each enable signal\nparameter [n-1:0] en1_ctrls = 4'b0001;\nparameter [n-1:0] en2_ctrls = 4'b0011;\n\n// Implement the functionality of the control register block\nassign en[0] = (ctrl & en1_ctrls) == en1_ctrls;\nassign en[1] = (ctrl & en2_ctrls) == en2_ctrls;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dual_edge_triggered_ff_4de2d663", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule dual_edge_triggered_ff (\n    input clk,\n    input d,\n    output q\n);\n\nreg q;\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\nmodule top_module (\n    input clk,\n    input d,\n    output q\n);\n\ndual_edge_triggered_ff ff (\n    .clk(clk),\n    .d(d),\n    .q(q)\n);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "reg32_R0_c5fa8953", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule reg32_R0(Rout, clr, clk, BA_out, write_enable, write_value);\n\tinput clr,clk, write_enable, BA_out;\n\tinput [31:0] write_value;\n\toutput [31:0]Rout;\n\treg[31:0] Rout;\n\n\talways @ (posedge clk)begin\n\t\tif(clr) begin\n\t\t\tRout = 32'h00000000;\n\t\tend\n\t\tif(write_enable && !BA_out) begin\n\t\t\tRout = write_value;\n\t\tend\n\tend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipelined_adder_45ee7613", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipelined_adder (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\nwire [7:0] p, g, c;\n\nassign p = a ^ b;\nassign g = a & b;\nassign c[0] = 1'b0;\n\ngenvar i;\n\ngenerate\n    for (i = 1; i < 8; i = i + 1) begin : carry_lookahead\n        assign c[i] = g[i-1] | (p[i-1] & c[i-1]);\n    end\nendgenerate\n\nassign s = a + b + c;\n\nassign overflow = (a[7] == b[7]) && (a[7] != s[7]);\n\nendmodule\n\nmodule top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\npipelined_adder adder(a, b, s, overflow);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "single_port_ram #_a6c31fb1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule single_port_ram #(\n  parameter addr_width = 8,\n  parameter data_width = 8\n)(\n  input clock,\n  input [addr_width-1:0] addr,\n  input [data_width-1:0] data,\n  input we,\n  output reg [data_width-1:0] out\n);\n\n  parameter mem_depth = 1024;\n\n  reg [data_width-1:0] Mem [0:mem_depth-1];\n\n  always @(posedge clock) begin\n    if (we) begin\n      Mem[addr] <= data;\n    end\n    out <= Mem[addr];\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "audio_codec_782178ec", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule audio_codec (\n  input [n-1:0] in,\n  input clk, \n  input ctrl_in,\n  output [m-1:0] out,\n  output reg ctrl_out \n);\n\nparameter n = 16; \nparameter m = 16; \nparameter fs = 44100; \nparameter bitrate = 128; \nparameter mode = \"MP3\"; \n\nreg [m-1:0] out_reg; \nassign out = out_reg; \n\nalways @ (posedge clk) begin\n  if (ctrl_in == 1'b0) begin\n    ctrl_out <= 1'b0; \n    out_reg <= {16{1'b0}}; \n  end else begin\n    ctrl_out <= 1'b1; \n    out_reg <= {16{1'b0}}; \n  end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mc_ctrl_e6888511", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mc_ctrl (\n\tclk\t\t,\n\trstn\t\t,\n\tmc_start_i\t\t,\n\tmc_done_o\t\t,\n  mvd_access_o    ,\n\tchroma_start_o\t\t,\n\tchroma_sel_o\t\t,\n\tchroma_done_i\t\t,\n\ttq_start_o\t\t,\n\ttq_sel_o\t\t,\n\ttq_done_i\t\t\n);\n\n\ninput \t [1-1:0] \t clk \t         ; // clk signal \ninput \t [1-1:0] \t rstn \t         ; // asynchronous reset\ninput \t [1-1:0] \t mc_start_i \t ; // mc start \noutput \t [1-1:0] \t mc_done_o \t ; // mc done \noutput             mvd_access_o ;\noutput \t [1-1:0] \t chroma_start_o  ; // chroma interpolation start \noutput \t [1-1:0] \t chroma_sel_o \t ; // chroma interpolation select: 0:cb, 1:cr\ninput \t [1-1:0] \t chroma_done_i \t ; // chroma interpolation done \noutput \t [1-1:0] \t tq_start_o \t ; // tq start \noutput \t [2-1:0] \t tq_sel_o \t ; // tq sel: 00:luma, 10:cb, 11:cr\ninput \t [1-1:0] \t tq_done_i \t ; // tq done \n\n\nparameter IDLE         = 3'd0;\nparameter TQ_LUMA      = 3'd1;\nparameter MC_CB        = 3'd2;\nparameter TQ_CB        = 3'd3;\nparameter MC_CR        = 3'd4;\nparameter TQ_CR        = 3'd5;\nparameter DONE         = 3'd6;\n\nreg      [3-1:0]        current_state, next_state;\n\nalways @(*) begin\n                next_state = IDLE;\n    case(current_state) \n        IDLE : begin\n            if ( mc_start_i)\n                next_state = TQ_LUMA;\n            else\n                next_state = IDLE;\n        end\n        TQ_LUMA: begin\n            if ( tq_done_i)\n                next_state = MC_CB;\n            else\n                next_state = TQ_LUMA;\n        end\n        MC_CB: begin\n            if ( chroma_done_i)\n                next_state = TQ_CB;\n            else\n                next_state = MC_CB;\n        end\n        TQ_CB: begin\n            if ( tq_done_i)\n                next_state = MC_CR;\n            else\n                next_state = TQ_CB;\n        end\n        MC_CR: begin\n            if ( chroma_done_i)\n                next_state = TQ_CR;\n            else\n                next_state = MC_CR;\n        end\n        TQ_CR: begin\n            if ( tq_done_i)\n                next_state = DONE;\n            else\n                next_state = TQ_CR;\n        end\n        DONE: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n\nassign \t mc_done_o \t = (current_state == DONE); \nassign \t chroma_start_o  = (current_state == TQ_LUMA && next_state == MC_CB)  ||\n                           (current_state == TQ_CB   && next_state == MC_CR)  ; \nassign \t chroma_sel_o \t = (current_state == MC_CR) ? 1'b1 : 1'b0; \nassign \t tq_start_o \t = (current_state == IDLE    && next_state == TQ_LUMA)||\n                           (current_state == MC_CB   && next_state == TQ_CB)  || \n                           (current_state == MC_CR   && next_state == TQ_CR)  ; \nassign \t tq_sel_o \t = (current_state == TQ_LUMA) ? 2'b00 :\n                           (current_state == TQ_CB  ) ? 2'b10 :\n                           (current_state == TQ_CR  ) ? 2'b11 : 2'b00;\n\nassign mvd_access_o = ( current_state == TQ_LUMA );\n\n\nalways @ (posedge clk or negedge rstn) begin\n    if(~rstn) begin\n        current_state <= IDLE;\n    end\n    else begin\n        current_state <= next_state;\n    end\nend\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tracking_camera_system_jtag_uart_0_sim_scfifo_r_9b9d6bc6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule tracking_camera_system_jtag_uart_0_sim_scfifo_r (\n  // inputs:\n  input clk,\n  input fifo_rd,\n  input rst_n,\n\n  // outputs:\n  output fifo_EF,\n  output [7:0] fifo_rdata,\n  output rfifo_full,\n  output [5:0] rfifo_used,\n  output [6:0] rfifo_entries\n);\n  reg [31:0] bytes_left;\n  reg fifo_rd_d;\n\n  // Generate rfifo_entries for simulation\n  assign rfifo_entries = bytes_left[5:0];  // Fix the width\n\n  // Decrement bytes_left on read\n  always @(posedge clk) begin\n    if (fifo_rd_d) begin\n      bytes_left <= bytes_left - 1;\n    end\n  end\n\n  // Set fifo_rd_d on reset\n  always @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n      fifo_rd_d <= 0;\n    end else begin\n      fifo_rd_d <= fifo_rd;\n    end\n  end\n\n  // Set fifo_EF and rfifo_full\n  assign fifo_EF = (bytes_left == 0);\n  assign rfifo_full = (bytes_left > 64);\n\n  // Set fifo_rdata\n  assign fifo_rdata = 8'b0;  // Initialize to 0 for now\n\n  // Set rfifo_used\n  assign rfifo_used = 64 - rfifo_entries;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_02af291a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo\n   #(\n  \tparameter adr_width = 4,\n\tparameter dat_width = 8\n   )\n   (\n    input  clk, reset,\n    input  rd, wr,\n    input  [dat_width-1:0] data_in,\n    output [dat_width-1:0] data_out,\n    output empty, \n    output full\n   );\n\n   \n   parameter depth = (1 << adr_width);\n\n   reg [dat_width-1:0] array_reg [depth-1:0];reg [adr_width-1:0] w_ptr_reg, w_ptr_next;\n   reg [adr_width-1:0] r_ptr_reg, r_ptr_next;\n   reg full_reg, empty_reg, full_next, empty_next;\n   wire wr_en;\n\treg\t[1:0]\torden;\n\n\n   assign data_out = array_reg[r_ptr_reg];\n   assign wr_en = wr & ~full_reg;\n\n   assign full = full_reg;\n   assign empty = empty_reg;\n\n   always @(posedge clk) begin\n      if (wr_en)\n         array_reg[w_ptr_reg] <= data_in;\n   end\n\n   always @(posedge clk, posedge reset) begin\n      if (reset)\n         begin\n            w_ptr_reg <= 0;\n            r_ptr_reg <= 0;\n            full_reg <= 1'b0;\n            empty_reg <= 1'b1;\n         end\n      else\n         begin\n            w_ptr_reg <= w_ptr_next;\n            r_ptr_reg <= r_ptr_next;\n            full_reg <= full_next;\n            empty_reg <= empty_next;\n         end\n   end\n\n\talways @(posedge clk)\n\tbegin\n\t\tif(!wr&&rd)\n\t\tbegin\n\t\t\torden = 2'b01;\n\t\tend\n\t\tif(wr&&!rd)\n\t\tbegin\n\t\t\torden = 2'b10;\n\t\tend\n\t\tif(wr&&rd)\n\t\tbegin\n\t\t\torden = 2'b11;\n\t\tend\n\tend\n\n   \n   always @(posedge clk)\n   begin\n      if (reset) begin\n\tw_ptr_next =  0;\n        r_ptr_next =  0;       \n      end else begin\n\t      full_next = full_reg;\n\t      empty_next = empty_reg;\n\t      case (orden)\n\t\t 2'b01: if (~empty_reg) begin\n\t\t          r_ptr_next = r_ptr_reg + 1;\n\t\t          full_next = 1'b0;\n\t\t          if (r_ptr_next==w_ptr_reg)\n\t\t             empty_next = 1'b1;\n\t\t       end\n\t\t 2'b10: if (~full_reg) begin\n\t\t          w_ptr_next = w_ptr_reg + 1;\n\t\t          empty_next = 1'b0;\n\t\t          if (w_ptr_next==r_ptr_reg)\n\t\t             full_next = 1'b1;\n\t\t       end\n\t\t 2'b11: begin\n\t\t       w_ptr_next =  w_ptr_reg + 1;\n\t\t       r_ptr_next = r_ptr_reg + 1;\n\t\t    end\n\t      endcase\n\tend\n   end\n\n\n  \nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "valve_controller_2e38d3f6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule valve_controller\n  (input clk, input reset, input clear,\n   input shutoff,\n   input [35:0] data_i, input src_rdy_i, output dst_rdy_o,\n   output [35:0] data_o, output src_rdy_o, input dst_rdy_i);\n   \n   reg shutoff_int, active;\n   wire active_next = (src_rdy_i & dst_rdy_o) ? ~data_i[33] : active;\n\n   assign data_o = data_i;\n\n   assign dst_rdy_o = shutoff_int ? 1'b1 : dst_rdy_i;\n   assign src_rdy_o = shutoff_int ? 1'b0 : src_rdy_i;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       active <= 0;\n     else\n       active <= active_next;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       shutoff_int <= 0;\n     else if(~active_next)\n       shutoff_int <= shutoff;\n   \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mealy_fsm_890a9259", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mealy_fsm (\n  input clk,\n  input reset,\n  input in1,\n  input in2,\n  output reg out\n);\n\n  parameter A = 2'b00;\n  parameter B = 2'b01;\n  parameter C = 2'b10;\n  parameter D = 2'b11;\n  \n  reg [1:0] state, next_state;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      state <= A;\n    end else begin\n      state <= next_state;\n    end\n  end\n  \n  always @(*) begin\n    case (state)\n      A: begin\n        if (in1 == 1 && in2 == 1) begin\n          next_state = D;\n          out = 0;\n        end else begin\n          if (in1 == 1) begin\n            next_state = C;\n            out = 1;\n          end else if (in2 == 1) begin\n            next_state = B;\n            out = 0;\n          end else begin\n            next_state = A;\n            out = 0;\n          end\n        end\n      end\n      B: begin\n        if (in1 == 1 && in2 == 1) begin\n          next_state = D;\n          out = 0;\n        end else begin\n          if (in1 == 1) begin\n            next_state = C;\n            out = 1;\n          end else if (in2 == 1) begin\n            next_state = B;\n            out = 0;\n          end else begin\n            next_state = B;\n            out = 0;\n          end\n        end\n      end\n      C: begin\n        if (in1 == 1 && in2 == 1) begin\n          next_state = D;\n          out = 0;\n        end else begin\n          if (in1 == 1) begin\n            next_state = C;\n            out = 1;\n          end else if (in2 == 1) begin\n            next_state = B;\n            out = 0;\n          end else begin\n            next_state = C;\n            out = 1;\n          end\n        end\n      end\n      D: begin\n        if (in1 == 1 && in2 == 1) begin\n          next_state = D;\n          out = 0;\n        end else begin\n          if (in1 == 1) begin\n            next_state = C;\n            out = 1;\n          end else if (in2 == 1) begin\n            next_state = B;\n            out = 0;\n          end else begin\n            next_state = D;\n            out = 0;\n          end\n        end\n      end\n      default: begin\n        next_state = A;\n        out = 0;\n      end\n    endcase\n  end\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "delay_gate_b5c69546", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule delay_gate (\n  input clk,\n  input data,\n  output delayed_data\n);\n\n  parameter DELAY = 1;\n  reg [DELAY-1:0] data_buffer;\n  reg [DELAY-1:0] delayed_data_buffer;\n  reg [DELAY-1:0] delay_counter;\n\n  always @(posedge clk) begin\n    delay_counter <= delay_counter + 1;\n    if (delay_counter == DELAY) begin\n      delayed_data_buffer <= data_buffer;\n    end\n    data_buffer <= data;\n  end\n\n  assign delayed_data = delayed_data_buffer[DELAY-1];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Round_Sgf_Dec_84a34a78", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Round_Sgf_Dec(\n    input wire clk,\n    input wire [1:0] Data_i,\n    input wire [1:0] Round_Type_i,\n    input wire Sign_Result_i,\n    output reg Round_Flag_o\n    );\n    \n    always @*\n    \tcase ({Sign_Result_i,Round_Type_i,Data_i})\n    \t\n\n\t\t\n\n    \t\n\n    \t5'b10101: Round_Flag_o <=1;  \n    \t5'b10110: Round_Flag_o <=1;  \n    \t5'b10111: Round_Flag_o <=1;  \n\n    \t5'b01001: Round_Flag_o <=1;  \n    \t5'b01010: Round_Flag_o <=1;  \n    \t5'b01011: Round_Flag_o <=1;  \n\n\n    \t\n\n    \tdefault: Round_Flag_o <=0;\n\n    \tendcase\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multi_input_output_875d8aff", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multi_input_output (\n    input [7:0] A,\n    input [7:0] B,\n    input [7:0] C,\n    input [7:0] D,\n    input [7:0] E,\n    input [7:0] F,\n    input [7:0] G,\n    input [7:0] H,\n    output [7:0] Y\n);\n\n    assign Y = (A + B) - (C + D) + (E + F) - (G + H);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "input_output_module_9e3e7a03", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule input_output_module(\n    input wire CLK,\n    output reg [6:0] Q\n);\n\nreg [6:0] inputs_reg;\nwire [6:0] inputs_delayed;\n\nalways @(posedge CLK) begin\n    inputs_reg <= Q;\nend\n\nassign inputs_delayed[0] = inputs_reg[6];\nassign inputs_delayed[1] = inputs_reg[5];\nassign inputs_delayed[2] = inputs_reg[4];\nassign inputs_delayed[3] = inputs_reg[3];\nassign inputs_delayed[4] = inputs_reg[2];\nassign inputs_delayed[5] = inputs_reg[1];\nassign inputs_delayed[6] = inputs_reg[0];\n\nreg [6:0] delay_counter;\nreg [2:0] input_counter;\nreg [1:0] state_counter;\n\nalways @(posedge CLK) begin\n    delay_counter <= delay_counter + 1;\n    if (delay_counter == 20) begin\n        delay_counter <= 0;\n        input_counter <= input_counter + 1;\n        if (input_counter == 7) begin\n            input_counter <= 0;\n            state_counter <= state_counter + 1;\n            if (state_counter == 3) begin\n                state_counter <= 0;\n            end\n        end\n    end\nend\n\nreg [6:0] inputs_pattern_0 = 7'b1000000;\nreg [6:0] inputs_pattern_1 = 7'b0111111;\nreg [6:0] inputs_pattern_2 = 7'bxxxxxxx;\n\nalways @(posedge CLK) begin\n    case (state_counter)\n        0: Q <= inputs_pattern_0;\n        1: Q <= inputs_pattern_1;\n        2: Q <= inputs_pattern_2;\n    endcase\nend\n\nwire Q_delayed;\nreg Q_delayed_reg;\nassign Q_delayed = Q;\n\nalways @(posedge CLK) begin\n    Q_delayed_reg <= Q;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_to_one_mux_9ccde0e5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_to_one_mux(\n    input [3:0] in,\n    input [1:0] sel,\n    output reg out\n);\n\nalways @ (*)\n    case(sel)\n        2'b00: out = in[0];\n        2'b01: out = in[1];\n        2'b10: out = in[2];\n        2'b11: out = in[3];\n        default: out = 1'b0;\n    endcase\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "v468a05_e9b64b5c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule v468a05 (\n  input [31:0] ve841af,\n  output [7:0] vdd0469,\n  output [7:0] v4ba85d,\n  output [7:0] vf93ecb,\n  output [7:0] vc6471a\n);\n\n  // Instantiate v468a05_v9a2a06 module\n  v468a05_v9a2a06 v9a2a06 (\n    .i(ve841af),\n    .o0(vdd0469),\n    .o1(vf93ecb),\n    .o2(v4ba85d),\n    .o3(vc6471a)\n  );\n\nendmodule\nmodule v468a05_v9a2a06 (\n  input [31:0] i,\n  output [7:0] o0,\n  output [7:0] o1,\n  output [7:0] o2,\n  output [7:0] o3\n);\n\n  wire [31:0] w0;\n  wire [31:0] w1;\n  wire [31:0] w2;\n  wire [31:0] w3;\n  wire [31:0] w4;\n\n  // Assign input to wire\n  assign w0 = i;\n\n  // Xors of i\n  assign w1 = i ^ 32'h09436c12;\n  assign w2 = i ^ 32'h1423bf56;\n  assign w3 = i ^ 32'h22fb9439;\n  assign w4 = i ^ 32'h30648dbc;\n\n  // Assign wires to outputs\n  assign o0 = w1[7:0];\n  assign o1 = w2[7:0];\n  assign o2 = w3[7:0];\n  assign o3 = w4[7:0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_f16cff88", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder (\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] sum,\n    output carry_out\n);\n\n    wire [8:0] temp_sum;\n    assign temp_sum = A + B;\n    assign carry_out = temp_sum[8];\n    assign sum = temp_sum[7:0];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_b30ff500", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module(\n    input [31:0] a,\n    input [31:0] b,\n    input sel,\n    output [31:0] sum\n);\n\nwire [7:0] adder1_out;\nwire [7:0] adder2_out;\nwire [15:0] adder3_out;\nwire [3:0] mux_out;\n\nmux_3_4 mux_inst(\n    .a(a[23]),\n    .b(a[15]),\n    .c(a[7]),\n    .sel(sel),\n    .y(mux_out)\n);\n\nadd_8 adder1_inst(\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .sum(adder1_out)\n);\n\nadd_8 adder2_inst(\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .sum(adder2_out)\n);\n\nadd_16 adder3_inst(\n    .a(a[31:16]),\n    .b(b[31:16]),\n    .sum(adder3_out)\n);\n\nassign sum = sel ? {mux_out, a[31:23]} + b : a + b;\n\nendmodule\n\nmodule mux_3_4(\n    input a,\n    input b,\n    input c,\n    input sel,\n    output [3:0] y\n);\n\nassign y[0] = (~sel & ~a) & b;\nassign y[1] = (~sel & a) & c;\nassign y[2] = (sel & ~a) & b;\nassign y[3] = (sel & a) & c;\n\nendmodule\n\nmodule add_8(\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n\nassign sum = a + b;\n\nendmodule\n\nmodule add_16(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n\nadd_8 adder1_inst(\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .sum(sum[7:0])\n);\n\nadd_8 adder2_inst(\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .sum(sum[15:8])\n);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "led_flasher_c6151c8d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule led_flasher\n          (\n           clk,\n\t\t\t  LED_flash,\n\t\t\t  LED_out\n          );\n\t\t\t \ninput clk;\ninput LED_flash;\noutput LED_out;\n\t\t\t \nparameter HIGH_PERIOD = 600; parameter LOW_PERIOD = 600; parameter s_reset = 2'd0;\nparameter s_off = 2'd1;\nparameter s_on = 2'd2;\n\n\nreg[15:0] cnt = 0;\nreg [1:0] state = 2'd0;\n\nalways @(posedge clk) begin\n\t\tcase(state)\n\t\t\ts_reset:\n\t\t\t\tbegin\n\t\t\t\t\tcnt  <= 16'd0;\n\t\t\t\t\tstate <= (LED_flash) ? s_on : s_reset;\n\t\t\t\tend\n\t\t\t\n\t\t\ts_off: \n\t\t\t\tbegin\n\t\t\t\t\tstate <= (cnt == LOW_PERIOD && LED_flash) ? s_on : \n\t\t\t\t\t\t\t\t(!LED_flash) ? s_reset : \n\t\t\t\t\t\t\t\ts_off;\n\t\t\t\t\tcnt <= (cnt == LOW_PERIOD && LED_flash) ? 16'd0 : cnt + 16'd1;\n\t\t\t\tend\n\t\t\t\n\t\t\ts_on: \n\t\t\t\tbegin\n\t\t\t\t\tstate <= (cnt == HIGH_PERIOD && LED_flash) ? s_off : \n\t\t\t\t\t\t\t\t(!LED_flash) ? s_reset : \n\t\t\t\t\t\t\t\ts_on;\n\t\t\t\t\tcnt <= (cnt == HIGH_PERIOD && LED_flash) ? 16'd0 : cnt + 16'd1;\n\t\t\t\tend\n\t\tendcase\nend\n\nassign LED_out = (state == s_on);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_d8bdf159", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule d_ff(\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\nmodule xor_gate(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_xor\n);\n    assign out_xor = a ^ b;\nendmodule\nmodule and_gate(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and\n);\n    assign out_and = a & b;\nendmodule\nmodule top_module( \n    input [2:0] a,\n    input [2:0] b,\n    input select,\n    input clk,\n    output reg [2:0] out_xor_bitwise,\n    output reg out_and_logical,\n    output reg [5:0] out_not\n);\n    wire [2:0] xor_out;\n    wire [2:0] and_out;\n    wire [2:0] a_not;\n    wire [2:0] b_not;\n\n    xor_gate xor_inst(.a(a), .b(b), .out_xor(xor_out));\n    and_gate and_inst(.a(a), .b(b), .out_and(and_out));\n    d_ff d_ff_inst_a(.clk(clk), .d(~a[0]), .q(a_not[0]));\n    d_ff d_ff_inst_b(.clk(clk), .d(~b[0]), .q(b_not[0]));\n    d_ff d_ff_inst_a_1(.clk(clk), .d(~a[1]), .q(a_not[1]));\n    d_ff d_ff_inst_b_1(.clk(clk), .d(~b[1]), .q(b_not[1]));\n    d_ff d_ff_inst_a_2(.clk(clk), .d(~a[2]), .q(a_not[2]));\n    d_ff d_ff_inst_b_2(.clk(clk), .d(~b[2]), .q(b_not[2]));\n\n    always @(*) begin\n        if (select == 1'b1) begin\n            out_xor_bitwise <= xor_out;\n            out_and_logical <= and_out[0];\n            out_not[2:0] <= b_not;\n            out_not[5:3] <= a_not;\n        end\n        else begin\n            out_xor_bitwise <= 3'b0;\n            out_and_logical <= 1'b0;\n            out_not <= {~a, ~b, 3'b0, 3'b0};\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "async_reset_release_bdce19e3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule async_reset_release (\n  input clk,\n  input rst,\n  input in,\n  output out\n);\n\n  reg out_reg; // register to hold the output value\n\n  always @(posedge clk) begin\n    if (rst) begin // reset state\n      out_reg <= 0;\n    end else begin // release state\n      out_reg <= in;\n    end\n  end\n\n  assign out = out_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sum_4bit_f2b6dd42", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sum_4bit(input [3:0] input_a, output reg [4:0] output_sum);\n\nalways @(*) begin\n    output_sum = {1'b0, input_a} + 4'b0001;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__a21oi_e67edd80", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__a21oi (\n    Y ,\n    A1,\n    A2,\n    B1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out  ;\n    wire nor0_out_Y;\n\n    and and0 (and0_out  , A1, A2         );\n    nor nor0 (nor0_out_Y, B1, and0_out   );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__nor3_62f7bd9b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__nor3 (\n    Y,\n    A,\n    B,\n    C\n);\n\n    output Y;\n    input  A;\n    input  B;\n    input  C;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire nor0_out_Y;\n\n    nor nor0 (nor0_out_Y, C, A, B        );\n    buf buf0 (Y         , nor0_out_Y     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__4ae7e6a2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [1:0] d,\n    output [4:0] q\n);\n\nreg [2:0] shift_reg_async;\nreg [1:0] shift_reg_sync;\n\n// Asynchronous reset for the 3-bit shift register\nalways @(posedge clk, negedge reset) begin\n    if (!reset) begin\n        shift_reg_async <= 3'b0;\n    end else begin\n        shift_reg_async <= {shift_reg_async[1:0], d};\n    end\nend\n\n// Synchronous reset for the 2-bit shift register\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_reg_sync <= 2'b0;\n    end else begin\n        shift_reg_sync <= {shift_reg_sync[0], d[1]};\n    end\nend\n\n// Functional module that combines the two shift registers\nassign q = {shift_reg_async, shift_reg_sync};\n\nendmodule\n\n// Inputs and outputs for the two given modules\nmodule shift_register_async (\n    input clk,\n    input reset,\n    input d,\n    output reg [2:0] q\n);\n\n// Asynchronous reset for the 3-bit shift register\nalways @(posedge clk, negedge reset) begin\n    if (!reset) begin\n        q <= 3'b0;\n    end else begin\n        q <= {q[1:0], d};\n    end\nend\n\nendmodule\n\nmodule shift_register_sync (\n    input clk,\n    input reset,\n    input [1:0] d,\n    output reg [1:0] q\n);\n\n// Synchronous reset for the 2-bit shift register\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 2'b0;\n    end else begin\n        q <= {q[0], d[1]};\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "macc_simple_arst_clr_ena_46465a41", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule macc_simple_arst_clr_ena (\n    input  wire        clk,\n    input  wire        rst,\n    input  wire        clr,\n    input  wire        ena,\n    input  wire [ 7:0] A,\n    input  wire [ 7:0] B,\n    output reg  [15:0] Z\n);\n\n    always @(posedge clk or posedge rst)\n        if (rst)     Z <= 0;\n        else if (ena) begin\n            if (clr) Z <=     (A * B);\n            else     Z <= Z + (A * B);\n        end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "hard_sync #_07b32bb4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule hard_sync #(\n    parameter INIT = 1'b0, // optional initialization value\n    parameter IS_CLK_INVERTED = 1'b0, // optional clock inversion\n    parameter LATENCY = 2 // latency of 2 or 3 clock cycles\n)(\n    output reg DOUT,\n    input CLK,\n    input DIN\n);\n\n    reg [2:0] DIN_reg; // register to store input data\n\n    always @(posedge CLK) begin\n        if (IS_CLK_INVERTED) begin // invert clock if enabled\n            DIN_reg <= {DIN_reg[1:0], ~DIN};\n        end else begin\n            DIN_reg <= {DIN_reg[1:0], DIN};\n        end\n\n        if (LATENCY == 2) begin // synchronize output after 2 clock cycles\n            DOUT <= DIN_reg[1];\n        end else begin // synchronize output after 3 clock cycles\n            DOUT <= DIN_reg[2];\n        end\n    end\n\n    initial begin\n        DIN_reg <= {INIT, INIT, INIT}; // initialize register with INIT value\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "temperature_sensor_5bf1a5d1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule temperature_sensor (\n  input [9:0] analog_in,\n  output reg [3:0] temp_range\n);\n\n  always @* begin\n    case(analog_in)\n      0: temp_range = 4'b0000; // below 0 degrees Celsius\n      1: temp_range = 4'b0001; // below 0 degrees Celsius\n      2: temp_range = 4'b0001; // below 0 degrees Celsius\n      3: temp_range = 4'b0001; // below 0 degrees Celsius\n      4: temp_range = 4'b0001; // below 0 degrees Celsius\n      5: temp_range = 4'b0001; // below 0 degrees Celsius\n      6: temp_range = 4'b0001; // below 0 degrees Celsius\n      7: temp_range = 4'b0001; // below 0 degrees Celsius\n      8: temp_range = 4'b0001; // below 0 degrees Celsius\n      9: temp_range = 4'b0001; // below 0 degrees Celsius\n      10: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      11: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      12: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      13: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      14: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      15: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      16: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      17: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      18: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      19: temp_range = 4'b0010; // 0 to 10 degrees Celsius\n      20: temp_range = 4'b0011; // 10 to 20 degrees Celsius\n      21: temp_range = 4'b0011; // 10 to 20 degrees Celsius\n      22: temp_range = 4'b0011; // 10 to 20 degrees Celsius\n      23: temp_range = 4'b0011; // 10 to 20 degrees Celsius\n      24: temp_range = 4'b0011; // 10 to 20 degrees Celsius\n      25: temp_range = 4'b0100; // above 20 degrees Celsius\n      26: temp_range = 4'b0100; // above 20 degrees Celsius\n      27: temp_range = 4'b0100; // above 20 degrees Celsius\n      28: temp_range = 4'b0100; // above 20 degrees Celsius\n      29: temp_range = 4'b0100; // above 20 degrees Celsius\n      30: temp_range = 4'b0100; // above 20 degrees Celsius\n      31: temp_range = 4'b0100; // above 20 degrees Celsius\n      32: temp_range = 4'b0100; // above 20 degrees Celsius\n      33: temp_range = 4'b0100; // above 20 degrees Celsius\n      34: temp_range = 4'b0100; // above 20 degrees Celsius\n      default: temp_range = 4'b0000; // below 0 degrees Celsius (default case)\n    endcase\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vending_machine_3ccdf13c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule vending_machine (\n    input clk,\n    input reset,\n    input [2:0] coin,\n    input [1:0] product,\n    output reg dispense,\n    output reg [2:0] change,\n    output reg [3:0] display\n);\n\n    // Constants for product costs\n    localparam COST_A = 2;\n    localparam COST_B = 3;\n    localparam COST_C = 4;\n\n    // Registers for amount inserted and product cost\n    reg [2:0] amount_inserted;\n    reg [2:0] product_cost;\n\n    // Register for excess change\n    reg [2:0] excess_change;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            amount_inserted <= 0;\n            product_cost <= 0;\n            excess_change <= 0;\n            dispense <= 0;\n            change <= 0;\n            display <= 0;\n        end else begin\n            // Update amount inserted\n            case (coin)\n                1: amount_inserted <= amount_inserted + 5;\n                2: amount_inserted <= amount_inserted + 10;\n                3: amount_inserted <= amount_inserted + 25;\n                4: amount_inserted <= amount_inserted + 50;\n                5: amount_inserted <= amount_inserted + 100;\n            endcase\n\n            // Update product cost\n            case (product)\n                1: product_cost <= COST_A;\n                2: product_cost <= COST_B;\n                3: product_cost <= COST_C;\n            endcase\n\n            // Calculate change\n            excess_change <= amount_inserted - product_cost;\n            change <= excess_change;\n\n            // Dispense product if exact amount inserted\n            if (amount_inserted >= product_cost) begin\n                dispense <= 1;\n                amount_inserted <= amount_inserted - product_cost;\n            end else begin\n                dispense <= 0;\n            end\n\n            // Update display\n            display <= {amount_inserted, product_cost};\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_logic_op_955ee02c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_logic_op (\n    input [2:0] in,\n    output out\n);\n\n    wire [1:0] and_out;\n    wire and0_out;\n    wire and1_out;\n    wire and2_out;\n    wire or0_out;\n    wire or1_out;\n    wire not0_out;\n    wire not1_out;\n    wire not2_out;\n    wire xor0_out;\n    wire xor1_out;\n    wire xor2_out;\n    wire xor3_out;\n    wire xor4_out;\n    wire xor5_out;\n    wire xor6_out;\n\n    // AND gates\n    and and0 (and0_out, in[0], in[1]);\n    and and1 (and1_out, in[0], in[2]);\n    and and2 (and2_out, in[1], in[2]);\n\n    // XOR gates\n    xor xor0 (xor0_out, in[0], in[1]);\n    xor xor1 (xor1_out, in[0], in[2]);\n    xor xor2 (xor2_out, in[1], in[2]);\n    xor xor3 (xor3_out, xor0_out, in[2]);\n    xor xor4 (xor4_out, xor1_out, in[1]);\n    xor xor5 (xor5_out, xor2_out, in[0]);\n    xor xor6 (xor6_out, xor3_out, xor4_out, xor5_out);\n\n    // OR gates\n    or or0 (or0_out, and0_out, and1_out);\n    or or1 (or1_out, or0_out, and2_out, xor6_out);\n\n    // NOT gates\n    not not0 (not0_out, in[0]);\n    not not1 (not1_out, in[1]);\n    not not2 (not2_out, in[2]);\n\n    // Final output\n    assign out = (not1_out & not2_out & or1_out ) | (not0_out & not2_out & or1_out ) | (not0_out & not1_out & or1_out) | (not0_out & not1_out & not2_out);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and4_56dab7a1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y\n);\n\n    wire and1_out;\n    wire and2_out;\n\n    and and1 (and1_out, A, B);\n    and and2 (and2_out, C, D);\n    and and3 (Y, and1_out, and2_out);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_16bit_2416e7b0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register_16bit (\n  input clk,\n  input resetn,\n  input parallel_load,\n  input serial_in,\n  output serial_out\n);\n\n  reg [15:0] shift_reg;\n\n  always @(posedge clk or negedge resetn) begin\n    if (!resetn) begin\n      shift_reg <= 16'b0;\n    end\n    else if (parallel_load) begin\n      shift_reg <= serial_in;\n    end\n    else begin\n      shift_reg <= {shift_reg[14:0], 1'b0};\n    end\n  end\n\n  assign serial_out = shift_reg[15];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lpm_ram_dq_9a0c8061", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule lpm_ram_dq (\n    address,\n    inclock,\n    outclock,\n    data,\n    we,\n    q\n);\n\nparameter lpm_width = 8;\nparameter lpm_widthad = 11;\nparameter lpm_indata = \"REGISTERED\";            parameter lpm_address_control = \"REGISTERED\";   parameter lpm_outdata = \"UNREGISTERED\";         parameter lpm_hint = \"USE_EAB=ON\";              localparam dw = lpm_width;\nlocalparam aw = lpm_widthad;\n\ninput [aw-1:0] address;\ninput inclock;\ninput outclock;\ninput [dw-1:0] data;\ninput we;\noutput [dw-1:0] q;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign q = mem[addr_reg];\n\nalways @(posedge inclock)\n    addr_reg <= #1 address;\n\nalways @(posedge inclock)\n\tif (we)\n\t\tmem[address] <= #1 data;\n\nendmodule\n\nmodule altqpram (\n\twraddress_a,\n\tinclocken_a,\n\twraddress_b,\n\twren_a,\n\tinclocken_b,\n\twren_b,\n\tinaclr_a,\n\tinaclr_b,\n\tinclock_a,\n\tinclock_b,\n\tdata_a,\n\tdata_b,\n\tq_a,\n\tq_b \n);\n\nparameter width_write_a = 8;\nparameter widthad_write_a = 11;\nparameter width_write_b = 8;\nparameter widthad_write_b = 11;\n\nlocalparam dw = width_write_a;\nlocalparam aw = widthad_write_a;\n\ninput inclock_a, inaclr_a, inclocken_a, wren_a, inclock_b, inaclr_b, inclocken_b, wren_b;\ninput [dw-1:0] data_a, data_b;\noutput [dw-1:0] q_a, q_b;\ninput [aw-1:0] wraddress_a, wraddress_b;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg_a;\t\treg\t[aw-1:0]\taddr_reg_b;\t\tassign q_a = mem[addr_reg_a][dw-1:0];\nassign q_b = mem[addr_reg_b][dw-1:0];\n\nalways @(posedge inclock_a or posedge inaclr_a)\n    if ( inaclr_a == 1'b1 )\n        addr_reg_a <= #1 {aw{1'b0}};\n    else if ( inclocken_a )\n        addr_reg_a <= #1 wraddress_a;\n\nalways @(posedge inclock_b or posedge inaclr_b)\n    if ( inaclr_b == 1'b1 )\n        addr_reg_b <= #1 {aw{1'b0}};\n    else if ( inclocken_b )\n        addr_reg_b <= #1 wraddress_b;\n\nalways @(posedge inclock_a)\n\tif (inclocken_a && wren_a)\n\t\tmem[wraddress_a] <= #1 data_a;\n\nalways @(posedge inclock_b)\n\tif (inclocken_b && wren_b)\n\t\tmem[wraddress_b] <= #1 data_b;\n\nendmodule\nmodule RAMB16_S36_S36 (\n    CLKA,\n    SSRA,\n    ADDRA,\n    DIA,\n    DIPA,\n    ENA,\n    WEA,\n    DOA,\n    DOPA,\n\n    CLKB,\n    SSRB,\n    ADDRB,\n    DIB,\n    DIPB,\n    ENB,\n    WEB,\n    DOB,\n    DOPB\n);\n\nparameter dw = 32;\nparameter dwp = 4;\nparameter aw = 9;\n\ninput CLKA, SSRA, ENA, WEA, CLKB, SSRB, ENB, WEB;\ninput [dw-1:0] DIA, DIB;\noutput [dw-1:0] DOA, DOB;\ninput [dwp-1:0] DIPA, DIPB;\noutput [dwp-1:0] DOPA, DOPB;\ninput [aw-1:0] ADDRA, ADDRB;\n\nreg\t[dw+dwp-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg_a;\t\treg\t[aw-1:0]\taddr_reg_b;\t\tassign DOA = mem[addr_reg_a][dw-1:0];\nassign DOPA = mem[addr_reg_a][dwp+dw-1:dw];\nassign DOB = mem[addr_reg_b][dw-1:0];\nassign DOPB = mem[addr_reg_b][dwp+dw-1:dw];\n\nalways @(posedge CLKA or posedge SSRA)\n    if ( SSRA == 1'b1 )\n        addr_reg_a <= #1 {aw{1'b0}};\n    else if ( ENA )\n        addr_reg_a <= #1 ADDRA;\n\nalways @(posedge CLKB or posedge SSRB)\n    if ( SSRB == 1'b1 )\n        addr_reg_b <= #1 {aw{1'b0}};\n    else if ( ENB )\n        addr_reg_b <= #1 ADDRB;\n\nalways @(posedge CLKA)\n\tif (ENA && WEA)\n\t\tmem[ADDRA] <= #1 { DIPA , DIA };\n\nalways @(posedge CLKB)\n\tif (ENB && WEB)\n\t\tmem[ADDRB] <= #1 { DIPB , DIB };\n\nendmodule\n\n\nmodule RAMB16_S9 (\n    CLK,\n    SSR,\n    ADDR,\n    DI,\n    DIP,\n    EN,\n    WE,\n    DO,\n    DOP\n);\n\nparameter dw = 8;\nparameter dwp = 1;\nparameter aw = 11;\n\ninput CLK, SSR, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [dwp-1:0] DIP;\noutput [dwp-1:0] DOP;\ninput [aw-1:0] ADDR;\n\nreg\t[dw+dwp-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\nassign DOP = mem[addr_reg][dwp+dw-1:dw];\n\nalways @(posedge CLK or posedge SSR)\n    if ( SSR == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 { DIP , DI };\n\nendmodule\n\n\nmodule RAMB16_S36 (\n    CLK,\n    SSR,\n    ADDR,\n    DI,\n    DIP,\n    EN,\n    WE,\n    DO,\n    DOP\n);\n\nparameter dw = 32;\nparameter dwp = 4;\nparameter aw = 9;\n\ninput CLK, SSR, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [dwp-1:0] DIP;\noutput [dwp-1:0] DOP;\ninput [aw-1:0] ADDR;\n\nreg\t[dw+dwp-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\nassign DOP = mem[addr_reg][dwp+dw-1:dw];\n\nalways @(posedge CLK or posedge SSR)\n    if ( SSR == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 { DIP , DI };\n\nendmodule\n\n\nmodule RAMB16_S18 (\n    CLK,\n    SSR,\n    ADDR,\n    DI,\n    DIP,\n    EN,\n    WE,\n    DO,\n    DOP\n);\n\nparameter dw = 16;\nparameter dwp = 2;\nparameter aw = 10;\n\ninput CLK, SSR, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [dwp-1:0] DIP;\noutput [dwp-1:0] DOP;\ninput [aw-1:0] ADDR;\n\nreg\t[dw+dwp-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\nassign DOP = mem[addr_reg][dwp+dw-1:dw];\n\nalways @(posedge CLK or posedge SSR)\n    if ( SSR == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 { DIP , DI };\n\nendmodule\nmodule RAMB4_S16_S16 (\n    CLKA,\n    RSTA,\n    ADDRA,\n    DIA,\n    ENA,\n    WEA,\n    DOA,\n\n    CLKB,\n    RSTB,\n    ADDRB,\n    DIB,\n    ENB,\n    WEB,\n    DOB\n);\n\nparameter dw = 16;\nparameter aw = 8;\n\ninput CLKA, RSTA, ENA, WEA, CLKB, RSTB, ENB, WEB;\ninput [dw-1:0] DIA, DIB;\noutput [dw-1:0] DOA, DOB;\ninput [aw-1:0] ADDRA, ADDRB;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg_a;\t\treg\t[aw-1:0]\taddr_reg_b;\t\tassign DOA = mem[addr_reg_a][dw-1:0];\nassign DOB = mem[addr_reg_b][dw-1:0];\n\nalways @(posedge CLKA or posedge RSTA)\n    if ( RSTA == 1'b1 )\n        addr_reg_a <= #1 {aw{1'b0}};\n    else if ( ENA )\n        addr_reg_a <= #1 ADDRA;\n\nalways @(posedge CLKB or posedge RSTB)\n    if ( RSTB == 1'b1 )\n        addr_reg_b <= #1 {aw{1'b0}};\n    else if ( ENB )\n        addr_reg_b <= #1 ADDRB;\n\nalways @(posedge CLKA)\n\tif (ENA && WEA)\n\t\tmem[ADDRA] <= #1 DIA;\n\nalways @(posedge CLKB)\n\tif (ENB && WEB)\n\t\tmem[ADDRB] <= #1 DIB;\n\nendmodule\n\nmodule RAMB4_S4 (\n    CLK,\n    RST,\n    ADDR,\n    DI,\n    EN,\n    WE,\n    DO,\n);\n\nparameter dw = 4;\nparameter aw = 10;\n\ninput CLK, RST, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [aw-1:0] ADDR;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\n\nalways @(posedge CLK or posedge RST)\n    if ( RST == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 DI;\n\nendmodule\n\nmodule RAMB4_S16 (\n    CLK,\n    RST,\n    ADDR,\n    DI,\n    EN,\n    WE,\n    DO\n);\n\nparameter dw = 16;\nparameter aw = 8;\n\ninput CLK, RST, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [aw-1:0] ADDR;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\n\nalways @(posedge CLK or posedge RST)\n    if ( RST == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 DI;\n\nendmodule\n\nmodule RAMB4_S2 (\n    CLK,\n    RST,\n    ADDR,\n    DI,\n    EN,\n    WE,\n    DO,\n);\n\nparameter dw = 2;\nparameter aw = 11;\n\ninput CLK, RST, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [aw-1:0] ADDR;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\n\nalways @(posedge CLK or posedge RST)\n    if ( RST == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 DI;\n\nendmodule\n\nmodule RAMB4_S8 (\n    CLK,\n    RST,\n    ADDR,\n    DI,\n    EN,\n    WE,\n    DO,\n);\n\nparameter dw = 8;\nparameter aw = 9;\n\ninput CLK, RST, EN, WE;\ninput [dw-1:0] DI;\noutput [dw-1:0] DO;\ninput [aw-1:0] ADDR;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\treg\t[aw-1:0]\taddr_reg;\t\tassign DO = mem[addr_reg][dw-1:0];\n\nalways @(posedge CLK or posedge RST)\n    if ( RST == 1'b1 )\n        addr_reg <= #1 {aw{1'b0}};\n    else if ( EN )\n        addr_reg <= #1 ADDR;\n\nalways @(posedge CLK)\n\tif (EN && WE)\n\t\tmem[ADDR] <= #1 DI;\n\nendmodule\nmodule RAM32X1D (\n    DPO,\n    SPO,\n    A0,\n    A1,\n    A2,\n    A3,\n    A4,\n    D,\n    DPRA0,\n    DPRA1,\n    DPRA2,\n    DPRA3,\n    DPRA4,\n    WCLK,\n    WE\n);\n\nparameter dw = 1;\nparameter aw = 5;\n\noutput DPO, SPO;\ninput DPRA0, DPRA1, DPRA2, DPRA3, DPRA4;\ninput A0, A1, A2, A3, A4;\ninput D;\ninput WCLK;\ninput WE;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\tassign DPO = mem[{DPRA4 , DPRA3 , DPRA2 , DPRA1 , DPRA0}][dw-1:0];\nassign SPO = mem[{A4 , A3 , A2 , A1 , A0}][dw-1:0];\n\nalways @(posedge WCLK)\n\tif (WE)\n\t\tmem[{A4 , A3 , A2 , A1 , A0}] <= #1 D;\n\nendmodule\nmodule RAM16X1D (\n    DPO,\n    SPO,\n    A0,\n    A1,\n    A2,\n    A3,\n    D,\n    DPRA0,\n    DPRA1,\n    DPRA2,\n    DPRA3,\n    WCLK,\n    WE\n);\n\nparameter dw = 1;\nparameter aw = 4;\n\noutput DPO, SPO;\ninput DPRA0, DPRA1, DPRA2, DPRA3;\ninput A0, A1, A2, A3;\ninput D;\ninput WCLK;\ninput WE;\n\nreg\t[dw-1:0]\tmem [(1<<aw)-1:0];\tassign DPO = mem[{DPRA3 , DPRA2 , DPRA1 , DPRA0}][dw-1:0];\nassign SPO = mem[{A3 , A2 , A1 , A0}][dw-1:0];\n\nalways @(posedge WCLK)\n\tif (WE)\n\t\tmem[{A3 , A2 , A1 , A0}] <= #1 D;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "edge_detector_a6a89063", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule edge_detector (\n    input clk,\n    input [15:0] in,\n    output reg [15:0] anyedge\n);\n\nreg [15:0] in_reg1, in_reg2;\nreg [15:0] out_reg1, out_reg2;\n\nalways @(posedge clk) begin\n    in_reg1 <= in;\n    out_reg1 <= out_reg2;\nend\n\nalways @(posedge clk) begin\n    in_reg2 <= in_reg1;\n    out_reg2 <= out_reg1;\nend\n\nalways @(posedge clk) begin\n    if (in_reg2[0] == 1 && in_reg1[0] == 0) begin\n        anyedge <= out_reg2;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "crossbar_3x2_c200b241", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule crossbar_3x2 (\n    input aclk,\n    input aresetn,\n    input [31:0] s_axis_0_tdata,\n    input [31:0] s_axis_1_tdata,\n    input [31:0] s_axis_2_tdata,\n    input s_axis_0_tvalid,\n    input s_axis_1_tvalid,\n    input s_axis_2_tvalid,\n    output s_axis_0_tready,\n    output s_axis_1_tready,\n    output s_axis_2_tready,\n    output [31:0] m_axis_0_tdata,\n    output [31:0] m_axis_1_tdata,\n    output m_axis_0_tvalid,\n    output m_axis_1_tvalid,\n    input m_axis_0_tready,\n    input m_axis_1_tready\n);\n\n// internal signals\nreg [31:0] buffer_0;\nreg [31:0] buffer_1;\nreg [31:0] buffer_2;\nreg [1:0] current_route;\nreg [1:0] next_route;\n\n// initialize buffers to zero\ninitial begin\n    buffer_0 <= 0;\n    buffer_1 <= 0;\n    buffer_2 <= 0;\nend\n\n// compute next buffers\nalways @(*) begin\n    buffer_0 <= (current_route == 0) ? s_axis_0_tdata :\n                    (current_route == 1) ? s_axis_1_tdata :\n                                         s_axis_2_tdata;\n    buffer_1 <= (current_route == 0) ? s_axis_1_tdata :\n                    (current_route == 1) ? s_axis_2_tdata :\n                                         s_axis_0_tdata;\n    buffer_2 <= (current_route == 0) ? s_axis_2_tdata :\n                    (current_route == 1) ? s_axis_0_tdata :\n                                         s_axis_1_tdata;\nend\n\n// compute current route\nalways @(posedge aclk or negedge aresetn) begin\n    if (!aresetn) begin\n        current_route <= 0;\n    end else begin\n        case (m_axis_0_tvalid)\n            1: current_route <= (s_axis_1_tvalid || s_axis_2_tvalid) ? 1 :\n                               (s_axis_2_tvalid) ? 2 :\n                                                 current_route;\n            0: case (m_axis_1_tvalid)\n                1: current_route <= (s_axis_0_tvalid || s_axis_2_tvalid) ? 0 :\n                               (s_axis_2_tvalid) ? 2 :\n                                                 current_route;\n                0: current_route <= (s_axis_0_tvalid || s_axis_1_tvalid) ? 0 :\n                               (s_axis_1_tvalid) ? 1 :\n                                                 current_route;\n            endcase\n        endcase\n    end\nend\n\n// compute next route\nalways @(posedge aclk or negedge aresetn) begin\n    if (!aresetn) begin\n        next_route <= 0;\n    end else begin\n        case (current_route)\n            0: next_route <= (s_axis_1_tvalid || s_axis_2_tvalid) ? 1 :\n                               (s_axis_2_tvalid) ? 2 :\n                                                 next_route;\n            1: next_route <= (s_axis_0_tvalid || s_axis_2_tvalid) ? 0 :\n                               (s_axis_2_tvalid) ? 2 :\n                                                 next_route;\n            2: next_route <= (s_axis_0_tvalid || s_axis_1_tvalid) ? 0 :\n                               (s_axis_1_tvalid) ? 1 :\n                                                 next_route;\n            default: next_route <= next_route;\n        endcase\n    end\nend\n\n// assign outputs\nassign s_axis_0_tready = !(m_axis_0_tvalid || m_axis_1_tvalid);\nassign s_axis_1_tready = !(m_axis_0_tvalid || m_axis_1_tvalid);\nassign s_axis_2_tready = !m_axis_0_tvalid;\nassign m_axis_0_tdata = buffer_0;\nassign m_axis_1_tdata = buffer_1;\nassign m_axis_0_tvalid = (m_axis_0_tready) && ((s_axis_0_tvalid) || (s_axis_1_tvalid) || (s_axis_2_tvalid));\nassign m_axis_1_tvalid = (m_axis_1_tready) && ((s_axis_0_tvalid) || (s_axis_1_tvalid) || (s_axis_2_tvalid));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "communication_module_ae235b27", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule communication_module(\n\n    input wire clk,\n    input wire rst,\n    input wire ready_op,\n    input wire max_tick_address,\n    input wire max_tick_ch,\n    input wire TX_DONE,\n    \n    output reg beg_op,\n    output reg ack_op,\n    output reg load_address,\n    output reg enab_address,\n    output reg enab_ch,\n    output reg load_ch,\n    output reg TX_START\n    );\n\n//symbolic state declaration\nlocalparam [3:0]    est0 = 4'b0000,\n                    est1 = 4'b0001,\n                    est2 = 4'b0010,\n                    est3 = 4'b0011,\n                    est4 = 4'b0100,\n                    est5 = 4'b0101, \n                    est6 = 4'b0110,\n                    est7 = 4'b0111,\n                    est8 = 4'b1000,\n                    est9 = 4'b1001,\n                    est10 = 4'b1010,\n                    est11 = 4'b1011;\n//signal declaration\nreg [3:0] state_reg, state_next;    //    Guardan el estado actual y el estado futuro, respectivamente.\n\n//state register\n\nalways @( posedge clk, posedge rst)\n    begin\n        if(rst)\t// Si hay reset, el estado actual es el estado inicial.\n            state_reg <= est0;\n        else\t\t//Si no hay reset el estado actual es igual al estado siguiente.\n            state_reg <= state_next;\n    end\n    \n//next-state logic and output logic\n\nalways @*\n    begin\n        state_next = state_reg; // default state : the same\n        \n        //declaration of default outputs. \n        beg_op = 1'b0;\n        ack_op = 1'b0;\n        load_address = 1'b0;\n        enab_address = 1'b0;\n        enab_ch = 1'b0;\n        load_ch = 1'b0;\n        TX_START = 1'b0;\n        \n        case(state_reg)\n        est0:\n            begin\n                state_next = est1;\n            end\n            \n        est1:\n            begin\n                load_address = 1'b1;\n                enab_address = 1'b1;\n                state_next = est2;\n            end\n            \n        est2:\n            begin\n                beg_op = 1'b1;\n                state_next=est3;\n            end\n            \n        est3:\n            begin\n                beg_op = 1'b1;\n                enab_ch = 1'b1;\n                load_ch = 1'b1;\n                state_next=est4;\n            end\n            \n        est4:\n            begin\n                if(ready_op)\n                    state_next=est5;\n                else\n                    state_next=est4;\n            end\n            \n        est5:\n            begin\n                state_next=est6;\n            end\n            \n        est6:\n            begin\n                TX_START = 1'b1;\n                state_next=est7;\n            end\n            \n        est7:\n            begin\n                if(TX_DONE)\n                    if(max_tick_ch)\n                        state_next=est9;\n                    else\n                        begin\n                            state_next=est8;\n                        end\n                else\n                    state_next=est7;\n            end\n            \n        est8:\n            begin\n                enab_ch = 1'b1;\n                state_next=est5;\n            end\n            \n        est9:\n            begin\n                if(max_tick_address)\n                    state_next=est11;\n                else\n                    begin\n                        state_next=est10;\n                    end\n            end\n            \n        est10:\n            begin\n                enab_address = 1'b1;\n                ack_op = 1'b1;\n                state_next=est2;\n            end\n            \n        est11:\n            begin\n                state_next=est11;\n            end\n            \n        default:\n            state_next=est0;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__fe751193", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    input load,    // Load value into counter when asserted\n    input up_down, // Count up or down based on value\n    input [31:0] in, // Input vector for the transition detector\n    output [7:0] q // 8-bit output from the functional module\n);\n\n    // Counter module with parallel load and up/down counting\n    reg [15:0] count;\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else if (load) begin\n            count <= {in[15:12], in[23:20], in[31:28], in[27:24]};\n        end else if (up_down) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\n    // Transition detector module using FSM architecture\n    reg [31:0] prev_in;\n    reg [31:0] transition;\n    parameter IDLE = 2'b00;\n    parameter DETECT = 2'b01;\n    parameter OUTPUT = 2'b10;\n    reg [1:0] state;\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            prev_in <= 0;\n            transition <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (in != prev_in) begin\n                        state <= DETECT;\n                        prev_in <= in;\n                    end\n                end\n                DETECT: begin\n                    if (in == prev_in) begin\n                        state <= IDLE;\n                        transition <= transition | prev_in;\n                    end else begin\n                        prev_in <= in;\n                    end\n                end\n                OUTPUT: begin\n                    state <= IDLE;\n                    prev_in <= in;\n                end\n            endcase\n        end\n    end\n\n    // Functional module to combine counter and transition detector outputs\n    assign q = {count[3:0], count[7:4], count[11:8], count[15:12], transition[31:24], transition[23:16], transition[15:8], transition[7:0]};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand2_7ddc56f0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nand2 (\n    output Y,\n    input A,\n    input B\n);\n\n    // NAND gate\n    assign Y = ~(A & B);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__2bdb6e78", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule my_module (\n    X   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    C1  ,\n    VPWR,\n    VGND,\n    Y\n);\n\n    output X   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  C1  ;\n    input  VPWR;\n    input  VGND;\n    output Y;\n\n    nor  (X, A1, A2);\n    buf  (Y, X);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "debounce_switch  #_c3f91ca9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule debounce_switch  #(\n    parameter WIDTH=1, parameter N=3, parameter RATE=125000 )(\n    input wire clk,\n    input wire rst,\n    input wire [WIDTH-1:0] in,\n    output wire [WIDTH-1:0] out\n);\n\nreg [23:0] cnt_reg = 24'd0;\n\nreg [N-1:0] debounce_reg[WIDTH-1:0];\n\nreg [WIDTH-1:0] state;\n\n\nassign out = state;\n\ninteger k;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        cnt_reg <= 0;\n        state <= 0;\n\n        for (k = 0; k < WIDTH; k = k + 1) begin\n            debounce_reg[k] <= 0;\n        end\n    end else begin\n        if (cnt_reg < RATE) begin\n            cnt_reg <= cnt_reg + 24'd1;\n        end else begin\n            cnt_reg <= 24'd0;\n        end\n\n        if (cnt_reg == 24'd0) begin\n            for (k = 0; k < WIDTH; k = k + 1) begin\n                debounce_reg[k] <= {debounce_reg[k][N-2:0], in[k]};\n            end\n        end\n\n        for (k = 0; k < WIDTH; k = k + 1) begin\n            if (|debounce_reg[k] == 0) begin\n                state[k] <= 0;\n            end else if (&debounce_reg[k] == 1) begin\n                state[k] <= 1;\n            end else begin\n                state[k] <= state[k];\n            end\n        end\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__d41b22d0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,      // Asynchronous active-high reset\n    input a,           // 1-bit input for edge detection\n    output [3:0] counter_out,  // 4-bit output from the counter\n    output reg rise,   // Output indicating rising edge detection\n    output reg down,   // Output indicating falling edge detection\n    output [3:0] final_out  // 4-bit output from the functional module\n);\n\nreg [3:0] counter;\nreg [1:0] edge_detect;\nreg [1:0] edge_detect_prev;\n\nalways @(posedge clk or negedge reset) begin\n    if (!reset) begin\n        counter <= 4'b1000; // Reset to 8\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nalways @(posedge clk) begin\n    edge_detect_prev <= edge_detect;\n    edge_detect <= {edge_detect[0], a} ^ {edge_detect_prev[0], edge_detect_prev[1]};\n    rise <= edge_detect[1] & !edge_detect_prev[1];\n    down <= !edge_detect[1] & edge_detect_prev[1];\nend\n\nassign final_out = counter + rise - down;\nassign counter_out = counter;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplexer_c612e50f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiplexer (in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16, sel, out);\n    input[5:0] in1;\n    input[5:0] in2;\n    input[5:0] in3;\n    input[5:0] in4;\n    input[5:0] in5;\n    input[5:0] in6;\n    input[5:0] in7;\n    input[5:0] in8;\n    input[5:0] in9;\n    input[5:0] in10;\n    input[5:0] in11;\n    input[5:0] in12;\n    input[5:0] in13;\n    input[5:0] in14;\n    input[5:0] in15;\n    input[5:0] in16;\n    input[3:0] sel;\n    output[5:0] out;\n    reg[5:0] out;\n    \n    \n    always @(in1, in2, in3, in4, in5, in6, in7, in8, in9, in10, in11, in12, in13, in14, in15, in16, sel)\n    begin \n    case(sel)\n        4'b0000: out = in1;\n        4'b0001: out = in2;\n        4'b0010: out = in3;\n        4'b0011: out = in4;\n        4'b0100: out = in5;\n        4'b0101: out = in6;\n        4'b0110: out = in7;\n        4'b0111: out = in8;\n        4'b1000: out = in9;\n        4'b1001: out = in10;\n        4'b1010: out = in11;\n        4'b1011: out = in12;\n        4'b1100: out = in13;\n        4'b1101: out = in14;\n        4'b1110: out = in15;\n        4'b1111: out = in16;\n        default: out = 0;\n    endcase\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_to_gray_406f8567", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_to_gray(\n  input [7:0] bin_in,\n  output [7:0] gray_out\n);\n\n  wire [7:0] bin_to_gray; // Temporary variable to calculate binary code\n\n  // Calculate binary code by xoring gray_out with shifted bin_to_gray\n  assign gray_out = bin_in ^ ({bin_in[7], bin_in[7:1]});\n  assign bin_to_gray = gray_out ^ ({gray_out[7], gray_out[7:1]});\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_ccdd2ebc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_counter (\n    input clk,\n    input reset,   // Synchronous active-high reset\n    output [3:1] ena,\n    output [15:0] q);\n    \n    reg [15:0] count;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (ena[3]) begin\n                count <= count + 8'b0001_0000;\n            end\n            if (ena[2]) begin\n                count <= count + 8'b0000_1000;\n            end\n            if (ena[1]) begin\n                count <= count + 8'b0000_0010;\n            end\n            count <= count + 8'b0000_0001;\n        end\n    end\n    \n    assign q = count;\n    \n    assign ena = {1'b0, 1'b0, 1'b0, 1'b1}; // Enable all bits\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_counter_d3689067", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_register_counter (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input areset,     // Async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    output wire [3:0] shift_out,\n    output wire [3:0] counter_out\n);\n\n    // Shift register\n    reg [3:0] shift_reg;\n    always @(posedge clk, negedge areset) begin\n        if (!areset) begin\n            shift_reg <= 4'b0000;\n        end else if (load) begin\n            shift_reg <= data;\n        end else if (ena) begin\n            shift_reg <= {shift_reg[2:0], shift_reg[3]};\n        end\n    end\n    assign shift_out = shift_reg;\n\n    // Counter\n    reg [3:0] count;\n    always @(posedge clk, negedge reset) begin\n        if (!reset) begin\n            count <= 4'b0000;\n        end else begin\n            count <= count + 1;\n        end\n    end\n    assign counter_out = count;\n\n    // Output\n    assign shift_out = shift_reg;\n    assign counter_out = count;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sel_add_eaac20de", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sel_add(\n    input [3:0] A,\n    input [3:0] B,\n    input SEL,\n    input ADD,\n    output reg [3:0] OUT\n);\n\nalways @(*) begin\n    if(SEL == 0) begin\n        OUT = A;\n    end\n    else if(SEL == 1 && ADD == 0) begin\n        OUT = B;\n    end\n    else if(SEL == 1 && ADD == 1) begin\n        OUT = A + B;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Alu_6d7e1249", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Alu(Alu_in1,Alu_in2,Alu_sel,Alu_zero_flg,Alu_out\n    );\n\t \n\t parameter wrd_size = 8,\n\t           sel_width= 3;\n\tinput [wrd_size-1:0] Alu_in1,Alu_in2;\n\tinput [sel_width-1:0] Alu_sel;\n\toutput reg [wrd_size-1:0] Alu_out;\n\toutput  Alu_zero_flg;\n\tlocalparam NOP = 3'b000,\n\t           ADD = 3'b001,\n\t\t\t\t  SUB = 3'b010,\n\t           AND = 3'b011,\n\t\t\t\t  OR  = 3'b100,\n              SLT = 3'b101,\n\t\t\t\t  SRT = 3'b110,\t\t\t\t  \n\t\t\t\t  NOT = 3'b111;\n\t\t\t\t  \t\t\t\t  \n\tassign Alu_zero_flg = ~|Alu_out;\n\t\t\t  \n\t\nalways @(*)\ncase(Alu_sel)\n           NOP:  Alu_out = 0;\n\t\t\t  AND:  Alu_out = Alu_in1&Alu_in2;\n\t\t\t  OR:   Alu_out = Alu_in1|Alu_in2;\n\t\t\t  ADD:  Alu_out = Alu_in1+Alu_in2;\n\t\t\t  SUB:  Alu_out = Alu_in1-Alu_in2;\n\t\t\t  NOT:  Alu_out = ~Alu_in1;\n\t\t\t  SLT:  Alu_out =  Alu_in1<<Alu_in2;\n\t\t\t  SRT:  Alu_out =  Alu_in1>>Alu_in2;\n\t\t\t  default: Alu_out = 0;\n\t\t\t  endcase\n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_475baf57", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder (\n    input clk,\n    input rst,\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] Y\n);\n\n    wire [31:0] sum;\n\n    assign sum = A + B;\n\n    assign Y = rst ? 0 : sum;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "logic__38c31d76", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule logic_module (\n    Y,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    // Module ports\n    output Y;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n    input B2;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB;\n    supply0 VNB;\n\n    // Local signals\n    wire nand0_out;\n    wire nand1_out;\n    wire and0_out_Y;\n\n    // Gates\n    nand nand0 (nand0_out, A1, A2, A3);\n    nand nand1 (nand1_out, B1, B2);\n    and and0 (and0_out_Y, nand0_out, nand1_out);\n    buf buf0 (Y, and0_out_Y);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dc_offset_removal_9ce4c190", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dc_offset_removal \n  #(parameter WIDTH=16,\n    parameter ADDR=8'd0,\n    parameter alpha_shift=20)\n   (input clk, input rst, \n    input set_stb, input [7:0] set_addr, input [31:0] set_data,\n    input [WIDTH-1:0] in, output [WIDTH-1:0] out);\n   \n   wire \t      set_now = set_stb & (ADDR == set_addr);\n   \n   reg \t\t      fixed;  // uses fixed offset\n   wire [WIDTH-1:0]   fixed_dco;\n\n   localparam int_width = WIDTH + alpha_shift;\n   reg [int_width-1:0] integrator;\n   wire [WIDTH-1:0]    quantized;\n\n   always @(posedge clk)\n     if(rst)\n       begin\n\t  fixed <= 0;\n\t  integrator <= {int_width{1'b0}};\n       end\n     else if(set_now)\n       begin\n\t  fixed <= set_data[31];\n\t  if(set_data[30])\n\t    integrator <= {set_data[29:0],{(int_width-30){1'b0}}};\n       end\n     else if(~fixed)\n       integrator <= integrator +  {{(alpha_shift){in[WIDTH-1]}},in};\n\n   round_sd #(.WIDTH_IN(int_width),.WIDTH_OUT(WIDTH)) round_sd\n     (.clk(clk), .reset(rst), .in(integrator), .strobe_in(1'b1), .out(quantized), .strobe_out());\n   \n   add2_and_clip_reg #(.WIDTH(WIDTH)) add2_and_clip_reg\n     (.clk(clk), .rst(rst), .in1(in), .in2(-quantized), .strobe_in(1'b1), .sum(out), .strobe_out());\n\nendmodule\n\n// Round to nearest with saturation\nmodule round_sd #(parameter WIDTH_IN=16, WIDTH_OUT=16) (\n    input clk,\n    input reset,\n    input signed [WIDTH_IN-1:0] in,\n    input strobe_in,\n    output reg signed [WIDTH_OUT-1:0] out,\n    output reg strobe_out\n);\n    localparam WIDTH_OUT_1 = WIDTH_OUT - 1;\n    localparam WIDTH_IN_1 = WIDTH_IN - 1;\n    localparam WIDTH_DIFF = WIDTH_IN - WIDTH_OUT;\n    localparam WIDTH_DIFF_1 = WIDTH_DIFF - 1;\n    localparam ROUND_CONST = (1 << (WIDTH_DIFF - 1)) - 1;\n    reg signed [WIDTH_IN_1:0] in_shifted;\n    reg signed [WIDTH_OUT_1:0] out_shifted;\n    reg [WIDTH_DIFF_1:0] round_bits;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 0;\n            strobe_out <= 0;\n            in_shifted <= 0;\n            out_shifted <= 0;\n            round_bits <= 0;\n        end\n        else if (strobe_in) begin\n            in_shifted <= in >> WIDTH_DIFF;\n            out_shifted <= in_shifted + round_bits;\n            if (out_shifted > (1 << WIDTH_OUT_1) - 1) begin\n                out <= (1 << WIDTH_OUT_1) - 1;\n            end\n            else if (out_shifted < -(1 << WIDTH_OUT_1)) begin\n                out <= -(1 << WIDTH_OUT_1);\n            end\n            else begin\n                out <= out_shifted;\n            end\n            round_bits <= ROUND_CONST & in[WIDTH_DIFF_1:0];\n            strobe_out <= 1;\n        end\n        else begin\n            strobe_out <= 0;\n        end\n    end\nendmodule\n\n// Add two signed numbers and clip the result to the range of [-2^(WIDTH-1), 2^(WIDTH-1)-1]\nmodule add2_and_clip_reg #(parameter WIDTH=16) (\n    input clk,\n    input rst,\n    input signed [WIDTH-1:0] in1,\n    input signed [WIDTH-1:0] in2,\n    input strobe_in,\n    output reg signed [WIDTH-1:0] sum,\n    output reg strobe_out\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            sum <= 0;\n            strobe_out <= 0;\n        end\n        else if (strobe_in) begin\n            sum <= in1 + in2;\n            if (sum > (1 << (WIDTH-1)) - 1) begin\n                sum <= (1 << (WIDTH-1)) - 1;\n            end\n            else if (sum < -(1 << (WIDTH-1))) begin\n                sum <= -(1 << (WIDTH-1));\n            end\n            strobe_out <= 1;\n        end\n        else begin\n            strobe_out <= 0;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "video_7f2acbf0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n \nmodule video(\n\n    input wire        clock,        \n    input wire [7:0]  d8_chr,\n    output reg [13:0] addr,\n    output reg [4:0]  r,\n    output reg [5:0]  g,\n    output reg [4:0]  b,\n    output reg        hs,\n    output reg        vs\n);\n\nreg  [9:0] x;\nreg  [9:0] y;\nreg  [7:0] attr;\nreg  [7:0] bit8;\nreg  [7:0] mask;\n\nwire [9:0] rx = x - 8'd48;\nwire [9:0] ry = y - 8'd48;\nwire       bitset = mask[ 3'h7 ^ rx[3:1] ];\n\nalways @(posedge clock) begin\n\n    if (x == 10'd800) begin\n    \n        x <= 1'b0;\n        y <= (y == 10'd525) ? 1'b0 : (y + 1'b1); \n        \n    end else x <= x + 1'b1;\n    \n    hs <= (x >= 10'd656 && x <= 10'd751); vs <= (y >= 10'd490 && y <= 10'd492); if (x < 10'd640 && y < 10'd480) begin\n    \n        if (x >= 64 && x < 576 && y >= 48 && y < 432) begin\n        \n            r <= bitset? 1'b0 : 5'h0F; g <= bitset? 1'b0 : 6'h1F;\n            b <= bitset? 1'b0 : 5'h0F;\n        \n        end else begin r <= 5'h0F; g <= 6'h1F; b <= 5'h0F; end\n\n    end else begin r <= 1'b0; g <= 1'b0; b <= 1'b0; end\n    case (rx[3:0])\n    \n        4'h0: begin addr <= {2'b10, ry[8:1], rx[8:4]}; end \n        \n        4'h1: begin addr <= {5'b10110, ry[8:4], rx[8:4]}; bit8 <= d8_chr; end \n        \n        4'hF: begin attr <= d8_chr; mask <= bit8; end \n\n    endcase\n\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__e1509b24", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] q\n);\n\n// Edge Detection Module\nreg [7:0] in_prev;\nreg [7:0] edge_detected;\nalways @(posedge clk) begin\n    in_prev <= in;\n    edge_detected <= in ^ in_prev;\nend\n\n// Functional Module\nreg [7:0] q_reg;\nalways @(*) begin\n    q_reg <= edge_detected;\nend\n\nalways @(posedge clk) begin\n    q <= q_reg;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_ring_counter_99ddd5b4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register_ring_counter (input clk, input d, output reg q);\n\n  reg [2:0] shift_reg;\n\n  always @(posedge clk)\n    shift_reg <= {shift_reg[1:0], d};\n\n  always @*\n    q = shift_reg[2];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "logic_operation_2fb476a3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule logic_operation (\n    input [1:0] logic_op_x,\n    input [31:0] operand_0_x,\n    input [31:0] operand_1_x,\n    output [31:0] logic_result_x\n);\n\nreg [31:0] temp_result;\n\nalways @*\nbegin\n    case (logic_op_x)\n        2'b00: temp_result = operand_0_x & operand_1_x;\n        2'b01: temp_result = operand_0_x | operand_1_x;\n        2'b10: temp_result = operand_0_x ^ operand_1_x;\n        default: temp_result = 0;\n    endcase\nend\n\nassign logic_result_x = temp_result;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_reset_set_ce_b5041092", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_reset_set_ce (\n    input  wire D,\n    input  wire CLK,\n    input  wire RESET,\n    input  wire SET,\n    input  wire CE,\n    output reg  Q,\n    output reg  Q_N\n);\n\n    always @(posedge CLK) begin\n        if (RESET) begin\n            Q <= 0;\n            Q_N <= 1;\n        end else if (SET) begin\n            Q <= 1;\n            Q_N <= 0;\n        end else if (CE) begin\n            Q <= D;\n            Q_N <= ~D;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "TLATNTSCAX2TS_9a9ec2ad", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule TLATNTSCAX2TS (E, SE, CK, ECK);\n  input E, SE, CK;\n  output ECK;\n\n  assign ECK = SE ? E : ~E;\nendmodule\nmodule flipflop (CLK, D, RESET, EN, Q);\n  input CLK, D, RESET, EN;\n  output Q;\n\n  wire E, SE, ECK;\n  TLATNTSCAX2TS latch ( .E(E), .SE(SE), .CK(CLK), .ECK(ECK) );\n\n  assign E = EN;\n  assign SE = RESET;\n  assign Q = ECK;\n\n  reg SE_REG; initial SE_REG=0; // moved the declaration of SE here\n  always @ (posedge CLK) begin\n    if (EN) begin\n      if (D) begin\n        SE_REG <= 1'b0;\n      end else begin\n        SE_REG <= 1'b1;\n      end\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_4to1_5cec47af", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux_4to1(\n  input [3:0] a, b, c, d,\n  input [1:0] sel,\n  output reg [3:0] y\n);\n\n  wire [3:0] ab_sel, cd_sel;\n\n  // First level of 2-to-1 MUXes\n  mux2to1 mux_ab(.a(a[0]), .b(b[0]), .sel(sel[0]), .y(ab_sel[0]));\n  mux2to1 mux_cd(.a(c[0]), .b(d[0]), .sel(sel[0]), .y(cd_sel[0]));\n  mux2to1 mux_ab1(.a(a[1]), .b(b[1]), .sel(sel[0]), .y(ab_sel[1]));\n  mux2to1 mux_cd1(.a(c[1]), .b(d[1]), .sel(sel[0]), .y(cd_sel[1]));\n  mux2to1 mux_ab2(.a(a[2]), .b(b[2]), .sel(sel[0]), .y(ab_sel[2]));\n  mux2to1 mux_cd2(.a(c[2]), .b(d[2]), .sel(sel[0]), .y(cd_sel[2]));\n  mux2to1 mux_ab3(.a(a[3]), .b(b[3]), .sel(sel[0]), .y(ab_sel[3]));\n  mux2to1 mux_cd3(.a(c[3]), .b(d[3]), .sel(sel[0]), .y(cd_sel[3]));\n\n  // Second level of 2-to-1 MUX to select between the outputs of the first level\n  always @(*) begin\n    case (sel[1])\n      1'b0: y = ab_sel;\n      1'b1: y = cd_sel;\n    endcase\n  end\n\nendmodule\nmodule mux2to1(\n  input a, b, sel,\n  output reg y\n);\n\n  always @(*) begin\n    y = (sel == 1'b0) ? a : b;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ps2_keyboard_13972019", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ps2_keyboard (\n    input CLK,\n    input RESET_N,\n    input PS2_CLK,\n    input PS2_DATA,\n    output RX_PRESSED,\n    output RX_EXTENDED,\n    output [7:0] RX_SCAN\n);\n\nreg [7:0] scan_code;\nreg rx_pressed;\nreg rx_extended;\nreg [2:0] bit_count;\nreg [3:0] state;\nreg [7:0] timer;\nreg [7:0] rx_scan;\n\nassign RX_PRESSED = rx_pressed;\nassign RX_EXTENDED = rx_extended;\nassign RX_SCAN = rx_scan;\n\nparameter IDLE = 3'b000;\nparameter START_BIT = 3'b001;\nparameter DATA_BIT = 3'b010;\nparameter PARITY_BIT = 3'b011;\nparameter STOP_BIT = 3'b100;\nparameter EXTENDED_CODE = 8'hE0;\nparameter RELEASE_CODE = 8'hF0;\n\nalways @(posedge CLK or negedge RESET_N) begin\n    if (~RESET_N) begin\n        scan_code <= 0;\n        rx_scan <= 0;\n        rx_pressed <= 0;\n        rx_extended <= 0;\n        bit_count <= 0;\n        state <= IDLE;\n        timer <= 0;\n    end\n    else begin\n        case (state)\n            IDLE: begin\n                if (!PS2_CLK && PS2_DATA) begin\n                    state <= START_BIT;\n                    bit_count <= 0;\n                    scan_code <= 0;\n                    timer <= 0;\n                end\n            end\n            START_BIT: begin\n                if (PS2_CLK) begin\n                    state <= DATA_BIT;\n                end\n            end\n            DATA_BIT: begin\n                if (!PS2_CLK) begin\n                    scan_code[bit_count] <= PS2_DATA;\n                    bit_count <= bit_count + 1;\n                    if (bit_count == 7) begin\n                        state <= PARITY_BIT;\n                    end\n                end\n            end\n            PARITY_BIT: begin\n                if (PS2_CLK) begin\n                    state <= STOP_BIT;\n                end\n                else begin\n                    if (PS2_DATA == ~(scan_code[0]^scan_code[1]^scan_code[2]^scan_code[3]^scan_code[4]^scan_code[5]^scan_code[6])) begin\n                        if (scan_code == EXTENDED_CODE) begin\n                            rx_extended <= 1;\n                            state <= IDLE;\n                        end\n                        else if (scan_code == RELEASE_CODE) begin\n                            rx_pressed <= 0;\n                            state <= IDLE;\n                        end\n                        else begin\n                            rx_scan <= scan_code;\n                            rx_pressed <= 1;\n                            state <= STOP_BIT;\n                        end\n                    end\n                    else begin\n                        state <= IDLE;\n                    end\n                end\n            end\n            STOP_BIT: begin\n                if (PS2_CLK) begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n        if (!PS2_CLK && !PS2_DATA) begin\n            timer <= 0;\n        end\n        else if (!PS2_CLK && PS2_DATA) begin\n            timer <= timer + 1;\n            if (timer == 255) begin\n                state <= IDLE;\n            end\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RegFile_ae16b4f4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule RegFile (clk,  regA, regB, regTEST, regW, Wdat, RegWrite,  Adat, Bdat, TESTdat);\n    input clk,RegWrite;\t\tinput [4:0] regTEST, regA, regB, regW;\tinput [31:0] Wdat;\t\t\toutput wire [31:0] Adat, Bdat, TESTdat;\t\treg [31:0] regfile [0:31];\n\t assign  Adat=regfile[regA];\n\t assign  Bdat=regfile[regB];\n\t assign  TESTdat=regfile[regTEST];\n\t always @(posedge clk) begin\n        if(RegWrite) regfile[regW]=(regW==0)?0:Wdat;\n\tend\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "eight_to_one_32796bf9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule eight_to_one (\n    y,\n    a1,\n    a2,\n    a3,\n    b1,\n    vpwr,\n    vgnd,\n    vpb,\n    vnb\n);\n\n    output y;\n    input [3:0] a1, a2, a3, b1;\n    input vpwr, vgnd, vpb, vnb;\n\n    wire [4:0] sum;\n    assign sum = a1 + a2 + a3 + b1;\n\n    wire greater_than_or_equal_to_10;\n    assign greater_than_or_equal_to_10 = (sum >= 10);\n\n    assign y = (greater_than_or_equal_to_10) ? 1 : 0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Multiplier_d67d742e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Multiplier(\n    input [3:0] A,\n    input [3:0] B,\n    output reg [7:0] C\n);\n\n    wire [3:0] B0, B1, B2, B3;\n    wire [7:0] P0, P1, P2, P3;\n\n    // Splitting B into 4 bits\n    assign {B3, B2, B1, B0} = B;\n\n    // Multiplying A with each bit of B\n    assign P0 = A * B0;\n    assign P1 = A * B1;\n    assign P2 = A * B2;\n    assign P3 = A * B3;\n\n    // Combining the results to get the final output\n    always @(*) begin\n        C = {P3[7:4], P2[7:4], P1[7:4], P0[7:4]};\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "edge_detection_b6d717c1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule edge_detection (\n    input clk,\n    input reset,\n    input [3:0] in,\n    output reg [3:0] out\n);\n\nreg [3:0] prev_in;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        prev_in <= 4'b0000;\n        out <= 4'b0000;\n    end else begin\n        prev_in <= in;\n        out <= 4'b0000;\n        if (in[0] != prev_in[0]) out[0] <= 1'b1;\n        if (in[1] != prev_in[1]) out[1] <= 1'b1;\n        if (in[2] != prev_in[2]) out[2] <= 1'b1;\n        if (in[3] != prev_in[3]) out[3] <= 1'b1;\n    end\nend\n\nendmodule\n\nmodule bitwise_or (\n    input [3:0] in1,\n    input [3:0] in2,\n    output reg [3:0] out\n);\n\nalways @(in1, in2) begin\n    out <= in1 | in2;\nend\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] in1,\n    input [3:0] in2,\n    output [3:0] out\n);\n\nwire [3:0] edge1;\nwire [3:0] edge2;\n\nedge_detection ed1(clk, reset, in1, edge1);\nedge_detection ed2(clk, reset, in2, edge2);\nbitwise_or or_gate(edge1, edge2, out);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dpram_664121cc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dpram(wclk,wdata,waddr,wen,rclk,rdata,raddr);\n   parameter depth = 4;\n   parameter width = 16;\n   parameter size = 16;\n   \n   input wclk;\n   input [width-1:0] wdata;\n   input [depth-1:0] waddr;\n   input \t     wen;\n\n   input rclk;\n   output reg [width-1:0] rdata;\n   input [depth-1:0]  raddr;\n   \n   reg [width-1:0]    ram [0:size-1];\n   \n   always @(posedge wclk)\n     if(wen)\n       ram[waddr] <= #1 wdata;\n   \n   always @(posedge rclk)\n     rdata <= #1 ram[raddr];\n   \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ll8_to_txmac_c4667177", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ll8_to_txmac\n  (input clk, input reset, input clear,\n   input [7:0] ll_data, input ll_sof, input ll_eof, input ll_src_rdy, output ll_dst_rdy,\n   output [7:0] tx_data, output tx_valid, output tx_error, input tx_ack );\n\n   reg [2:0] xfer_state;\n\n   localparam XFER_IDLE      = 0;\n   localparam XFER_ACTIVE    = 1;\n   localparam XFER_WAIT1     = 2;\n   localparam XFER_UNDERRUN  = 3;\n   localparam XFER_DROP      = 4;\n   \n   always @(posedge clk)\n     if(reset | clear)\n       xfer_state \t    <= XFER_IDLE;\n     else\n       case(xfer_state)\n\t XFER_IDLE :\n\t   if(tx_ack)\n\t     xfer_state <= XFER_ACTIVE;\n\t XFER_ACTIVE :\n\t   if(~ll_src_rdy)\n\t     xfer_state <= XFER_UNDERRUN;\n\t   else if(ll_eof)\n\t     xfer_state <= XFER_WAIT1;\n\t XFER_WAIT1 :\n\t   xfer_state <= XFER_IDLE;\n\t XFER_UNDERRUN :\n\t   xfer_state <= XFER_DROP;\n\t XFER_DROP :\n\t   if(ll_eof)\n\t     xfer_state <= XFER_IDLE;\n       endcase assign ll_dst_rdy \t = (xfer_state == XFER_ACTIVE) | tx_ack | (xfer_state == XFER_DROP);\n   assign tx_valid \t = (ll_src_rdy & (xfer_state == XFER_IDLE))|(xfer_state == XFER_ACTIVE);\n   assign tx_data \t = ll_data;\n   assign tx_error \t = (xfer_state == XFER_UNDERRUN);\n   \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__c9a821a8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input [7:0] d,    // Input data for the adder\n    output pwm,       // PWM output\n    output reg [7:0] q,   // 8-bit output from the counter\n    output reg [7:0] out  // Final output from the functional module\n);\n\n    reg [7:0] counter;\n    reg [7:0] adder_out;\n    reg pwm_out;\n\n    // Counter module\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 8'b0;\n        end else begin\n            if (counter == 8'hff) begin\n                counter <= 8'b0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    // Adder module\n    always @(posedge clk) begin\n        adder_out <= counter + d;\n    end\n\n    // PWM module\n    always @(posedge clk) begin\n        if (adder_out > 8'h80) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\n    // Functional module\n    always @(posedge clk) begin\n        q <= counter;\n        out <= q * pwm_out;\n    end\n\n    // Output assignments\n    assign pwm = pwm_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "magnitude_comparator_9369c88e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule magnitude_comparator (\n    input valid,\n    input [3:0] A,\n    input [3:0] B,\n    input [1:0] sel,\n    output [1:0] out_mode0,\n    output less_than,\n    output equal_to,\n    output greater_than\n);\n\n    reg [1:0] magnitude;\n    reg less_than_reg, equal_to_reg, greater_than_reg;\n    \n    always @(*) begin\n        if (A == B) begin\n            magnitude = 2'b00;\n            less_than_reg = 1'b0;\n            equal_to_reg = 1'b1;\n            greater_than_reg = 1'b0;\n        end else if (A > B) begin\n            magnitude = 2'b01;\n            less_than_reg = 1'b0;\n            equal_to_reg = 1'b0;\n            greater_than_reg = 1'b1;\n        end else begin\n            magnitude = 2'b10;\n            less_than_reg = 1'b1;\n            equal_to_reg = 1'b0;\n            greater_than_reg = 1'b0;\n        end\n    end\n    \n    assign out_mode0 = (sel == 2'b00) ? magnitude : 2'b00;\n    assign less_than = (sel == 2'b01) ? less_than_reg : 1'b0;\n    assign equal_to = (sel == 2'b01) ? equal_to_reg : 1'b0;\n    assign greater_than = (sel == 2'b01) ? greater_than_reg : 1'b0;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__inputiso1n_457c303f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_lp__inputiso1n (\n    input A,\n    input SLEEP_B,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output X\n);\n\n    assign X = (!A && !SLEEP_B && !VPWR && !VGND && !VPB && !VNB);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_comp_34a15785", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_comp(\n    input [63:0] in,\n    input [3:0] sel,\n    input [3:0] comp_val,\n    output out\n);\n\nreg [3:0] selected_input;\n\nalways @(*) begin\n    case(sel)\n        0: selected_input = in[3:0];\n        1: selected_input = in[7:4];\n        2: selected_input = in[11:8];\n        3: selected_input = in[15:12];\n        4: selected_input = in[19:16];\n        5: selected_input = in[23:20];\n        6: selected_input = in[27:24];\n        7: selected_input = in[31:28];\n        8: selected_input = in[35:32];\n        9: selected_input = in[39:36];\n        10: selected_input = in[43:40];\n        11: selected_input = in[47:44];\n        12: selected_input = in[51:48];\n        13: selected_input = in[55:52];\n        14: selected_input = in[59:56];\n        15: selected_input = in[63:60];\n    endcase\nend\n\nassign out = (selected_input == comp_val) ? 1'b1 : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "video_sys_CPU_nios2_performance_monitors_91cef8b8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule video_sys_CPU_nios2_performance_monitors (\n    input clk,\n    input reset,\n    input [31:0] inst,\n    input stall,\n    output reg [31:0] ipc,\n    output reg [31:0] cpi\n);\n\nreg [31:0] inst_count;\nreg [31:0] cycle_count;\nreg [31:0] stalled_cycle_count;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        inst_count <= 0;\n        cycle_count <= 0;\n        stalled_cycle_count <= 0;\n    end else begin\n        inst_count <= inst_count + 1;\n        cycle_count <= cycle_count + 1;\n        if (stall) begin\n            stalled_cycle_count <= stalled_cycle_count + 1;\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        ipc <= 0;\n        cpi <= 0;\n    end else begin\n        if (cycle_count - stalled_cycle_count == 0) begin\n            ipc <= 0;\n        end else begin\n            ipc <= inst_count / (cycle_count - stalled_cycle_count);\n        end\n        if (inst_count == 0) begin\n            cpi <= 0;\n        end else begin\n            cpi <= (cycle_count - stalled_cycle_count) / inst_count;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vga_converter_4dcbbecb", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule vga_converter (\n  input [23:0] data,\n  input blank,\n  input hs,\n  input vs,\n  input clk,\n  output [7:0] vga_data,\n  output blank_out,\n  output hs_out,\n  output vs_out\n);\n\n  reg [1:0] cnt;\n  reg [23:0] data_reg;\n  reg hs_reg;\n  reg hs_reg1;\n  reg vs_reg;\n  reg blank_reg;\n\n  always @(posedge clk) begin\n    hs_reg <= hs;\n    hs_reg1 <= hs_reg;\n    vs_reg <= vs;\n    blank_reg <= blank;\n  end\n\n  wire sync_pulse = (hs_reg & !hs_reg1) ? 1'b1 : 1'b0;\n  always @(posedge clk) begin\n    if (sync_pulse) begin\n      cnt <= 2'b11; \n    end\n    else begin\n      if (cnt == 2)\n        cnt <= 2'b00;\n      else    \n        cnt <= cnt+1;\n    end\n  end\n\n  always @(posedge clk) begin\n    if (cnt == 2'b11)\n      data_reg <= data;\n  end\n\n  assign vga_data = {3'b0, cnt[1] ? data_reg[23:16] : (cnt[0] ? data_reg[15:8] : data_reg[7:0])};\n  assign blank_out = blank_reg & cnt != 0;\n  assign hs_out = hs_reg & cnt != 0;\n  assign vs_out = vs_reg & cnt != 0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_35b88f49", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n  input CLK,\n  input RST,\n  input EN,\n  output reg [3:0] COUNT\n);\n\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      COUNT <= 4'b0;\n    end else if (EN) begin\n      COUNT <= COUNT + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__6926522b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input clk,\n    input reset,\n    input data,\n    output reg q\n);\nreg [2:0] shift_reg;\nwire [2:0] complement;\n\nshift_register sr (.clk(clk), .reset(reset), .data(data), .q(shift_reg));\nfunctional_module fm (.in1(shift_reg), .in2(q), .out(complement));\nd_ff ff (.clk(clk), .reset(reset), .d(complement[2]), .q(q));\nendmodule\nmodule shift_register(\n    input clk,\n    input reset,\n    input data,\n    output reg [2:0] q\n);\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 3'b0;\n    end else begin\n        q <= {q[1:0], data};\n    end\nend\nendmodule\nmodule d_ff (\n    input clk,\n    input reset,\n    input d,\n    output reg q\n);\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\nendmodule\nmodule functional_module (\n    input [2:0] in1,\n    input in2,\n    output reg [2:0] out\n);\nalways@(*) begin\n    out = ~in1;\nend\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "majority_gate_bcc0bd4e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule majority_gate(\n    input a, \n    input b,\n    input c,\n    input reset,\n    output wire out_assign,\n    output reg out_alwaysblock\n);\n\n    // Majority gate using assign statements\n    assign out_assign = (a & b) | (a & c) | (b & c);\n    \n    // Majority gate using a combinational always block\n    always @* begin\n        if(reset == 1'b1)\n             out_alwaysblock = 1'b0;\n        else begin\n           case ({a, b, c}) \n             3'b111: out_alwaysblock = 1'b1;\n             3'b110: out_alwaysblock = 1'b1;\n             3'b101: out_alwaysblock = 1'b1;\n             3'b011: out_alwaysblock = 1'b1;\n             default: out_alwaysblock = 1'b0;\n           endcase\n       end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_3bit_a86d53c9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter_3bit (\n    input clk,\n    input rst,\n    input en,\n    output reg [2:0] count\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        count <= 3'b0;\n    end else if (en) begin\n        count <= count + 3'b1;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "VoltageLevelShifter #_1ae1b245", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule VoltageLevelShifter #(\n  parameter n = 4, // number of input signals \n  parameter m = 2 // number of output signal\n) (\n  input [n-1:0] in,\n  output [m-1:0] out\n);\n\n\nparameter V1 = 3.3; // input voltage level\nparameter V2 = 5; // output voltage level\n\n// calculate R1 based on input parameters\nparameter R2 = 1000; // choose a value for R2\nparameter R1 = (V2 - V1) / (V1 / R2);\n\n// fixed implementation to avoid division\nassign out = (in * R2) >> 10; // equivalent to out = (in * R2) / (R1 + R2)\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "func5_17b3a3fa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule func5(A, C);\n    input [25:0] A;\n    output [25:0] C;\n\n    wire [24:0] sum;  // Internal wire to store the sum of each bit\n    wire [24:0] c_out; // Internal wire to store the carry-out of each bit\n\n    // FullAdder module\n    FullAdder FA0(.a(A[25]), .b(A[24]), .c_in(1'b0), .sum(sum[24]), .c_out(c_out[24]));\n    FullAdder FA1(.a(sum[24]), .b(A[23]), .c_in(c_out[24]), .sum(sum[23]), .c_out(c_out[23]));\n    FullAdder FA2(.a(sum[23]), .b(A[22]), .c_in(c_out[23]), .sum(sum[22]), .c_out(c_out[22]));\n    FullAdder FA3(.a(sum[22]), .b(A[21]), .c_in(c_out[22]), .sum(sum[21]), .c_out(c_out[21]));\n    FullAdder FA4(.a(sum[21]), .b(A[20]), .c_in(c_out[21]), .sum(sum[20]), .c_out(c_out[20]));\n    FullAdder FA5(.a(sum[20]), .b(A[19]), .c_in(c_out[20]), .sum(sum[19]), .c_out(c_out[19]));\n    FullAdder FA6(.a(sum[19]), .b(A[18]), .c_in(c_out[19]), .sum(sum[18]), .c_out(c_out[18]));\n    FullAdder FA7(.a(sum[18]), .b(A[17]), .c_in(c_out[18]), .sum(sum[17]), .c_out(c_out[17]));\n    FullAdder FA8(.a(sum[17]), .b(A[16]), .c_in(c_out[17]), .sum(sum[16]), .c_out(c_out[16]));\n    FullAdder FA9(.a(sum[16]), .b(A[15]), .c_in(c_out[16]), .sum(sum[15]), .c_out(c_out[15]));\n    FullAdder FA10(.a(sum[15]), .b(A[14]), .c_in(c_out[15]), .sum(sum[14]), .c_out(c_out[14]));\n    FullAdder FA11(.a(sum[14]), .b(A[13]), .c_in(c_out[14]), .sum(sum[13]), .c_out(c_out[13]));\n    FullAdder FA12(.a(sum[13]), .b(A[12]), .c_in(c_out[13]), .sum(sum[12]), .c_out(c_out[12]));\n    FullAdder FA13(.a(sum[12]), .b(A[11]), .c_in(c_out[12]), .sum(sum[11]), .c_out(c_out[11]));\n    FullAdder FA14(.a(sum[11]), .b(A[10]), .c_in(c_out[11]), .sum(sum[10]), .c_out(c_out[10]));\n    FullAdder FA15(.a(sum[10]), .b(A[9]), .c_in(c_out[10]), .sum(sum[9]), .c_out(c_out[9]));\n    FullAdder FA16(.a(sum[9]), .b(A[8]), .c_in(c_out[9]), .sum(sum[8]), .c_out(c_out[8]));\n    FullAdder FA17(.a(sum[8]), .b(A[7]), .c_in(c_out[8]), .sum(sum[7]), .c_out(c_out[7]));\n    FullAdder FA18(.a(sum[7]), .b(A[6]), .c_in(c_out[7]), .sum(sum[6]), .c_out(c_out[6]));\n    FullAdder FA19(.a(sum[6]), .b(A[5]), .c_in(c_out[6]), .sum(sum[5]), .c_out(c_out[5]));\n    FullAdder FA20(.a(sum[5]), .b(A[4]), .c_in(c_out[5]), .sum(sum[4]), .c_out(c_out[4]));\n    FullAdder FA21(.a(sum[4]), .b(A[3]), .c_in(c_out[4]), .sum(sum[3]), .c_out(c_out[3]));\n    FullAdder FA22(.a(sum[3]), .b(A[2]), .c_in(c_out[3]), .sum(sum[2]), .c_out(c_out[2]));\n    FullAdder FA23(.a(sum[2]), .b(A[1]), .c_in(c_out[2]), .sum(sum[1]), .c_out(c_out[1]));\n    FullAdder FA24(.a(sum[1]), .b(A[0]), .c_in(c_out[1]), .sum(C[0]), .c_out(c_out[0]));\n\n    // Assign the carry-out of the last FullAdder to the carry-out of the top-level module\n    assign C[25] = c_out[0];\n\n    // Assign the sum of each FullAdder to the output of the top-level module\n    assign C[24:1] = sum[24:1];\nendmodule\nmodule FullAdder(a, b, c_in, sum, c_out);\n    input a, b, c_in;\n    output sum, c_out;\n\n    assign sum = a ^ b ^ c_in;\n    assign c_out = (a & b) | (c_in & (a ^ b));\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "parity_checker_97374f46", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule parity_checker (\n  input [7:0] in,\n  output [8:0] out\n);\n  assign out[8] = ^in;\n  assign out[7:0] = {in[6:4], in[2:0]};\nendmodule\n\nmodule edge_detector (\n  input clk,\n  input reset,\n  input in,\n  output rise,\n  output down\n);\n  reg [1:0] dff_out;\n  always @(posedge clk, negedge reset) begin\n    if (reset == 0) begin\n      dff_out <= 2'b0;\n    end else begin\n      dff_out <= {dff_out[0], in};\n    end\n  end\n  assign rise = (dff_out[0] == 1'b1) && (dff_out[1] == 1'b0);\n  assign down = (dff_out[0] == 1'b0) && (dff_out[1] == 1'b1);\nendmodule\n\nmodule active_signal (\n  input [8:0] parity_in,\n  input rise_in,\n  input down_in,\n  output active_out\n);\n  assign active_out = ((parity_in[8] == 1'b0 && rise_in == 1'b1) || (parity_in[8] == 1'b1 && down_in == 1'b1)) ? 1'b1 : 1'b0;\nendmodule\n\nmodule top_module (\n  input               clk,\n  input               reset,\n  input [7:0]         in,\n  output [8:0]    parity_out,\n  output          rise,\n  output          down,\n  output          active\n);\n\n  parity_checker parity_checker_inst (\n    .in(in),\n    .out(parity_out)\n  );\n\n  edge_detector edge_detector_inst (\n    .clk(clk),\n    .reset(reset),\n    .in(in[0]),\n    .rise(rise),\n    .down(down)\n  );\n\n  active_signal active_signal_inst (\n    .parity_in(parity_out),\n    .rise_in(rise),\n    .down_in(down),\n    .active_out(active)\n  );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wallace_multiplier_2ce6e161", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule wallace_multiplier (\n    input signed [7:0] a,\n    input signed [7:0] b,\n    input signed_ctrl,\n    output signed [15:0] result,\n    input clk  // Added clock input\n);\n\n// Pipeline registers\nreg signed [7:0] a_reg, b_reg;\nreg signed_ctrl_reg;\nreg signed [15:0] partial_sum_reg [0:2];\n\n// Wallace tree multiplier components\nwire signed [7:0] a1, b1, a2, b2, a3, b3;\nwire signed [11:0] p1, p2, p3, p4, p5;\nwire signed [15:0] s1, s2, s3;\n\n// Assign inputs to pipeline registers\nalways @(posedge clk) begin\n    a_reg <= a;\n    b_reg <= b;\n    signed_ctrl_reg <= signed_ctrl;\nend\n\n// Stage 1\nassign a1 = a_reg;\nassign b1 = signed_ctrl_reg ? b_reg : {1'b0, b_reg[6:0]};\nassign p1 = a1 * b1;\nassign s1 = {p1[5:0], 4'b0};\n\n// Stage 2\nassign a2 = a_reg;\nassign b2 = signed_ctrl_reg ? {1'b0, b_reg[7:0]} : b_reg;\nassign p2 = a2 * b2;\nassign s2 = {p2[5:0], 4'b0};\n\n// Stage 3\nassign a3 = a_reg;\nassign b3 = signed_ctrl_reg ? {1'b0, b_reg[7:1]} : {1'b0, b_reg[6:0]};\nassign p3 = a3 * b3;\nassign p4 = a3 * b2;\nassign p5 = a1 * b3;\nassign s3 = {p3[8:3], p4[8:3], p5[8:3]};\n\n// Stage 4\nalways @(posedge clk) begin\n    partial_sum_reg[0] <= s1;\n    partial_sum_reg[1] <= s2;\n    partial_sum_reg[2] <= s3;\nend\n\n// Final stage\nassign result = partial_sum_reg[0] + partial_sum_reg[1] + partial_sum_reg[2];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ROM_TEST #_3981e2c7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ROM_TEST #(\n    parameter ADDR_WIDTH = 6,\n    parameter DATA_WIDTH = 1,\n    parameter ADDRESS_STEP = 1,\n    parameter MAX_ADDRESS = 63\n) (\n    input rst,\n    input clk,\n    input [DATA_WIDTH-1:0] read_data,\n    output reg [ADDR_WIDTH-1:0] read_address,\n    input [DATA_WIDTH-1:0] rom_read_data,\n    output reg [ADDR_WIDTH-1:0] rom_read_address,\n    output reg loop_complete,\n    output reg error,\n    output reg [7:0] error_state,\n    output reg [ADDR_WIDTH-1:0] error_address,\n    output reg [DATA_WIDTH-1:0] expected_data,\n    output reg [DATA_WIDTH-1:0] actual_data\n);\n    reg [7:0] state;\n    reg [DATA_WIDTH-1:0] test_value;\n    reg [1:0]            delay = 1'b0;\n\n    localparam START = 8'd1,\n        VERIFY_INIT = 8'd2;\n\n    always @(posedge clk) begin\n        if(rst) begin\n            state <= START;\n            error <= 0;\n        end else begin\n            case(state)\n                START: begin\n                    loop_complete <= 0;\n                    state <= VERIFY_INIT;\n                    read_address <= 0;\n                    rom_read_address <= 0;\n                    error <= 0;\n                end\n                VERIFY_INIT: begin\n                    if(delay == 0) begin\n                        if(rom_read_data != read_data) begin\n                            error <= 1;\n                            error_state <= state;\n                            error_address <= read_address;\n                            expected_data <= rom_read_data;\n                            actual_data <= read_data;\n                        end else begin\n                            error <= 0;\n                        end\n                    end\n                    else if (delay == 1) begin\n                        if(read_address + ADDRESS_STEP <= MAX_ADDRESS) begin\n                            read_address <= read_address + ADDRESS_STEP;\n                            rom_read_address <= rom_read_address + ADDRESS_STEP;\n                        end else begin\n                            rom_read_address <= 0;\n                            read_address <= 0;\n                            loop_complete <= 1;\n                            state <= START;\n                        end\n                    end\n                    delay <= delay + 1;\n                end\n            endcase\n        end\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_counter_757a3f49", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register_counter (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    input in,         // Input signal to be delayed\n    input [3:0] delay, // Number of clock cycles to delay the input signal\n    output [3:0] q    // 4-bit output from the functional module\n);\n\n    reg [3:0] counter = 4'd0;\n    reg [3:0] shift_reg = 4'd0;\n    wire [3:0] delayed_out;\n    wire [3:0] counter_out;\n\n    // Shift register with delay\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 4'd0;\n        end else begin\n            shift_reg <= {in, shift_reg[3:1]};\n        end\n    end\n\n    assign delayed_out = shift_reg[delay];\n\n    // State machine counter\n    always @(posedge clk) begin\n        if (reset) begin\n            counter <= 4'd0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign counter_out = counter;\n\n    // Functional module\n    assign q = delayed_out | counter_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "key_gen_f250ac8e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule key_gen(previous_key,iteration,decrypt,non_perm_key,new_key);\n\ninput [55:0] previous_key;\ninput [3:0] iteration;\ninput decrypt;\noutput [55:0] non_perm_key;\noutput [47:0] new_key;\n\nreg [55:0] non_perm_key;\nreg [47:0] new_key;\n\n\nreg  prev0,prev1;\nreg[55:0]  prev_key_var,non_perm_key_var;\nreg[47:0]  new_key_var;\nreg[27:0]  semi_key;\n\n\nalways @(  previous_key or   iteration or   decrypt)\n\nbegin\n\n\n\t\n\tprev_key_var=previous_key;\n\tnew_key_var=0;\n\tnew_key = (0);\n\tnon_perm_key_var=0;\n\tnon_perm_key = (0);\n\t\n\tif(!decrypt)\n      begin\n\t  case(iteration)\n\n\t\t  0, 1, 8, 15:\n\t\t\tbegin\n\t\t      semi_key=prev_key_var[55:28];\n\t\t      prev0=semi_key[27];\n\t\t      semi_key=semi_key<<1;\n\t\t      semi_key[0]=prev0;\n\t\t      non_perm_key_var[55:28]=semi_key;\n\t\t      semi_key=prev_key_var[27:0];\n\t\t      prev0=semi_key[27];\n\t\t      semi_key=semi_key<<1;\n\t\t      semi_key[0]=prev0;\n\t\t      non_perm_key_var[27:0]=semi_key;\n\t\t     end\n\t\t  default:    \n\t\t\tbegin\n\t\t      semi_key=prev_key_var[55:28];\n\t\t      prev0=semi_key[27];\n\t\t      prev1=semi_key[26];\n\t\t      semi_key=semi_key<<2;\n\t\t      semi_key[1]=prev0;\n\t\t      semi_key[0]=prev1;\n\t\t      non_perm_key_var[55:28]=semi_key;\n\t\t      semi_key=prev_key_var[27:0];\n\t\t      prev0=semi_key[27];\n\t\t      prev1=semi_key[26];\n\t\t      semi_key=semi_key<<2;\n\t\t      semi_key[1]=prev0;\n\t\t      semi_key[0]=prev1;\n\t\t      non_perm_key_var[27:0]=semi_key;\n\t\t\tend\n      \n      endcase\n\t  end\n    else\n    begin\n\t  case(iteration)\n\n\t\t  0:\n\t\t  begin\n\t\t\t  semi_key=prev_key_var[55:28];\n\t\t      non_perm_key_var[55:28]=semi_key;\n\t\t      semi_key=prev_key_var[27:0];\n              non_perm_key_var[27:0]=semi_key;\n\t\t  end\n\t\t  1, 8, 15:\n\t\t  begin\n\t\t      semi_key=prev_key_var[55:28];\n\t\t      prev0=semi_key[0];\n\t\t      semi_key=semi_key>>1;\n\t\t      semi_key[27]=prev0;\n\t\t      non_perm_key_var[55:28]=semi_key;\n\t\t      semi_key=prev_key_var[27:0];\n\t\t      prev0=semi_key[0];\n\t\t      semi_key=semi_key>>1;\n\t\t      semi_key[27]=prev0;\n\t\t      non_perm_key_var[27:0]=semi_key;\n\t\t  end\n\t\t  default:    \n\t\t\tbegin\n\t\t      semi_key=prev_key_var[55:28];\n\t\t      prev0=semi_key[0];\n\t\t      prev1=semi_key[1];\n\t\t      semi_key=semi_key>>2;\n\t\t      semi_key[26]=prev0;\n\t\t      semi_key[27]=prev1;\n\t\t      non_perm_key_var[55:28]=semi_key;\n\t\t      semi_key=prev_key_var[27:0];\n\t\t      prev0=semi_key[0];\n\t\t      prev1=semi_key[1];\n\t\t      semi_key=semi_key>>2;\n\t\t      semi_key[26]=prev0;\n\t\t      semi_key[27]=prev1;\n\t\t      non_perm_key_var[27:0]=semi_key;\n\t\t  end\n\t \n      endcase\n\tend\n\n   \n   non_perm_key = (non_perm_key_var);\n      \n\n   new_key_var[47]=non_perm_key_var[42]; new_key_var[46]=non_perm_key_var[39]; new_key_var[45]=non_perm_key_var[45]; new_key_var[44]=non_perm_key_var[32];\n   new_key_var[43]=non_perm_key_var[55]; new_key_var[42]=non_perm_key_var[51]; new_key_var[41]=non_perm_key_var[53]; new_key_var[40]=non_perm_key_var[28];\n\t\n   new_key_var[39]=non_perm_key_var[41]; new_key_var[38]=non_perm_key_var[50]; new_key_var[37]=non_perm_key_var[35]; new_key_var[36]=non_perm_key_var[46];\n   new_key_var[35]=non_perm_key_var[33]; new_key_var[34]=non_perm_key_var[37]; new_key_var[33]=non_perm_key_var[44]; new_key_var[32]=non_perm_key_var[52];\n  \n   new_key_var[31]=non_perm_key_var[30]; new_key_var[30]=non_perm_key_var[48]; new_key_var[29]=non_perm_key_var[40]; new_key_var[28]=non_perm_key_var[49];\n   new_key_var[27]=non_perm_key_var[29]; new_key_var[26]=non_perm_key_var[36]; new_key_var[25]=non_perm_key_var[43]; new_key_var[24]=non_perm_key_var[54];\n\t\n   new_key_var[23]=non_perm_key_var[15]; new_key_var[22]=non_perm_key_var[4]; new_key_var[21]=non_perm_key_var[25]; new_key_var[20]=non_perm_key_var[19];\n   new_key_var[19]=non_perm_key_var[9]; new_key_var[18]=non_perm_key_var[1]; new_key_var[17]=non_perm_key_var[26]; new_key_var[16]=non_perm_key_var[16]; \n\n   new_key_var[15]=non_perm_key_var[5]; new_key_var[14]=non_perm_key_var[11]; new_key_var[13]=non_perm_key_var[23]; new_key_var[12]=non_perm_key_var[8]; \n   new_key_var[11]=non_perm_key_var[12]; new_key_var[10]=non_perm_key_var[7]; new_key_var[9]=non_perm_key_var[17]; new_key_var[8]=non_perm_key_var[0]; \n\t\n   new_key_var[7]=non_perm_key_var[22]; new_key_var[6]=non_perm_key_var[3]; new_key_var[5]=non_perm_key_var[10]; new_key_var[4]=non_perm_key_var[14]; \n   new_key_var[3]=non_perm_key_var[6]; new_key_var[2]=non_perm_key_var[20]; new_key_var[1]=non_perm_key_var[27]; new_key_var[0]=non_perm_key_var[24]; \n\n   new_key = (new_key_var);\n   \n\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux2_1_d46fbd46", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux2_1(\n    input A,\n    input B,\n    input SEL,\n    output VOUT,\n    output VOUT_N\n);\n    assign VOUT = (SEL)? B:A;\n    assign VOUT_N = ~(SEL)? B:A;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_adder_xor_b7eb5225", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_adder_xor (\n    input [1:0] a,b,c,d,\n    input [1:0] sel,\n    output [1:0] mux_out,\n    output [1:0] adder_out,\n    output [1:0] final_output\n);\n\n    // 4-to-1 multiplexer module\n    reg [1:0] mux_input;\n    always @(*) begin\n        case(sel)\n            2'b00: mux_input = a;\n            2'b01: mux_input = b;\n            2'b10: mux_input = c;\n            2'b11: mux_input = d;\n        endcase\n    end\n    assign mux_out = mux_input;\n\n    // 2-bit adder module\n    wire [1:0] adder_input = {mux_input, b};\n    wire [1:0] sum = adder_input + 2'b01;\n    assign adder_out = sum;\n\n    // Functional module for XOR operation\n    wire [1:0] xor_output = mux_out ^ adder_out;\n    assign final_output = xor_output;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__einvp_c4f094cd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ms__einvp (\n    Z ,\n    A ,\n    TE\n);\n\n    output Z ;\n    input  A ;\n    input  TE;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    notif1 notif10 (Z     , A, TE          );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "altera_up_video_camera_decoder_141c6266", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule altera_up_video_camera_decoder (\n\tclk,\n\treset,\n\n\tPIXEL_DATA,\n\tLINE_VALID,\n\tFRAME_VALID,\n\n\tready,\n\n\tdata,\n\tstartofpacket,\n\tendofpacket,\n\tvalid\n);\n\n\n\nparameter DW = 9;\n\n\n\ninput\t\t\t\t\t\tclk;\ninput\t\t\t\t\t\treset;\n\ninput\t\t\t[DW: 0]\tPIXEL_DATA;\ninput\t\t\t\t\t\tLINE_VALID;\ninput\t\t\t\t\t\tFRAME_VALID;\n\ninput\t\t\t\t\t\tready;\n\noutput reg\t[DW: 0]\tdata;\noutput reg\t\t\t\tstartofpacket;\noutput reg\t\t\t \tendofpacket;\noutput reg\t\t\t \tvalid;\n\n\n\n\nwire\t\t\t\tread_temps;\n\nreg\t\t\t[DW: 0]\tio_pixel_data;\nreg\t\t\t\t\t\tio_line_valid;\nreg\t\t\t\t\t\tio_frame_valid;\n\nreg\t\t\t\t\t\tframe_sync;\n\nreg\t\t\t[DW: 0]\ttemp_data;\nreg\t\t\t\t\t\ttemp_start;\nreg\t\t\t\t\t\ttemp_end;\nreg\t\t\t\t\t\ttemp_valid;\n\n\n\n\n\nalways @ (posedge clk)\nbegin\n\tio_pixel_data\t\t<= PIXEL_DATA;\n\tio_line_valid\t\t<= LINE_VALID;\n\tio_frame_valid\t\t<= FRAME_VALID;\nend\n\nalways @ (posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\tdata\t\t\t\t<= 'h0;\n\t\tstartofpacket\t<= 1'b0;\n\t\tendofpacket\t\t<= 1'b0;\n\t\tvalid\t\t\t\t<= 1'b0;\n\tend\n\telse if (read_temps)\n\tbegin\n\t\tdata\t\t\t\t<= temp_data;\n\t\tstartofpacket\t<= temp_start;\n\t\tendofpacket\t\t<= temp_end;\n\t\tvalid\t\t\t\t<= temp_valid;\n\tend\n\telse if (ready)\n\t\tvalid\t\t\t\t<= 1'b0;\nend\n\nalways @ (posedge clk)\nbegin\n\tif (reset)\n\t\tframe_sync \t\t<= 1'b0;\n\telse if (~io_frame_valid)\n\t\tframe_sync \t\t<= 1'b1;\n\telse if (io_line_valid & io_frame_valid)\n\t\tframe_sync \t\t<= 1'b0;\nend\n\nalways @ (posedge clk)\nbegin\n\tif (reset)\n\tbegin\n\t\ttemp_data \t\t<= 'h0;\n\t\ttemp_start\t\t<= 1'b0;\n\t\ttemp_end\t\t\t<= 1'b0;\n\t\ttemp_valid\t\t<= 1'b0;\n\tend\n\telse if (read_temps)\n\tbegin\n\t\ttemp_data \t\t<= io_pixel_data;\n\t\ttemp_start\t\t<= frame_sync;\n\t\ttemp_end\t\t\t<= ~io_frame_valid;\n\t\ttemp_valid\t\t<= io_line_valid & io_frame_valid;\n\tend\n\telse if (~io_frame_valid)\n\tbegin\n\t\ttemp_end\t\t\t<= ~io_frame_valid;\n\tend\nend\n\n\nassign read_temps = (ready | ~valid) & \n\t((io_line_valid & io_frame_valid) | \n\t ((temp_start | temp_end) & temp_valid));\n\n\n\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_b29231c4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n    input clk,\n    input up_down,\n    input reset,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'b0;\n        end else begin\n            if (up_down) begin\n                out <= out + 4'b1;\n            end else begin\n                out <= out - 4'b1;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_3to8_case_99b0211b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_3to8_case (\n    input A, B, C,\n    output reg [7:0] Y\n);\n\n    always @* begin\n        case ({A, B, C})\n            3'b000: Y = 8'b00000001;\n            3'b001: Y = 8'b00000010;\n            3'b010: Y = 8'b00000100;\n            3'b011: Y = 8'b00001000;\n            3'b100: Y = 8'b00010000;\n            3'b101: Y = 8'b00100000;\n            3'b110: Y = 8'b01000000;\n            3'b111: Y = 8'b10000000;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "t_ff_6e670c8e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule t_ff (\n    input clk,\n    input t,\n    output reg q\n);\n\nreg d1, d2;\n\nalways @(posedge clk) begin\n    d1 <= t;\n    d2 <= d1;\n    q <= d1 ^ d2;\nend\n\nendmodule\nmodule bcd_counter (\n    input clk,\n    input reset,\n    input [2:0] ena, // ena[3] is undef\n    output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        count <= 4'b0000;\n    end else begin\n        if (ena[0]) begin\n            if (count[0] == 4'b1001) begin\n                count[0] <= 4'b0000;\n                if (ena[1]) begin\n                    if (count[1] == 4'b1001) begin\n                        count[1] <= 4'b0000;\n                        if (ena[2]) begin\n                            if (count[2] == 4'b1001) begin\n                                count[2] <= 4'b0000;\n                                if (count[3] == 4'b1001) begin\n                                    count[3] <= 4'b0000;\n                                end else begin\n                                    count[3] <= count[3] + 1;\n                                end\n                            end else begin\n                                count[2] <= count[2] + 1;\n                            end\n                        end\n                    end else begin\n                        count[1] <= count[1] + 1;\n                    end\n                end\n            end else begin\n                count[0] <= count[0] + 1;\n            end\n        end\n    end\nend\n\nendmodule\nmodule functional_module (\n    input t,\n    input [3:0] count,\n    output [15:0] q\n);\n\nassign q = {count, 1'b0} | (t ? 16'b0000000000000001 : 16'b0);\n\nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input t,\n    output reg [2:0] ena,\n    output [15:0] q\n);\n\nwire t_ff_q;\nwire [3:0] bcd_count;\n\nt_ff t_ff_inst (\n    .clk(clk),\n    .t(t),\n    .q(t_ff_q)\n);\n\nbcd_counter bcd_counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .ena(ena),\n    .count(bcd_count)\n);\n\nfunctional_module functional_module_inst (\n    .t(t_ff_q),\n    .count(bcd_count),\n    .q(q)\n);\n\ninitial begin\n    ena = 3'b000;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "util_rfifo_7e6aa621", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule util_rfifo (\n\n  dac_clk,\n  dac_rd,\n  dac_rdata,\n  dac_runf,\n\n  dma_clk,\n  dma_rd,\n  dma_rdata,\n  dma_runf,\n\n  fifo_rst,\n  fifo_rstn,\n  fifo_wr,\n  fifo_wdata,\n  fifo_wfull,\n  fifo_rd,\n  fifo_rdata,\n  fifo_rempty,\n  fifo_runf);\n\n  parameter DAC_DATA_WIDTH = 32;\n  parameter DMA_DATA_WIDTH = 64;\n \n  input                           dac_clk;\n  input                           dac_rd;\n  output  [DAC_DATA_WIDTH-1:0]    dac_rdata;\n  output                          dac_runf;\n\n  input                           dma_clk;\n  output                          dma_rd;\n  input   [DMA_DATA_WIDTH-1:0]    dma_rdata;\n  input                           dma_runf;\n\n  output                          fifo_rst;\n  output                          fifo_rstn;\n  output                          fifo_wr;\n  output  [DMA_DATA_WIDTH-1:0]    fifo_wdata;\n  input                           fifo_wfull;\n  output                          fifo_rd;\n  input   [DAC_DATA_WIDTH-1:0]    fifo_rdata;\n  input                           fifo_rempty;\n  input                           fifo_runf;\n\n  reg     [ 1:0]                  dac_runf_m = 'd0;\n  reg                             dac_runf = 'd0;\n  reg                             dma_rd = 'd0;\n\n  always @(posedge dac_clk) begin\n    dac_runf_m[0] <= dma_runf | fifo_runf;\n    dac_runf_m[1] <= dac_runf_m[0];\n    dac_runf <= dac_runf_m[1];\n  end\n\n  always @(posedge dma_clk) begin\n    dma_rd <= ~fifo_wfull;\n  end\n\n  assign fifo_wr = dma_rd;\n\n  genvar s;\n  generate\n  for (s = 0; s < DMA_DATA_WIDTH; s = s + 1) begin: g_wdata\n  assign fifo_wdata[s] = dma_rdata[(DMA_DATA_WIDTH-1)-s];\n  end\n  endgenerate\n\n  assign fifo_rd = ~fifo_rempty & dac_rd;\n\n  genvar m;\n  generate\n  for (m = 0; m < DAC_DATA_WIDTH; m = m + 1) begin: g_rdata\n  assign dac_rdata[m] = fifo_rdata[(DAC_DATA_WIDTH-1)-m];\n  end\n  endgenerate\n\n  assign fifo_rst = 1'b0;\n  assign fifo_rstn = 1'b1;\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "scale_1d #_72676cb5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule scale_1d #\n(\n\tparameter integer C_M_WIDTH = 12,\n\tparameter integer C_S_WIDTH = 10,\n\n\tparameter integer C_S_ADDR_WIDTH = 32\n)\n(\n\tinput wire clk,\n\tinput wire resetn,\n\n\tinput wire [C_S_WIDTH-1:0] s_width,\n\tinput wire [C_M_WIDTH-1:0] m_width,\n\n\tinput wire start,\n\n\toutput wire o_valid,\n\toutput wire [C_S_WIDTH-1:0] s_index,\n\toutput wire [C_M_WIDTH-1:0] m_index,\n\toutput wire o_last,\n\tinput wire  o_ready,\n\n\tinput  wire [C_S_ADDR_WIDTH-1:0] s_base_addr,\n\tinput  wire [C_S_ADDR_WIDTH-1:0] s_off_addr,\n\tinput  wire [C_S_ADDR_WIDTH-1:0] s_inc_addr,\n\toutput reg  [C_S_ADDR_WIDTH-1:0] s_addr\n);\n\n\tlocalparam integer C_CNT_WIDTH = C_M_WIDTH + C_S_WIDTH;\n\n\twire progress;\n\tassign progress = ~o_valid || o_ready;\n\twire next;\n\tassign next = o_valid && o_ready;\n\n\treg [C_CNT_WIDTH-1 : 0] s_cnt;\n\treg [C_CNT_WIDTH-1 : 0] m_cnt;\n\n\treg [C_S_WIDTH-1 : 0] s_idx;\n\tassign s_index = s_idx;\n\treg [C_M_WIDTH-1 : 0] m_idx;\n\tassign m_index = m_idx;\n\n\treg running;\n\talways @(posedge clk) begin\n\t\tif (resetn == 0) begin\n\t\t\trunning <= 0;\n\t\tend\n\t\telse if (start) begin\n\t\t\trunning <= 1;\n\t\tend\n\t\telse if (next && m_idx == m_width - 1) begin\n\t\t\trunning <= 0;\n\t\tend\n\tend\n\n\tassign o_valid = (running && s_cnt >= m_cnt);\n\talways @(posedge clk) begin\n\t\tif (resetn == 0) begin\n\t\t\ts_cnt <= 0;\n\t\t\ts_idx <= 0;\n\t\t\ts_addr <= 0;\n\n\t\t\tm_cnt <= 0;\n\t\t\tm_idx <= 0;\n\t\tend\n\t\telse if (start) begin\n\t\t\ts_cnt <= m_width;\n\t\t\ts_idx <= 0;\n\t\t\ts_addr <= s_base_addr + s_off_addr;\n\n\t\t\tm_cnt <= s_width;\n\t\t\tm_idx <= 0;\n\t\tend\n\t\telse if (running) begin\n\t\t\tif (progress) begin\n\t\t\t\tif (s_cnt <= m_cnt) begin\n\t\t\t\t\ts_cnt <= s_cnt + m_width;\n\t\t\t\t\ts_idx <= s_idx + 1;\n\t\t\t\t\ts_addr <= s_addr + s_inc_addr;\n\t\t\t\tend\n\t\t\t\tif (s_cnt >= m_cnt) begin\n\t\t\t\t\tm_cnt <= m_cnt + s_width;\n\t\t\t\t\tm_idx <= m_idx + 1;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\n\treg last;\n\tassign o_last = last;\n\talways @(posedge clk) begin\n\t\tif (resetn == 0) begin\n\t\t\tlast <= 0;\n\t\tend\n\t\telse if (start) begin\n\t\t\tlast <= 0;\n\t\tend\n\t\telse if (next && m_idx == m_width - 2) begin\n\t\t\tlast <= 1;\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "system_axi_quad_spi_shield_0_wr_status_flags_as_d61aebb1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule system_axi_quad_spi_shield_0_wr_status_flags_as\n   (\\gic0.gc1.count_reg[0] ,\n    E,\n    \\gic0.gc1.count_d2_reg[0] ,\n    s_axi_aclk,\n    out,\n    p_6_in,\n    ip2Bus_WrAck_core_reg_1,\n    Bus_RNW_reg);\n  output \\gic0.gc1.count_reg[0] ;\n  output [0:0]E;\n  input \\gic0.gc1.count_d2_reg[0] ;\n  input s_axi_aclk;\n  input out;\n  input p_6_in;\n  input ip2Bus_WrAck_core_reg_1;\n  input Bus_RNW_reg;\n\n  wire Bus_RNW_reg;\n  wire [0:0]E;\n  wire \\gic0.gc1.count_d2_reg[0] ;\n  wire ip2Bus_WrAck_core_reg_1;\n  wire out;\n  wire p_6_in;\n  reg ram_full_fb_i;\n  reg ram_full_i;\n  reg ram_full_i_reg0;\n  reg ram_full_i_reg1;\n  reg ram_full_i_reg2;\n  wire s_axi_aclk;\n\n  assign \\gic0.gc1.count_reg[0]  = ram_full_i_reg2;\n  assign E = 1'b0;\n\n   reg [255:0] ram [0:0] ; \n\n  always @(posedge s_axi_aclk) begin\n    if (p_6_in) begin\n        ram[0][ip2Bus_WrAck_core_reg_1] <= 1'b1;\n    end\n  end\n\n  // Flip-flops\n  always @(posedge s_axi_aclk) begin\n    if (Bus_RNW_reg) begin\n      ram_full_i <= out;\n      ram_full_fb_i <= 1'b0;\n    end\n    else begin\n      ram_full_fb_i <= ram_full_i;\n    end\n  end\n\n  always @(posedge s_axi_aclk) begin\n    ram_full_i_reg0 <= ram_full_fb_i;\n    ram_full_i_reg1 <= ram_full_i_reg0;\n    ram_full_i_reg2 <= ram_full_i_reg1;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__5885fe3f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [3:0] A,\n    input [3:0] B,\n    output eq,\n    output gt,\n    input C,\n    input [3:0] D,\n    output [3:0] final_output\n);\n\n    assign eq = (A == B); \n    assign gt = (A > B); \n\n\n    wire [3:0] shifted_value;\n    assign shifted_value = (C == 0) ? (A << D[1:0]) : (A >> D[1:0]); // Limit shift to meaningful range\n\n\n    assign final_output = eq ? shifted_value : 4'b0000;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_8c9dfa74", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module( \n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output reg [7:0] final_out\n);\n\n    // 2-level AND-OR circuit\n    wire [1:0] and_out;\n    assign and_out[0] = in[0] & in[1];\n    assign and_out[1] = in[2] & in[3];\n    assign out_and = and_out[0] | and_out[1];\n    \n    // 2-level OR-AND circuit\n    wire [1:0] or_out;\n    assign or_out[0] = in[0] | in[1];\n    assign or_out[1] = in[2] | in[3];\n    assign out_or = or_out[0] & or_out[1];\n    \n    // 2-level XOR-AND circuit\n    wire [1:0] xor_out;\n    assign xor_out[0] = in[0] ^ in[1];\n    assign xor_out[1] = in[2] ^ in[3];\n    assign out_xor = xor_out[0] & xor_out[1];\n    \n    // Final output\n    always @* begin\n        final_out = {1'b0, out_and, out_or, out_xor};\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "signal_module_936bd7b8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule signal_module(\n    input clk,\n    input reset,\n    input [3:0] data_in,\n    input enable,\n    output [3:0] data_out,\n    output parity,\n    output overflow,\n    output underflow\n);\n\nreg [3:0] data_out_reg;\nreg parity_reg;\nreg overflow_reg;\nreg underflow_reg;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        data_out_reg <= 4'b0000;\n        parity_reg <= 1'b0;\n        overflow_reg <= 1'b0;\n        underflow_reg <= 1'b0;\n    end else if (enable) begin\n        data_out_reg <= data_out_reg + data_in;\n        parity_reg <= ~parity_reg;\n        overflow_reg <= (data_out_reg + data_in) > 4'b1111;\n        underflow_reg <= (data_out_reg + data_in) < 4'b0000;\n    end\nend\n\nassign data_out = data_out_reg;\nassign parity = parity_reg;\nassign overflow = overflow_reg;\nassign underflow = underflow_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_536e986e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule mux4to1 (\n    input in0,\n    input in1,\n    input in2,\n    input in3,\n    input sel0,\n    input sel1,\n    output out,\n    inout VPWR,\n    inout VGND,\n    inout VPB,\n    inout VNB\n);\n\n    assign out = (sel1 & (sel0 & in0 | ~sel0 & in1)) | (~sel1 & (sel0 & in2 | ~sel0 & in3));\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sqrt_16bit_c0e70a85", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sqrt_16bit (\n    input [15:0] a,\n    input ctrl,\n    output reg [15:0] b\n);\n\n    reg [15:0] x;\n    reg [3:0] i;\n    reg [15:0] temp;\n\n    always @(*) begin\n        x = 8'd0;\n        i = 4'd0;\n        temp = 16'd0;\n        for (i = 4'd0; i < 4'd8; i = i + 1) begin\n            temp = (x << 1) + (1 << (7 - i));\n            if (temp * temp <= a) begin\n                x = temp;\n            end\n        end\n        if (ctrl == 1) begin\n            if (((x + 1) * (x + 1) - a) <= (a - x * x)) begin\n                b = x + 1;\n            end else begin\n                b = x;\n            end\n        end else begin\n            b = x;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__89baf090", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input wire [15:0] in,\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire [7:0] out\n);\n\n    wire [7:0] upper_byte;\n    wire [7:0] lower_byte;\n    wire [7:0] sum;\n    wire overflow;\n\n    byte_splitter bs(\n        .in(in),\n        .out_hi(upper_byte),\n        .out_lo(lower_byte)\n    );\n\n    add_overflow_detection aod_upper(\n        .a(a),\n        .b(upper_byte),\n        .s(sum),\n        .overflow(overflow)\n    );\n\n    add_overflow_detection aod_lower(\n        .a(b),\n        .b(lower_byte),\n        .s(),\n        .overflow()\n    );\n\n    assign out = sum;\n\nendmodule\nmodule byte_splitter (\n    input wire [15:0] in,\n    output wire [7:0] out_hi,\n    output wire [7:0] out_lo\n);\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\nendmodule\nmodule add_overflow_detection (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    reg [8:0] temp_sum;\n    assign s = temp_sum[7:0];\n    assign overflow = (temp_sum[8] == 1);\n\n    always @(*) begin\n        temp_sum = a + b;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hs__a222o_0559ff41", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_hs__a222o (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2,\n    C1,\n    C2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n    input  C1;\n    input  C2;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n\n    assign X = ((A1 & A2) | (B1 & B2) | (~C1 & ~C2)) ? 1'b1 : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sync_ptr_d27fe5fd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sync_ptr\n\n    #(\n    parameter ASIZE = 4\n    )(\n    input  wire              dest_clk,\n    input  wire              dest_rst_n,\n    input  wire [ASIZE:0] src_ptr,\n    output reg  [ASIZE:0] dest_ptr\n    );\n\n    reg [ASIZE:0] ptr_x;\n\n    always @(posedge dest_clk or negedge dest_rst_n) begin\n\n        if (!dest_rst_n)\n            {dest_ptr,ptr_x} <= 0;\n        else\n            {dest_ptr,ptr_x} <= {ptr_x,src_ptr};\n    end\n\nendmodule\n\n`resetall\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "user_design_cbce69ca", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule user_design\n   (IN1_STB,\n    OUT1_ACK,\n    output_rs232_out,\n    INTERNAL_RST_reg,\n    OUT1,\n    IN1_ACK,\n    ETH_CLK_OBUF,\n    OUT1_STB);\n  output IN1_STB;\n  output OUT1_ACK;\n  output [7:0]output_rs232_out;\n  input INTERNAL_RST_reg;\n  input [7:0]OUT1;\n  input IN1_ACK;\n  input ETH_CLK_OBUF;\n  input OUT1_STB;\n\n  assign IN1_STB = (INTERNAL_RST_reg == 1'b0) && (IN1_ACK == 1'b1) && (OUT1_STB == 1'b0);\n  assign OUT1_ACK = (INTERNAL_RST_reg == 1'b0) && (OUT1_STB == 1'b1);\n  assign output_rs232_out = (INTERNAL_RST_reg == 1'b0) && (OUT1_STB == 1'b1) ? OUT1 : 8'h0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "parity #_7c9351b3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule parity #(\n  parameter n = 8 // width of the data stream (number of bits)\n)(\n  input [n-1:0] data,\n  input sel,\n  output parity,\n  output [n:0] out\n);\n\n\nreg [n-1:0] temp_data;\nreg [n:0] temp_out;\nreg temp_parity;\n\ninteger i;\ninteger count;\n\nalways @(*) begin\n  count = 0;\n  for (i = 0; i < n; i = i + 1) begin\n    if (data[i] == 1) begin\n      count = count + 1;\n    end\n  end\n  \n  if (sel == 0) begin // parity generator\n    if (count % 2 == 0) begin // even parity\n      temp_parity = 0;\n      temp_out = {data, temp_parity};\n    end\n    else begin // odd parity\n      temp_parity = 1;\n      temp_out = {data, temp_parity};\n    end\n  end\n  else begin // parity checker\n    if (count % 2 == 0) begin // even parity\n      temp_parity = 0;\n      temp_out = data;\n    end\n    else begin // odd parity\n      temp_parity = 1;\n      temp_out = data ^ 1; // flip the last bit to correct the parity\n    end\n  end\nend\n\nassign parity = temp_parity;\nassign out = temp_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "barrel_shifter_4bit_babef8b8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule barrel_shifter_4bit (\n    input [3:0] DATA_IN,\n    input [1:0] SHIFT,\n    output reg [3:0] DATA_OUT\n);\n\n    always @(*) begin\n        case(SHIFT)\n            2'b00: DATA_OUT = DATA_IN;\n            2'b01: DATA_OUT = {DATA_IN[3], DATA_IN[2:0]};\n            2'b10: DATA_OUT = {DATA_IN[2:0], DATA_IN[3]};\n            2'b11: DATA_OUT = {DATA_IN[1:0], DATA_IN[3:2]};\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_66d12da0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1 (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "lcd_driver_d6047d03", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule lcd_driver (\n  input [3:0] data,\n  input [1:0] ctrl,\n  output [6:0] seg\n);\n\n  // Define the 7-bit segment signal as a Boolean function of the 4-bit data signal and the 2-bit control signal\n  assign seg[0] = (data[0] & ctrl[0]) | (~data[0] & ctrl[1]);\n  assign seg[1] = (data[1] & ctrl[0]) | (~data[1] & ctrl[1]);\n  assign seg[2] = (data[2] & ctrl[0]) | (~data[2] & ctrl[1]);\n  assign seg[3] = (data[3] & ctrl[0]) | (~data[3] & ctrl[1]);\n  assign seg[4] = ctrl[0];\n  assign seg[5] = ctrl[1];\n  assign seg[6] = 0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_adder_2317b27c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_adder (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    input [1:0] add_in,\n    input clk,\n    input reset,\n    input select,\n    output reg [7:0] out\n);\n\nreg [3:0] mux_out;\nreg [1:0] add_out;\n\nalways @ (sel or data0 or data1 or data2 or data3 or data4 or data5) begin\n    case (sel)\n        3'b000: mux_out = data0;\n        3'b001: mux_out = data1;\n        3'b010: mux_out = data2;\n        3'b011: mux_out = data3;\n        3'b100: mux_out = data4;\n        3'b101: mux_out = data5;\n        default: mux_out = 4'b0;\n    endcase\nend\n\nalways @ (add_in or select) begin\n    if (select == 1'b0) begin\n        add_out = 2'b0;\n    end else begin\n        add_out = add_in;\n    end\nend\n\nalways @ (posedge clk or posedge reset) begin\n    if (reset) begin\n        out <= 8'b0;\n    end else begin\n        if (select == 1'b0) begin\n            out <= mux_out;\n        end else begin\n            out <= {2'b0, mux_out} + {2'b0, add_out};\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pfpu_prog_6fbd571c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule pfpu_prog(\n\tinput sys_clk,\n\tinput count_rst,\n\n\toutput [6:0] a_addr,\n\toutput [6:0] b_addr,\n\toutput [3:0] opcode,\n\toutput [6:0] w_addr,\n\t\n\t\n\tinput c_en,\n\tinput [1:0] c_page,\n\tinput [8:0] c_offset,\n\toutput [31:0] c_do,\n\tinput [31:0] c_di,\n\tinput c_w_en,\n\n\toutput [10:0] pc\n);\n\n\nwire [10:0] mem_a;\nwire [24:0] mem_di;\nreg [24:0] mem_do;\nwire mem_we;\nreg [24:0] mem[0:2047];\nalways @(posedge sys_clk) begin\n\tif(mem_we)\n\t\tmem[mem_a] <= mem_di;\n\tmem_do <= mem[mem_a];\nend\n\n\nreg [10:0] counter;\nalways @(posedge sys_clk) begin\n\tif(count_rst)\n\t\tcounter <= 10'd0;\n\telse\n\t\tcounter <= counter + 10'd1;\nend\nassign mem_a = c_en ? {c_page, c_offset} : counter;\n\nassign c_do = {7'd0, mem_do};\nassign mem_di = c_di[24:0];\nassign mem_we = c_en & c_w_en;\n\nassign a_addr = mem_do[24:18];\tassign b_addr = mem_do[17:11];\tassign opcode = mem_do[10:7];\tassign w_addr = mem_do[6:0];\tassign pc = counter;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4to1_5c5b6652", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4to1 (\n    // module ports\n    input [3:0] D,\n    input S0,\n    input S1,\n    output Y\n);\n\n    wire not_S1;\n    wire not_S0;\n\n    // invert S1 and S0 signals\n    assign not_S1 = ~S1;\n    assign not_S0 = ~S0;\n\n    // select the correct input based on S1 and S0\n    assign Y = (D[0] & not_S1 & not_S0) | (D[1] & not_S1 & S0) | (D[2] & S1 & not_S0) | (D[3] & S1 & S0);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__o22a_095569e2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__o22a (\n    X ,\n    A1,\n    A2,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  B2;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out   ;\n    wire or1_out   ;\n    wire and0_out_X;\n\n    or  or0  (or0_out   , A2, A1          );\n    or  or1  (or1_out   , B2, B1          );\n    and and0 (and0_out_X, or0_out, or1_out);\n    buf buf0 (X         , and0_out_X      );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "generic_dpram_faa6eece", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define VENDOR_FPGA\nmodule generic_dpram(\n\trclk, rrst, rce, oe, raddr, do,\n\twclk, wrst, wce, we, waddr, di\n);\n\n\tparameter aw = 5;  parameter dw = 16; input           rclk;  input           rrst;  input           rce;   input           oe;\t   input  [aw-1:0] raddr; output [dw-1:0] do;    input          wclk;  input          wrst;  input          wce;   input          we;    input [aw-1:0] waddr; input [dw-1:0] di;    `ifdef VENDOR_FPGA\n\treg [dw-1:0] mem [(1<<aw) -1:0]; reg [aw-1:0] ra;                 always @(posedge rclk)\n\t  if (rce)\n\t    ra <= raddr;\n\n\tassign do = mem[ra];\n\n\talways@(posedge wclk)\n\t\tif (we && wce)\n\t\t\tmem[waddr] <= di;\n\n`else\n\n`ifdef VENDOR_XILINX\n\txilinx_ram_dp xilinx_ram(\n\t\t.CLKA(rclk),\n\t\t.RSTA(rrst),\n\t\t.ENA(rce),\n\t\t.ADDRA(raddr),\n\t\t.DIA( {dw{1'b0}} ),\n\t\t.WEA(1'b0),\n\t\t.DOA(do),\n\n\t\t.CLKB(wclk),\n\t\t.RSTB(wrst),\n\t\t.ENB(wce),\n\t\t.ADDRB(waddr),\n\t\t.DIB(di),\n\t\t.WEB(we),\n\t\t.DOB()\n\t);\n\n\tdefparam\n\t\txilinx_ram.dwidth = dw,\n\t\txilinx_ram.awidth = aw;\n\n`else\n\n`ifdef VENDOR_ALTERA\n\taltera_ram_dp altera_ram(\n\t\t.rdclock(rclk),\n\t\t.rdclocken(rce),\n\t\t.rdaddress(raddr),\n\t\t.q(do),\n\n\t\t.wrclock(wclk),\n\t\t.wrclocken(wce),\n\t\t.wren(we),\n\t\t.wraddress(waddr),\n\t\t.data(di)\n\t);\n\n\tdefparam\n\t\taltera_ram.dwidth = dw,\n\t\taltera_ram.awidth = aw;\n\n`else\n\n`ifdef VENDOR_ARTISAN\n\n\tart_hsdp #(dw, 1<<aw, aw) artisan_sdp(\n\t\t.qa(do),\n\t\t.clka(rclk),\n\t\t.cena(~rce),\n\t\t.wena(1'b1),\n\t\t.aa(raddr),\n\t\t.da( {dw{1'b0}} ),\n\t\t.oena(~oe),\n\n\t\t.qb(),\n\t\t.clkb(wclk),\n\t\t.cenb(~wce),\n\t\t.wenb(~we),\n\t\t.ab(waddr),\n\t\t.db(di),\n\t\t.oenb(1'b1)\n\t);\n\n`else\n\n`ifdef VENDOR_AVANT\n\n\tavant_atp avant_atp(\n\t\t.web(~we),\n\t\t.reb(),\n\t\t.oeb(~oe),\n\t\t.rcsb(),\n\t\t.wcsb(),\n\t\t.ra(raddr),\n\t\t.wa(waddr),\n\t\t.di(di),\n\t\t.do(do)\n\t);\n\n`else\n\n`ifdef VENDOR_VIRAGE\n\n\tvirage_stp virage_stp(\n\t\t.CLKA(rclk),\n\t\t.MEA(rce_a),\n\t\t.ADRA(raddr),\n\t\t.DA( {dw{1'b0}} ),\n\t\t.WEA(1'b0),\n\t\t.OEA(oe),\n\t\t.QA(do),\n\n\t\t.CLKB(wclk),\n\t\t.MEB(wce),\n\t\t.ADRB(waddr),\n\t\t.DB(di),\n\t\t.WEB(we),\n\t\t.OEB(1'b1),\n\t\t.QB()\n\t);\n\n`else\n\n\treg\t[dw-1:0]\tmem [(1<<aw)-1:0]; reg\t[dw-1:0]\tdo_reg;            assign do = (oe & rce) ? do_reg : {dw{1'bz}};\n\n\talways @(posedge rclk)\n\t\tif (rce)\n          \t\tdo_reg <= (we && (waddr==raddr)) ? {dw{1'b x}} : mem[raddr];\n\n\talways @(posedge wclk)\n\t\tif (wce && we)\n\t\t\tmem[waddr] <= di;\n\n\n\ttask print_ram;\n\tinput [aw-1:0] start;\n\tinput [aw-1:0] finish;\n\tinteger rnum;\n  \tbegin\n    \t\tfor (rnum=start;rnum<=finish;rnum=rnum+1)\n      \t\t\t$display(\"Addr %h = %h\",rnum,mem[rnum]);\n  \tend\n\tendtask\n\n`endif `endif `endif `endif `endif `endif endmodule\n\n`ifdef VENDOR_ALTERA\n\tmodule altera_ram_dp(\n\t\tdata,\n\t\twraddress,\n\t\trdaddress,\n\t\twren,\n\t\twrclock,\n\t\twrclocken,\n\t\trdclock,\n\t\trdclocken,\n\t\tq) ;\n\n\t\tparameter awidth = 7;\n\t\tparameter dwidth = 8;\n\n\t\tinput [dwidth -1:0] data;\n\t\tinput [awidth -1:0] wraddress;\n\t\tinput [awidth -1:0] rdaddress;\n\t\tinput               wren;\n\t\tinput               wrclock;\n\t\tinput               wrclocken;\n\t\tinput               rdclock;\n\t\tinput               rdclocken;\n\t\toutput [dwidth -1:0] q;\n\n\t\tsyn_dpram_rowr #(\n\t\t\t\"UNUSED\",\n\t\t\tdwidth,\n\t\t\tawidth,\n\t\t\t1 << awidth\n\t\t)\n\t\taltera_dpram_model (\n\t\t\t.RdClock(rdclock),\n\t\t\t.RdClken(rdclocken),\n\t\t\t.RdAddress(rdaddress),\n\t\t\t.RdEn(1'b1),\n\t\t\t.Q(q),\n\n\t\t\t.WrClock(wrclock),\n\t\t\t.WrClken(wrclocken),\n\t\t\t.WrAddress(wraddress),\n\t\t\t.WrEn(wren),\n\t\t\t.Data(data)\n\t\t);\n\n\t\tendmodule\n`endif `ifdef VENDOR_XILINX\n\tmodule xilinx_ram_dp (\n\t\tADDRA,\n\t\tCLKA,\n\t\tADDRB,\n\t\tCLKB,\n\t\tDIA,\n\t\tWEA,\n\t\tDIB,\n\t\tWEB,\n\t\tENA,\n\t\tENB,\n\t\tRSTA,\n\t\tRSTB,\n\t\tDOA,\n\t\tDOB)  ;\n\n\tparameter awidth = 7;\n\tparameter dwidth = 8;\n\n\tinput               CLKA;\n\tinput               RSTA;\n\tinput               ENA;\n\tinput [awidth-1:0]  ADDRA;\n\tinput [dwidth-1:0]  DIA;\n\tinput               WEA;\n\toutput [dwidth-1:0] DOA;\n\n\tinput               CLKB;\n\tinput               RSTB;\n\tinput               ENB;\n\tinput [awidth-1:0]  ADDRB;\n\tinput [dwidth-1:0]  DIB;\n\tinput               WEB;\n\toutput [dwidth-1:0] DOB;\n\n\tC_MEM_DP_BLOCK_V1_0 #(\n\t\tawidth,\n\t\tawidth,\n\t\t1,\n\t\t1,\n\t\t\"0\",\n\t\t1 << awidth,\n\t\t1 << awidth,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t\"\",\n\t\t16,\n\t\t0,\n\t\t0,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\t1,\n\t\tdwidth,\n\t\tdwidth)\n\txilinx_dpram_model (\n\t\t.ADDRA(ADDRA),\n\t\t.CLKA(CLKA),\n\t\t.ADDRB(ADDRB),\n\t\t.CLKB(CLKB),\n\t\t.DIA(DIA),\n\t\t.WEA(WEA),\n\t\t.DIB(DIB),\n\t\t.WEB(WEB),\n\t\t.ENA(ENA),\n\t\t.ENB(ENB),\n\t\t.RSTA(RSTA),\n\t\t.RSTB(RSTB),\n\t\t.DOA(DOA),\n\t\t.DOB(DOB));\n\n\t\tendmodule\n`endif "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "VGACtrl_ed9ad47b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule VGACtrl(clk, reset, vga_h_sync, vga_v_sync, inDisplayArea, CounterX, CounterY);\n\ninput clk, reset;\n\noutput vga_h_sync, vga_v_sync;\noutput inDisplayArea;\noutput [9:0] CounterX;\noutput [9:0] CounterY;\n\nreg [9:0] CounterX;\nreg [9:0] CounterY;\nreg vga_HS, vga_VS;\nreg inDisplayArea;\n\nalways @(posedge clk, posedge reset)\n\tbegin\n\t\tif(reset)\n\t\t\tCounterX <= 0;\n\t\telse if(CounterX==10'h320)\n\t\t\tCounterX <= 0;\n\t\telse\n\t\t\tCounterX <= CounterX + 1;\n\tend\n\nalways @(posedge clk, posedge reset)\n\tbegin\n\t\tif(reset)\n\t\t\tCounterY<=0; \n\t\telse if(CounterY==10'h209)    CounterY<=0;\n\t\telse if(CounterX==10'h320)    CounterY <= CounterY + 1;\n\tend\n\t\nalways @(posedge clk)\n\tbegin\n\t\tvga_HS <= (CounterX > 655 && CounterX < 752); \tvga_VS <= (CounterY == 490 || CounterY == 491); \tend \n\n\nalways @(posedge clk, posedge reset)\n   if(reset)\n      inDisplayArea<=0;\n   else\n\t   inDisplayArea <= (CounterX<640) && (CounterY<480);\n\t\nassign vga_h_sync = ~vga_HS;\nassign vga_v_sync = ~vga_VS;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__dlxtn_d9066d82", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_ms__dlxtn (\n    input D,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    input GATE_N,\n    output reg Q\n);\n\nalways @ (GATE_N, VPWR, VGND, VPB, VNB, D)\nbegin\n    if (GATE_N == 1'b0) begin\n        Q <= 1'bx;\n    end else begin\n        if (VPWR == 1'b1 && VGND == 1'b0) begin\n            Q <= D;\n        end else if (VPWR == 1'b0 && VGND == 1'b0) begin\n            Q <= VPB;\n        end else if (VPWR == 1'b1 && VGND == 1'b1) begin\n            Q <= VNB;\n        end else if (VPWR == 1'b0 && VGND == 1'b1) begin\n            Q <= VGND;\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pram_sram_ctrl_3d356cf6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pram_sram_ctrl(\n\tinput clk,\n\tinput clr,\n\tinput go,\n\tinput halt,\n\toutput reg we,\n\toutput [17:0] sram_addr,\n\toutput [5:0] pattern,\n\toutput reg en\n);\n\nreg[2:0] state;\nparameter\n\tSTART\t\t= 3'b000,\n\tADDROUT\t\t= 3'b001,\n\tTEST1\t\t= 3'b010,\n\tWAIT_AND_GO\t= 3'b011,\n\tREAD\t\t= 3'b100,\n\tTEST2\t\t= 3'b101,\n\tHALT\t\t= 3'b110;\nreg [17:0] addrv;\nreg [5:0] patternv;\n\nassign sram_addr = addrv;\nassign pattern = patternv;\n\nalways @(posedge clk or posedge clr)\nbegin\n\tif (clr == 1)\n\t\tbegin\n\t\t\tstate <= START;\n\t\t\taddrv = 0;\n\t\t\tpatternv = 0;\n\t\t\twe <= 1;\n\t\t\ten <= 0;\n\t\tend\n\telse\n\t\tcase(state)\n\t\t\tSTART:\n\t\t\tbegin\n\t\t\t\twe <= 1;\n\t\t\t\tif (go == 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\taddrv = 0;\n\t\t\t\t\t\ten <= 1;\n\t\t\t\t\t\tstate <= ADDROUT;\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tstate <= START;\n\t\t\tend\n\t\t\t\n\t\t\tADDROUT:\n\t\t\tbegin\n\t\t\t\tstate <= TEST1;\n\t\t\t\twe <= 1;\n\t\t\tend\n\t\t\t\n\t\t\tTEST1:\n\t\t\tbegin\n\t\t\t\twe <= 0;\n\t\t\t\tif (halt == 1)\n\t\t\t\t\tstate <= HALT;\n\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\taddrv = addrv + 1;\n\t\t\t\t\t\tif (addrv == 0)\n\t\t\t\t\t\t\tbegin\n\t\t\t\t\t\t\t\tstate <= WAIT_AND_GO;\n\t\t\t\t\t\t\t\ten <= 0;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tstate <= ADDROUT;\n\t\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tWAIT_AND_GO:\n\t\t\tbegin\n\t\t\t\twe <= 1;\n\t\t\t\tif (go == 1)\n\t\t\t\t\tstate <= WAIT_AND_GO;\n\t\t\t\telse\n\t\t\t\t\tstate <= READ;\n\t\t\tend\n\t\t\t\n\t\t\tREAD:\n\t\t\tbegin\n\t\t\t\twe <= 1;\n\t\t\t\tif (go == 1)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tstate <= TEST2;\n\t\t\t\t\t\taddrv = addrv + 1;\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tstate <= READ;\n\t\t\tend\n\t\t\t\n\t\t\tTEST2:\n\t\t\tbegin\n\t\t\t\twe <= 1;\n\t\t\t\tif (addrv == 0)\n\t\t\t\t\tbegin\n\t\t\t\t\t\tpatternv = patternv + 1;\n\t\t\t\t\t\tstate <= START;\n\t\t\t\t\tend\n\t\t\t\telse\n\t\t\t\t\tstate <= WAIT_AND_GO;\n\t\t\tend\n\t\t\t\n\t\t\tHALT:\n\t\t\tbegin\n\t\t\t\tstate <= HALT;\n\t\t\tend\n\t\t\t\n\t\t\tdefault;\n\t\tendcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "simple_ram_e575d1d0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule simple_ram\n  #(parameter width     = 1,\n    parameter widthad   = 1\n    )\n   (\n    input \t\t   clk,\n    \n    input [widthad-1:0]    wraddress,\n    input \t\t   wren,\n    input [width-1:0] \t   data,\n    \n    input [widthad-1:0]    rdaddress,\n    output reg [width-1:0] q\n    );\n\nreg [width-1:0] mem [(2**widthad)-1:0];\n\nalways @(posedge clk) begin\n    if(wren) mem[wraddress] <= data;\n    \n    q <= mem[rdaddress];\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "data_converter_67e16cc5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule data_converter (\n  input clk,\n  input reset,\n  input [7:0] in,\n  input select,\n  output [15:0] out\n);\n\n  reg [15:0] out_reg;\n  \n  always @(posedge clk) begin\n    if (reset) begin\n      out_reg <= 16'b0;\n    end else begin\n      if (select) begin\n        out_reg <= {8'b0, in};\n      end else begin\n        out_reg <= {in, 8'b0};\n      end\n    end\n  end\n\n  assign out = out_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_b7f802ae", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux (\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    input [1:0] sel,\n    input en,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        2'b00: out = en ? in0 : 8'b0;\n        2'b01: out = en ? in1 : 8'b0;\n        2'b10: out = en ? in2 : 8'b0;\n        2'b11: out = en ? in3 : 8'b0;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "alu4bit_bf48f099", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule alu4bit(\n  input [3:0] A, B,\n  input CIN, BINV,\n  input [1:0] OP,\n  output reg COUT,\n  output reg [3:0] Y\n);\n\n  reg [3:0] B_inv;\n  always @(*)\n    B_inv = BINV ? ~B : B;\n  \n  always @(*) begin\n    case(OP)\n      2'b00: begin // Addition\n        {COUT, Y} = A + B_inv + CIN;\n      end\n      2'b01: begin // Subtraction\n        {COUT, Y} = A - B_inv - ~CIN;\n      end\n      2'b10: begin // Logical AND\n        Y = A & B_inv;\n        COUT = 1'b0;\n      end\n      2'b11: begin // Logical OR\n        Y = A | B_inv;\n        COUT = 1'b0;\n      end\n    endcase\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wb_readback_mux_16LE_db43c249", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule wb_readback_mux_16LE\n  (input wb_clk_i,\n   input wb_rst_i,\n   input wb_stb_i,\n   input [15:0] wb_adr_i,\n   output [15:0] wb_dat_o,\n   output reg wb_ack_o,\n\n   input [31:0] word00,\n   input [31:0] word01,\n   input [31:0] word02,\n   input [31:0] word03,\n   input [31:0] word04,\n   input [31:0] word05,\n   input [31:0] word06,\n   input [31:0] word07,\n   input [31:0] word08,\n   input [31:0] word09,\n   input [31:0] word10,\n   input [31:0] word11,\n   input [31:0] word12,\n   input [31:0] word13,\n   input [31:0] word14,\n   input [31:0] word15\n   );\n\n   wire ack_next = wb_stb_i & ~wb_ack_o;\n\n   always @(posedge wb_clk_i)\n     if(wb_rst_i)\n       wb_ack_o <= 0;\n     else\n       wb_ack_o <= ack_next;\n\n   reg [31:0] data;\n   assign wb_dat_o = data[15:0];\n\n   always @(posedge wb_clk_i)\n    if (wb_adr_i[1] & ack_next) begin data[15:0] <= data[31:16];\n    end\n    else if (~wb_adr_i[1] & ack_next) begin case(wb_adr_i[5:2])\n       0 : data <= word00;\n       1 : data <= word01;\n       2 : data <= word02;\n       3 : data <= word03;\n       4 : data <= word04;\n       5 : data <= word05;\n       6 : data <= word06;\n       7 : data <= word07;\n       8 : data <= word08;\n       9 : data <= word09;\n       10: data <= word10;\n       11: data <= word11;\n       12: data <= word12;\n       13: data <= word13;\n       14: data <= word14;\n       15: data <= word15;\n     endcase end\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie3_7x_0_qpll_reset #_b497bccd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule pcie3_7x_0_qpll_reset #\n(\n\n    parameter PCIE_PLL_SEL       = \"CPLL\",                  parameter PCIE_POWER_SAVING  = \"TRUE\",                  parameter PCIE_LANE          = 1,                       parameter BYPASS_COARSE_OVRD = 1                        )\n\n(\n\n    input                           QRST_CLK,\n    input                           QRST_RST_N,\n    input                           QRST_MMCM_LOCK,\n    input       [PCIE_LANE-1:0]     QRST_CPLLLOCK,\n    input       [(PCIE_LANE-1)>>2:0]QRST_DRP_DONE,\n    input       [(PCIE_LANE-1)>>2:0]QRST_QPLLLOCK,\n    input       [ 1:0]              QRST_RATE,\n    input       [PCIE_LANE-1:0]     QRST_QPLLRESET_IN,\n    input       [PCIE_LANE-1:0]     QRST_QPLLPD_IN,\n    \n    output                          QRST_OVRD,\n    output                          QRST_DRP_START,\n    output                          QRST_QPLLRESET_OUT,\n    output                          QRST_QPLLPD_OUT,\n    output                          QRST_IDLE,\n    output      [11:0]              QRST_FSM\n\n);\n\n        reg                             mmcm_lock_reg1;\n    reg         [PCIE_LANE-1:0]     cplllock_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg1;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg1;\n    reg         [ 1:0]              rate_reg1;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg1;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg1;\n\n    reg                             mmcm_lock_reg2;\n    reg         [PCIE_LANE-1:0]     cplllock_reg2;  \n    reg         [(PCIE_LANE-1)>>2:0]drp_done_reg2;\n    reg         [(PCIE_LANE-1)>>2:0]qplllock_reg2;\n    reg         [ 1:0]              rate_reg2;\n    reg         [PCIE_LANE-1:0]     qpllreset_in_reg2;\n    reg         [PCIE_LANE-1:0]     qpllpd_in_reg2;\n    \n    reg                             ovrd              =  1'd0;\n    reg                             qpllreset         =  1'd1;\n    reg                             qpllpd            =  1'd0;\n    reg         [11:0]              fsm               = 12'd2;                 \n   \n    localparam                      FSM_IDLE          = 12'b000000000001; \n    localparam                      FSM_WAIT_LOCK     = 12'b000000000010;\n    localparam                      FSM_MMCM_LOCK     = 12'b000000000100;   \n    localparam                      FSM_DRP_START_NOM = 12'b000000001000;\n    localparam                      FSM_DRP_DONE_NOM  = 12'b000000010000;\n    localparam                      FSM_QPLLLOCK      = 12'b000000100000;\n    localparam                      FSM_DRP_START_OPT = 12'b000001000000;                            \n    localparam                      FSM_DRP_DONE_OPT  = 12'b000010000000;\n    localparam                      FSM_QPLL_RESET    = 12'b000100000000;                                                         \n    localparam                      FSM_QPLLLOCK2     = 12'b001000000000;\n    localparam                      FSM_QPLL_PDRESET  = 12'b010000000000;\n    localparam                      FSM_QPLL_PD       = 12'b100000000000;                                         \n \n \n    \nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin    \n        mmcm_lock_reg1    <=  1'd0;\n        cplllock_reg1     <= {PCIE_LANE{1'd1}}; \n        drp_done_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}};     \n        qplllock_reg1     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        rate_reg1         <=  2'd0; \n        qpllreset_in_reg1 <= {PCIE_LANE{1'd1}}; \n        qpllpd_in_reg1    <= {PCIE_LANE{1'd0}}; \n        mmcm_lock_reg2    <=  1'd0;\n        cplllock_reg2     <= {PCIE_LANE{1'd1}};\n        drp_done_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        qplllock_reg2     <= {(((PCIE_LANE-1)>>2)+1){1'd0}}; \n        rate_reg2         <=  2'd0;\n        qpllreset_in_reg2 <= {PCIE_LANE{1'd1}}; \n        qpllpd_in_reg2    <= {PCIE_LANE{1'd0}};  \n        end\n    else\n        begin  \n        mmcm_lock_reg1    <= QRST_MMCM_LOCK;   \n        cplllock_reg1     <= QRST_CPLLLOCK; \n        drp_done_reg1     <= QRST_DRP_DONE; \n        qplllock_reg1     <= QRST_QPLLLOCK;\n        rate_reg1         <= QRST_RATE; \n        qpllreset_in_reg1 <= QRST_QPLLRESET_IN;\n        qpllpd_in_reg1    <= QRST_QPLLPD_IN;\n        mmcm_lock_reg2    <= mmcm_lock_reg1;\n        cplllock_reg2     <= cplllock_reg1;\n        drp_done_reg2     <= drp_done_reg1; \n        qplllock_reg2     <= qplllock_reg1;\n        rate_reg2         <= rate_reg1;\n        qpllreset_in_reg2 <= qpllreset_in_reg1;\n        qpllpd_in_reg2    <= qpllpd_in_reg1;\n        end\n        \nend    \n\n\n\nalways @ (posedge QRST_CLK)\nbegin\n\n    if (!QRST_RST_N)\n        begin\n        fsm       <= FSM_WAIT_LOCK;\n        ovrd      <= 1'd0;\n        qpllreset <= 1'd1;\n        qpllpd    <= 1'd0;\n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (!QRST_RST_N)\n                begin\n                fsm       <= FSM_WAIT_LOCK;\n                ovrd      <= 1'd0;\n                qpllreset <= 1'd1;\n                qpllpd    <= 1'd0;\n                end\n            else\n                begin\n                fsm       <= FSM_IDLE;\n                ovrd      <= ovrd;\n                qpllreset <= &qpllreset_in_reg2;\n                qpllpd    <= &qpllpd_in_reg2;\n                end\n            end  \n            \n        FSM_WAIT_LOCK :\n        \n            begin\n            fsm       <= ((&(~cplllock_reg2)) && (&(~qplllock_reg2)) ? FSM_MMCM_LOCK : FSM_WAIT_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end      \n            \n        FSM_MMCM_LOCK :\n        \n            begin\n            fsm       <= ((mmcm_lock_reg2 && (&cplllock_reg2)) ? FSM_DRP_START_NOM : FSM_MMCM_LOCK);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end      \n            \n        FSM_DRP_START_NOM:\n        \n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_NOM : FSM_DRP_START_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_NOM :\n        \n            begin\n            fsm       <= (&drp_done_reg2 ? FSM_QPLLLOCK : FSM_DRP_DONE_NOM);\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end \n            \n        FSM_QPLLLOCK :\n        \n            begin\n            fsm       <= (&qplllock_reg2 ? ((BYPASS_COARSE_OVRD == 1) ? FSM_QPLL_PDRESET : FSM_DRP_START_OPT) : FSM_QPLLLOCK);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= qpllpd;\n            end\n            \n        FSM_DRP_START_OPT:\n        \n            begin\n            fsm       <= (&(~drp_done_reg2) ? FSM_DRP_DONE_OPT : FSM_DRP_START_OPT);\n            ovrd      <= 1'd1;\n            qpllreset <= qpllreset;\n            qpllpd    <= qpllpd;\n            end\n\n        FSM_DRP_DONE_OPT :\n        \n            begin\n            if (&drp_done_reg2)\n                begin\n                fsm       <= ((PCIE_PLL_SEL == \"QPLL\") ? FSM_QPLL_RESET : FSM_QPLL_PDRESET);\n                ovrd      <= ovrd;\n                qpllreset <= (PCIE_PLL_SEL == \"QPLL\");\n                qpllpd    <= qpllpd;\n                end\n            else\n                begin\n                fsm       <= FSM_DRP_DONE_OPT;\n                ovrd      <= ovrd;\n                qpllreset <= qpllreset;\n                qpllpd    <= qpllpd;\n                end\n            end \n            \n        FSM_QPLL_RESET :\n            \n            begin\n            fsm       <= (&(~qplllock_reg2) ? FSM_QPLLLOCK2 : FSM_QPLL_RESET);  \n            ovrd      <= ovrd;\n            qpllreset <= 1'd1;\n            qpllpd    <= 1'd0;\n            end     \n            \n        FSM_QPLLLOCK2 :\n        \n            begin\n            fsm       <= (&qplllock_reg2 ? FSM_IDLE : FSM_QPLLLOCK2);\n            ovrd      <= ovrd;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n            \n        FSM_QPLL_PDRESET :\n        \n            begin\n            fsm       <= FSM_QPLL_PD;\n            ovrd      <= ovrd;\n            qpllreset <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0; \n            qpllpd    <= qpllpd;\n            end\n            \n        FSM_QPLL_PD :\n        \n            begin\n            fsm       <= FSM_IDLE;\n            ovrd      <= ovrd;\n            qpllreset <= qpllreset;\n            qpllpd    <= (PCIE_PLL_SEL == \"CPLL\") ? (rate_reg2 != 2'd2) : 1'd0; \n            end \n                \n        default :\n        \n            begin\n            fsm       <= FSM_WAIT_LOCK;\n            ovrd      <= 1'd0;\n            qpllreset <= 1'd0;\n            qpllpd    <= 1'd0;\n            end\n\n        endcase\n        \n        end\n        \nend\n\n\n\nassign QRST_OVRD          = ovrd;\nassign QRST_DRP_START     = (fsm == FSM_DRP_START_NOM) || (fsm == FSM_DRP_START_OPT); \nassign QRST_QPLLRESET_OUT = qpllreset;\nassign QRST_QPLLPD_OUT    = ((PCIE_POWER_SAVING == \"FALSE\") ? 1'd0 : qpllpd);  \nassign QRST_IDLE          = (fsm == FSM_IDLE);\nassign QRST_FSM           = fsm;                   \n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "settings_bus_16LE_276f80af", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule settings_bus_16LE\n  #(parameter AWIDTH=16, RWIDTH=8)\n    (input wb_clk, \n     input wb_rst, \n     input [AWIDTH-1:0] wb_adr_i,\n     input [15:0] wb_dat_i,\n     input wb_stb_i,\n     input wb_we_i,\n     output reg wb_ack_o,\n     output strobe,\n     output reg [7:0] addr,\n     output reg [31:0] data);\n\n   reg \t\t       stb_int;\n   \n   always @(posedge wb_clk)\n     if(wb_rst)\n       begin\n\t  stb_int <= 1'b0;\n\t  addr <= 8'd0;\n\t  data <= 32'd0;\n       end\n     else if(wb_we_i & wb_stb_i)\n       begin\n\t  addr <= wb_adr_i[RWIDTH+1:2];  if(wb_adr_i[1])\n\t    begin\n\t       stb_int <= 1'b1;     data[31:16] <= wb_dat_i;\n\t    end\n\t  else\n\t    begin\n\t       stb_int <= 1'b0;     data[15:0] <= wb_dat_i;\n\t    end\n       end\n     else\n       stb_int <= 1'b0;\n\n   always @(posedge wb_clk)\n     if(wb_rst)\n       wb_ack_o <= 0;\n     else\n       wb_ack_o <= wb_stb_i & ~wb_ack_o;\n\n   assign strobe = stb_int & wb_ack_o;\n          \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_d2a2ba1f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo\n   #(\n  \tparameter adr_width = 10,\n\tparameter dat_width = 8\n   )\n   (\n    input  clk_div, reset,\n    input  wr,rd,\n    input  [dat_width-1:0] data_in,\n    output [dat_width-1:0] data_out,\n    output empty, \n    output full\n);\n\n\n   parameter depth = (1 << adr_width);\n\n   reg [dat_width-1:0] array_reg [depth-1:0];reg [adr_width-1:0] w_ptr_reg, w_ptr_next;\n   reg [adr_width-1:0] r_ptr_reg, r_ptr_next;\n   reg full_reg, empty_reg, full_next, empty_next;\n   wire wr_en;\n  \n   \n\n   assign data_out = array_reg[r_ptr_reg];\n   assign wr_en = wr & ~full_reg;\n\n   assign full = full_reg;\n   assign empty = empty_reg;\n\n   always @(posedge clk_div) begin\n      if (wr_en)\n         array_reg[w_ptr_reg] <= data_in;\n   end\n\n   always @(posedge clk_div, posedge reset) begin\n      if (reset)\n         begin\n            w_ptr_reg <= 0;\n            r_ptr_reg <= 0;\n            full_reg <= 1'b0;\n            empty_reg <= 1'b1;\n         end\n      else\n         begin\n            w_ptr_reg <= w_ptr_next;\n            r_ptr_reg <= r_ptr_next;\n            full_reg <= full_next;\n            empty_reg <= empty_next;\n         end\n   end\n\n\n   \n   always @(*)\n   begin\n      if (reset) begin\n\tw_ptr_next =  0;\n        r_ptr_next =  0;       \n      end else begin\n\t      full_next = full_reg;\n\t      empty_next = empty_reg;\n\t      case ({wr, rd})\n\t\t 2'b01: if (~empty_reg) begin\n\t\t          r_ptr_next = r_ptr_reg + 1;\n\t\t          full_next = 1'b0;\n\t\t          if (r_ptr_next==w_ptr_reg)\n\t\t             empty_next = 1'b1;\n\t\t       end\n\t\t 2'b10: if (~full_reg) begin\n\t\t          w_ptr_next = w_ptr_reg + 1;\n\t\t          empty_next = 1'b0;\n\t\t          if (w_ptr_next==r_ptr_reg)\n\t\t             full_next = 1'b1;\n\t\t       end\n\t\t 2'b11: begin\n\t\t       w_ptr_next =  w_ptr_reg + 1;\n\t\t       r_ptr_next = r_ptr_reg + 1;\n\t\t    end\n\t      endcase\n\tend\n   end\n\n\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "addfxp_e1ad70ff", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule addfxp(a, b, q, clk);\n\n   parameter width = 16, cycles=1;\n   \n   input signed [width-1:0]  a, b;\n   input                     clk;   \n   output signed [width-1:0] q;\n   reg signed [width-1:0]    res[cycles-1:0];\n\n   assign                    q = res[cycles-1];\n   \n   integer                   i;   \n   \n   always @(posedge clk) begin\n     res[0] <= a+b;\n      for (i=1; i < cycles; i = i+1)\n        res[i] <= res[i-1];\n      \n   end\n   \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "acl_vector_to_stream_converter_single_65f78187", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule acl_vector_to_stream_converter_single(\n\t\t\tclock, clock2x, resetn, start,\n\t\t\ta1, a2, dataa,\n\t\t\tvalid_in, valid_out, stall_in, stall_out);\n\tparameter WIDTH = 32;\n\t\n  input clock, clock2x, resetn, valid_in, stall_in, start;\n\tinput [WIDTH-1:0] a1;\n  input [WIDTH-1:0] a2;\n  output [WIDTH-1:0] dataa;\n\toutput valid_out;\n\toutput stall_out;\n\n  reg [WIDTH-1:0] a1_sr ;\n  reg [WIDTH-1:0] a2_sr ;\n  reg sr_in_valid ;\n  wire stall_sr;\n  assign stall_out = sr_in_valid;\n  reg start_reg ;\n  \n  always@(posedge clock or negedge resetn)\n  begin\n    if (~resetn)\n    begin\n      sr_in_valid <= 1'b0;\n      start_reg <= 1'b0;\n      a1_sr <= {WIDTH{1'bx}};\n      a2_sr <= {WIDTH{1'bx}};\n    end\n    else\n    begin\n      start_reg <= start;\n      if (~stall_sr | start)\n        sr_in_valid <= 1'b0;\n      else if (~sr_in_valid)\n        sr_in_valid <= valid_in;\n\n      if (~sr_in_valid)\n      begin\n        a1_sr <= a1;\n        a2_sr <= a2;\n      end\n    end\n  end\n  \n  reg sel2x, sel_ref ;\n\tinitial\n\tbegin\n\t\tsel2x = 1'b0;\n\t\tsel_ref = 1'b0;\n\tend\n\n  always@(posedge clock2x)\n  begin\n    sel2x <= ~sel2x;\t\n  end\n  \n\treg [WIDTH-1:0] a1_reg ;\n  reg [WIDTH-1:0] a2_reg ;\n  reg valid_reg ;\n  wire stall_reg;\n  \n  assign stall_sr = valid_reg & stall_reg;\n  \n  always@(posedge clock or negedge resetn)\n  begin\n    if (~resetn)\n    begin\n      sel_ref <= 1'b0;\n      valid_reg <= 1'b0;\n      a1_reg <= {WIDTH{1'bx}};\n      a2_reg <= {WIDTH{1'bx}};\n    end\n    else \n    begin\n      sel_ref <= sel2x;\n      if (start)\n        valid_reg <= 1'b0;\n      else if (~valid_reg | ~stall_reg)\n        valid_reg <= valid_in | sr_in_valid;\n        \n      if (~valid_reg | ~stall_reg)\n      begin\n        a1_reg <= sr_in_valid ? a1_sr : a1;\n        a2_reg <= sr_in_valid ? a2_sr : a2;\n      end\n    end\n  end\n  \n  reg [WIDTH-1:0] shift_reg_a1 ;\n  reg [WIDTH-1:0] shift_reg_a2 ;\n  reg read_data ;\n  reg valid_a1, valid_a2 ;\n  reg start_reg_2x ;\n  wire stall_shift;\n  assign stall_reg = ~read_data;\n  wire w;\n  assign w = (sel_ref == sel2x);\n  always@(posedge clock2x or negedge resetn)  \n  begin\n    if (~resetn)\n    begin\n      start_reg_2x <= 1'b0;\n      valid_a1 <= 1'b0;\n      valid_a2 <= 1'b0;\n      read_data <= 1'b0;\n      shift_reg_a1 <= {WIDTH{1'bx}};\n      shift_reg_a2 <= {WIDTH{1'bx}};\n    end\n    else\n    begin\n     start_reg_2x <= start_reg;\n\t   if (~w)\n\t\t begin\n\t\t   if (~valid_a1)\n       begin\n         valid_a1 <= valid_reg & ~start_reg_2x;\n         valid_a2 <= valid_reg & ~start_reg_2x;\n         shift_reg_a1 <= a1_reg;\n         shift_reg_a2 <= a2_reg;\n\t\t\t   read_data <= valid_reg;\n       end\n\t\t   else if (~stall_shift)\n\t\t   begin\n\t\t     if (~valid_a2)\n         begin\n           valid_a1 <= valid_reg & ~start_reg_2x;\n           valid_a2 <= valid_reg & ~start_reg_2x;\n           shift_reg_a1 <= a1_reg;\n           shift_reg_a2 <= a2_reg;\n\t\t\t\t   read_data <= valid_reg;\n         end\n         else\n         begin\n\t\t\t     valid_a1 <= valid_a2 & ~start_reg_2x;\n           valid_a2 <= 1'b0;\n           shift_reg_a1 <= shift_reg_a2;\n           shift_reg_a2 <= {WIDTH{1'b0}};\n           read_data <= 1'b0;\n         end\t\t\t \n\t\t   end\n       else\n         read_data <= 1'b0;\n\t\t end\n\t\t else\n\t\t begin\n\t\t   if (~stall_shift)\n       begin\n\t\t     valid_a1 <= valid_a2 & ~start_reg_2x;\n         valid_a2 <= 1'b0;\n         shift_reg_a1 <= shift_reg_a2;\n         shift_reg_a2 <= {WIDTH{1'b0}};\n       end\n       else\n       begin\n         valid_a1 <= valid_a1 & ~start_reg_2x;\n         valid_a2 <= valid_a2 & ~start_reg_2x;\n       end\n     end\n    end\n  end\n  \n  assign dataa = shift_reg_a1;\n  assign stall_shift = stall_in;\n  assign valid_out = valid_a1;\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "anteconmutador_9e571a59", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule anteconmutador (\n    input clk,\n    input [7:0] count,\n    input calculate,\n    output reg [3:0] centenas,\n    output reg [3:0] decenas,\n    output reg [3:0] unidades,\n    output reg C,\n    output reg De,\n    output reg U\n);\n\n    reg [7:0] digitT;\n    reg i;\n\n    always @(posedge clk) begin\n        if (calculate) begin\n            if (i) begin\n                digitT = count;\n                i = 0;\n            end\n            if (digitT > 7'b1100011) begin\n                digitT = digitT - 7'b1100100;\n                centenas = centenas + 1;\n            end\n            else begin\n                if (digitT > 7'b0001001) begin\n                    digitT = digitT - 7'b0001010;\n                    decenas = decenas + 1;\n                end\n                else begin\n                    unidades = {digitT[3:0]};\n                    if (centenas >= 1) begin\n                        C = 1;\n                    end\n                    if (decenas >= 1) begin\n                        De = 1;\n                    end\n                    if (unidades >= 1) begin\n                        U = 1;\n                    end\n                end\n            end\n        end\n        else begin\n            digitT = 0;\n            C = 0;\n            De = 0;\n            U = 0;\n            i = 1;\n            centenas = 0;\n            decenas = 0;\n            unidades = 0;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bt_receiver #_c84fe60c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bt_receiver #(\n  parameter n = 8,\n  parameter m = 8\n)(\n  input [n-1:0] rx_in,\n  input clk,\n  input reset,\n  output reg rx_en,\n  output reg [m-1:0] data_out\n);\n\n  parameter baud_rate = 9600;\n  integer counter;\n  reg [n-1:0] data_reg;\n\n  always @(posedge clk or posedge reset) begin\n    if (reset) begin\n      counter <= 0;\n      rx_en <= 0;\n      data_out <= 0;\n    end else begin\n      if (counter == 0) begin\n        counter <= (50_000_000 / baud_rate) - 1;\n        data_reg <= rx_in;\n        rx_en <= 1;\n        data_out <= data_reg;\n        data_reg <= data_reg >> 1;\n      end else begin\n        counter <= counter - 1;\n      end\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_4e19dcea", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n    input clk,\n    input rst,\n    input [1:0] op,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] result\n);\n\nalways @ (posedge clk) begin\n    if (rst == 1) begin\n        result <= 0;\n    end\n    else begin\n        case (op)\n            2'b00: result <= a + b;\n            2'b01: result <= a - b;\n            2'b10: result <= a * b;\n            2'b11: result <= a / b;\n        endcase\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "jt51_sh #_ad5177dd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule jt51_sh #(parameter width=5, stages=32, rstval=1'b0 ) (\n    input                           rst,\n    input                           clk,\n    input                           cen,\n    input       [width-1:0]         din,\n    output      [width-1:0]         drop\n);\n\nreg [stages-1:0] bits[width-1:0];\n\ngenvar i;\ngenerate\n    for (i=0; i < width; i=i+1) begin: bit_shifter\n        always @(posedge clk, posedge rst) begin\n            if(rst)\n                bits[i] <= {stages{rstval}};\n            else if(cen)\n                bits[i] <= {bits[i][stages-2:0], din[i]};\n        end\n        assign drop[i] = bits[i][stages-1];\n    end\nendgenerate\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MIB #_b8994511", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MIB #(\n    parameter data_width = 32, // width of the data bus (in bits)\n    parameter addr_width = 8 // width of the address bus (in bits)\n)(\n  input clk,\n  input rst,\n  input [addr_width-1:0] addr,\n  input wr_en,\n  input [data_width-1:0] wr_data,\n  input rd_en,\n  output reg [data_width-1:0] rd_data\n);\n\n\nreg [data_width-1:0] mem[0:2**addr_width-1]; // internal memory array\n\nreg [1:0] state; // state variable for FSM\nparameter IDLE = 2'b00;\nparameter READ = 2'b01;\nparameter WRITE = 2'b10;\n\nreg [addr_width-1:0] burst_addr; // address for burst operations\nreg [1:0] burst_count; // counter for burst operations\nparameter BURST_IDLE = 2'b00;\nparameter BURST_READ = 2'b01;\nparameter BURST_WRITE = 2'b10;\n\nalways @( posedge clk ) begin\n    if (rst) begin\n        state <= IDLE;\n        burst_count <= 0;\n        rd_data <= 0;\n    end else begin\n        case (state)\n            IDLE: begin\n                if (rd_en) begin\n                    state <= READ;\n                    rd_data <= mem[addr];\n                end else if (wr_en) begin\n                    state <= WRITE;\n                    mem[addr] <= wr_data;\n                end\n            end\n            READ: begin\n                if (rd_en) begin\n                    rd_data <= mem[addr];\n                end else begin\n                    state <= IDLE;\n                end\n            end\n            WRITE: begin\n                if (wr_en) begin\n                    mem[addr] <= wr_data;\n                end else begin\n                    state <= IDLE;\n                end\n            end\n        endcase\n        if (rd_en && (burst_count != 0)) begin\n            burst_count <= burst_count - 1;\n            burst_addr <= burst_addr + 1;\n            rd_data <= mem[burst_addr];\n        end else if (wr_en && (burst_count != 0)) begin\n            burst_count <= burst_count - 1;\n            burst_addr <= burst_addr + 1;\n            mem[burst_addr] <= wr_data;\n        end else if (rd_en && (burst_count == 0)) begin\n            burst_count <= addr_width/2 - 1;\n            burst_addr <= addr + 1;\n            rd_data <= mem[addr];\n            state <= BURST_READ;\n        end else if (wr_en && (burst_count == 0)) begin\n            burst_count <= addr_width/2 - 1;\n            burst_addr <= addr + 1;\n            mem[addr] <= wr_data;\n            state <= BURST_WRITE;\n        end else if (state == BURST_READ) begin\n            if (rd_en) begin\n                burst_count <= burst_count - 1;\n                burst_addr <= burst_addr + 1;\n                rd_data <= mem[burst_addr];\n            end else begin\n                state <= IDLE;\n            end\n        end else if (state == BURST_WRITE) begin\n            if (wr_en) begin\n                burst_count <= burst_count - 1;\n                burst_addr <= burst_addr + 1;\n                mem[burst_addr] <= wr_data;\n            end else begin\n                state <= IDLE;\n            end\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "SNPS_CLOCK_GATE_HIGH_d_ff_en_W32_0_11_94e66ff0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule SNPS_CLOCK_GATE_HIGH_d_ff_en_W32_0_11 ( CLK, EN, TE, ENCLK );\n  input CLK, EN, TE;\n  output ENCLK;\n\n  reg ENCLK_reg;\n\n  always @ (posedge CLK) begin\n    if (EN && TE) begin\n      ENCLK_reg <= 1;\n    end else begin\n      ENCLK_reg <= 0;\n    end\n  end\n\n  assign ENCLK = ENCLK_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__a3337de6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] in,\n    output [7:0] toggled,\n    output [7:0] count,\n    output [7:0] final_output\n);\n\nreg [7:0] toggled_reg;\nreg [7:0] count_reg;\nreg [7:0] final_output_reg;\n\nwire [7:0] toggled_wire;\nwire [7:0] count_wire;\n\n// Toggling circuit\nreg [7:0] dff_in;\nreg [7:0] dff_out;\nwire [7:0] xor_out;\n\nalways @(posedge clk) begin\n    dff_in <= in;\n    dff_out <= dff_in ^ toggled_reg;\nend\n\nassign toggled_wire = xor_out;\nassign toggled = toggled_reg;\n\n// Population count circuit\nwire [3:0] count_0;\nwire [3:0] count_1;\nwire [3:0] count_2;\nwire [3:0] count_3;\n\nassign count_0 = in[0] + in[4];\nassign count_1 = in[1] + in[5];\nassign count_2 = in[2] + in[6];\nassign count_3 = in[3] + in[7];\n\nwire [3:0] count_01;\nwire [3:0] count_23;\n\nassign count_01 = count_0 + count_1;\nassign count_23 = count_2 + count_3;\n\nassign count_wire = count_01 + count_23;\nassign count = count_reg;\n\n// Final functional module\nalways @(posedge clk) begin\n    toggled_reg <= dff_out;\n    count_reg <= count_wire;\n    final_output_reg <= toggled_reg + count_reg;\nend\n\nassign final_output = final_output_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "d_ff_en_7aaef812", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule d_ff_en(clk, en, te, d, q);\n    input clk, en, te, d;\n    output q;\n    reg q;\n\n    always @(posedge clk) begin\n        if (en && te) begin\n            q <= d;\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dpMem_dc_51bcf767", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dpMem_dc(  addrIn, addrOut, wrClk, rdClk, dataIn, writeEn, readEn, dataOut);\n  parameter FIFO_WIDTH = 8;\n  parameter FIFO_DEPTH = 64; \n  parameter ADDR_WIDTH = 6;   \n  \ninput wrClk;\ninput rdClk;\ninput [FIFO_WIDTH-1:0] dataIn;\noutput [FIFO_WIDTH-1:0] dataOut;\ninput writeEn;\ninput readEn;\ninput [ADDR_WIDTH-1:0] addrIn;\ninput [ADDR_WIDTH-1:0] addrOut;\n\nwire wrClk;\nwire rdClk;\nwire [FIFO_WIDTH-1:0] dataIn;\nreg [FIFO_WIDTH-1:0] dataOut;\nwire writeEn;\nwire readEn;\nwire [ADDR_WIDTH-1:0] addrIn;\nwire [ADDR_WIDTH-1:0] addrOut;\n\nreg [FIFO_WIDTH-1:0] buffer [0:FIFO_DEPTH-1];\n\nalways @(posedge rdClk) begin\n  dataOut <= buffer[addrOut];\nend\n\nalways @(posedge wrClk) begin\n  if (writeEn == 1'b1)\n    buffer[addrIn] <= dataIn;\nend                  \n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "UART_TX_f7534648", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule UART_TX(\n    input [7:0] RxD_par, input RxD_start,\n\t input RTS, input sys_clk,\n\t input BaudTick,\n    output reg TxD_ser\n    );\n\n\n\treg [3:0] state=0;\n\treg [7:0] RxD_buff=0;\n\t\n\talways @(posedge sys_clk)\n\tbegin\n\t\tif (RxD_start & state<2) begin\n\t\t\tRxD_buff <= RxD_par; end else if (state[3] & BaudTick) begin\n\t\t\tRxD_buff <= (RxD_buff >> 1); end\n\t\n\t\tcase(state)\n\t\t\t4'b0000: if(RxD_start & RTS) state <= 4'b0010;4'b0010: if(BaudTick) state <= 4'b0011; 4'b0011: if(BaudTick) state <= 4'b1000; 4'b1000: if(BaudTick) state <= 4'b1001; 4'b1001: if(BaudTick) state <= 4'b1010; 4'b1010: if(BaudTick) state <= 4'b1011; 4'b1011: if(BaudTick) state <= 4'b1100; 4'b1100: if(BaudTick) state <= 4'b1101; 4'b1101: if(BaudTick) state <= 4'b1110; 4'b1110: if(BaudTick) state <= 4'b1111; 4'b1111: if(BaudTick) state <= 4'b0001; 4'b0001: if(BaudTick) begin if(RxD_start & RTS) begin\n\t\t\t\t\t\t\t\tstate <= 4'b0011; end else begin\n\t\t\t\t\t\t\t\tstate <= 4'b0000; end\n\t\t\t\t\t\tend\t\t\t\t\t\t\n\t\t\tdefault: if(BaudTick) state <= 4'b0000; \n\t\tendcase\n\t\t\t\n\tend\n\t\n\talways @(posedge sys_clk)\n\tbegin\n\t\tTxD_ser <= (state < 3) | (state[3] & RxD_buff[0]); end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "johnson_code_d7144465", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule johnson_code (\n    input clk,\n    output reg [4:0] johnson_out\n);\n\nreg [4:0] pipeline1;\nreg [4:0] pipeline2;\nreg [4:0] pipeline3;\nreg [4:0] pipeline4;\n\nalways @(posedge clk) begin\n    pipeline1 <= johnson_out;\n    pipeline2 <= pipeline1;\n    pipeline3 <= pipeline2;\n    pipeline4 <= pipeline3;\n    johnson_out <= {pipeline4[3:0], ~pipeline4[4]};\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mig_7series_v4_0_poc_meta #_ab97a92b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule mig_7series_v4_0_poc_meta #\n  (parameter SCANFROMRIGHT              = 0,\n   parameter TCQ                        = 100,\n   parameter TAPCNTRWIDTH               = 7,\n   parameter TAPSPERKCLK                = 112)\n  (\n  run_ends, mmcm_edge_detect_done, edge_center, left, right,\n  window_center, diff, poc_backup, mmcm_lbclk_edge_aligned,\n  rst, clk, mmcm_edge_detect_rdy, run_too_small, run, run_end,\n  run_polarity, rise_lead_right, rise_trail_left, rise_lead_center,\n  rise_trail_center, rise_trail_right, rise_lead_left, ninety_offsets,\n  use_noise_window, ktap_at_right_edge, ktap_at_left_edge\n  );\n\n  localparam NINETY = TAPSPERKCLK/4;\n  \n  function [TAPCNTRWIDTH-1:0] offset (input [TAPCNTRWIDTH-1:0] a, \n                                      input [1:0] b,\n                                      input integer base);\n    integer offset_ii;\n    begin\n      offset_ii = (a + b * NINETY) < base\n                     ? (a + b * NINETY) \n                     : (a + b * NINETY - base);\n      offset = offset_ii[TAPCNTRWIDTH-1:0];\n    end\n  endfunction function [TAPCNTRWIDTH-1:0] mod_sub (input [TAPCNTRWIDTH-1:0] a, \n                                       input [TAPCNTRWIDTH-1:0] b,\n                                       input integer base); \n    begin\n      mod_sub = (a>=b) ? a-b : a+base-b;\n    end\n  endfunction function [TAPCNTRWIDTH:0] center (input [TAPCNTRWIDTH-1:0] left, \n                                    input [TAPCNTRWIDTH-1:0] diff,\n                                    input integer base);\n    integer center_ii;\n    begin\n      center_ii = ({left, 1'b0} + diff < base * 2)\n                    ? {left, 1'b0} + diff + 32'h0\n\t            : {left, 1'b0} + diff - base * 2;\n      center = center_ii[TAPCNTRWIDTH:0];\n    end\n  endfunction input rst;\n  input clk;\n\n\n  input mmcm_edge_detect_rdy;\n\n  reg [1:0] run_ends_r;\n\n  input run_too_small;\n  reg run_too_small_r1, run_too_small_r2, run_too_small_r3;\n\n  always @ (posedge clk) run_too_small_r1 <= #TCQ run_too_small & (run_ends_r == 'd1);  always @ (posedge clk) run_too_small_r2 <= #TCQ run_too_small_r1;\n  always @ (posedge clk) run_too_small_r3 <= #TCQ run_too_small_r2;\n\n  wire reset_run_ends = rst || ~mmcm_edge_detect_rdy || run_too_small_r3 ;\n\n  input [TAPCNTRWIDTH-1:0] run;\n  \n  input run_end;\n  reg run_end_r, run_end_r1, run_end_r2, run_end_r3;\n  always @(posedge clk) run_end_r <= #TCQ run_end;\n  always @(posedge clk) run_end_r1 <= #TCQ run_end_r;\n  always @(posedge clk) run_end_r2 <= #TCQ run_end_r1;\n  always @(posedge clk) run_end_r3 <= #TCQ run_end_r2;\n\n  input run_polarity;\n  reg run_polarity_held_ns, run_polarity_held_r;\n  always @(posedge clk) run_polarity_held_r <= #TCQ run_polarity_held_ns;\n  always @(*) run_polarity_held_ns = run_end ? run_polarity : run_polarity_held_r;\n  \n  reg [1:0] run_ends_ns;\n  always @(posedge clk) run_ends_r <= #TCQ run_ends_ns;\n  always @(*) begin\n    run_ends_ns = run_ends_r;\n    if (reset_run_ends) run_ends_ns = 2'b0;\n    else case (run_ends_r) \n           2'b00 : run_ends_ns = run_ends_r + {1'b0, run_end_r3 && run_polarity_held_r};\n\t   2'b01, 2'b10 : run_ends_ns = run_ends_r + {1'b0, run_end_r3};\n\t  endcase end output [1:0] run_ends;\n  assign run_ends = run_ends_r;\n\n  reg done_r;\n  wire done_ns = mmcm_edge_detect_rdy && &run_ends_r;\n  always @(posedge clk) done_r <= #TCQ done_ns;\n  output mmcm_edge_detect_done;\n  assign mmcm_edge_detect_done = done_r;  \n\n  input [TAPCNTRWIDTH-1:0] rise_lead_right;\n  input [TAPCNTRWIDTH-1:0] rise_trail_left;\n  input [TAPCNTRWIDTH-1:0] rise_lead_center;\n  input [TAPCNTRWIDTH-1:0] rise_trail_center;\n  input [TAPCNTRWIDTH-1:0] rise_trail_right;\n  input [TAPCNTRWIDTH-1:0] rise_lead_left;\n\n  input [1:0] ninety_offsets;\n  wire [1:0] offsets = SCANFROMRIGHT == 1 ? ninety_offsets : 2'b00 - ninety_offsets;\n\n  wire [TAPCNTRWIDTH-1:0] rise_lead_center_offset_ns = offset(rise_lead_center, offsets, TAPSPERKCLK);\n  wire [TAPCNTRWIDTH-1:0] rise_trail_center_offset_ns = offset(rise_trail_center, offsets, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH-1:0] rise_lead_center_offset_r, rise_trail_center_offset_r;\n  always @(posedge clk) rise_lead_center_offset_r <= #TCQ rise_lead_center_offset_ns;\n  always @(posedge clk) rise_trail_center_offset_r <= #TCQ rise_trail_center_offset_ns;\n\n  wire [TAPCNTRWIDTH-1:0] edge_diff_ns = mod_sub(rise_trail_center_offset_r, rise_lead_center_offset_r, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH-1:0] edge_diff_r;\n  always @(posedge clk) edge_diff_r <= #TCQ edge_diff_ns;\n  \n  wire [TAPCNTRWIDTH:0] edge_center_ns = center(rise_lead_center_offset_r, edge_diff_r, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH:0] edge_center_r;\n  always @(posedge clk) edge_center_r <= #TCQ edge_center_ns;\n  output [TAPCNTRWIDTH:0] edge_center;\n  assign edge_center = edge_center_r;\n\n  input use_noise_window;\n  output [TAPCNTRWIDTH-1:0] left, right;\n  assign left = use_noise_window ? rise_lead_left : rise_trail_left;\n  assign right = use_noise_window ? rise_trail_right : rise_lead_right;\n\n  wire [TAPCNTRWIDTH-1:0] center_diff_ns = mod_sub(right, left, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH-1:0] center_diff_r;\n  always @(posedge clk) center_diff_r <= #TCQ center_diff_ns;\n  \n  wire [TAPCNTRWIDTH:0] window_center_ns = center(left, center_diff_r, TAPSPERKCLK);\n  reg [TAPCNTRWIDTH:0] window_center_r;\n  always @(posedge clk) window_center_r <= #TCQ window_center_ns;\n  output [TAPCNTRWIDTH:0] window_center;\n  assign window_center = window_center_r;\n\n  localparam TAPSPERKCLKX2 = TAPSPERKCLK * 2;\n\n  wire [TAPCNTRWIDTH+1:0] left_center = {1'b0, SCANFROMRIGHT == 1 ? window_center_r : edge_center_r};\n  wire [TAPCNTRWIDTH+1:0] right_center = {1'b0, SCANFROMRIGHT == 1 ? edge_center_r : window_center_r};\n\t\t\t  \n  wire [TAPCNTRWIDTH+1:0] diff_ns = right_center >= left_center\n                                     ? right_center - left_center\n                                     : right_center + TAPSPERKCLKX2[TAPCNTRWIDTH+1:0] - left_center;\n  \n  reg [TAPCNTRWIDTH+1:0] diff_r;\n  always @(posedge clk) diff_r <= #TCQ diff_ns;\n  output [TAPCNTRWIDTH+1:0] diff;\n  assign diff = diff_r;\n\n  wire [TAPCNTRWIDTH+1:0] abs_diff = diff_r > TAPSPERKCLKX2[TAPCNTRWIDTH+1:0]/2\n                                       ? TAPSPERKCLKX2[TAPCNTRWIDTH+1:0] - diff_r\n                                       : diff_r;\n\n  reg [TAPCNTRWIDTH+1:0] prev_ns, prev_r;\n  always @(posedge clk) prev_r <= #TCQ prev_ns;\n  always @(*) prev_ns = done_ns ? diff_r : prev_r;\n\n  input ktap_at_right_edge;\n  input ktap_at_left_edge;\n  \n  wire centering = !(ktap_at_right_edge || ktap_at_left_edge);\n  wire diffs_eq = abs_diff == diff_r;\n  reg diffs_eq_ns, diffs_eq_r;\n  always @(*) diffs_eq_ns = centering && ((done_r && done_ns) ? diffs_eq : diffs_eq_r);\n  always @(posedge clk) diffs_eq_r <= #TCQ diffs_eq_ns;\n\n  reg edge_aligned_r;\n  reg prev_valid_ns, prev_valid_r;\n  always @(posedge clk) prev_valid_r <= #TCQ prev_valid_ns;\n  always @(*) prev_valid_ns = (~rst && ~ktap_at_right_edge && ~ktap_at_left_edge && ~edge_aligned_r) && prev_valid_r | done_ns;\n\n  wire indicate_alignment = ~rst && centering && done_ns;\n  wire edge_aligned_ns = indicate_alignment && (~|diff_r || ~diffs_eq & diffs_eq_r);\n  always @(posedge clk) edge_aligned_r <= #TCQ edge_aligned_ns;\n\n  reg poc_backup_r;\n  wire poc_backup_ns = edge_aligned_ns && abs_diff > prev_r;\n  always @(posedge clk) poc_backup_r <= #TCQ poc_backup_ns;\n  output poc_backup;\n  assign poc_backup = poc_backup_r;\n\n  output mmcm_lbclk_edge_aligned;\n  assign mmcm_lbclk_edge_aligned = edge_aligned_r;\n  \nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register #_b9a63447", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register #(\n  parameter DATA_WIDTH = 8\n) (\n  input clk,\n  input reset,\n  input shift_in,\n  output reg shift_out\n);\n\n  reg [DATA_WIDTH-1:0] buffer;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      buffer <= 0;\n      shift_out <= 0;\n    end else begin\n      buffer <= {shift_in, buffer[DATA_WIDTH-1:1]};\n      shift_out <= buffer[0];\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__69cf08fc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset,      // Synchronous active-high reset\n    output reg pwm,   // 1-bit PWM output\n    input [3:0] encoder_out,\n    output reg [1:0] pos  );  // 2-bit output indicating the highest priority input bit.\n\n    reg [3:0] counter;\n    reg [7:0] compare_value;\n    reg [3:0] gray_code;\n    reg [2:0] highest_priority;\n\n    // Generate PWM signal with 100Hz frequency and 50% duty cycle\n    always @(posedge clk, posedge reset) begin\n        if (reset) begin\n            counter <= 4'b0000;\n            compare_value <= 8'd125;\n            pwm <= 1'b0;\n        end else begin\n            if (counter == compare_value) begin\n                counter <= 4'b0000;\n                pwm <= ~pwm;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    // Convert binary to gray code\n    always @(encoder_out) begin\n        gray_code[0] = encoder_out[0];\n        gray_code[1] = encoder_out[0] ^ encoder_out[1];\n        gray_code[2] = encoder_out[1] ^ encoder_out[2];\n        gray_code[3] = encoder_out[2] ^ encoder_out[3];\n    end\n\n    // Convert gray code to one-hot code\n    always @(gray_code) begin\n        case (gray_code)\n            4'b0001: highest_priority = 3'b001;\n            4'b0010: highest_priority = 3'b010;\n            4'b0100: highest_priority = 3'b100;\n            4'b1000: highest_priority = 3'b000;\n            default: highest_priority = 3'b000;\n        endcase\n    end\n\n    // Output the highest priority input bit\n    always @(highest_priority) begin\n        case (highest_priority)\n            3'b001: pos = 2'b01;\n            3'b010: pos = 2'b10;\n            3'b100: pos = 2'b11;\n            default: pos = 2'b00;\n        endcase\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__b4ba587c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input [15:0] A,\n    input [15:0] B,\n    input [3:0] S,\n    input [3:0] input_bcd,\n    output [7:0] final_output\n);\n\n    wire [15:0] barrel_shifter_output;\n    wire [7:0] bcd_converter_output;\n    \n    assign barrel_shifter_output = (S == 4'b0000) ? A :\n                                   (S == 4'b0001) ? A << 1 :\n                                   (S == 4'b0010) ? A << 2 :\n                                   (S == 4'b0011) ? A << 3 :\n                                   (S == 4'b0100) ? A << 4 :\n                                   (S == 4'b0101) ? A << 5 :\n                                   (S == 4'b0110) ? A << 6 :\n                                   (S == 4'b0111) ? A << 7 :\n                                   (S == 4'b1000) ? A << 8 :\n                                   (S == 4'b1001) ? A << 9 :\n                                   (S == 4'b1010) ? A << 10 :\n                                   (S == 4'b1011) ? A << 11 :\n                                   (S == 4'b1100) ? A << 12 :\n                                   (S == 4'b1101) ? A << 13 :\n                                   (S == 4'b1110) ? A << 14 :\n                                   (S == 4'b1111) ? A << 15 : 16'b0;\n\n    assign bcd_converter_output = (input_bcd == 4'b0000) ? 8'b00000000 :\n                                  (input_bcd == 4'b0001) ? 8'b00000001 :\n                                  (input_bcd == 4'b0010) ? 8'b00000010 :\n                                  (input_bcd == 4'b0011) ? 8'b00000011 :\n                                  (input_bcd == 4'b0100) ? 8'b00000100 :\n                                  (input_bcd == 4'b0101) ? 8'b00000101 :\n                                  (input_bcd == 4'b0110) ? 8'b00000110 :\n                                  (input_bcd == 4'b0111) ? 8'b00000111 :\n                                  (input_bcd == 4'b1000) ? 8'b00001000 :\n                                  (input_bcd == 4'b1001) ? 8'b00001001 :\n                                  (input_bcd == 4'b1010) ? 8'b00001010 :\n                                  (input_bcd == 4'b1011) ? 8'b00001011 :\n                                  (input_bcd == 4'b1100) ? 8'b00001100 :\n                                  (input_bcd == 4'b1101) ? 8'b00001101 :\n                                  (input_bcd == 4'b1110) ? 8'b00001110 :\n                                  8'b00000000;\n\n    assign final_output = barrel_shifter_output[15:8] + bcd_converter_output[7:0];\n    \nendmodule\nmodule barrel_shifter (\n    input [15:0] A,\n    input [15:0] B,\n    input [3:0] S,\n    output [15:0] Y\n);\n\n    assign Y = (S == 4'b0000) ? A :\n               (S == 4'b0001) ? A << 1 :\n               (S == 4'b0010) ? A << 2 :\n               (S == 4'b0011) ? A << 3 :\n               (S == 4'b0100) ? A << 4 :\n               (S == 4'b0101) ? A << 5 :\n               (S == 4'b0110) ? A << 6 :\n               (S == 4'b0111) ? A << 7 :\n               (S == 4'b1000) ? A << 8 :\n               (S == 4'b1001) ? A << 9 :\n               (S == 4'b1010) ? A << 10 :\n               (S == 4'b1011) ? A << 11 :\n               (S == 4'b1100) ? A << 12 :\n               (S == 4'b1101) ? A << 13 :\n               (S == 4'b1110) ? A << 14 :\n               (S == 4'b1111) ? A << 15 : 16'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ms__a2111o_52317091", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_ms__a2111o (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1,\n    D1\n);\n\n    // Module ports\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    // Local signals\n    wire and0_out ;\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    and and0 (and0_out , A1, A2              );\n    or  or0  (or0_out_X, C1, B1, and0_out, D1);\n    buf buf0 (X        , or0_out_X           );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_0c0c265b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n    input clk,\n    input reset,\n    output reg [3:0] count_out\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            count_out <= 4'b0000;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule mux (\n    input [3:0] d,\n    input [3:0] count_out,\n    input select,\n    output reg [3:0] mux_out\n);\n    always @(*) begin\n        if (select) begin\n            mux_out = d;\n        end else begin\n            mux_out = count_out;\n        end\n    end\nendmodule\n\nmodule adder (\n    input [3:0] a,\n    input [3:0] b,\n    output reg [3:0] sum\n);\n    always @(*) begin\n        sum = a + b;\n    end\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [3:0] d,\n    input select,\n    output [3:0] final_out\n);\n    wire [3:0] count_out;\n    wire [3:0] mux_out;\n    wire [3:0] adder_out;\n\n    counter counter_inst (\n        .clk(clk),\n        .reset(reset),\n        .count_out(count_out)\n    );\n\n    mux mux_inst (\n        .d(d),\n        .count_out(count_out),\n        .select(select),\n        .mux_out(mux_out)\n    );\n\n    adder adder_inst (\n        .a(mux_out),\n        .b(count_out),\n        .sum(adder_out)\n    );\n\n    reg [3:0] final_out_reg;\n    always @(posedge clk) begin\n        final_out_reg <= adder_out;\n    end\n\n    assign final_out = final_out_reg;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiplier_81bca97c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result\n);\n\nreg [3:0] i;\n\nalways @(*) begin\n    result = 0;\n    for (i = 0; i < 8; i = i + 1) begin\n        if (a[i] == 1) begin\n            result = result + (b << i);\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipelined_multiplier_1f19b281", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipelined_multiplier (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result\n);\n\nreg [7:0] a_reg;\nreg [7:0] b_reg;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        a_reg <= 8'h00;\n        b_reg <= 8'h00;\n        result <= 16'h0000;\n    end else begin\n        a_reg <= a;\n        b_reg <= b;\n        result <= {8'h00, a_reg} * {8'h00, b_reg};\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "modulo_operator_fd78c8a9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule modulo_operator (\n  input [31:0] dividend,\n  input [31:0] divisor,\n  output reg [31:0] remainder\n);\n\n  // Calculate the quotient\n  reg [31:0] quotient;\n  always @* begin\n    quotient = dividend / divisor;\n  end\n\n  // Calculate the product of the quotient and the divisor\n  reg [31:0] product;\n  always @* begin\n    product = quotient * divisor;\n  end\n\n  // Subtract the product from the dividend to get the remainder\n  always @* begin\n    remainder = dividend - product;\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ripple_adder_663d963a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule ripple_adder(\n  input [3:0] a,\n  input [3:0] b,\n  input cin,\n  output [3:0] sum,\n  output cout\n);\n\n  wire [3:0] temp_sum;\n  wire [4:0] temp_carry;\n\n  assign temp_sum = a + b + cin;\n  assign temp_carry = {cin, temp_sum} + 1'b0;\n\n  assign sum = temp_sum;\n  assign cout = temp_carry[4];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_8aca14bf", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder(\n    input [3:0] a, \n    input [3:0] b, \n    input cin, \n    output [3:0] sum, \n    output cout\n);\n\n    wire c1, c2, c3;\n    full_adder fa1(a[0], b[0], cin, sum[0], c1);\n    full_adder fa2(a[1], b[1], c1, sum[1], c2);\n    full_adder fa3(a[2], b[2], c2, sum[2], c3);\n    full_adder fa4(a[3], b[3], c3, sum[3], cout);\n    \nendmodule\n\nmodule full_adder(\n    input a, \n    input b, \n    input cin, \n    output sum, \n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "MUX_4to1_d6356c8b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule MUX_4to1 (\n  input X0,\n  input X1,\n  input X2,\n  input X3,\n  input S0,\n  input S1,\n  output Y\n);\n\n  assign Y = (S1 & S0) ? X3 :\n             (S1 & ~S0) ? X2 :\n             (~S1 & S0) ? X1 :\n             X0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "FpuFp32_fc63c546", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule FpuFp32(\n    input clk,\n    input [3:0] opMode,\n    input [31:0] srca,\n    input [31:0] srcb,\n    output [31:0] dst\n);\n\n// Parameter definitions\nparameter [3:0] OP_NONE = 4'h00;\nparameter [3:0] OP_ADD = 4'h01;\nparameter [3:0] OP_SUB = 4'h02;\nparameter [3:0] OP_MUL = 4'h03;\nparameter [3:0] OP_DIV = 4'h04;\nparameter [3:0] OP_ABS = 4'h05;\nparameter [3:0] OP_NEG = 4'h06;\nparameter [3:0] OP_RCP = 4'h07;\nparameter [3:0] OP_SQRT = 4'h08;\n\n// Internal signals\nwire fpaIsSub;\nwire [31:0] fpaDst;\nwire [31:0] fpmSrcB;\nwire [31:0] fpmDst;\nwire [31:0] fpRcpDst;\n\n// Instantiate submodules\nFpuFp32Add fpadd(clk, fpaIsSub, srca, srcb, fpaDst);\nFpuFp32Mul fpmul(clk, srca, fpmSrcB, fpmDst);\nFpuFp32Rcp fprcp(clk, srcb, fpRcpDst);\n\n// Assign inputs to submodules\nassign fpaIsSub = (opMode == OP_SUB);\nassign fpmSrcB = (opMode == OP_DIV) ? fpRcpDst : srcb;\n\n// Output selection logic\nassign dst = (opMode == OP_ADD) ? fpaDst :\n             (opMode == OP_SUB) ? fpaDst :\n             (opMode == OP_MUL) ? fpmDst :\n             (opMode == OP_DIV) ? fpmDst :\n             (opMode == OP_ABS) ? ((srcb[31] == 1) ? -srcb : srcb) :\n             (opMode == OP_NEG) ? -srcb :\n             (opMode == OP_RCP) ? fpRcpDst :\n             (opMode == OP_SQRT) ? ((srcb - 32'h3F80_0000) >>> 1) + 32'h3F80_0000 :\n             srcb;\n\nendmodule\n\nmodule FpuFp32Add(clk, isSub, srca, srcb, dst);\n\ninput clk;\ninput isSub;\ninput [31:0] srca;\ninput [31:0] srcb;\n\noutput [31:0] dst;\n\nreg [31:0] dst_reg;\n\nalways @ (posedge clk) begin\n    if (isSub) begin\n        dst_reg = srca - srcb;\n    end else begin\n        dst_reg = srca + srcb;\n    end\nend\n\nassign dst = dst_reg;\n\nendmodule\n\nmodule FpuFp32Mul(clk, srca, srcb, dst);\n\ninput clk;\ninput [31:0] srca;\ninput [31:0] srcb;\n\noutput [31:0] dst;\n\nreg [31:0] dst_reg;\n\nalways @ (posedge clk) begin\n    dst_reg = srca * srcb;\nend\n\nassign dst = dst_reg;\n\nendmodule\n\nmodule FpuFp32Rcp(clk, srcb, dst);\n\ninput clk;\ninput [31:0] srcb;\n\noutput [31:0] dst;\n\nreg [31:0] dst_reg;\n\nalways @ (posedge clk) begin\n    dst_reg = 32'h3F80_0000 / srcb;\nend\n\nassign dst = dst_reg;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_tree_top_aee90600", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define ADDER_WIDTH 019\n`define DUMMY_WIDTH 128\n\n`define 3_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "center_pos_97e85c9d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule center_pos(\n    input [15:0] x_row,\n    input [15:0] y_col,\n    input reset,\n    input clk,\n    input [15:0] valid,\n    output reg [15:0] center_x,\n    output reg [15:0] center_y\n);\n\nreg [31:0] center_x_temp;\nreg [31:0] center_y_temp;\nreg [31:0] pixel_counter;\nreg [31:0] dirty;\n\nwire [31:0] result_x;\nwire [31:0] result_y;\n\n// Replace the alt_div modules with generic division operators\n\n// Calculate the center x position\nassign result_x = (center_x_temp / pixel_counter);\n\n// Calculate the center y position\nassign result_y = (center_y_temp / pixel_counter);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        center_x <= 16'h0;\n        center_y <= 16'h0;\n        center_x_temp <= 32'h0;\n        center_y_temp <= 32'h0;\n        pixel_counter <= 32'h0;\n        dirty <= 32'h0;\n    end else begin\n        if (dirty >= 32'h00075300) begin\n            center_x <= result_x[15:0];\n            center_y <= result_y[15:0];\n            center_x_temp <= 32'h0;\n            center_y_temp <= 32'h0;\n            pixel_counter <= 32'h0;\n            dirty <= 32'h0;\n        end else if (valid[dirty[31:16]]) begin\n            center_x_temp <= center_x_temp + x_row;\n            center_y_temp <= center_y_temp + y_col;\n            pixel_counter <= pixel_counter + 1;\n            dirty <= dirty + 1;\n        end else begin\n            dirty <= dirty + 1;\n        end\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_f8f349fd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder (\n    input A,\n    input B,\n    input CI,\n    output SUM,\n    output COUT_N\n);\n\n    // Local signals\n    wire xor0_out_SUM ;\n    wire a_b          ;\n    wire a_ci         ;\n    wire b_ci         ;\n    wire or0_out_coutn;\n\n    //  Name  Output         Other arguments\n    xor xor0 (xor0_out_SUM , A, B, CI       );\n    buf buf0 (SUM          , xor0_out_SUM   );\n    nor nor0 (a_b          , A, B           );\n    nor nor1 (a_ci         , A, CI          );\n    nor nor2 (b_ci         , B, CI          );\n    or  or0  (or0_out_coutn, a_b, a_ci, b_ci);\n    buf buf1 (COUT_N       , or0_out_coutn  );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RegFileWW_9b80856b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule RegFileWW (rd1data,rd2data,wrdata,rd1addr,rd2addr,wraddr,\n\trd1en,rd2en,wren,wrbyteen,clk);\n\n\n\t\n\toutput [127:0] rd1data,rd2data;\n\t\n\t\n\t\n\tinput [0:127] wrdata;\n\tinput clk;\n\tinput wren;\n\tinput rd1en, rd2en;\n\t\n\tinput [4:0] wraddr, rd1addr, rd2addr;\n\t\n\tinput [15:0] wrbyteen;\n\t\n\t\n\t\n\t\n\treg [127:0] rd1data,rd2data;\t\t\n\treg [127:0] reg_file [31:0];\t\treg [127:0] ones;\t\t\t\t\treg [127:0] result;\t\t\t\t\treg [7:0] operand;\t\t\t\t\talways @(posedge clk)\n\tbegin\n\t\tones=128'd0;\n\t\tones=ones-1'd1;\n\t\n\t\tif(wren)\n\t\tbegin\n\t\t\tif(wrbyteen==16'h1)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[0:7];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h3)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[8:15];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h7)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[16:23];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'hf)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[24:31];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h1f)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[32:39];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h3f)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[40:47];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h7f)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[48:55];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'hff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[56:63];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h1ff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[64:71];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h3ff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[72:79];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h7ff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[80:87];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'hfff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[88:95];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h1fff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[96:103];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h3fff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[104:111];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'h7fff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[112:119];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\telse if(wrbyteen==16'hffff)\n\t\t\tbegin\n\t\t\t\toperand=wrdata[120:127];\n\t\t\t\tresult = ones & operand;\n\t\t\t\treg_file[wraddr] <= result;\n\t\t\tend\n\t\t\t\n\t\tend\n\t\t\n\t\t\n\t\tif(rd1en)\n\t\tbegin\n\t\t\trd1data<=reg_file[rd1addr];\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\trd1data<=128'b0;\n\t\tend\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif(rd2en)\n\t\tbegin\n\t\t\trd2data<=reg_file[rd2addr];\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\trd2data<=128'b0;\n\t\tend\n\tend\n\t\n\t\n\t\n\t\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_gate_ctrl_fbfa6ff2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_gate_ctrl(\n    input [3:0] a,\n    input [3:0] b,\n    input [3:0] c,\n    input [3:0] d,\n    input ctrl,\n    input vdd,\n    input gnd,\n    output out\n);\n\nwire [3:0] and_out;\n\nassign and_out = a & b & c & d;\n\nassign out = (ctrl == 1'b1) ? (~and_out) : and_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "zbroji_7b74bf42", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule zbroji (\n        ap_start,\n        ap_done,\n        ap_idle,\n        ap_ready,\n        a,\n        b,\n        ap_return\n);\n\ninput   ap_start;\noutput   ap_done;\noutput   ap_idle;\noutput   ap_ready;\ninput  [31:0] a;\ninput  [31:0] b;\noutput  [31:0] ap_return;\n\nparameter    ap_const_logic_1 = 1'b1;\nparameter    ap_const_logic_0 = 1'b0;\n\n\n\nassign ap_done = ap_start;\nassign ap_idle = ap_const_logic_1;\nassign ap_ready = ap_start;\nassign ap_return = (b + a);\n\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "hamming_encoder_decoder_fe628fcd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule hamming_encoder_decoder (\n  input [k-1:0] data_in,\n  output [n-1:0] encoded_data,\n  output [k-1:0] decoded_data\n);\n\nparameter k = 4; // length of input data\nparameter n = 7; // length of encoded data\n\n// Calculate the parity bits for the encoded data\nwire p1, p2, p3;\nassign p1 = data_in[0] ^ data_in[1] ^ data_in[3];\nassign p2 = data_in[0] ^ data_in[2] ^ data_in[3];\nassign p3 = data_in[1] ^ data_in[2] ^ data_in[3];\n\n// Append the parity bits to the input data to create the encoded data\nassign encoded_data = {data_in, p1, p2, p3};\n\n// Calculate the syndrome of the encoded data\nwire s1, s2, s3;\nassign s1 = encoded_data[0] ^ encoded_data[1] ^ encoded_data[3] ^ encoded_data[4] ^ encoded_data[6];\nassign s2 = encoded_data[0] ^ encoded_data[2] ^ encoded_data[3] ^ encoded_data[5] ^ encoded_data[6];\nassign s3 = encoded_data[1] ^ encoded_data[2] ^ encoded_data[3] ^ encoded_data[6];\n\n// Correct any single-bit errors in the encoded data\nwire [n-1:0] corrected_data;\nassign corrected_data = encoded_data;\nassign corrected_data[s1 + s2*2 + s3*4 - 1] = ~corrected_data[s1 + s2*2 + s3*4 - 1];\n\n// Extract the original input data from the corrected data\nassign decoded_data = {corrected_data[3], corrected_data[5], corrected_data[6], corrected_data[4]};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "AND4_W9_c9b37ae3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule AND4_W9 (\n  input [3:0] A,\n  output Y\n);\n\n  wire n1, n2, n3;\n  \n  assign n1 = ~(A[0] & A[1]);\n  assign n2 = ~(A[2] & A[3]);\n  assign n3 = ~(n1 & n2);\n  \n  assign Y = ~n3;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_327ba869", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule adder(\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire [15:0] sum_in,\n    output wire [7:0] sum,\n    output wire carry\n);\n\n    assign {carry, sum} = sum_in + {a, b};\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sync_fifo #_37a37cd2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sync_fifo #(\n    parameter DWIDTH = 16,\n    parameter DEPTH = 8\n) (\n    input clk,\n    input res_n,\n    input [DWIDTH-1:0] d_in,\n    input shift_in,\n    input shift_out,\n    output reg [DWIDTH-1:0] d_out,\n    output reg full,\n    output reg empty,\n    output wire almost_full,\n    output wire almost_empty\n);\n\n    reg [DWIDTH-1:0] buffer [DEPTH-1:0];\n    reg [DEPTH-1:0] fill_level;\n    reg [DEPTH-1:0] read_pointer;\n    reg [DEPTH-1:0] write_pointer;\n    \n    always @(posedge clk, negedge res_n) begin\n        if (~res_n) begin\n            d_out <= 0;\n            fill_level <= 0;\n            read_pointer <= 0;\n            write_pointer <= 0;\n            empty <= 1;\n            full <= 0;\n        end else begin\n            if (shift_out && ~empty) begin\n                d_out <= buffer[read_pointer];\n                read_pointer <= read_pointer + 1;\n                if (read_pointer == write_pointer) begin\n                    empty <= 1;\n                end\n                fill_level <= fill_level - 1;\n                full <= 0;\n            end else if (shift_in && ~full) begin\n                buffer[write_pointer] <= d_in;\n                write_pointer <= write_pointer + 1;\n                if (write_pointer == read_pointer) begin\n                    full <= 1;\n                end\n                fill_level <= fill_level + 1;\n                empty <= 0;\n            end else begin\n                d_out <= d_out;\n            end\n        end\n    end\n    \n    assign almost_full = (fill_level >= DEPTH-1);\n    assign almost_empty = (fill_level <= 1);\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my_or_28677c13", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_or (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    // Module ports\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    // Module supplies\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Local signals\n    wire or0_out_X;\n\n    //  Name  Output     Other arguments\n    or  or0  (or0_out_X, D, C, B, A     );\n    buf buf0 (X        , or0_out_X      );\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and3_not_A_24f4a44c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule and3_not_A (\n    input A,\n    input B,\n    input C,\n    output X\n);\n\n    // Intermediate signals\n    wire not_A, and_B_C;\n\n    // Logic gates\n    not not_A(not_A, A);\n    and and_B_C(and_B_C, B, C);\n\n    assign X = not_A & and_B_C;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "tg68_ram #_869f481c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule tg68_ram #(\n  parameter MS = 512\n)(\n  input  wire           clk,\n  input  wire           tg68_as,\n  input  wire [ 32-1:0] tg68_adr,\n  input  wire           tg68_rw,\n  input  wire           tg68_lds,\n  input  wire           tg68_uds,\n  input  wire [ 16-1:0] tg68_dat_out,\n  output wire [ 16-1:0] tg68_dat_in,\n  output wire           tg68_dtack\n);\n\nreg  [8-1:0] mem0 [0:MS-1];\nreg  [8-1:0] mem1 [0:MS-1];\n\nreg  [16-1:0] mem_do = 0;\nreg           trn = 1;\nreg           ack = 1;\n\ninteger i;\ninitial begin\n  for (i=0; i<MS; i=i+1) begin\n    mem1[i] = 0;\n    mem0[i] = 0;\n  end\nend\n\nalways @ (posedge clk) begin\n  if (!tg68_as && tg68_rw) mem_do <= #1 {mem1[tg68_adr[31:1]], mem0[tg68_adr[31:1]]};\nend\n\nalways @ (posedge clk) begin\n  if (!tg68_as && !tg68_rw) begin\n    if (!tg68_uds) mem1[tg68_adr[31:1]] <= #1 tg68_dat_out[15:8];\n    if (!tg68_lds) mem0[tg68_adr[31:1]] <= #1 tg68_dat_out[7:0];\n  end\nend\n\nalways @ (posedge clk) begin\n  trn <= #1 tg68_as;\n  ack <= #1 trn;\nend\n\nassign tg68_dat_in = mem_do;\nassign tg68_dtack = ack || tg68_as; task load;\n  input [1024*8-1:0] file;\n  reg [16-1:0] memory[0:MS-1];\n  reg [16-1:0] dat;\n  integer i;\nbegin\n  $readmemh(file, memory);\n  for (i=0; i<MS; i=i+1) begin\n    dat = memory[i];\n    mem1[i] = dat[15:8];\n    mem0[i] = dat[7:0];\n  end\nend\nendtask\n\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mult_16x16_c253e063", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mult_16x16 (\n    input  wire [15:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] Z\n);\n\n    assign Z = A * B;\n\nendmodule\n\nmodule mult_20x18 (\n    input  wire [19:0] A,\n    input  wire [17:0] B,\n    output wire [37:0] Z\n);\n\n    assign Z = A * B;\n\nendmodule\n\nmodule mult_8x8 (\n    input  wire [ 7:0] A,\n    input  wire [ 7:0] B,\n    output wire [15:0] Z\n);\n\n    assign Z = A * B;\n\nendmodule\n\nmodule mult_10x9 (\n    input  wire [ 9:0] A,\n    input  wire [ 8:0] B,\n    output wire [18:0] Z\n);\n\n    assign Z = A * B;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RAM_SHIFTER #_1b7b3f93", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RAM_SHIFTER #(\n    parameter IO_WIDTH = 16,\n    parameter ADDR_WIDTH = 4,\n    parameter PHASE_SHIFT = 2\n) (\n    input                       clk,\n\n    input [IO_WIDTH-1:0]        in,\n    output reg [IO_WIDTH-1:0]   out,\n\n    output reg [ADDR_WIDTH-1:0] addr,\n    input                       ram_out,\n    output                      ram_in\n);\n\n    reg [IO_WIDTH-1:0]          shift_in;\n    reg [IO_WIDTH-1:0]          shift_out;\n\n    assign ram_in = shift_in[0];\n\n    initial begin\n        out       <= 0;\n        addr      <= 0;\n        shift_in  <= 0;\n        shift_out <= 0;\n    end\n\n    always @(posedge clk) begin\n        if(addr == 0)\n          begin out <= {shift_out[IO_WIDTH-PHASE_SHIFT-1:0], shift_out[IO_WIDTH-1:IO_WIDTH-PHASE_SHIFT]};\n\n              shift_in <= in;\n          end\n        else\n          begin\n              shift_in <= {shift_in[IO_WIDTH-2:0], shift_in[IO_WIDTH-1]};\n          end\n\n        shift_out <= {shift_out[IO_WIDTH-2:0], ram_out};\n\n        addr <= addr + 1;\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_c7050afa", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n    input clk,\n    input parallel_load,\n    input [3:0] in,\n    output reg out\n);\n\nreg [3:0] reg1, reg2, reg3, reg4;\n\nalways @(posedge clk) begin\n    reg4 <= reg3;\n    reg3 <= reg2;\n    reg2 <= reg1;\n    reg1 <= parallel_load ? in : reg1;\n    out <= reg4;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sequence_detector_9ecdde8e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sequence_detector (\n    input clk,\n    input reset,\n    input [35:0] in,\n    output [3:0] sequence_detected,\n    output [31:0] change_detection\n);\n\n    reg [35:0] shift_reg;\n    reg [3:0] sequence_detected_reg;\n    reg [31:0] change_detection_reg;\n    wire [31:0] change_detection_output;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 36'b0;\n            sequence_detected_reg <= 4'b0;\n            change_detection_reg <= 32'b0;\n        end else begin\n            shift_reg <= {shift_reg[34:0], in};\n            if (shift_reg[35:32] == 4'b1010) begin\n                sequence_detected_reg <= 4'b1010;\n            end else begin\n                sequence_detected_reg <= 4'b0;\n            end\n            change_detection_reg <= change_detection_output;\n        end\n    end\n\n    assign change_detection_output = ({32'b0, sequence_detected_reg} & (in ^ shift_reg[35:2]));\n\n    assign sequence_detected = sequence_detected_reg;\n    assign change_detection = change_detection_reg;\n\nendmodule\nmodule combined_module (\n    input clk,\n    input reset,\n    input [35:0] in,\n    output [31:0] out\n);\n\n    wire [3:0] sequence_detected;\n    wire [31:0] change_detection;\n\n    sequence_detector detector (\n        .clk(clk),\n        .reset(reset),\n        .in(in),\n        .sequence_detected(sequence_detected),\n        .change_detection(change_detection)\n    );\n\n    assign out = (in ^ change_detection) | ({32'b0, sequence_detected} << 28);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fifo_24in_24out_12kb_compare_0_097996f9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fifo_24in_24out_12kb_compare_0 (\n  input wire clk,\n  input wire rst,\n  input wire [23:0] din,\n  output reg [23:0] dout,\n  output reg comp\n);\n\n  // Constants\n  localparam WIDTH = 24;\n  localparam DEPTH = 512;\n  localparam ADDR_WIDTH = 9;\n  localparam FULL_ADDR = DEPTH - 1;\n  localparam EMPTY_ADDR = 0;\n  localparam COMP_OFFSET = 24;\n\n  // Registers\n  reg [ADDR_WIDTH-1:0] write_ptr;\n  reg [ADDR_WIDTH-1:0] read_ptr;\n  reg [WIDTH-1:0] fifo [0:DEPTH-1];\n\n  // Wires\n  wire [WIDTH-1:0] read_data;\n  wire [WIDTH-1:0] comp_data;\n  wire full;\n  wire empty;\n\n  // Internal logic\n  assign full = (write_ptr == FULL_ADDR) && (read_ptr == EMPTY_ADDR);\n  assign empty = (write_ptr == read_ptr) && (read_ptr != EMPTY_ADDR);\n\n  assign read_data = empty ? 0 : fifo[read_ptr];\n  assign comp_data = (read_ptr >= COMP_OFFSET) ? fifo[read_ptr - COMP_OFFSET] : 0;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      write_ptr <= EMPTY_ADDR;\n      read_ptr <= EMPTY_ADDR;\n      dout <= 0;\n      comp <= 0;\n    end else begin\n      if (!full) begin\n        fifo[write_ptr] <= din;\n        write_ptr <= (write_ptr == FULL_ADDR) ? EMPTY_ADDR : write_ptr + 1;\n      end\n      if (!empty) begin\n        dout <= read_data;\n        read_ptr <= (read_ptr == FULL_ADDR) ? EMPTY_ADDR : read_ptr + 1;\n      end\n      comp <= (comp_data == dout) ? 1 : 0;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipeline_register_e9ff71f3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule pipeline_register (\n  input clk,\n  input reset,\n  input [31:0] data_in,\n  output [31:0] data_out\n);\n\n  reg [31:0] data_reg;\n\n  always @(posedge clk) begin\n    if (reset) begin\n      data_reg <= 0;\n    end else begin\n      data_reg <= data_in;\n    end\n  end\n\n  assign data_out = data_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_98bc81d9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule four_bit_adder (\n    input [3:0] a,\n    input [3:0] b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n\n    wire [4:0] c;\n    wire [3:0] g;\n    wire [3:0] p;\n\n    assign g = a ^ b;\n    assign p = a & b;\n\n    assign c[0] = cin;\n    assign c[4:1] = {p[3], g[2], g[1], g[0]};\n\n    assign sum = g + c[4:1];\n    assign cout = c[4];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DecoEscrituraRegistros_8e90f7be", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule DecoEscrituraRegistros(Address,Write,EnableStart,EnableRegister\n );\n \n input Write;\n input [8:0] Address;\n output    [21:0] EnableRegister ;\n output  EnableStart;\n \n\n\n\tassign EnableStart = (Address==9'h08C) ? 1'b1 : 1'b0 ;\n\t\n\tassign EnableRegister[0] = (Address==9'h00C)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[1] = (Address==9'h010)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[2] = (Address==9'h014)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[3] = (Address==9'h018)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[4] = (Address==9'h01C)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[5] = (Address==9'h020)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[6] = (Address==9'h024)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[7] = (Address==9'h028)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[8] = (Address==9'h02C)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[9] = (Address==9'h030)&Write ? 1'b1 : 1'b0 ;  assign EnableRegister[10] = (Address==9'h034)&Write ? 1'b1 : 1'b0;  assign EnableRegister[11] = (Address==9'h038)&Write ? 1'b1 : 1'b0;  assign EnableRegister[12] = (Address==9'h03C)&Write ? 1'b1 : 1'b0;  assign EnableRegister[13] = (Address==9'h040)&Write ? 1'b1 : 1'b0;  assign EnableRegister[14] = (Address==9'h044)&Write ? 1'b1 : 1'b0;  assign EnableRegister[15] = (Address==9'h048)&Write ? 1'b1 : 1'b0;  assign EnableRegister[16] = (Address==9'h04C)&Write ? 1'b1 : 1'b0;  assign EnableRegister[17] = (Address==9'h050)&Write ? 1'b1 : 1'b0;  assign EnableRegister[18] = (Address==9'h054)&Write ? 1'b1 : 1'b0;  assign EnableRegister[19] = (Address==9'h058)&Write ? 1'b1 : 1'b0;  assign EnableRegister[20] = (Address==9'h05C)&Write ? 1'b1 : 1'b0; assign EnableRegister[21] = (Address==9'h060)&Write ? 1'b1 : 1'b0; endmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wait_time__bfa7d2c0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule wait_time_module (reset, work, clk, wait_time); \ninput  clk,work,reset;\noutput [11:0] wait_time;\nreg [11:0] wait_time;\n\nreg [5:0] i;\n\nalways @ (posedge clk or negedge reset)\nbegin\n\tif(!reset) \n\tbegin\n\t\twait_time <= 0;\n\t\ti <= 0;\n\tend\n\telse if (work == 0)\n\tbegin\n\t\tif(i >= 4)\n\t\t\tbegin\n\t\t\t\twait_time <= wait_time +1;\n\t\t\t\ti <= 0;\n\t\t\tend\n\t\telse i <= i+1;\n\tend\nend\n\n\n\n\n\n\n\n\n\nendmodule \n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bin2sevenseg_fce1175f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bin2sevenseg(inputbin, displayout);\n\ninput [3:0] inputbin;\noutput [6:0] displayout;\n\nparameter bit0 = 7'b0000001;\nparameter bit1 = 7'b0000010;\nparameter bit2 = 7'b0000100;\nparameter bit3 = 7'b0001000;\nparameter bit4 = 7'b0010000;\nparameter bit5 = 7'b0100000;\nparameter bit6 = 7'b1000000;\n\nparameter zero  = ~(bit0 | bit1 | bit2 | bit3 | bit4 | bit5);\nparameter one   = ~(bit1 | bit2);\nparameter two   = ~(bit0 | bit1 | bit3 | bit4 | bit6);\nparameter three = ~(bit0 | bit1 | bit2 | bit3 | bit6);\nparameter four  = ~(bit1 | bit2 | bit5 | bit6);\nparameter five  = ~(bit0 | bit2 | bit3 | bit5 | bit6);\nparameter six   = ~(bit0 | bit2 | bit3 | bit4 | bit5 | bit6);\nparameter seven = ~(bit0 | bit1 | bit2);\nparameter eight = ~(bit0 | bit1 | bit2 | bit3 | bit4 | bit5 | bit6);\nparameter nine  = ~(bit0 | bit1 | bit2 | bit5 | bit6);\nparameter blank = ~(7'd0);\n\nreg [6:0] displayout;\n\nalways @ (inputbin)\nbegin\n    case (inputbin)\n        4'd0: displayout = zero;\n        4'd1: displayout = one;\n        4'd2: displayout = two;\n        4'd3: displayout = three;\n        4'd4: displayout = four;\n        4'd5: displayout = five;\n        4'd6: displayout = six;\n        4'd7: displayout = seven;\n        4'd8: displayout = eight;\n        4'd9: displayout = nine;\n        4'd10: displayout = 7'b0111111; // A\n        4'd11: displayout = 7'b0001111; // b\n        4'd12: displayout = 7'b0100111; // C\n        4'd13: displayout = 7'b0011110; // d\n        4'd14: displayout = 7'b0100111; // E\n        4'd15: displayout = 7'b0100011; // F\n        default: displayout = blank;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_79b2de3f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule calculator(\n   input [7:0] a,\n   input [7:0] b,\n   input [1:0] op,\n   input start,\n   output reg done,\n   output reg [7:0] result\n   );\n\n   reg [15:0] temp;\n   reg [7:0] i;\n   \n   always@(posedge start)\n   begin\n      case(op)\n         2'b00:result <= a + b;\n         2'b01:result <= a - b;\n         2'b10:result <= a * b;\n         2'b11:begin\n                  if(b == 0) begin\n                     done <= 1;\n                     result <= 8'hFF; // division by zero\n                  end\n                  else begin\n                     temp <= a;\n                     result <= 0;\n                     for (i = 0; i < 8; i = i + 1) begin\n                        if (temp >= b) begin\n                           temp <= temp - b;\n                           result[i] <= 1;\n                        end\n                        temp <= {temp[6:0], 1'b0};\n                     end\n                     done <= 1;\n                  end\n               end\n         default:begin\n                     done <= 1;\n                     result <= 8'hFF; // invalid operation\n                  end\n      endcase\n      done <= 0;\n   end\n   \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_display_1c094147", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_display(\n    input clk,\n    input [3:0] data,\n    output reg display_enable  \n);\n\nreg [3:0] prev_data;\nreg [3:0] data_count;\n\nalways @(posedge clk) begin\n    if (data == prev_data) begin\n        data_count <= data_count + 1;\n    end else begin\n        data_count <= 0;\n    end\n    \n    if (data_count == 9) begin\n        display_enable <= 1;\n        data_count <= 0;  \n    end else begin\n        display_enable <= (data_count == 0) ? 0 : display_enable;\n    end\n    \n    prev_data <= data;\nend\n\nreg [3:0] count;  \n\nalways @(posedge clk) begin\n    if (display_enable) begin\n        count <= (count == 10) ? 0 : count + 1;\n    end else begin\n        count <= 0;  // Reset count when display_enable is not active\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nand4_07bb3b2f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nand4 (\n    input A,\n    input B,\n    input C,\n    input D,\n    output Y\n);\n\nwire AB, CD, ABCD;\nnot (AB, A & B);\nnot (CD, C & D);\nnot (ABCD, AB & CD);\nnot (Y, ABCD);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "clock_divider_0acb425f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule clock_divider (\n  input clock,\n  input reset,\n  output reg clk_out\n);\n\nparameter divisor = 2; // factor by which the frequency of the input clock signal is divided\n\nalways @ (posedge clock, posedge reset) begin\n  if (reset) begin\n    clk_out <= 0;\n    counter <= 0;\n  end else begin\n    if (counter == divisor - 1) begin\n      clk_out <= ~clk_out;\n      counter <= 0;\n    end else begin\n      counter <= counter + 1;\n    end\n  end\nend\n\nreg [32-1:0] counter;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "antiDroopIIR_16_038fc804", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule antiDroopIIR_16 (\n\tinput clk,\n\tinput trig,\n\tinput signed [15:0] din,\n\tinput signed [6:0] tapWeight,\n\tinput accClr_en,\n\t output reg oflowDetect = 1'd0,\n\toutput reg signed [15:0] dout = 16'sd0);\n\nparameter IIR_scale = 15;  reg signed [15:0] din_del = 16'sd0;\n`ifdef ADDPIPEREG  reg signed [15:0] din_del_b = 16'sd0;\n`endif\nreg signed [47:0] tap = 48'sd0;\nreg signed [22:0] multreg = 23'sd0;\n\n reg trig_a = 1'b0, trig_b = 1'b0;\nwire trig_edge = trig_a & ~trig_b;\n reg signed [6:0] tapWeight_a = 7'sd0, tapWeight_b = 7'sd0;\n\nwire oflow = (~&tap[47:IIR_scale+15] && ~&(~tap[47:IIR_scale+15]));\n\n\nalways @(posedge clk) begin\n\ttapWeight_a <= tapWeight;\n\ttapWeight_b <= tapWeight_a;\n\ttrig_a <= trig;\n\ttrig_b <= trig_a;\n\tdin_del <= din;\n\t`ifdef ADDPIPEREG\n\t\tdin_del_b <= din_del;\n\t\tmultreg <= din_del*tapWeight_b;\n\t\tif (oflow) dout <= (tap[IIR_scale+16]) ? -16'sd32768 : 16'sd32767;\n\t\telse dout <= din_del_b + tap[IIR_scale+15:IIR_scale];\n\t`else\n\t\tmultreg <= din*tapWeight_b;\n\t\tif (oflow) dout <= (tap[IIR_scale+16]) ? -16'sd32768 : 16'sd32767;\n\t\telse dout <= din_del + tap[IIR_scale+15:IIR_scale];\n\t`endif\n\tif (trig_edge && accClr_en) tap <= 48'sd0;\n\telse tap <= multreg + tap;\n\toflowDetect <= oflow;\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_2to1_ca92ca15", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_2to1 (\n    Y   ,\n    A   ,\n    B   ,\n    S   \n);\n\n    output Y   ;\n    input  A   ;\n    input  B   ;\n    input  S   ;\n\n    assign Y = (S == 1) ? B : A;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "inputiso1n_855ce8a7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule inputiso1n (\n    X      ,\n    A      ,\n    SLEEP_B,\n    VPWR   ,\n    VGND   ,\n    VPB    ,\n    VNB\n);\n\n    output X      ;\n    input  A      ;\n    input  SLEEP_B;\n    input  VPWR   ;\n    input  VGND   ;\n    input  VPB    ;\n    input  VNB    ;\n\n    wire A_iso, SLEEP_B_iso, VPWR_iso, VGND_iso, VPB_iso, VNB_iso;\n\n    assign A_iso = A ^ VPWR;\n    assign SLEEP_B_iso = SLEEP_B ^ VGND;\n    assign VPWR_iso = VPWR;\n    assign VGND_iso = VGND;\n    assign VPB_iso = VPB;\n    assign VNB_iso = VNB;\n\n    assign X = A_iso & SLEEP_B_iso & VPWR_iso & VGND_iso & VPB_iso & VNB_iso;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "and_nand_e1546799", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule and_nand (\n    input A,\n    input B,\n    output Y\n);\n\n    wire nand1;\n    wire nand2;\n    wire nand3;\n\n    nand nand_gate1(nand1, A, B);\n    nand nand_gate2(nand2, nand1, nand1);\n    nand nand_gate3(nand3, nand2, nand2);\n    nand nand_gate4(Y, nand3, nand3);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wb_drp #_423110ef", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule wb_drp #\n(\n    parameter ADDR_WIDTH = 16\n)\n(\n    input  wire                    clk,\n    input  wire                    rst,\n\n    \n    input  wire [ADDR_WIDTH-1:0]   wb_adr_i,   input  wire [15:0]             wb_dat_i,   output wire [15:0]             wb_dat_o,   input  wire                    wb_we_i,    input  wire                    wb_stb_i,   output wire                    wb_ack_o,   input  wire                    wb_cyc_i,   \n    output wire [ADDR_WIDTH-1:0]   drp_addr,\n    output wire [15:0]             drp_do,\n    input  wire [15:0]             drp_di,\n    output wire                    drp_en,\n    output wire                    drp_we,\n    input  wire                    drp_rdy\n);\n\nreg cycle = 1'b0;\n\nassign drp_addr = wb_adr_i;\nassign drp_do = wb_dat_i;\nassign wb_dat_o = drp_di;\nassign drp_en = wb_cyc_i & wb_stb_i & ~cycle;\nassign drp_we = wb_cyc_i & wb_stb_i & wb_we_i & ~cycle;\nassign wb_ack_o = drp_rdy;\n\nalways @(posedge clk) begin\n    cycle <= wb_cyc_i & wb_stb_i & ~drp_rdy;\n\n    if (rst) begin\n        cycle <= 1'b0;\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_f89a296b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder(\n  input [3:0] A, B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\n  wire C1, C2, C3;\n  full_adder FA1(S[0], C1, A[0], B[0], Cin);\n  full_adder FA2(S[1], C2, A[1], B[1], C1);\n  full_adder FA3(S[2], C3, A[2], B[2], C2);\n  full_adder FA4(S[3], Cout, A[3], B[3], C3);\n\nendmodule\n\nmodule full_adder(\n  output sum,\n  output carry_out,\n  input A,\n  input B,\n  input carry_in\n);\n\n  assign {carry_out, sum} = A + B + carry_in;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Clock_Gating_Module_a016a727", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Clock_Gating_Module(CLK, EN, TE, RESET, ENCLK);\n  input CLK, EN, TE, RESET;\n  output ENCLK;\n\n  wire gated_clk;\n\n  assign gated_clk = (EN & ~RESET) ? CLK : 1'b0;\n\n  assign ENCLK = (TE) ? ~gated_clk : gated_clk;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "priority_encoder_shift_register_b5eaeaa5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule priority_encoder_shift_register (\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input [7:0] in,\n    output reg [6:0] out\n);\n\n    // Priority Encoder\n    wire [2:0] gray_code;\n    wire [2:0] decimal_code;\n    wire [8:0] in_gray;\n    assign in_gray = {in[7], in[7]^in[6], in[6]^in[5], in[5]^in[4], in[4]^in[3], in[3]^in[2], in[2]^in[1], in[1]^in[0]};\n    gray_to_decimal_converter gray_to_decimal(.gray(in_gray[2:0]), .decimal(decimal_code));\n\n    // Shift Register\n    reg [3:0] shift_reg;\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            shift_reg <= 4'b0;\n        end else if (load) begin\n            shift_reg <= in[3:0];\n        end else if (ena) begin\n            shift_reg <= {shift_reg[2:0], shift_reg[3]};\n        end\n    end\n\n    // Mux\n    wire [3:0] mux_out;\n    assign mux_out = load ? in[3:0] : shift_reg;\n\n    // Output\n    wire [6:0] sum;\n    adder add(.a(decimal_code), .b(mux_out), .sum(sum));\n    always @* begin\n        out = sum;\n    end\n\nendmodule\nmodule gray_to_decimal_converter (\n    input [2:0] gray,\n    output reg [2:0] decimal\n);\n\n    always @* begin\n        case (gray)\n            3'b000: decimal = 3'b000;\n            3'b001: decimal = 3'b001;\n            3'b010: decimal = 3'b011;\n            3'b011: decimal = 3'b010;\n            3'b100: decimal = 3'b110;\n            3'b101: decimal = 3'b111;\n            3'b110: decimal = 3'b101;\n            3'b111: decimal = 3'b100;\n        endcase\n    end\nendmodule\nmodule adder (\n    input [2:0] a,\n    input [3:0] b,\n    output reg [6:0] sum\n);\n\n    always @* begin\n        sum = {1'b0, a} + b;\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nfa_get_finals_8db73dc5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule nfa_get_finals (\n        ap_clk,\n        ap_rst,\n        ap_start,\n        ap_done,\n        ap_idle,\n        ap_ready,\n        ap_ce,\n        nfa_finals_buckets_req_din,\n        nfa_finals_buckets_req_full_n,\n        nfa_finals_buckets_req_write,\n        nfa_finals_buckets_rsp_empty_n,\n        nfa_finals_buckets_rsp_read,\n        nfa_finals_buckets_address,\n        nfa_finals_buckets_datain,\n        nfa_finals_buckets_dataout,\n        nfa_finals_buckets_size,\n        ap_return_0,\n        ap_return_1\n);\n\nparameter    ap_const_logic_1 = 1'b1;\nparameter    ap_const_logic_0 = 1'b0;\nparameter    ap_ST_pp0_stg0_fsm_0 = 2'b10;\nparameter    ap_ST_pp0_stg1_fsm_1 = 2'b00;\nparameter    ap_ST_pp0_stg2_fsm_2 = 2'b1;\nparameter    ap_ST_pp0_stg3_fsm_3 = 2'b11;\nparameter    ap_const_lv64_1 = 64'b1;\nparameter    ap_const_lv32_0 = 32'b00000000000000000000000000000000;\nparameter    ap_const_lv32_1 = 32'b1;\nparameter    ap_true = 1'b1;\n\ninput   ap_clk;\ninput   ap_rst;\ninput   ap_start;\noutput   ap_done;\noutput   ap_idle;\noutput   ap_ready;\ninput   ap_ce;\noutput   nfa_finals_buckets_req_din;\ninput   nfa_finals_buckets_req_full_n;\noutput   nfa_finals_buckets_req_write;\ninput   nfa_finals_buckets_rsp_empty_n;\noutput   nfa_finals_buckets_rsp_read;\noutput  [31:0] nfa_finals_buckets_address;\ninput  [31:0] nfa_finals_buckets_datain;\noutput  [31:0] nfa_finals_buckets_dataout;\noutput  [31:0] nfa_finals_buckets_size;\noutput  [31:0] ap_return_0;\noutput  [31:0] ap_return_1;\n\nreg ap_done;\nreg ap_idle;\nreg ap_ready;\nreg nfa_finals_buckets_req_write;\nreg nfa_finals_buckets_rsp_read;\nreg[31:0] nfa_finals_buckets_address;\nreg   [1:0] ap_CS_fsm = 2'b10;\nreg    ap_reg_ppiten_pp0_it0;\nreg    ap_reg_ppiten_pp0_it1 = 1'b0;\nreg   [31:0] nfa_finals_buckets_read_reg_59;\nreg    ap_reg_ppiten_pp0_it0_preg = 1'b0;\nreg   [1:0] ap_NS_fsm;\nreg    ap_sig_pprstidle_pp0;\nreg    ap_sig_bdd_131;\nreg    ap_sig_bdd_130;\n\n\n\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_CS_fsm\n    if (ap_rst == 1'b1) begin\n        ap_CS_fsm <= ap_ST_pp0_stg0_fsm_0;\n    end else begin\n        ap_CS_fsm <= ap_NS_fsm;\n    end\nend\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_reg_ppiten_pp0_it0_preg\n    if (ap_rst == 1'b1) begin\n        ap_reg_ppiten_pp0_it0_preg <= ap_const_logic_0;\n    end else begin\n        if (((ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm) & ~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_start == ap_const_logic_0))))) begin\n            ap_reg_ppiten_pp0_it0_preg <= ap_start;\n        end\n    end\nend\n\nalways @ (posedge ap_clk)\nbegin : ap_ret_ap_reg_ppiten_pp0_it1\n    if (ap_rst == 1'b1) begin\n        ap_reg_ppiten_pp0_it1 <= ap_const_logic_0;\n    end else begin\n        if (((ap_ST_pp0_stg1_fsm_1 == ap_CS_fsm) & ~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))) & ~(ap_const_logic_1 == ap_reg_ppiten_pp0_it0))) begin\n            ap_reg_ppiten_pp0_it1 <= ap_const_logic_0;\n        end else if (((ap_ST_pp0_stg3_fsm_3 == ap_CS_fsm) & (ap_const_logic_1 == ap_ce))) begin\n            ap_reg_ppiten_pp0_it1 <= ap_reg_ppiten_pp0_it0;\n        end\n    end\nend\n\nalways @(posedge ap_clk)\nbegin\n    if (((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_1 == ap_ce) & (ap_ST_pp0_stg2_fsm_2 == ap_CS_fsm) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0)))) begin\n        nfa_finals_buckets_read_reg_59 <= nfa_finals_buckets_datain;\n    end\nend\n\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_reg_ppiten_pp0_it1 or ap_ce or nfa_finals_buckets_rsp_empty_n)\nbegin\n    if (((~(ap_const_logic_1 == ap_start) & (ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm) & (ap_const_logic_1 == ap_reg_ppiten_pp0_it0)) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (ap_const_logic_1 == ap_ce) & (ap_ST_pp0_stg1_fsm_1 == ap_CS_fsm) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))))) begin\n        ap_done = ap_const_logic_1;\n    end else begin\n        ap_done = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_reg_ppiten_pp0_it1)\nbegin\n    if ((~(ap_const_logic_1 == ap_start) & (ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm) & (ap_const_logic_0 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_0 == ap_reg_ppiten_pp0_it1))) begin\n        ap_idle = ap_const_logic_1;\n    end else begin\n        ap_idle = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_ce)\nbegin\n    if (((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_ST_pp0_stg3_fsm_3 == ap_CS_fsm) & (ap_const_logic_1 == ap_ce))) begin\n        ap_ready = ap_const_logic_1;\n    end else begin\n        ap_ready = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0_preg)\nbegin\n    if ((ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm)) begin\n        ap_reg_ppiten_pp0_it0 = ap_start;\n    end else begin\n        ap_reg_ppiten_pp0_it0 = ap_reg_ppiten_pp0_it0_preg;\n    end\nend\n\nalways @ (ap_start or ap_reg_ppiten_pp0_it0)\nbegin\n    if (((ap_const_logic_0 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_0 == ap_start))) begin\n        ap_sig_pprstidle_pp0 = ap_const_logic_1;\n    end else begin\n        ap_sig_pprstidle_pp0 = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_CS_fsm or ap_sig_bdd_131 or ap_sig_bdd_130)\nbegin\n    if (ap_sig_bdd_130) begin\n        if ((ap_ST_pp0_stg3_fsm_3 == ap_CS_fsm)) begin\n            nfa_finals_buckets_address = ap_const_lv64_1;\n        end else if (ap_sig_bdd_131) begin\n            nfa_finals_buckets_address = ap_const_lv32_0;\n        end else begin\n            nfa_finals_buckets_address = 'bx;\n        end\n    end else begin\n        nfa_finals_buckets_address = 'bx;\n    end\nend\n\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_ce)\nbegin\n    if ((((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_ST_pp0_stg3_fsm_3 == ap_CS_fsm) & (ap_const_logic_1 == ap_ce)) | ((ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm) & (ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_1 == ap_ce) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_start == ap_const_logic_0))))) begin\n        nfa_finals_buckets_req_write = ap_const_logic_1;\n    end else begin\n        nfa_finals_buckets_req_write = ap_const_logic_0;\n    end\nend\n\nalways @ (ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_reg_ppiten_pp0_it1 or ap_ce or nfa_finals_buckets_rsp_empty_n)\nbegin\n    if ((((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_1 == ap_ce) & (ap_ST_pp0_stg2_fsm_2 == ap_CS_fsm) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (ap_const_logic_1 == ap_ce) & (ap_ST_pp0_stg1_fsm_1 == ap_CS_fsm) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))))) begin\n        nfa_finals_buckets_rsp_read = ap_const_logic_1;\n    end else begin\n        nfa_finals_buckets_rsp_read = ap_const_logic_0;\n    end\nend\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0 or ap_reg_ppiten_pp0_it1 or ap_ce or nfa_finals_buckets_rsp_empty_n or ap_sig_pprstidle_pp0)\nbegin\n    case (ap_CS_fsm)\n        ap_ST_pp0_stg0_fsm_0 : \n            if ((~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_start == ap_const_logic_0))) & ~((ap_const_logic_0 == ap_reg_ppiten_pp0_it1) & (ap_const_logic_0 == ap_start)))) begin\n                ap_NS_fsm = ap_ST_pp0_stg1_fsm_1;\n            end else begin\n                ap_NS_fsm = ap_ST_pp0_stg0_fsm_0;\n            end\n        ap_ST_pp0_stg1_fsm_1 : \n            if ((~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))) & ~(ap_const_logic_1 == ap_sig_pprstidle_pp0))) begin\n                ap_NS_fsm = ap_ST_pp0_stg2_fsm_2;\n            end else if ((~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it1) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0))) & (ap_const_logic_1 == ap_sig_pprstidle_pp0))) begin\n                ap_NS_fsm = ap_ST_pp0_stg0_fsm_0;\n            end else begin\n                ap_NS_fsm = ap_ST_pp0_stg1_fsm_1;\n            end\n        ap_ST_pp0_stg2_fsm_2 : \n            if (~(~(ap_const_logic_1 == ap_ce) | ((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (nfa_finals_buckets_rsp_empty_n == ap_const_logic_0)))) begin\n                ap_NS_fsm = ap_ST_pp0_stg3_fsm_3;\n            end else begin\n                ap_NS_fsm = ap_ST_pp0_stg2_fsm_2;\n            end\n        ap_ST_pp0_stg3_fsm_3 : \n            if ((ap_const_logic_1 == ap_ce)) begin\n                ap_NS_fsm = ap_ST_pp0_stg0_fsm_0;\n            end else begin\n                ap_NS_fsm = ap_ST_pp0_stg3_fsm_3;\n            end\n        default : \n            ap_NS_fsm = 'bx;\n    endcase\nend\nassign ap_return_0 = nfa_finals_buckets_read_reg_59;\nassign ap_return_1 = nfa_finals_buckets_datain;\n\nalways @ (ap_reg_ppiten_pp0_it0 or ap_ce)\nbegin\n    ap_sig_bdd_130 = ((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_const_logic_1 == ap_ce));\nend\n\nalways @ (ap_start or ap_CS_fsm or ap_reg_ppiten_pp0_it0)\nbegin\n    ap_sig_bdd_131 = ((ap_ST_pp0_stg0_fsm_0 == ap_CS_fsm) & ~((ap_const_logic_1 == ap_reg_ppiten_pp0_it0) & (ap_start == ap_const_logic_0)));\nend\nassign nfa_finals_buckets_dataout = ap_const_lv32_0;\nassign nfa_finals_buckets_req_din = ap_const_logic_0;\nassign nfa_finals_buckets_size = ap_const_lv32_1;\n\n\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "eth_clockgen_b28b194c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule eth_clockgen(Clk, Reset, Divider, MdcEn, MdcEn_n, Mdc);\n\nparameter Tp=1;\n\ninput       Clk;              input       Reset;            input [7:0] Divider;          output      Mdc;              output      MdcEn;            output      MdcEn_n;          reg         Mdc;\nreg   [7:0] Counter;\n\nwire        CountEq0;\nwire  [7:0] CounterPreset;\nwire  [7:0] TempDivider;\n\n\nassign TempDivider[7:0]   = (Divider[7:0]<2)? 8'h02 : Divider[7:0]; assign CounterPreset[7:0] = (TempDivider[7:0]>>1) -1;               always @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    Counter[7:0] <= #Tp 8'h1;\n  else\n    begin\n      if(CountEq0)\n        begin\n          Counter[7:0] <= #Tp CounterPreset[7:0];\n        end\n      else\n        Counter[7:0] <= #Tp Counter - 8'h1;\n    end\nend\n\n\nalways @ (posedge Clk or posedge Reset)\nbegin\n  if(Reset)\n    Mdc <= #Tp 1'b0;\n  else\n    begin\n      if(CountEq0)\n        Mdc <= #Tp ~Mdc;\n    end\nend\n\n\nassign CountEq0 = Counter == 8'h0;\nassign MdcEn = CountEq0 & ~Mdc;\nassign MdcEn_n = CountEq0 & Mdc;\n\nendmodule\n\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_en_e376f30b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_en(input D, C, E, output Q);\n  reg Q;\n\n  always @(posedge C) begin\n    if (E) begin\n      Q <= D;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "BRAM1_ba2f84e4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule BRAM1(\n    input CLK,\n    input EN,\n    input WE,\n    input [ADDR_WIDTH-1:0] ADDR,\n    input [DATA_WIDTH-1:0] DI,\n    output [DATA_WIDTH-1:0] DO\n);\n\nparameter PIPELINED = 0;\nparameter ADDR_WIDTH = 1;\nparameter DATA_WIDTH = 1;\nparameter MEMSIZE = 1;\n\nreg [DATA_WIDTH-1:0] RAM [0:MEMSIZE-1];\nreg [DATA_WIDTH-1:0] DO_R;\nreg [DATA_WIDTH-1:0] DO_R2;\n\nalways @(posedge CLK) begin\n    if (EN) begin\n        if (WE) begin\n            RAM[ADDR] <= DI;\n            DO_R <= DI;\n        end else begin\n            DO_R <= RAM[ADDR];\n        end\n    end\n    DO_R2 <= DO_R;\nend\n\nassign DO = (PIPELINED) ? DO_R2 : DO_R;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_reg_3650de4e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_reg (\n  input clk,\n  input reset,\n  input load,\n  input [3:0] data_in,\n  output reg [3:0] shift_out\n);\n\n  always @(posedge clk, posedge reset) begin\n    if (reset) begin\n      shift_out <= 4'b0;\n    end\n    else if (load) begin\n      shift_out <= data_in;\n    end\n    else begin\n      shift_out <= {shift_out[2:0], shift_out[3]};\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "macc_module_96e4eb70", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule macc_module(\n  input clk,\n  input reset,\n  input [31:0] a,\n  input [31:0] b,\n  output [31:0] out\n);\n\n  reg [31:0] accum; // register to hold accumulated value\n\n  always @(posedge clk) begin\n    if (reset) begin\n      accum <= 0;\n    end else begin\n      accum <= accum + (a * b);\n    end\n  end\n\n  assign out = accum;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_adder_c40e4a6f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] S,\n    output C\n);\n\n    wire [3:0] sum;\n    wire [3:0] carry;\n\n    full_adder fa0(.A(A[0]), .B(B[0]), .C_in(1'b0), .S(sum[0]), .C_out(carry[1]));\n    full_adder fa1(.A(A[1]), .B(B[1]), .C_in(carry[1]), .S(sum[1]), .C_out(carry[2]));\n    full_adder fa2(.A(A[2]), .B(B[2]), .C_in(carry[2]), .S(sum[2]), .C_out(carry[3]));\n    full_adder fa3(.A(A[3]), .B(B[3]), .C_in(carry[3]), .S(sum[3]), .C_out(C));\n\n    assign S = sum;\n\nendmodule\n\nmodule full_adder(\n    input A,\n    input B,\n    input C_in,\n    output S,\n    output C_out\n);\n\n    assign {C_out, S} = A + B + C_in;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "select_bits #_f1f3e897", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule select_bits #(\n    parameter WIDTH = 16\n)(\n    input signed [WIDTH-1:0] in,\n    output reg [9:0] out\n);\n\n    always @(*) begin\n        if (in[0] == 1'b0) // even\n            out = in[9:0];\n        else // odd\n            out = in[WIDTH-1:WIDTH-10];\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_4to1_cd286f1a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_4to1 (\n    input A,\n    input B,\n    input C,\n    input D,\n    input S0,\n    input S1,\n    output Y\n);\n\n    wire sel1, sel2;\n\n    // First level of selection\n    assign sel1 = (S1 == 0) ? S0 : ~S0;\n\n    // Second level of selection\n    assign sel2 = (S1 == 0) ? A : B;\n    assign Y = (sel1 & sel2) | (~sel1 & ((S1 == 0) ? C : D));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "my__00645347", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule my_module (\n    X,\n    A1,\n    A2,\n    A3,\n    B1\n);\n\n    output X;\n    input A1;\n    input A2;\n    input A3;\n    input B1;\n\n    assign X = ((A1 & ~A2) | (A2 & ~A1 & A3 & ~B1) | (~A1 & ~A2 & ~A3 & B1)) ? 1'b1 : 1'b0;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__o2111ai_e71debc7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__o2111ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    C1,\n    D1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A2, A1             );\n    nand nand0 (nand0_out_Y, C1, B1, D1, or0_out);\n    buf  buf0  (Y          , nand0_out_Y        );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__fahcon_044f8233", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_hd__fahcon (\n    input A,\n    input B,\n    input CI,\n    input VPWR,\n    input VGND,\n    input VPB,\n    input VNB,\n    output COUT_N,\n    output SUM\n);\n\nwire w1, w2, w3;\n\nassign w1 = A ^ B;\nassign SUM = w1 ^ CI;\nassign w2 = A & B;\nassign w3 = CI & w1;\nassign COUT_N = w2 | w3;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_3d891443", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter(\n  input rst, clk, enable,\n  input [31:0] inc_value,\n  output reg [31:0] count\n);\n\n  always @(posedge clk or negedge rst) begin\n    if (!rst) begin\n      count <= 0;\n    end else if (enable) begin\n      count <= count + inc_value;\n      if (count >= 2**32 - inc_value) begin\n        count <= 0;\n      end\n    end\n  end\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_to_bcd_d8676919", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule binary_to_bcd(clk, reset, in, out1, out2, out3, out4, clear);\n    input clk, reset, clear;\n    input [7:0] in;\n    output reg [3:0] out1, out2, out3, out4;\n\n    reg [23:0] temp;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            temp <= 0;\n            out1 <= 0;\n            out2 <= 0;\n            out3 <= 0;\n            out4 <= 0;\n        end\n        else begin\n            if (clear) begin\n                out1 <= 0;\n                out2 <= 0;\n                out3 <= 0;\n                out4 <= 0;\n                temp <= 0;\n            end\n            else begin\n                temp <= {temp[19:0], in};\n                if (temp >= 24'd10000) begin\n                    temp <= temp + 3'd3;\n                end\n                if (temp >= 24'd100000) begin\n                    temp <= temp + 3'd3;\n                end\n                if (temp >= 24'd1000000) begin\n                    temp <= temp + 3'd3;\n                end\n                if (temp >= 24'd10000000) begin\n                    temp <= temp + 3'd3;\n                end\n                out1 <= temp[3:0];\n                out2 <= temp[7:4];\n                out3 <= temp[11:8];\n                out4 <= temp[15:12];\n            end\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "addition_module_d8db8a87", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule addition_module\n  (\n   input   [1:0] i,\n   input   [1:0] a,\n   output  [1:0] o\n   );\n   assign o = i + a;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "majority_circuit_4ae782e7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule majority_circuit (\n  input a,\n  input b,\n  input c,\n  output reg out\n);\n\n  always @ (a, b, c) begin\n    out = (a & b) | (b & c) | (c & a);\n  end\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__and4_3b82f347", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__and4 (\n    X,\n    A,\n    B,\n    C,\n    D\n);\n\n    output X;\n    input  A;\n    input  B;\n    input  C;\n    input  D;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out_X;\n\n    and and0 (and0_out_X, A, B, C, D     );\n    buf buf0 (X         , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux2to1_b19fc623", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux2to1 (Y, A, B, S);\n    output Y;\n    input A, B, S;\n    assign Y = (S == 1'b0) ? A : B;\nendmodule\n\nmodule mux4to1 (Y, D0, D1, D2, D3, S0, S1);\n    output Y;\n    input D0, D1, D2, D3, S0, S1;\n    wire w1, w2, w3;\n    mux2to1 mux1 (.Y(w1), .A(D0), .B(D1), .S(S1));\n    mux2to1 mux2 (.Y(w2), .A(D2), .B(D3), .S(S1));\n    mux2to1 mux3 (.Y(w3), .A(w1), .B(w2), .S(S0));\n    assign Y = w3;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__a211o_b9a08d7f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__a211o (\n    X ,\n    A1,\n    A2,\n    B1,\n    C1\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    wire and0_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A1, A2          );\n    or  or0  (or0_out_X, and0_out, C1, B1);\n    buf buf0 (X        , or0_out_X       );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_8200ddc7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter (\n    input clk,\n    input reset,\n    output reg [7:0] counter,\n    output reg [7:0] waveforms,\n    output reg interrupt_event\n);\n\nreg [3:0] state;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        counter <= 8'b0;\n        waveforms <= 8'b0;\n        interrupt_event <= 1'b0;\n        state <= 4'b0000;\n    end else begin\n        counter <= counter + 1;\n        case (state)\n            4'b0000: begin // count < 128\n                waveforms <= {8{counter[6]}};\n                if (counter == 127) begin\n                    state <= 4'b0001;\n                end\n            end\n            4'b0001: begin // 128 <= count <= 191\n                waveforms <= counter[2:0] << 5;\n                if (counter == 191) begin\n                    state <= 4'b0010;\n                end\n            end\n            4'b0010: begin // count >= 192\n                waveforms <= {6{counter[6]}};\n                if (counter == 255) begin\n                    interrupt_event <= 1'b1;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_f0b170a3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n  input clk,\n  input rst,\n  input [1:0] op,\n  input [7:0] num1,\n  input [7:0] num2,\n  output [7:0] result,\n  output valid);\n\n  reg [7:0] result_reg;\n  reg valid_reg;\n  \n  always@(posedge clk) begin\n    if(rst) begin\n      result_reg <= 8'b0;\n      valid_reg <= 1'b0;\n    end else begin\n      case(op)\n        2'b00: result_reg <= num1 + num2;\n        2'b01: result_reg <= num1 - num2;\n        2'b10: result_reg <= num1 * num2;\n        2'b11: result_reg <= num1 / num2;\n      endcase\n      \n      valid_reg <= 1'b1;\n    end\n  end\n  \n  assign result = result_reg;\n  assign valid = valid_reg;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "averager_counter_1d02cee3", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule averager_counter (\n  input        restart,\n  input        clken,\n  input [31:0] count_max,\n  input        clk,\n  input        avg_on,\n  output       clr_fback,\n  output       ready,\n  output       wen,\n  output       avg_on_out,\n  output [31:0] n_avg,\n  output [31:0] address\n);\n\n  parameter N = 4; // number of values to average (must be a power of 2)\n  parameter WIDTH = $clog2(N); // number of bits needed to represent N\n  parameter AVG_WIDTH = 2*WIDTH + $clog2(32); // number of bits needed to represent the average\n\n  reg [WIDTH-1:0]  index; // index of the current value in the averaging buffer\n  reg [31:0]       sum;   // sum of the last N values of the counter\n  reg [AVG_WIDTH-1:0] avg; // current average value\n  \n  reg [31:0] count; // current value of the counter\n  reg [31:0] next_count; // next value of the counter (after incrementing)\n  reg [31:0] max_count; // maximum value of the counter\n  \n  reg avg_on_reg; // register to store the value of avg_on\n  reg [WIDTH-1:0]  wen_cnt; // counter to track the number of values written to the averaging buffer\n  wire wen_int; // internal signal to indicate when the averaging buffer is ready to receive a new value\n  wire ready_int; // internal signal to indicate when the averaging function has calculated a new average value\n  \n  assign clr_fback = (count == count_max); // clear the counter when it reaches its maximum value\n  assign address = count; // output the current value of the counter\n  \n  // increment the counter on each clock cycle\n  always @(posedge clk) begin\n    if (restart) begin\n      count <= 0;\n    end else if (clken) begin\n      if (count == count_max) begin\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\n  \n  // calculate the next value of the counter (after incrementing)\n  always @(*) begin\n    if (count == count_max) begin\n      next_count = 0;\n    end else begin\n      next_count = count + 1;\n    end\n  end\n  \n  // calculate the maximum value of the counter\n  always @(*) begin\n    max_count = count_max;\n  end\n  \n  // enable or disable the averaging function\n  always @(posedge clk) begin\n    if (restart) begin\n      avg_on_reg <= 0;\n    end else if (clken) begin\n      avg_on_reg <= avg_on;\n    end\n  end\n  \n  // calculate the sum of the last N values of the counter\n  always @(posedge clk) begin\n    if (restart) begin\n      sum <= 0;\n    end else if (clken) begin\n      if (count == count_max) begin\n        sum <= 0;\n      end else begin\n        sum <= sum + count - (wen_int ? avg[N-1] : 0);\n      end\n    end\n  end\n  \n  // calculate the current average value\n  always @(posedge clk) begin\n    if (restart) begin\n      avg <= 0;\n    end else if (clken) begin\n      if (count == count_max) begin\n        avg <= 0;\n      end else if (wen_int) begin\n        avg <= {sum[N-1:0], wen_cnt, count};\n      end\n    end\n  end\n  \n  // write the current value of the counter to the averaging buffer\n  always @(posedge clk) begin\n    if (restart) begin\n      index <= 0;\n      wen_cnt <= 0;\n    end else if (clken) begin\n      if (wen_int) begin\n        index <= index + 1;\n        wen_cnt <= wen_cnt + 1;\n      end\n    end\n  end\n  \n  // check if the averaging buffer is ready to receive a new value\n  assign wen_int = (wen_cnt < N);\n  \n  // check if the averaging function has calculated a new average value\n  assign ready_int = (wen_cnt == N);\n  \n  // output the current average value\n  assign n_avg = avg[N-1:0];\n  \n  // output the control signals\n  assign wen = wen_int && avg_on_reg;\n  assign ready = ready_int;\n  assign avg_on_out = avg_on_reg;\n  \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "async_fifo_align_64in_out_rd_handshaking_flags_a71f5a3e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule async_fifo_align_64in_out_rd_handshaking_flags\n   (valid,\n    ram_valid_i,\n    clk,\n    Q);\n  output valid;\n  input ram_valid_i;\n  input clk;\n  input [0:0]Q;\n\n  reg [0:0] Q_reg;\n  reg [0:0] ram_valid_d1_reg;\n  wire [0:0] Q;\n  wire clk;\n  wire ram_valid_i;\n  wire valid;\n\n  always @(posedge clk) begin\n    Q_reg <= Q;\n    ram_valid_d1_reg <= ram_valid_i;\n  end\n\n  assign valid = (Q_reg && ram_valid_d1_reg);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "avalon_to_wb_bridge #_ddd41088", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule avalon_to_wb_bridge #(\n\tparameter DW = 32,\tparameter AW = 32\t)(\n\tinput \t\t  clk,\n\tinput \t\t  rst,\n\tinput [AW-1:0] \t  avm_address_i,\n\tinput [DW/8-1:0]  avm_byteenable_i,\n\tinput \t\t  avm_read_i,\n\toutput [DW-1:0]   avm_readdata_o,\n\tinput [7:0] \t  avm_burstcount_i,\n\tinput \t\t  avm_write_i,\n\tinput [DW-1:0] \t  avm_writedata_i,\n\toutput \t\t  avm_waitrequest_o,\n\toutput \t\t  avm_readdatavalid_o,\n\toutput [AW-1:0]   wbm_adr_o,\n\toutput [DW-1:0]   wbm_dat_o,\n\toutput [DW/8-1:0] wbm_sel_o,\n\toutput \t\t  wbm_we_o,\n\toutput \t\t  wbm_cyc_o,\n\toutput \t\t  wbm_stb_o,\n\toutput [2:0] \t  wbm_cti_o,\n\toutput [1:0] \t  wbm_bte_o,\n\tinput [DW-1:0] \t  wbm_dat_i,\n\tinput \t\t  wbm_ack_i,\n\tinput \t\t  wbm_err_i,\n\tinput \t\t  wbm_rty_i\n);\n\nreg read_access;\n\nalways @(posedge clk)\n\tif (rst)\n\t\tread_access <= 0;\n\telse if (wbm_ack_i | wbm_err_i)\n\t\tread_access <= 0;\n\telse if (avm_read_i)\n\t\tread_access <= 1;\n\nreg readdatavalid;\nreg [DW-1:0] readdata;\nalways @(posedge clk) begin\n\treaddatavalid <= (wbm_ack_i | wbm_err_i) & read_access;\n\treaddata <= wbm_dat_i;\nend\n\nassign wbm_adr_o = avm_address_i;\nassign wbm_dat_o = avm_writedata_i;\nassign wbm_sel_o =  avm_byteenable_i;\nassign wbm_we_o = avm_write_i;\nassign wbm_cyc_o = read_access | avm_write_i;\nassign wbm_stb_o = read_access | avm_write_i;\nassign wbm_cti_o = 3'b111; assign wbm_bte_o = 2'b00;\nassign avm_waitrequest_o = !(wbm_ack_i | wbm_err_i);\nassign avm_readdatavalid_o = readdatavalid;\nassign avm_readdata_o = readdata;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "hpdmc_mgmt #_eab536be", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule hpdmc_mgmt #(\n\tparameter sdram_depth = 26,\n\tparameter sdram_columndepth = 9,\n\tparameter sdram_addrdepth = sdram_depth-1-1-(sdram_columndepth+2)+1\n) (\n\tinput sys_clk,\n\tinput sdram_rst,\n\t\n\tinput [2:0] tim_rp,\n\tinput [2:0] tim_rcd,\n\tinput [10:0] tim_refi,\n\tinput [3:0] tim_rfc,\n\t\n\tinput stb,\n\tinput we,\n\tinput [sdram_depth-1-1:0] address, \n\toutput reg ack,\n\t\n\toutput reg read,\n\toutput reg write,\n\toutput [3:0] concerned_bank,\n\tinput read_safe,\n\tinput write_safe,\n\tinput [3:0] precharge_safe,\n\t\n\toutput sdram_cs_n,\n\toutput sdram_we_n,\n\toutput sdram_cas_n,\n\toutput sdram_ras_n,\n\toutput [sdram_addrdepth-1:0] sdram_adr,\n\toutput [1:0] sdram_ba\n);\n\n\n\nlocalparam rowdepth = sdram_depth-1-1-(sdram_columndepth+2)+1;\nlocalparam sdram_addrdepth_o1024 = sdram_addrdepth-11;\n\nwire [sdram_depth-1-1:0] address16 = address;\n\nwire [sdram_columndepth-1:0] col_address = address16[sdram_columndepth-1:0];\nwire [1:0] bank_address = address16[sdram_columndepth+1:sdram_columndepth];\nwire [rowdepth-1:0] row_address = address16[sdram_depth-1-1:sdram_columndepth+2];\n\nreg [3:0] bank_address_onehot;\nalways @(*) begin\n\tcase(bank_address)\n\t\t2'b00: bank_address_onehot <= 4'b0001;\n\t\t2'b01: bank_address_onehot <= 4'b0010;\n\t\t2'b10: bank_address_onehot <= 4'b0100;\n\t\t2'b11: bank_address_onehot <= 4'b1000;\n\tendcase\nend\n\n\nreg [3:0] has_openrow;\nreg [rowdepth-1:0] openrows[0:3];\nreg [3:0] track_close;\nreg [3:0] track_open;\n\nalways @(posedge sys_clk) begin\n\tif(sdram_rst) begin\n\t\thas_openrow <= 4'h0;\n\tend else begin\n\t\thas_openrow <= (has_openrow | track_open) & ~track_close;\n\t\t\n\t\tif(track_open[0]) openrows[0] <= row_address;\n\t\tif(track_open[1]) openrows[1] <= row_address;\n\t\tif(track_open[2]) openrows[2] <= row_address;\n \t\tif(track_open[3]) openrows[3] <= row_address;\n\tend\nend\n\n\nassign concerned_bank = bank_address_onehot;\nwire current_precharge_safe =\n\t (precharge_safe[0] | ~bank_address_onehot[0])\n\t&(precharge_safe[1] | ~bank_address_onehot[1])\n\t&(precharge_safe[2] | ~bank_address_onehot[2])\n\t&(precharge_safe[3] | ~bank_address_onehot[3]);\n\n\n\nwire bank_open = has_openrow[bank_address];\nwire page_hit = bank_open & (openrows[bank_address] == row_address);\n\n\nreg sdram_adr_loadrow;\nreg sdram_adr_loadcol;\nreg sdram_adr_loadA10;\nassign sdram_adr =\n\t ({sdram_addrdepth{sdram_adr_loadrow}}\t& row_address)\n\t|({sdram_addrdepth{sdram_adr_loadcol}}\t& col_address)\n\t|({sdram_addrdepth{sdram_adr_loadA10}}\n     & { {sdram_addrdepth_o1024{1'b0}} , 11'd1024});\n\nassign sdram_ba = bank_address;\n\n\nreg sdram_cs;\nreg sdram_we;\nreg sdram_cas;\nreg sdram_ras;\nassign sdram_cs_n = ~sdram_cs;\nassign sdram_we_n = ~sdram_we;\nassign sdram_cas_n = ~sdram_cas;\nassign sdram_ras_n = ~sdram_ras;\n\n\n\n\nreg [2:0] precharge_counter;\nreg reload_precharge_counter;\nwire precharge_done = (precharge_counter == 3'd0);\nalways @(posedge sys_clk) begin\n\tif(reload_precharge_counter)\n\t\tprecharge_counter <= tim_rp;\n\telse if(~precharge_done)\n\t\tprecharge_counter <= precharge_counter - 3'd1;\nend\n\n\nreg [2:0] activate_counter;\nreg reload_activate_counter;\nwire activate_done = (activate_counter == 3'd0);\nalways @(posedge sys_clk) begin\n\tif(reload_activate_counter)\n\t\tactivate_counter <= tim_rcd;\n\telse if(~activate_done)\n\t\tactivate_counter <= activate_counter - 3'd1;\nend\n\n\nreg [10:0] refresh_counter;\nreg reload_refresh_counter;\nwire must_refresh = refresh_counter == 11'd0;\nalways @(posedge sys_clk) begin\n\tif(sdram_rst)\n\t\trefresh_counter <= 11'd0;\n\telse begin\n\t\tif(reload_refresh_counter)\n\t\t\trefresh_counter <= tim_refi;\n\t\telse if(~must_refresh)\n\t\t\trefresh_counter <= refresh_counter - 11'd1;\n\tend\nend\n\n\nreg [3:0] autorefresh_counter;\nreg reload_autorefresh_counter;\nwire autorefresh_done = (autorefresh_counter == 4'd0);\nalways @(posedge sys_clk) begin\n\tif(reload_autorefresh_counter)\n\t\tautorefresh_counter <= tim_rfc;\n\telse if(~autorefresh_done)\n\t\tautorefresh_counter <= autorefresh_counter - 4'd1;\nend\n\n\n\nreg [3:0] state;\nreg [3:0] next_state;\n\n  localparam [3:0]\n    IDLE\t\t\t= 4'd0,\n    ACTIVATE\t\t= 4'd1,\n    READ\t\t\t= 4'd2,\n    WRITE\t\t\t= 4'd3,\n    PRECHARGEALL\t\t= 4'd4,\n    AUTOREFRESH\t\t= 4'd5,\n    AUTOREFRESH_WAIT\t= 4'd6;\n\nalways @(posedge sys_clk) begin\n\tif(sdram_rst)\n\t\tstate <= IDLE;\n\telse begin\n\t\tstate <= next_state;\n\tend\nend\n\nalways @(*) begin\n\tnext_state = state;\n\t\n\treload_precharge_counter = 1'b0;\n\treload_activate_counter = 1'b0;\n\treload_refresh_counter = 1'b0;\n\treload_autorefresh_counter = 1'b0;\n\t\n\tsdram_cs = 1'b0;\n\tsdram_we = 1'b0;\n\tsdram_cas = 1'b0;\n\tsdram_ras = 1'b0;\n\t\n\tsdram_adr_loadrow = 1'b0;\n\tsdram_adr_loadcol = 1'b0;\n\tsdram_adr_loadA10 = 1'b0;\n\t\n\ttrack_close = 4'b0000;\n\ttrack_open = 4'b0000;\n\t\n\tread = 1'b0;\n\twrite = 1'b0;\n\t\n\tack = 1'b0;\n\t\n\tcase(state)\n\t\tIDLE: begin\n\t\t\tif(must_refresh)\n\t\t\t\tnext_state = PRECHARGEALL;\n\t\t\telse begin\n\t\t\t\tif(stb) begin\n\t\t\t\t\tif(page_hit) begin\n\t\t\t\t\t\tif(we) begin\n\t\t\t\t\t\t\tif(write_safe) begin\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\t\t\t\tsdram_ras = 1'b0;\n\t\t\t\t\t\t\t\tsdram_cas = 1'b1;\n\t\t\t\t\t\t\t\tsdram_we = 1'b1;\n\t\t\t\t\t\t\t\tsdram_adr_loadcol = 1'b1;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\twrite = 1'b1;\n\t\t\t\t\t\t\t\tack = 1'b1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\tif(read_safe) begin\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\t\t\t\tsdram_ras = 1'b0;\n\t\t\t\t\t\t\t\tsdram_cas = 1'b1;\n\t\t\t\t\t\t\t\tsdram_we = 1'b0;\n\t\t\t\t\t\t\t\tsdram_adr_loadcol = 1'b1;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tread = 1'b1;\n\t\t\t\t\t\t\t\tack = 1'b1;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tif(bank_open) begin\n\t\t\t\t\t\t\tif(current_precharge_safe) begin\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\t\t\t\tsdram_ras = 1'b1;\n\t\t\t\t\t\t\t\tsdram_cas = 1'b0;\n\t\t\t\t\t\t\t\tsdram_we = 1'b1;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\ttrack_close = bank_address_onehot;\n\t\t\t\t\t\t\t\treload_precharge_counter = 1'b1;\n\t\t\t\t\t\t\t\tnext_state = ACTIVATE;\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\tend else begin\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\t\t\tsdram_ras = 1'b1;\n\t\t\t\t\t\t\tsdram_cas = 1'b0;\n\t\t\t\t\t\t\tsdram_we = 1'b0;\n\t\t\t\t\t\t\tsdram_adr_loadrow = 1'b1;\n\t\t\t\t\n\t\t\t\t\t\t\ttrack_open = bank_address_onehot;\n\t\t\t\t\t\t\treload_activate_counter = 1'b1;\n\t\t\t\t\t\t\tif(we)\n\t\t\t\t\t\t\t\tnext_state = WRITE;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tnext_state = READ;\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\tACTIVATE: begin\n\t\t\tif(precharge_done) begin\n\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\tsdram_ras = 1'b1;\n\t\t\t\tsdram_cas = 1'b0;\n\t\t\t\tsdram_we = 1'b0;\n\t\t\t\tsdram_adr_loadrow = 1'b1;\n\t\t\t\t\n\t\t\t\ttrack_open = bank_address_onehot;\n\t\t\t\treload_activate_counter = 1'b1;\n\t\t\t\tif(we)\n\t\t\t\t\tnext_state = WRITE;\n\t\t\t\telse\n\t\t\t\t\tnext_state = READ;\n\t\t\tend\n\t\tend\n\t\tREAD: begin\n\t\t\tif(activate_done) begin\n\t\t\t\tif(read_safe) begin\n\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\tsdram_ras = 1'b0;\n\t\t\t\t\tsdram_cas = 1'b1;\n\t\t\t\t\tsdram_we = 1'b0;\n\t\t\t\t\tsdram_adr_loadcol = 1'b1;\n\t\t\t\t\t\n\t\t\t\t\tread = 1'b1;\n\t\t\t\t\tack = 1'b1;\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\tWRITE: begin\n\t\t\tif(activate_done) begin\n\t\t\t\tif(write_safe) begin\n\t\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\t\tsdram_ras = 1'b0;\n\t\t\t\t\tsdram_cas = 1'b1;\n\t\t\t\t\tsdram_we = 1'b1;\n\t\t\t\t\tsdram_adr_loadcol = 1'b1;\n\t\t\t\t\t\n\t\t\t\t\twrite = 1'b1;\n\t\t\t\t\tack = 1'b1;\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\t\n\t\tPRECHARGEALL: begin\n\t\t\tif(precharge_safe == 4'b1111) begin\n\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\tsdram_ras = 1'b1;\n\t\t\t\tsdram_cas = 1'b0;\n\t\t\t\tsdram_we = 1'b1;\n\t\t\t\tsdram_adr_loadA10 = 1'b1;\n\t\n\t\t\t\treload_precharge_counter = 1'b1;\n\t\t\t\t\n\t\t\t\ttrack_close = 4'b1111;\n\t\t\t\t\n\t\t\t\tnext_state = AUTOREFRESH;\n\t\t\tend\n\t\tend\n\t\tAUTOREFRESH: begin\n\t\t\tif(precharge_done) begin\n\t\t\t\tsdram_cs = 1'b1;\n\t\t\t\tsdram_ras = 1'b1;\n\t\t\t\tsdram_cas = 1'b1;\n\t\t\t\tsdram_we = 1'b0;\n\t\t\t\treload_refresh_counter = 1'b1;\n\t\t\t\treload_autorefresh_counter = 1'b1;\n\t\t\t\tnext_state = AUTOREFRESH_WAIT;\n\t\t\tend\n\t\tend\n\t\tAUTOREFRESH_WAIT: begin\n\t\t\tif(autorefresh_done)\n\t\t\t\tnext_state = IDLE;\n\t\tend\n\t\t\n\tendcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_h__a2bb2o_1_15910329", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_h__a2bb2o_1 (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Implement AND gate functionality\n    assign X = (A1_N & A2_N) | (B1 & B2);\n\nendmodule\n\nmodule my_AND_gate (\n    X   ,\n    A1_N,\n    A2_N,\n    B1  ,\n    B2\n);\n\n    output X   ;\n    input  A1_N;\n    input  A2_N;\n    input  B1  ;\n    input  B2  ;\n\n    // Voltage supply signals\n    supply1 VPWR;\n    supply0 VGND;\n    supply1 VPB ;\n    supply0 VNB ;\n\n    // Instantiate sky130_fd_sc_h__a2bb2o_1 module\n    sky130_fd_sc_h__a2bb2o_1 AND_gate (\n        .X(X),\n        .A1_N(A1_N),\n        .A2_N(A2_N),\n        .B1(B1),\n        .B2(B2)\n    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sfifo_nto8_320107d2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sfifo_nto8 (\n        clk         ,   // clock\n        ce          ,   // clock enable\n        nrst        ,   // asyn reset\n        reset       ,   // sync reset\n        din         ,   // data input\n        dout        ,   // data output\n        rd          ,   // read\n        wr          ,   // write\n        full        ,   // fifo full\n        empty       ,   // fifo empty\n        nsin        ,   // num of shift in (bits)\n        nsout           // num of shift out (bits)\n        ) ;\n        \ninput           clk ;\ninput           ce ;\ninput           nrst ;\ninput           reset ;\ninput   [7:0]   din ;\noutput  [7:0]   dout ;\ninput           rd ;\ninput           wr ;\noutput          full ;\noutput          empty ;\ninput   [3:0]   nsin ;\ninput   [3:0]   nsout ;\n\nreg     [23:0]  buffer ;        // 24-bit buffer\nreg     [5:0]   cnt ;           // counter to record num of bits loaded into buffer\nwire    [31:0]  shift_out ;\nwire    [31:0]  shift_in ;\nwire    [5:0]   space_left ;\n\nassign dout = shift_out [31:24] ;\nassign full = (cnt + nsin) > 24 ;\nassign empty = cnt < nsout ;\n\nalways @ (posedge clk or negedge nrst)\n  if (~nrst)\n    cnt <= 0 ;\n  else if (ce)\n  begin\n    if (reset)\n      cnt <= 0 ;\n    else\n    begin\n      if (wr & rd)\n        cnt <= cnt + nsin - nsout ;\n      if (wr & ~rd)\n        cnt <= cnt + nsin ;\n      if (~wr & rd)\n        cnt <= cnt - nsout ;\n    end\n  end\n  \nassign shift_out = {8'h0, buffer} << nsout ;  \nassign space_left = rd ? 24 -cnt + nsout : 24 -cnt ;  \nassign shift_in = {24'h0, din} << space_left ;\n  \nalways @ (posedge clk or negedge nrst)\n  if (~nrst)\n    buffer <= 0 ;\n  else if (ce)\n  begin\n    if (reset)\n      buffer <= 0 ;\n    else\n    begin\n      if (wr & rd)\n        buffer <= shift_out [23:0] | shift_in [31:8] ;\n      if (wr & ~rd)\n        buffer <= buffer | shift_in [31:8] ;\n      if (~wr & rd)\n        buffer <= shift_out [23:0] ;\n    end\n  end  \n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_0798e8fc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule counter(\n    input clk,\n    input reset,\n    input up_down,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'b0;\n        end else begin\n            if (up_down) begin\n                out <= out + 4'b1;\n            end else begin\n                out <= out - 4'b1;\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__o2111ai_f8f2ab01", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_ls__o2111ai (\n    Y ,\n    A1,\n    A2,\n    B1,\n    C1,\n    D1\n);\n\n    output Y ;\n    input  A1;\n    input  A2;\n    input  B1;\n    input  C1;\n    input  D1;\n\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    or   or0   (or0_out    , A2, A1             );\n    nand nand0 (nand0_out_Y, C1, B1, D1, or0_out);\n    buf  buf0  (Y          , nand0_out_Y        );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_d58a50b8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(input clk, input [7:0] a, input [7:0] b, input [1:0] op, output [7:0] result);\n  reg [7:0] temp;\n  \n  always @ (posedge clk) begin\n    case(op)\n      2'b00: temp <= a + b; // Addition\n      2'b01: temp <= a - b; // Subtraction\n      2'b10: temp <= a * b; // Multiplication\n      2'b11: temp <= a / b; // Division\n      default: temp <= 8'b0; // Default value\n    endcase\n  end\n  \n  assign result = temp;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sram_byte_en_824efe13", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sram_byte_en\n#(\nparameter DATA_WIDTH    = 128,\nparameter ADDRESS_WIDTH = 7\n)\n(\n    input                           i_clk,\n    input      [DATA_WIDTH-1:0]     i_write_data,\n    input                           i_write_enable,\n    input      [ADDRESS_WIDTH-1:0]  i_address,\n    input      [DATA_WIDTH/8-1:0]   i_byte_enable,\n    output reg [DATA_WIDTH-1:0]     o_read_data\n);\n\n    reg [DATA_WIDTH-1:0]   mem  [0:2**ADDRESS_WIDTH-1];\n    integer i;\n\n    always @(posedge i_clk) begin\n        // read\n        o_read_data <= i_write_enable ? {DATA_WIDTH{1'd0}} : mem[i_address];\n\n        // write\n        if (i_write_enable) begin\n            for (i=0; i<DATA_WIDTH/8; i=i+1) begin\n                mem[i_address][i*8+0] <= i_byte_enable[i] ? i_write_data[i*8+0] : mem[i_address][i*8+0] ;\n                mem[i_address][i*8+1] <= i_byte_enable[i] ? i_write_data[i*8+1] : mem[i_address][i*8+1] ;\n                mem[i_address][i*8+2] <= i_byte_enable[i] ? i_write_data[i*8+2] : mem[i_address][i*8+2] ;\n                mem[i_address][i*8+3] <= i_byte_enable[i] ? i_write_data[i*8+3] : mem[i_address][i*8+3] ;\n                mem[i_address][i*8+4] <= i_byte_enable[i] ? i_write_data[i*8+4] : mem[i_address][i*8+4] ;\n                mem[i_address][i*8+5] <= i_byte_enable[i] ? i_write_data[i*8+5] : mem[i_address][i*8+5] ;\n                mem[i_address][i*8+6] <= i_byte_enable[i] ? i_write_data[i*8+6] : mem[i_address][i*8+6] ;\n                mem[i_address][i*8+7] <= i_byte_enable[i] ? i_write_data[i*8+7] : mem[i_address][i*8+7] ;\n            end\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__83ed03c4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input [7:0] d,\n    input a,\n    input b,\n    output [7:0] q\n);\n\n    // XOR gate\n    wire xor_out;\n    assign xor_out = a ^ b;\n\n    // 8-bit shift register\n    reg [7:0] shift_reg;\n    always @(posedge clk) begin\n        shift_reg <= {shift_reg[6:0], d};\n    end\n\n    // Additive functional module\n    assign q = shift_reg + xor_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_counter_1c8455dd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_counter(\n  input clk,\n  input rst,\n  output reg [3:0] count\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      count <= 4'b0;\n    end else if (count == 4'b1111) begin\n      count <= 4'b0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RCB_FRL_count_to_128_95cd1a8c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule RCB_FRL_count_to_128(clk, rst, count, ud, counter_value);\n\ninput clk, rst, count, ud;\noutput [6:0] counter_value;\n\nwire [6:0] counter_value_preserver;\nreg [6:0] counter_value;\n\nalways@(posedge clk or posedge rst)\nbegin\nif(rst == 1'b1)\n counter_value = 7'h00;\nelse\n begin\n  case({count,ud})\n   2'b00: counter_value = 7'h00;\n   2'b01: counter_value = counter_value_preserver;\n   2'b10: counter_value = counter_value_preserver - 1;\n   2'b11: counter_value = counter_value_preserver + 1;\n   default: counter_value = 7'h00;\n  endcase\n end\nend\n\nassign counter_value_preserver = counter_value;\n\nendmodule\t\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__16c541b2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input [255:0] in0,\n    input [7:0] sel0,\n    input [255:0] in1,\n    input [7:0] sel1,\n    input select,\n    output [7:0] sum\n);\n\nreg [255:0] mux_in;\nreg [7:0] mux_sel;\nwire mux_out0, mux_out1;\n\nalways @(posedge clk) begin\n    if (select) begin\n        mux_in <= in1;\n        mux_sel <= sel1;\n    end else begin\n        mux_in <= in0;\n        mux_sel <= sel0;\n    end\nend\n\nmux256to1 mux0 (.in(mux_in), .sel(mux_sel), .out(mux_out0));\nmux256to1 mux1 (.in(in1), .sel(sel1), .out(mux_out1));\n\nreg [3:0] adder_in0, adder_in1;\nalways @(posedge clk) begin\n    adder_in0 <= {4{mux_out0}};\n    adder_in1 <= {4{mux_out1}};\nend\n\nadder4bit adder (.a(adder_in0), .b(adder_in1), .sum(sum));\n\nendmodule\n\nmodule mux256to1 (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\nassign out = in[sel];\n\nendmodule\n\nmodule adder4bit (\n    input [3:0] a,\n    input [3:0] b,\n    output [7:0] sum\n);\n\nwire [4:0] tmp_sum;\n\nassign tmp_sum = a + b;\nassign sum = {tmp_sum[4], tmp_sum[3:0], 3'b0};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "PGM_c9bb4a03", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule PGM(\n\tinput CLK, RESET, IN_VALID, BUTTON,\n\tinput [1:0] MORE,\n\toutput reg OUT_VALID,\n\toutput reg [1:0] WIN,\n\toutput reg [3:0] CARD,\n\toutput reg [3:0] SUM\n);\nparameter MAXH = 10;\nparameter ST_INIT = 3'b000;\nparameter ST_FC = 3'b001;\nparameter ST_SC = 3'b010;\nparameter ST_A = 3'b011;\nparameter ST_B = 3'b100;\nparameter ST_WAIT = 3'b101;\nparameter ST_OUTPUT = 3'b110;\nparameter ST_DONE = 3'b111;\n\nreg [2:0] state, next_state;\nreg [3:0] randcard;\ninteger m_w;\nreg inIN, inBT;\nreg [1:0] inMR;\nreg [4:0] handA, handB;\n\n\nalways @(posedge CLK)\nbegin\n\tif (RESET) begin\n\t\trandcard <= 4'b0000;\n\t\tm_w <= 55332;\n\tend\n\telse begin\n\t\tm_w <= 18000 * (m_w & 65535) + (m_w >> 16);\n\t\trandcard <= ((m_w >> 4) % 8) + 1;\n\tend\nend\n\n\nalways @(posedge CLK)\nbegin\n\tif (RESET) begin\n\t\tinIN <= 1'b0;\n\t\tinBT <= 1'b0;\n\t\tinMR <= 2'bxx;\n\tend\n\telse begin\n\t\tinIN <= IN_VALID;\n\t\tinBT <= BUTTON;\n\t\tinMR <= MORE;\n\tend\n\t\t\nend\n\nalways @(posedge CLK)\nbegin\n\tif (RESET)\n\t\tstate <= ST_INIT;\n\telse\n\t\tstate <= next_state;\nend\n\nalways @(state, handA, handB, MORE, inIN, inBT, inMR, RESET)\nbegin\n\tcase (state)\n\t\tST_INIT: if (inIN && inBT) next_state = ST_FC;\n\t\t\t\telse next_state = ST_INIT;\n\t\tST_FC: next_state = ST_SC;\n\t\tST_SC: if (handA > MAXH || handB > MAXH) next_state = ST_OUTPUT;\n\t\t\telse next_state = ST_WAIT;\n\t\tST_A: if (handA > MAXH || handB > MAXH) next_state = ST_OUTPUT;\n\t\t\telse next_state = ST_WAIT;\n\t\tST_B: if (handA > MAXH || handB > MAXH) next_state = ST_OUTPUT;\n\t\t\telse next_state = ST_WAIT;\n\t\tST_WAIT: if (inIN && inBT)\n\t\t\t\tcase (inMR)\n\t\t\t\t\t2'b00: next_state = ST_OUTPUT;\n\t\t\t\t\t2'b01: next_state = ST_A;\n\t\t\t\t\t2'b10: next_state = ST_B;\n\t\t\t\t\t2'b11: next_state = ST_FC;\n\t\t\t\tendcase\n\t\t\telse next_state = ST_WAIT;\n\t\tdefault: next_state = ST_DONE;\n\tendcase\n\tif (RESET)\n\t\tnext_state = ST_INIT;\nend\n\nalways @(posedge CLK)\nbegin\n\tcase (next_state)\n\t\tST_INIT: begin\n\t\t\thandA <= 3'b000;\n\t\t\thandB <= 3'b000;\n\t\tend\n\t\tST_FC: begin\n\t\t\thandA <= handA + randcard;\n\t\tend\n\t\tST_SC: begin\n\t\t\thandB <= handB + randcard;\n\t\tend\n\t\tST_A: begin\n\t\t\thandA <= handA + randcard;\n\t\tend\n\t\tST_B: begin\n\t\t\thandB <= handB + randcard;\n\t\tend\n\tendcase\n\tif (RESET) begin\n\t\thandA <= 3'b000;\n\t\thandB <= 3'b000;\n\tend\nend\n\n\n\nalways @(posedge CLK)\nbegin\n\tcase (next_state)\n\t\tST_FC: begin\n\t\t\tOUT_VALID <= 1'b1;\n\t\t\tCARD <= randcard;\n\t\tend\n\t\tST_SC: begin\n\t\t\tCARD <= randcard;\n\t\tend\n\t\tST_A: begin\n\t\t\tOUT_VALID <= 1'b1;\n\t\t\tCARD <= randcard;\n\t\tend\n\t\tST_B: begin\n\t\t\tOUT_VALID <= 1'b1;\n\t\t\tCARD <= randcard;\n\t\tend\n\t\tST_OUTPUT: begin\n\t\t\tOUT_VALID <= 1'b1;\n\t\tend\n\t\tdefault: begin\n\t\t\tOUT_VALID <= 1'b0;\n\t\t\tCARD <= 3'b000;\n\t\tend\n\tendcase\n\tif (RESET) begin\n\t\tOUT_VALID <= 1'b0;\n\t\tCARD <= 3'b000;\n\tend\nend\n\n\n\n\nalways @(posedge CLK)\nbegin\n\tif ((handA > handB || handB > MAXH) && handA <= MAXH) begin\n\t\tWIN <= 2'b00;\n\t\tSUM <= handA;\n\tend\n\telse if ((handB > handA || handA > MAXH) && handB <= MAXH) begin\n\t\tWIN <= 2'b01;\n\t\tSUM <= handB;\n\tend\n\telse begin\n\t\tWIN <= 2'b10;\n\t\tSUM <= 4'd0;\n\tend\n\n\tif (RESET) begin\n\t\tWIN <= 2'b10;\n\t\tSUM <= 4'd0;\n\tend\nend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__0b62a65b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input [3:0] A,\n    input [3:0] B,\n    input clk,\n    input reset,\n    input enable,\n    output reg [7:0] result\n);\n\n    wire [7:0] mult_out;\n    wire [3:0] count_out;\n\n    multiplier mult_inst (\n        .A(A),\n        .B(B),\n        .result(mult_out)\n    );\n\n    counter count_inst (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .count(count_out)\n    );\n\n    always @(*) begin\n        result = mult_out + count_out;\n    end\n\nendmodule\n\nmodule multiplier (\n    input [3:0] A,\n    input [3:0] B,\n    output reg [7:0] result\n);\n\n    always @(*) begin\n        result = A * B;\n    end\n\nendmodule\n\nmodule counter (\n    input clk,\n    input reset,\n    input enable,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else if (enable) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "timer_d4b5c3ce", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule timer\n#(parameter WIDTH = 32, RANGE = 60)\n(\n    input clk_normal,\n    input clk_change_time,\n    input power,\n    input enable,\n    input reset,\n    input add_time,\n    input sub_time,\n    output reg [(WIDTH-1):0] count,\n    output reg sig_end\n);\n\n    wire true_clk;\n\n    initial begin\n        count <= 0;\n        sig_end <= 0;\n    end\n    \n    assign true_clk = (!power || reset || !enable && (add_time || sub_time)) ? clk_change_time : clk_normal;\n    \n    always @(posedge true_clk) begin\n        if (power) begin\n            if (reset) begin\n                count <= 0;\n            end else if (enable) begin\n                count = (count + 1) % RANGE;\n                \n                if (count == 0) begin\n                    sig_end = 1;\n                end else begin\n                    sig_end = 0;\n                end\n            end else if (add_time) begin\n                count <= (count + 1) % RANGE;\n            end else if (sub_time) begin\n                if (count == 0) begin\n                    count = RANGE-1;\n                end else begin\n                    count <= (count - 1);\n                end\n            end\n        end else begin\n            count <= 0;\n            sig_end <= 0;\n        end\n    end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__51234180", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input [15:0] D,\n    input [15:0] V,\n    output equal,\n    output greater,\n    output [3:0] Q_out\n);\n\nwire equal_comp, greater_comp;\nwire [15:0] Q, R;\n\nmag_comp mag_comp_inst (\n    .A(D[3:0]),\n    .B(V[3:0]),\n    .equal(equal_comp),\n    .greater(greater_comp)\n);\n\ndiv_16bit_unsigned div_inst (\n    .D(D),\n    .V(V),\n    .Q(Q),\n    .R(R)\n);\n\nfunctional_module func_mod_inst (\n    .equal(equal_comp),\n    .greater(greater_comp),\n    .Q_in(Q),\n    .Q_out(Q_out)\n);\n\nassign equal = equal_comp;\nassign greater = greater_comp;\n\nendmodule\nmodule mag_comp (\n    input [3:0] A,\n    input [3:0] B,\n    output equal,\n    output greater\n);\n\n    assign equal = (A == B);\n    assign greater = (A > B);\n\nendmodule\nmodule div_16bit_unsigned (\n    input [15:0] D,\n    input [15:0] V,\n    output [15:0] Q,\n    output [15:0] R\n);\n\n    assign Q = D / V;\n    assign R = D % V;\n\nendmodule\nmodule functional_module (\n    input equal,\n    input greater,\n    input [15:0] Q_in,\n    output reg [3:0] Q_out\n);\n\n    always @(*) begin\n        if (greater) begin\n            Q_out = Q_in[15:12];\n        end else begin\n            Q_out = Q_in[3:0];\n        end\n    end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RegGPR_48c25645", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule RegGPR(\n    \n    clock, reset,\n    regIdRs, regValRs,\n    regIdRt, regValRt,\n    regIdRm, regValRm,\n    regIdRn, regValRn,\n    regSrVal);\n\ninput clock;\ninput reset;\n\ninput[6:0] regIdRs;\ninput[6:0] regIdRt;\ninput[6:0] regIdRm;\ninput[6:0] regIdRn;\n\noutput[31:0] regValRs;\noutput[31:0] regValRt;\noutput[31:0] regValRm;\ninput[31:0] regValRn;\n\ninput[31:0] regSrVal;\n\nreg regSrRB;\nreg[31:0] tRegValRs;\nreg[31:0] tRegValRt;\nreg[31:0] tRegValRm;\n\nreg[31:0] regGprLA[7:0];\nreg[31:0] regGprLB[7:0];\nreg[31:0] regGprH[7:0];\n\nassign regValRs = tRegValRs;\nassign regValRt = tRegValRt;\nassign regValRm = tRegValRm;\n\nalways @ (clock)\nbegin\n    tRegValRs=0;\n    tRegValRt=0;\n    tRegValRm=0;\n\n    regSrRB=regSrVal[29];\n\n    if(regIdRs[6:3]==4'h0)\n    begin\n        tRegValRs=regSrRB?\n            regGprLB[regIdRs[2:0]]:\n            regGprLA[regIdRs[2:0]];\n    end\n    else if(regIdRs[6:3]==4'h1)\n    begin\n        tRegValRs=regGprH[regIdRs[2:0]];\n    end\n    else if(regIdRs[6:3]==4'h4)\n    begin\n        tRegValRs=regSrRB?\n            regGprLB[regIdRs[2:0]]:\n            regGprLA[regIdRs[2:0]];\n    end\n\n    if(regIdRt[6:3]==4'h0)\n    begin\n        tRegValRt=regSrRB?\n            regGprLB[regIdRt[2:0]]:\n            regGprLA[regIdRt[2:0]];\n    end\n    else if(regIdRt[6:3]==4'h1)\n    begin\n        tRegValRt=regGprH[regIdRt[2:0]];\n    end\n    else if(regIdRt[6:3]==4'h4)\n    begin\n        tRegValRt=regSrRB?\n            regGprLB[regIdRt[2:0]]:\n            regGprLA[regIdRt[2:0]];\n    end\n\n    if(regIdRm[6:3]==4'h0)\n    begin\n        tRegValRm=regSrRB?\n            regGprLB[regIdRm[2:0]]:\n            regGprLA[regIdRm[2:0]];\n    end\n    else if(regIdRm[6:3]==4'h1)\n    begin\n        tRegValRm=regGprH[regIdRm[2:0]];\n    end\n    else if(regIdRm[6:3]==4'h4)\n    begin\n        tRegValRm=regSrRB?\n            regGprLB[regIdRm[2:0]]:\n            regGprLA[regIdRm[2:0]];\n    end\nend\n\nalways @ (posedge clock)\nbegin\n    if(regIdRn[6:3]==4'h0)\n    begin\n        if(regSrRB)\n            regGprLB[regIdRn[2:0]] <= regValRn;\n        else\n            regGprLA[regIdRn[2:0]] <= regValRn;\n    end\n    else if(regIdRn[6:3]==4'h1)\n    begin\n        regGprH[regIdRn[2:0]] <= regValRn;\n    end\n    else if(regIdRn[6:3]==4'h4)\n    begin\n        if(regSrRB)\n            regGprLA[regIdRn[2:0]] <= regValRn;\n        else\n            regGprLB[regIdRn[2:0]] <= regValRn;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "wb_mcb_32_83ef75bc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule wb_mcb_32\n(\n    input  wire        clk,\n    input  wire        rst,\n\n    \n    input  wire [31:0] wb_adr_i,     // ADR_I() address input\n    input  wire [31:0] wb_dat_i,     // DAT_I() data in\n    output wire [31:0] wb_dat_o,     // DAT_O() data out\n    input  wire        wb_we_i,      // WE_I write enable input\n    input  wire [3:0]  wb_sel_i,     // SEL_I() select input\n    input  wire        wb_stb_i,     // STB_I strobe input\n    output wire        wb_ack_o,     // ACK_O acknowledge output\n    input  wire        wb_cyc_i,     // CYC_I cycle input\n\n    \n    output wire        mcb_cmd_clk,\n    output wire        mcb_cmd_en,\n    output wire [2:0]  mcb_cmd_instr,\n    output wire [5:0]  mcb_cmd_bl,\n    output wire [31:0] mcb_cmd_byte_addr,\n    input  wire        mcb_cmd_empty,\n    input  wire        mcb_cmd_full,\n    output wire        mcb_wr_clk,\n    output wire        mcb_wr_en,\n    output wire [3:0]  mcb_wr_mask,\n    output wire [31:0] mcb_wr_data,\n    input  wire        mcb_wr_empty,\n    input  wire        mcb_wr_full,\n    input  wire        mcb_wr_underrun,\n    input  wire [6:0]  mcb_wr_count,\n    input  wire        mcb_wr_error,\n    output wire        mcb_rd_clk,\n    output wire        mcb_rd_en,\n    input  wire [31:0] mcb_rd_data,\n    input  wire        mcb_rd_empty,\n    input  wire        mcb_rd_full,\n    input  wire        mcb_rd_overflow,\n    input  wire [6:0]  mcb_rd_count,\n    input  wire        mcb_rd_error\n);\n\nreg cycle_reg = 0;\n\nreg [31:0] wb_dat_reg = 0;\nreg wb_ack_reg = 0;\n\nreg mcb_cmd_en_reg = 0;\nreg mcb_cmd_instr_reg = 0;\nreg mcb_wr_en_reg = 0;\nreg [3:0] mcb_wr_mask_reg = 0;\n\nassign wb_dat_o = wb_dat_reg;\nassign wb_ack_o = wb_ack_reg;\n\nassign mcb_cmd_clk = clk;\nassign mcb_cmd_en = mcb_cmd_en_reg;\nassign mcb_cmd_instr = mcb_cmd_instr_reg;\nassign mcb_cmd_bl = 0;\nassign mcb_cmd_byte_addr = wb_adr_i;\nassign mcb_wr_clk = clk;\nassign mcb_wr_en = mcb_wr_en_reg;\nassign mcb_wr_mask = mcb_wr_mask_reg;\nassign mcb_wr_data = wb_dat_i;\nassign mcb_rd_clk = clk;\nassign mcb_rd_en = 1;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        cycle_reg <= 0;\n        mcb_cmd_en_reg <= 0;\n        mcb_cmd_instr_reg <= 0;\n        mcb_wr_en_reg <= 0;\n    end else begin\n        wb_ack_reg <= 0;\n        mcb_cmd_en_reg <= 0;\n        mcb_cmd_instr_reg <= 0;\n        mcb_wr_en_reg <= 0;\n\n        if (cycle_reg) begin\n            if (~mcb_rd_empty) begin\n                cycle_reg <= 0;\n                wb_dat_reg <= mcb_rd_data;\n                wb_ack_reg <= 1;\n            end\n        end else if (wb_cyc_i & wb_stb_i & ~wb_ack_o) begin\n            if (wb_we_i) begin\n                mcb_cmd_instr_reg <= 3'b000;\n                mcb_cmd_en_reg <= 1;\n                mcb_wr_en_reg <= 1;\n                mcb_wr_mask_reg <= ~wb_sel_i;\n                wb_ack_reg <= 1;\n            end else begin\n                mcb_cmd_instr_reg <= 3'b001;\n                mcb_cmd_en_reg <= 1;\n                cycle_reg <= 1;\n            end\n        end\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_eedee02c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_counter (\n    input clk,\n    input up_down,\n    input load,\n    input [2:0] D,\n    output reg [2:0] Q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            Q <= D;\n        end else if (!up_down) begin\n            Q <= Q;\n        end else if (up_down) begin\n            Q <= Q + 1;\n        end else begin\n            Q <= Q - 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top_module_e2c98961", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module(\n    input signed [31:0] a,\n    input signed [31:0] b,\n    output signed [63:0] product\n);\n\n    wire signed [15:0] stage1_out;\n    wire signed [15:0] stage2_out;\n    wire signed [15:0] stage3_out;\n    wire signed [15:0] stage4_out;\n\n    // instantiate four 8-bit multiplication modules\n    mult8bit mult1(.a(a[7:0]), .b(b[7:0]), .product(stage1_out[15:0]));\n    mult8bit mult2(.a(a[15:8]), .b(b[15:8]), .product(stage2_out[15:0]));\n    mult8bit mult3(.a(a[23:16]), .b(b[23:16]), .product(stage3_out[15:0]));\n    mult8bit mult4(.a(a[31:24]), .b(b[31:24]), .product(stage4_out[15:0]));\n\n    // pipeline structure\n    reg signed [15:0] stage1_reg;\n    reg signed [15:0] stage2_reg;\n    reg signed [15:0] stage3_reg;\n    reg signed [15:0] stage4_reg;\n\n    always @(*) begin\n        stage1_reg = stage1_out;\n    end\n\n    always @(*) begin\n        stage2_reg = stage2_out;\n    end\n\n    always @(*) begin\n        stage3_reg = stage3_out;\n    end\n\n    always @(*) begin\n        stage4_reg = stage4_out;\n    end\n\n    assign product = {stage4_reg, stage3_reg, stage2_reg, stage1_reg};\n\nendmodule\nmodule mult8bit(\n    input signed [7:0] a,\n    input signed [7:0] b,\n    output signed [15:0] product\n);\n\n    assign product = a * b;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__111f840c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule top_module (\n    input signed [15:0] in1, // First 16-bit signed integer input\n    input signed [15:0] in2, // Second 16-bit signed integer input\n    output reg signed [15:0] sum_out, // 16-bit signed sum output\n    input [15:0] absolute_in, // Input for absolute_value module\n    output reg [15:0] max_out // 16-bit unsigned output from functional module\n);\n\n// Declare internal wires\nwire [2:0] priority_input;\n\n// Calculate sum of in1 and in2\nalways @* begin\n    sum_out = in1 + in2;\nend\n\n// Assign priority encoder input\nassign priority_input = {sum_out[15], absolute_in[15], sum_out[14:0] > absolute_in[14:0]};\n\n// Use a case statement to determine max value\nalways @* begin\n    case (priority_input)\n        3'b000: max_out = 16'b0000000000000001;\n        3'b001: max_out = 16'b0000000000000010;\n        3'b010: max_out = 16'b0000000000000100;\n        3'b011: max_out = 16'b0000000000001000;\n        3'b100: max_out = 16'b0000000000010000;\n        3'b101: max_out = 16'b0000000000100000;\n        3'b110: max_out = 16'b0000000001000000;\n        3'b111: max_out = 16'b0000000010000000;\n        default: max_out = 16'b0000000000000000;\n    endcase\nend\n\nendmodule\n\nmodule absolute_value (\n    input signed [15:0] in,\n    output reg [15:0] out\n);\n\nalways @* begin\n    if (in < 0) begin\n        out = ~in + 1;\n    end\n    else begin\n        out = in;\n    end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "gtwizard_ultrascale_v1_7_1_bit_synchronizer #_1f0059f8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule gtwizard_ultrascale_v1_7_1_bit_synchronizer # (\n\n  parameter INITIALIZE = 5'b00000,\n  parameter FREQUENCY  = 512\n\n)(\n\n  input  wire clk_in,\n  input  wire i_in,\n  output wire o_out\n\n);\n\n  // Use 5 flip-flops as a single synchronizer, and tag each declaration with the appropriate synthesis attribute to\n  // enable clustering. Their GSR default values are provided by the INITIALIZE parameter.\n\n   reg i_in_meta  = INITIALIZE[0];\n   reg i_in_sync1 = INITIALIZE[1];\n   reg i_in_sync2 = INITIALIZE[2];\n   reg i_in_sync3 = INITIALIZE[3];\n                           reg i_in_out   = INITIALIZE[4];\n\n  always @(posedge clk_in) begin\n    i_in_meta  <= i_in;\n    i_in_sync1 <= i_in_meta;\n    i_in_sync2 <= i_in_sync1;\n    i_in_sync3 <= i_in_sync2;\n    i_in_out   <= i_in_sync3;\n  end\n\n  assign o_out = i_in_out;\n\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_ones_complement_2db3ed22", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_ones_complement (\n    input [3:0] B,\n    output reg [3:0] C\n);\n\n    always @ (B) begin\n        C <= ~B;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_7x_v1_8_gtp_pipe_rate #_a18afc57", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule pcie_7x_v1_8_gtp_pipe_rate #\n(\n\n    parameter TXDATA_WAIT_MAX   = 4'd15                     )\n\n(\n\n    input               RATE_CLK,\n    input               RATE_RST_N,\n    input               RATE_RST_IDLE,\n    input       [ 1:0]  RATE_RATE_IN,\n    input               RATE_TXRATEDONE,\n    input               RATE_RXRATEDONE,\n    input               RATE_TXSYNC_DONE,\n    input               RATE_PHYSTATUS,\n    \n    output              RATE_PCLK_SEL,\n    output      [ 2:0]  RATE_RATE_OUT,\n    output              RATE_TXSYNC_START,\n    output              RATE_DONE,\n    output              RATE_IDLE,\n    output      [23:0]  RATE_FSM\n\n);\n\n    reg                 rst_idle_reg1;\n    reg         [ 1:0]  rate_in_reg1;\n    reg                 txratedone_reg1;\n    reg                 rxratedone_reg1;\n    reg                 phystatus_reg1;\n    reg                 txsync_done_reg1;\n    \n    reg                 rst_idle_reg2;\n    reg         [ 1:0]  rate_in_reg2;\n    reg                 txratedone_reg2;\n    reg                 rxratedone_reg2;\n    reg                 phystatus_reg2;\n    reg                 txsync_done_reg2;\n    \n    wire                pll_lock;\n    wire        [ 2:0]  rate;\n    reg         [ 3:0]  txdata_wait_cnt = 4'd0;\n    reg                 txratedone      = 1'd0;\n    reg                 rxratedone      = 1'd0;\n    reg                 phystatus       = 1'd0;\n    reg                 ratedone        = 1'd0;\n    \n    reg                 pclk_sel   =  1'd0; \n    reg         [ 2:0]  rate_out   =  3'd0; \n    reg         [7:0]   fsm        =  8'd0;                 \n   \n    localparam          FSM_IDLE             = 8'b00000001; \n    localparam          FSM_TXDATA_WAIT      = 8'b00000010;           \n    localparam          FSM_PCLK_SEL         = 8'b00000100;   \n    localparam          FSM_RATE_SEL         = 8'b00001000;\n    localparam          FSM_RATE_DONE        = 8'b00010000;\n    localparam          FSM_TXSYNC_START     = 8'b00100000;\n    localparam          FSM_TXSYNC_DONE      = 8'b01000000;             \n    localparam          FSM_DONE             = 8'b10000000; always @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin    \n        rst_idle_reg1       <= 1'd0;   \n        rate_in_reg1        <= 2'd0;\n        txratedone_reg1     <= 1'd0;\n        rxratedone_reg1     <= 1'd0;\n        phystatus_reg1      <= 1'd0;\n        txsync_done_reg1    <= 1'd0;\n        rst_idle_reg2       <= 1'd0;\n        rate_in_reg2        <= 2'd0;\n        txratedone_reg2     <= 1'd0;\n        rxratedone_reg2     <= 1'd0;\n        phystatus_reg2      <= 1'd0;\n        txsync_done_reg2    <= 1'd0;\n        end\n    else\n        begin  \n        rst_idle_reg1       <= RATE_RST_IDLE;\n        rate_in_reg1        <= RATE_RATE_IN;\n        txratedone_reg1     <= RATE_TXRATEDONE;\n        rxratedone_reg1     <= RATE_RXRATEDONE;\n        phystatus_reg1      <= RATE_PHYSTATUS;\n        txsync_done_reg1    <= RATE_TXSYNC_DONE;\n        rst_idle_reg2       <= rst_idle_reg1;\n        rate_in_reg2        <= rate_in_reg1;\n        txratedone_reg2     <= txratedone_reg1;\n        rxratedone_reg2     <= rxratedone_reg1;\n        phystatus_reg2      <= phystatus_reg1;\n        txsync_done_reg2    <= txsync_done_reg1;   \n        end\n        \nend    \n\n\n\n\n\n\nassign rate = (rate_in_reg2 == 2'd1) ? 3'd1 : 3'd0;\n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        txdata_wait_cnt <= 4'd0;\n    else\n    \n        if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt < TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt + 4'd1;\n            \n        else if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt == TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt;\n            \n        else\n            txdata_wait_cnt <= 4'd0;\n        \nend \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin   \n        txratedone <= 1'd0;\n        rxratedone <= 1'd0; \n        phystatus  <= 1'd0;\n        ratedone   <= 1'd0;\n        end\n    else\n        begin  \n\n        if (fsm == FSM_RATE_DONE)\n        \n            begin\n            \n            if (txratedone_reg2)\n                txratedone <= 1'd1; \n            else\n                txratedone <= txratedone;\n \n            if (rxratedone_reg2)\n                rxratedone <= 1'd1; \n            else\n                rxratedone <= rxratedone;\n  \n            if (phystatus_reg2)\n                phystatus <= 1'd1; \n            else\n                phystatus <= phystatus;\n  \n            if (rxratedone && txratedone && phystatus)\n                ratedone <= 1'd1; \n            else\n                ratedone <= ratedone;\n  \n            end\n  \n        else \n        \n            begin\n            txratedone <= 1'd0;\n            rxratedone <= 1'd0;\n            phystatus  <= 1'd0;\n            ratedone   <= 1'd0;\n            end\n        \n        end\n        \nend    \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin\n        fsm        <= FSM_IDLE;\n        pclk_sel   <= 1'd0; \n        rate_out   <= 3'd0;                              \n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (rate_in_reg2 != rate_in_reg1)\n                begin\n                fsm        <=  FSM_TXDATA_WAIT;\n                pclk_sel   <= pclk_sel;\n                rate_out   <= rate_out;\n                end\n            else\n                begin\n                fsm        <= FSM_IDLE;\n                pclk_sel   <= pclk_sel;\n                rate_out   <= rate_out;\n                end\n            end \n        FSM_TXDATA_WAIT :\n        \n            begin\n            fsm        <= (txdata_wait_cnt == TXDATA_WAIT_MAX) ? FSM_PCLK_SEL : FSM_TXDATA_WAIT;\n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate_out;\n            end \n\n        FSM_PCLK_SEL :\n        \n            begin\n            fsm        <= FSM_RATE_SEL;    \n            pclk_sel   <= (rate_in_reg2 == 2'd1);\n            rate_out   <= rate_out;\n            end\n\n        FSM_RATE_SEL :\n        \n            begin\n            fsm        <= FSM_RATE_DONE;\n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate;                             end    \n            \n        FSM_RATE_DONE :\n        \n            begin\n            if (ratedone ) \n                    fsm <= FSM_TXSYNC_START;\n            else      \n                    fsm <= FSM_RATE_DONE;\n            \n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate_out;\n            end      \n            \n        FSM_TXSYNC_START:\n        \n            begin\n            fsm        <= (!txsync_done_reg2 ? FSM_TXSYNC_DONE : FSM_TXSYNC_START);\n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate_out;\n            end\n            \n        FSM_TXSYNC_DONE:\n        \n            begin\n            fsm        <= (txsync_done_reg2 ? FSM_DONE : FSM_TXSYNC_DONE);\n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate_out;\n            end        \n\n        FSM_DONE :  \n          \n            begin  \n            fsm        <= FSM_IDLE;\n            pclk_sel   <= pclk_sel;\n            rate_out   <= rate_out;\n            end\n               \n        default :\n        \n            begin\n            fsm        <= FSM_IDLE;\n            pclk_sel   <= 1'd0; \n            rate_out   <= 3'd0;  \n            end\n\n        endcase\n        \n        end\n        \nend \n\n\n\nassign RATE_PCLK_SEL        = pclk_sel;\nassign RATE_RATE_OUT        = rate_out;\nassign RATE_TXSYNC_START    = (fsm == FSM_TXSYNC_START);\nassign RATE_DONE            = (fsm == FSM_DONE);\nassign RATE_IDLE            = (fsm == FSM_IDLE);\nassign RATE_FSM             = fsm;   \n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux_8to1_bd27451c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux_8to1 (\n  input [3:0] sel,\n  input [7:0] a,\n  input [7:0] b,\n  input [7:0] c,\n  input [7:0] d,\n  output reg [7:0] mux_out\n);\n\nalways @ (*) begin\n  case(sel)\n    4'b0000: mux_out = a;\n    4'b0001: mux_out = b;\n    4'b0010: mux_out = c;\n    4'b0011: mux_out = d;\n    4'b0100: mux_out = a;\n    4'b0101: mux_out = b;\n    4'b0110: mux_out = c;\n    4'b0111: mux_out = d;\n    4'b1000: mux_out = a;\n    4'b1001: mux_out = b;\n    4'b1010: mux_out = c;\n    4'b1011: mux_out = d;\n    4'b1100: mux_out = a;\n    4'b1101: mux_out = b;\n    4'b1110: mux_out = c;\n    4'b1111: mux_out = d;\n  endcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_subtractor_093799d0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_subtractor(output reg [3:0] SUM, output reg C_OUT, input [3:0] A, input [3:0] B, input SUB);\n\n\treg [4:0] temp;\n\t\n\talways @(*) begin\n\t\tif(SUB == 0) begin\n\t\t\ttemp = A + B;\n\t\t\tSUM = temp;\n\t\t\tC_OUT = (temp[4] == 1) ? 1 : 0;\n\t\tend\n\t\telse begin\n\t\t\ttemp = A - B;\n\t\t\tSUM = temp;\n\t\t\tC_OUT = (temp[4] == 1) ? 1 : 0;\n\t\tend\n\tend\n\t\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "csrbrg_e28efd83", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule csrbrg(\n\tinput sys_clk,\n\tinput sys_rst,\n\t\n\t\n\tinput [31:0] wb_adr_i,\n\tinput [31:0] wb_dat_i,\n\toutput reg [31:0] wb_dat_o,\n\tinput wb_cyc_i,\n\tinput wb_stb_i,\n\tinput wb_we_i,\n\toutput reg wb_ack_o,\n\t\n\t\n\toutput reg [13:0] csr_a,\n\toutput reg csr_we,\n\toutput reg [31:0] csr_do,\n\tinput [31:0] csr_di\n);\n\n\nalways @(posedge sys_clk) begin\n\twb_dat_o <= csr_di;\nend\n\n\nreg next_csr_we;\nalways @(posedge sys_clk) begin\n\tcsr_a <= wb_adr_i[15:2];\n\tcsr_we <= next_csr_we;\n\tcsr_do <= wb_dat_i;\nend\n\n\n\nreg [1:0] state;\nreg [1:0] next_state;\n\nparameter IDLE\t\t= 2'd0;\nparameter DELAYACK1\t= 2'd1;\nparameter DELAYACK2\t= 2'd2;\nparameter ACK\t\t= 2'd3;\n\nalways @(posedge sys_clk) begin\n\tif(sys_rst)\n\t\tstate <= IDLE;\n\telse\n\t\tstate <= next_state;\nend\n\nalways @(*) begin\n\tnext_state = state;\n\t\n\twb_ack_o = 1'b0;\n\tnext_csr_we = 1'b0;\n\t\n\tcase(state)\n\t\tIDLE: begin\n\t\t\tif(wb_cyc_i & wb_stb_i) begin\n\t\t\t\t\n\t\t\t\tnext_csr_we = wb_we_i;\n\t\t\t\tif(wb_we_i)\n\t\t\t\t\tnext_state = ACK;\n\t\t\t\telse\n\t\t\t\t\tnext_state = DELAYACK1;\n\t\t\tend\n\t\tend\n\t\tDELAYACK1: next_state = DELAYACK2;\n\t\tDELAYACK2: next_state = ACK;\n\t\tACK: begin\n\t\t\twb_ack_o = 1'b1;\n\t\t\tnext_state = IDLE;\n\t\tend\n\tendcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pipeline_c8a95260", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule pipeline (\n  input clk,\n  input reset,\n  input [15:0] instruction,\n  input [2:0] reg1_addr,\n  input [2:0] reg2_addr,\n  input [2:0] reg3_addr,\n  input [15:0] reg1_data,\n  input [15:0] reg2_data,\n  input [15:0] reg3_data,\n  output reg [15:0] reg1_out,\n  output reg [15:0] reg2_out,\n  output reg [15:0] reg3_out\n);\n\nreg [15:0] inst1, inst2, inst3;\nreg [2:0] reg1_addr1, reg2_addr1, reg3_addr1;\nreg [2:0] reg1_addr2, reg2_addr2, reg3_addr2;\nreg [2:0] reg1_addr3, reg2_addr3, reg3_addr3;\nreg [15:0] reg1_data1, reg2_data1, reg3_data1;\nreg [15:0] reg1_data2, reg2_data2, reg3_data2;\nreg [15:0] reg1_data3, reg2_data3, reg3_data3;\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    inst1 <= 16'h0;\n    inst2 <= 16'h0;\n    inst3 <= 16'h0;\n    reg1_addr1 <= 3'b0;\n    reg2_addr1 <= 3'b0;\n    reg3_addr1 <= 3'b0;\n    reg1_data1 <= 16'h0;\n    reg2_data1 <= 16'h0;\n    reg3_data1 <= 16'h0;\n  end else begin\n    inst1 <= instruction;\n    inst2 <= inst1;\n    inst3 <= inst2;\n    reg1_addr1 <= reg1_addr;\n    reg2_addr1 <= reg2_addr;\n    reg3_addr1 <= reg3_addr;\n    reg1_data1 <= reg1_data;\n    reg2_data1 <= reg2_data;\n    reg3_data1 <= reg3_data;\n  end\nend\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    reg1_addr2 <= 3'b0;\n    reg2_addr2 <= 3'b0;\n    reg3_addr2 <= 3'b0;\n    reg1_data2 <= 16'h0;\n    reg2_data2 <= 16'h0;\n    reg3_data2 <= 16'h0;\n  end else begin\n    reg1_addr2 <= reg1_addr1;\n    reg2_addr2 <= reg2_addr1;\n    reg3_addr2 <= reg3_addr1;\n    reg1_data2 <= reg1_data1;\n    reg2_data2 <= reg2_data1;\n    reg3_data2 <= reg3_data1;\n  end\nend\n\nalways @(posedge clk or posedge reset) begin\n  if (reset) begin\n    reg1_addr3 <= 3'b0;\n    reg2_addr3 <= 3'b0;\n    reg3_addr3 <= 3'b0;\n    reg1_data3 <= 16'h0;\n    reg2_data3 <= 16'h0;\n    reg3_data3 <= 16'h0;\n  end else begin\n    reg1_addr3 <= reg1_addr2;\n    reg2_addr3 <= reg2_addr2;\n    reg3_addr3 <= reg3_addr2;\n    reg1_data3 <= reg1_data2;\n    reg2_data3 <= reg2_data2;\n    reg3_data3 <= reg3_data2;\n\n    case (inst3[15:13])\n      3'b000: reg1_out <= reg1_data3 + reg2_data3;\n      3'b001: reg1_out <= reg1_data3 - reg2_data3;\n      3'b010: reg1_out <= reg1_data3 & reg2_data3;\n      3'b011: reg1_out <= reg1_data3 | reg2_data3;\n      3'b100: reg1_out <= reg1_data3 ^ reg2_data3;\n    endcase\n\n    case (inst2[15:13])\n      3'b000: reg2_out <= reg2_data3 + reg3_data3;\n      3'b001: reg2_out <= reg2_data3 - reg3_data3;\n      3'b010: reg2_out <= reg2_data3 & reg3_data3;\n      3'b011: reg2_out <= reg2_data3 | reg3_data3;\n      3'b100: reg2_out <= reg2_data3 ^ reg3_data3;\n    endcase\n\n    case (inst1[15:13])\n      3'b000: reg3_out <= reg3_data3 + reg1_data3;\n      3'b001: reg3_out <= reg3_data3 - reg1_data3;\n      3'b010: reg3_out <= reg3_data3 & reg1_data3;\n      3'b011: reg3_out <= reg3_data3 | reg1_data3;\n      3'b100: reg3_out <= reg3_data3 ^ reg1_data3;\n    endcase\n  end\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_ls__o21ai_f9d8d1a2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sky130_fd_sc_ls__o21ai (\n    //# {{data|Data Signals}}\n    input  A1  ,\n    input  A2  ,\n    input  B1  ,\n    output Y   ,\n\n    //# {{power|Power}}\n    input  VPB ,\n    input  VPWR,\n    input  VGND,\n    input  VNB\n);\n\n    assign Y = (A1 ^ A2) ? ~B1 : (A1 & A2) ? B1 : A1 & A2;\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_tree_top_43d620e2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n`define ADDER_WIDTH 018\n`define DUMMY_WIDTH 128\n\n`define 2_LEVEL_ADDER\n\nmodule adder_tree_top (\n\tclk,\n\tisum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1,\n\tsum,\n);\n\tinput clk;\n\tinput [`ADDER_WIDTH+0-1:0] isum0_0_0_0, isum0_0_0_1, isum0_0_1_0, isum0_0_1_1, isum0_1_0_0, isum0_1_0_1, isum0_1_1_0, isum0_1_1_1;\n\toutput [`ADDER_WIDTH  :0] sum;\n\treg    [`ADDER_WIDTH  :0] sum;\n\n\twire [`ADDER_WIDTH+3-1:0] sum0;\n\twire [`ADDER_WIDTH+2-1:0] sum0_0, sum0_1;\n\twire [`ADDER_WIDTH+1-1:0] sum0_0_0, sum0_0_1, sum0_1_0, sum0_1_1;\n\treg  [`ADDER_WIDTH+0-1:0] sum0_0_0_0, sum0_0_0_1, sum0_0_1_0, sum0_0_1_1, sum0_1_0_0, sum0_1_0_1, sum0_1_1_0, sum0_1_1_1;\n\n\tadder_tree_branch L1_0(sum0_0,     sum0_1,     sum0    );\n\tdefparam L1_0.EXTRA_BITS = 2;\n\n\tadder_tree_branch L2_0(sum0_0_0,   sum0_0_1,   sum0_0  );\n\tadder_tree_branch L2_1(sum0_1_0,   sum0_1_1,   sum0_1  );\n\tdefparam L2_0.EXTRA_BITS = 1;\n\tdefparam L2_1.EXTRA_BITS = 1;\n\n\tadder_tree_branch L3_0(sum0_0_0_0, sum0_0_0_1, sum0_0_0);\n\tadder_tree_branch L3_1(sum0_0_1_0, sum0_0_1_1, sum0_0_1);\n\tadder_tree_branch L3_2(sum0_1_0_0, sum0_1_0_1, sum0_1_0);\n\tadder_tree_branch L3_3(sum0_1_1_0, sum0_1_1_1, sum0_1_1);\n\tdefparam L3_0.EXTRA_BITS = 0;\n\tdefparam L3_1.EXTRA_BITS = 0;\n\tdefparam L3_2.EXTRA_BITS = 0;\n\tdefparam L3_3.EXTRA_BITS = 0;\n\n\talways @(posedge clk) begin\n\t\tsum0_0_0_0 <= isum0_0_0_0;\n\t\tsum0_0_0_1 <= isum0_0_0_1;\n\t\tsum0_0_1_0 <= isum0_0_1_0;\n\t\tsum0_0_1_1 <= isum0_0_1_1;\n\t\tsum0_1_0_0 <= isum0_1_0_0;\n\t\tsum0_1_0_1 <= isum0_1_0_1;\n\t\tsum0_1_1_0 <= isum0_1_1_0;\n\t\tsum0_1_1_1 <= isum0_1_1_1;\n\n\t\t`ifdef 3_LEVEL_ADDER\n\t\t\tsum <= sum0;\n\t\t`endif\n\t\t`ifdef 2_LEVEL_ADDER\n\t\t\tsum <= sum0_0;\n\t\t`endif\n\tend\n\nendmodule\n\nmodule adder_tree_branch(a,b,sum);\n\tparameter EXTRA_BITS = 0;\n\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] a;\n\tinput [`ADDER_WIDTH+EXTRA_BITS-1:0] b;\n\toutput [`ADDER_WIDTH+EXTRA_BITS:0] sum;\n\n\tassign sum = a + b;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_1269c7ae", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule shift_register(\n    input clk,\n    input areset,  // async active-high reset to zero\n    input load,\n    input ena,\n    input [3:0] data,\n    output [3:0] q);\n\n    reg [3:0] q1, q2, q3, q4;\n\n    always @(posedge clk) begin\n        if (areset) begin\n            q1 <= 4'b0;\n            q2 <= 4'b0;\n            q3 <= 4'b0;\n            q4 <= 4'b0;\n        end else begin\n            if (load && ena) begin\n                q1 <= data;\n                q2 <= 4'b0;\n                q3 <= 4'b0;\n                q4 <= 4'b0;\n            end else if (load) begin\n                q1 <= data;\n            end else if (ena) begin\n                q1 <= q2;\n                q2 <= q3;\n                q3 <= q4;\n                q4 <= 4'b0;\n            end\n        end\n    end\n\n    assign q = {q4, q3, q2, q1}; // Fix the output order to match the RTL\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "delay_module_a6b5585b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule delay_module(\n    input input_signal,\n    input [1:0] delay_amount,\n    input clk,\n    output reg output_signal\n);\n\nreg [3:0] delay_counter;\n\nalways @(posedge clk) begin\n    if(delay_amount == 0) begin\n        delay_counter <= 1;\n    end else if(delay_amount == 1) begin\n        delay_counter <= 2;\n    end else begin\n        delay_counter <= 4;\n    end\n    \n    if(delay_counter == 1) begin\n        output_signal <= input_signal;\n    end else if(delay_counter > 1) begin\n        output_signal <= 0;\n    end\n    \n    delay_counter <= delay_counter - 1;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_3to8_2911511c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_3to8 (\n    input [2:0] in,\n    output [7:0] out\n);\n\nassign out[0] = ~(in[2] | in[1] | in[0]);\nassign out[1] = ~(in[2] | in[1] | ~in[0]);\nassign out[2] = ~(in[2] | ~in[1] | in[0]);\nassign out[3] = ~(in[2] | ~in[1] | ~in[0]);\nassign out[4] = ~(~in[2] | in[1] | in[0]);\nassign out[5] = ~(~in[2] | in[1] | ~in[0]);\nassign out[6] = ~(~in[2] | ~in[1] | in[0]);\nassign out[7] = ~(~in[2] | ~in[1] | ~in[0]);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "decoder_4to16_45cfc24c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule decoder_4to16 (\n    input [1:0] A, B,\n    input EN,\n    output reg [15:0] Y\n);\n\nalways @ (A or B or EN) begin\n    case ({A,B})\n        2'b00: Y = EN ? 16'b1111111111111110 : 16'b1111111111111111;\n        2'b01: Y = EN ? 16'b1111111111111101 : 16'b1111111111111111;\n        2'b10: Y = EN ? 16'b1111111111111011 : 16'b1111111111111111;\n        2'b11: Y = EN ? 16'b1111111111110111 : 16'b1111111111111111;\n        default: Y = 16'b1111111111111111;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "LCD_7639fd3e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule LCD(\n    input clk,\n    input rst, input en,\n    input reset, input set,\n    input clear,\n    input off,\n    input on,\n    input entry_mode,\n    input cursor,\n    input w_char,\n\t input [7:0] cursor_pos,\n\t input [7:0] ascii_char,\n\t output reg busy,\n\t \n    input int_cnt,\n    output reg [15:0] limit_cnt,\n    output reg en_cnt,\n\t \n    output reg rs,\n    output reg e,\n    output reg [7:0] data\n    );\n\t \n\t reg rs_d;\n\t reg [5:0] state;\n\t reg [7:0] data_d; \n\t \n\t localparam f_rst\t\t= 0,\n\t\t\t\t\tf_idle\t= 1,\n\t\t\t\t\tf_reset\t= 2,\n\t\t\t\t\tf_set\t\t= 3,\n\t\t\t\t\tf_clear\t= 4,\n\t\t\t\t\tf_off\t\t= 5,\n\t\t\t\t\tf_on\t\t= 6,\n\t\t\t\t\tf_entry\t= 7,\n\t\t\t\t\tf_cursor\t= 8,\n\t\t\t\t\tf_w_char\t= 9;\n\t localparam res_data \t= 10;\n\t localparam set_data\t\t= 11;\n\t localparam clear_data\t= 12;\n\t localparam off_data\t\t= 13;\n\t localparam on_data\t\t= 14;\n\t localparam entry_data\t= 15;\n\t localparam cursor_data\t= 16;\n\t localparam write_data\t= 17;\n\t localparam lcd_en\t\t= 18,\n\t\t\t\t\tlcd_del_1\t= 19,\n\t\t\t\t\tlcd_dis\t\t= 20,\n\t\t\t\t\tlcd_del_200\t= 21;\n\t \n\t always@(posedge clk) begin\n\t\tif(rst) state <= f_rst;\n\t\telse begin\n\t\t\tcase(state)\n\t\t\tf_rst: state <= f_idle;\n\t\t\t\n\t\t\tf_idle: begin\n\t\t\t\tif(en) begin\n\t\t\t\t\tif(reset)\t\t\t\tstate <= f_reset;\n\t\t\t\t\telse if(set) \t\t\tstate <= f_set;\n\t\t\t\t\telse if(clear)\t\t\tstate <= f_clear;\n\t\t\t\t\telse if(off) \t\t\tstate <= f_off;\n\t\t\t\t\telse if(on) \t\t\tstate <= f_on;\n\t\t\t\t\telse if(entry_mode) \tstate <= f_entry;\n\t\t\t\t\telse if(cursor) \t\tstate <= f_cursor;\n\t\t\t\t\telse if(w_char) \t\tstate <= f_w_char;\n\t\t\t\t\telse \t\t\t\t\t\tstate <= f_idle;\n\t\t\t\tend else state <= f_idle;\n\t\t\tend\n\t\t\t\n\t\t\tf_reset: state <= res_data;\n\t\t\t\n\t\t\tres_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\t\t\t\t\t\t\n\t\t\tf_set: state <= set_data;\n\t\t\t\n\t\t\tset_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\t\t\t\n\t\t\t\n\t\t\tf_clear: state <= clear_data;\n\t\t\t\n\t\t\tclear_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tf_off: state <= off_data;\n\t\t\t\n\t\t\toff_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tf_on: state <= on_data;\n\t\t\t\n\t\t\ton_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tf_entry: state <= entry_data;\n\t\t\t\n\t\t\tentry_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tf_cursor: state <= cursor_data;\n\t\t\t\n\t\t\tcursor_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tf_w_char: state <= write_data;\n\t\t\t\n\t\t\twrite_data: state <= lcd_en;\n\t\t\t\n\t\t\tlcd_en: state <= lcd_del_1;\n\t\t\t\n\t\t\tlcd_del_1: begin\n\t\t\t\tif(int_cnt)\tstate <= lcd_dis;\n\t\t\t\telse state <= lcd_del_1;\n\t\t\tend\n\t\t\t\n\t\t\tlcd_dis: state <= lcd_del_200;\n\t\t\t\n\t\t\tlcd_del_200: begin\n\t\t\t\tif(int_cnt) state <= f_idle;\n\t\t\t\telse state <= lcd_del_200;\n\t\t\tend\n\t\t\t\n\t\t\tdefault: state <= f_rst;\n\t\t\t\n\t\t\tendcase\n\t\tend\n\t end\n\t \n\t always@(*) begin\n\t\tcase(state)\n\t\t\tf_rst: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_idle: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 0; end\n\t\t\tf_reset: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_set: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_clear: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_off: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_on: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_entry: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_cursor: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tf_w_char: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 1;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 0;\n\t\t\t\tbusy\t\t\t<= 1;\n\t\t\tend\n\t\t\tres_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h30;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\tset_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h38;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\tclear_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h01;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\toff_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h08;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\ton_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h0C;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\tentry_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h06;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\tcursor_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 0;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= 8'h80|cursor_pos; busy \t\t\t<= 1;\n\t\t\tend\n\t\t\t\n\t\t\twrite_data: begin\n\t\t\t\tlimit_cnt \t<= 0;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= 1;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= ascii_char; busy \t\t\t<= 1;\n\t\t\tend\n\t\t\tlcd_en: begin\n\t\t\t\tlimit_cnt \t<= 100;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= rs_d;\n\t\t\t\te\t\t\t\t<=\t1;\n\t\t\t\tdata\t\t\t<= data_d;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\tlcd_del_1: begin\n\t\t\t\tlimit_cnt \t<= 100; en_cnt\t\t<= 1;\n\t\t\t\trs\t\t\t\t<= rs_d;\n\t\t\t\te\t\t\t\t<=\t1;\n\t\t\t\tdata\t\t\t<= data_d;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\tlcd_dis: begin\n\t\t\t\tlimit_cnt \t<= 20000;\n\t\t\t\ten_cnt\t\t<= 0;\n\t\t\t\trs\t\t\t\t<= rs_d;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= data_d;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\t\tlcd_del_200: begin\n\t\t\t\tlimit_cnt \t<= 20000; en_cnt\t\t<= 1;\n\t\t\t\trs\t\t\t\t<= rs_d;\n\t\t\t\te\t\t\t\t<=\t0;\n\t\t\t\tdata\t\t\t<= data_d;\n\t\t\t\tbusy \t\t\t<= 1;\n\t\t\tend\n\t\tendcase\n\t end\n\t \n\t always@(negedge clk) begin\n\t\tdata_d <= data;\n\t\trs_d <= rs;\n\t end\n\t \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "counter_8b2c40fd", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule counter (\n   input clk,\n   input reset,\n   input [3:0] i_value,\n   output reg [3:0] value\n);\n\n   always @(posedge clk or posedge reset) begin\n      if (reset) begin\n         value <= 0;\n      end else if (value == 4'hF) begin\n         value <= 4'h0;\n      end else begin\n         value <= value + 4'h1;\n      end\n   end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Delay_936933bc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule Delay(\n    CLK,\n    RST,\n    DELAY_MS,\n    DELAY_EN,\n    DELAY_FIN\n    );\n\n\tinput CLK;\n    input RST;\n    input [11:0] DELAY_MS;\n    input DELAY_EN;\n    output DELAY_FIN;\n\n\twire DELAY_FIN;\n\t\t\t\t\treg [13:0] clk_counter = 14'b00000000000000;\t\treg [11:0] ms_counter = 12'h000;\t\t\t\t\t\t\tparameter Idle = 2'd0, Hold = 2'd1, Done = 2'd2;\n\treg [1:0] current_state = Idle;\n\n\tassign DELAY_FIN = (current_state == Done && DELAY_EN == 1'b1) ? 1'b1 : 1'b0;\n\t\n\talways @(posedge CLK) begin\n\t\t\tif(RST == 1'b1) begin\n\t\t\t\t\tcurrent_state <= Idle;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\t\tcase(current_state)\n\n\t\t\t\t\t\t\tIdle : begin\n\t\t\t\t\t\t\t\t\tif(DELAY_EN == 1'b1) begin\n\t\t\t\t\t\t\t\t\t\t\tcurrent_state <= Hold;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tHold : begin\n\t\t\t\t\t\t\t\t\tif(ms_counter == DELAY_MS) begin\n\t\t\t\t\t\t\t\t\t\t\tcurrent_state <= Done;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tDone : begin\n\t\t\t\t\t\t\t\t\tif(DELAY_EN == 1'b0) begin\n\t\t\t\t\t\t\t\t\t\t\tcurrent_state <= Idle;\n\t\t\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\tend\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tdefault : current_state <= Idle;\n\t\t\t\t\t\t\t\n\t\t\t\t\tendcase\n\t\t\tend\n\tend\n\talways @(posedge CLK) begin\n\t\t\tif(current_state == Hold) begin\n\t\t\t\t\tif(clk_counter == 14'b10111011100000) begin\t\tclk_counter <= 14'b00000000000000;\n\t\t\t\t\t\t\tms_counter <= ms_counter + 1'b1;\t\t\t\t\tend\n\t\t\t\t\telse begin\n\t\t\t\t\t\t\tclk_counter <= clk_counter + 1'b1;\n\t\t\t\t\tend\n\t\t\tend\n\t\t\telse begin\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tclk_counter <= 14'b00000000000000;\n\t\t\t\t\tms_counter <= 12'h000;\n\t\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "twos_complement_sum_d84812e6", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule twos_complement_sum (\n  input [31:0] input_data,\n  output reg [15:0] output_sum\n);\n\n  reg [15:0] lower_bits_twos_comp;\n  reg [15:0] upper_bits_twos_comp;\n  reg [15:0] sum;\n\n  always @(*) begin\n    lower_bits_twos_comp = ~input_data[15:0] + 1;\n    upper_bits_twos_comp = ~input_data[31:16] + 1;\n  end\n\n  always @(*) begin\n    sum = lower_bits_twos_comp + upper_bits_twos_comp;\n    if (sum > 32767) begin\n      output_sum = 32767;\n    end else begin\n      output_sum = sum;\n    end\n  end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__o21bai_a63fa427", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_hd__o21bai (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1_N\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1_N;\n\n    wire b          ;\n    wire or0_out    ;\n    wire nand0_out_Y;\n\n    not  not0  (b          , B1_N           );\n    or   or0   (or0_out    , A2, A1         );\n    nand nand0 (nand0_out_Y, b, or0_out     );\n    buf  buf0  (Y          , nand0_out_Y    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "UpDownCtr_c67a8260", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule UpDownCtr(\n  input        clock,\n  input        reset,\n  input  [9:0] io_strideInc,\n  input  [9:0] io_strideDec,\n  input        io_inc,\n  input        io_dec,\n  output [9:0] io_out,\n  output [9:0] io_nextInc,\n  output [9:0] io_nextDec\n);\n  reg  [9:0] reg$;  \n  wire [9:0] reg$_T_1;\n  wire [9:0] reg$_T_2;\n  wire [9:0] reg$_T_3;\n\n  assign io_out = reg$;\n  assign io_nextInc = reg$ + io_strideInc;\n  assign io_nextDec = reg$ - io_strideDec;\n  assign reg$_T_1 = io_inc ? io_strideInc : 10'h0;\n  assign reg$_T_2 = io_dec ? io_strideDec : 10'h0;\n\n  always @(posedge clock) begin\n    if (reset) begin\n      reg$ <= 10'h0;\n    end else begin\n      reg$ <= reg$_T_3;\n    end\n  end\n\n  assign reg$_T_3 = io_inc | io_dec ? reg$ + reg$_T_1 - reg$_T_2 : reg$;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_subtractor_4bit_d28d222c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder_subtractor_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input SUB,\n    output reg [3:0] result,\n    output reg OVFL\n    );\n\n    always @(*) begin\n        if(SUB == 1) begin\n            result = A - B;\n            OVFL = (result[3] == 1) ? 1 : 0;\n        end\n        else begin\n            result = A + B;\n            OVFL = (result[3] == 1) ? 1 : 0;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "bitwise_operations_30bf2ce5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule bitwise_operations(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_and,\n    output [2:0] out_xor,\n    output [2:0] out_nand\n);\n\nassign out_and = a & b;\nassign out_xor = a ^ b;\nassign out_nand = !(a & b);\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fpu_round_697d67e8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule fpu_round( clk, rst, enable, round_mode, sign_term, \nmantissa_term, exponent_term, round_out, exponent_final);\ninput\t\tclk;\ninput\t\trst;\ninput\t\tenable;\ninput\t[1:0]\tround_mode;\ninput\t\tsign_term;\ninput\t[55:0]\tmantissa_term;\ninput\t[11:0]\texponent_term;\noutput\t[63:0]\tround_out;\noutput\t[11:0]\texponent_final;\n\nwire\t[55:0] rounding_amount = { 53'b0, 1'b1, 2'b0};\nwire\tround_nearest = (round_mode == 2'b00);\nwire\tround_to_zero = (round_mode == 2'b01);\nwire\tround_to_pos_inf = (round_mode == 2'b10);\nwire\tround_to_neg_inf = (round_mode == 2'b11);\nwire \tround_nearest_trigger = round_nearest &  mantissa_term[1]; \nwire\tround_to_pos_inf_trigger = !sign_term & |mantissa_term[1:0]; \nwire\tround_to_neg_inf_trigger = sign_term & |mantissa_term[1:0];\nwire \tround_trigger = ( round_nearest & round_nearest_trigger)\n\t\t\t\t\t\t| (round_to_pos_inf & round_to_pos_inf_trigger) \n\t\t\t\t\t\t| (round_to_neg_inf & round_to_neg_inf_trigger);\n\n\nreg\t  [55:0] sum_round;\nwire\tsum_round_overflow = sum_round[55]; \n\treg\t  [55:0] sum_round_2;\nreg   [11:0] exponent_round;\nreg\t  [55:0] sum_final; \nreg   [11:0] exponent_final;\nreg   [63:0] round_out;\n\nalways @(posedge clk) \n\tbegin\n\t\tif (rst) begin\n\t\t\tsum_round <= 0;\n\t\t\tsum_round_2 <= 0;\n\t\t\texponent_round <= 0;\n\t\t\tsum_final <= 0; \n\t\t\texponent_final <= 0;\n\t\t\tround_out <= 0;\n\t\tend\n\t\telse begin\n\t\t\tsum_round <= rounding_amount + mantissa_term;\n\t\t\tsum_round_2 <= sum_round_overflow ? sum_round >> 1 : sum_round;\n\t\t\texponent_round <= sum_round_overflow ? (exponent_term + 1) : exponent_term;\n\t\t\tsum_final <= round_trigger ? sum_round_2 : mantissa_term; \n\t\t\texponent_final <= round_trigger ? exponent_round : exponent_term;\n\t\t\tround_out <= { sign_term, exponent_final[10:0], sum_final[53:2] };\n\t\t\tend\n\tend\nendmodule\t"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__27d6f1cc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input A,\n    input B,\n    input C_in,\n    output [8:0] out\n);\n\n    wire [1:0] fa1_out;\n    wire [1:0] fa2_out;\n    wire parity_bit;\n\n    // Full Adder 1\n    full_adder fa1 (\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .sum(fa1_out[0]),\n        .C_out(fa1_out[1])\n    );\n\n    // Full Adder 2\n    full_adder fa2 (\n        .A(fa1_out[0]),\n        .B(fa1_out[1]),\n        .C_in(1'b0),\n        .sum(fa2_out[0]),\n        .C_out(fa2_out[1])\n    );\n\n    // Parity Bit Calculation\n    assign parity_bit = (A ^ B ^ fa2_out[0]) & (A | B | fa2_out[0]);\n\n    // Output\n    assign out = {parity_bit, fa2_out};\n\nendmodule\n\n// Full Adder\nmodule full_adder (\n    input A,\n    input B,\n    input C_in,\n    output sum,\n    output C_out\n);\n\n    assign sum = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "InstrDecod_839e0c69", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule InstrDecod(instr, pc, regWrite, writeData, writeRegister, opcode, funct, regOut1, regOut2, regRt, regRd, immValue, jumpDest, branchDest);\n  input [31:0] instr;    input [31:0] pc; input [31:0] writeData; input [4:0] writeRegister; input regWrite;   output [5:0] opcode; output [5:0] funct;  output [31:0] regOut1; output [31:0] regOut2; output [4:0] regRt;  output [4:0] regRd;  output [31:0] jumpDest;  output [31:0] immValue; output [31:0] branchDest; reg signed [31:0] registerMem [0:31];\n\n  wire signed [31:0] writeData;\n  wire signed [31:0] pc;\n  reg [5:0] opcode, funct;\n  reg [4:0] regRs, regRt, regRd;\n  reg signed [31:0] regOut1, regOut2;\n  reg signed [31:0] immValue, jumpDest, branchDest;\n  reg signed [31:0] signedBranch;\n\n\n  integer idx;\n  initial\n    begin\n    for (idx = 0; idx < 32; idx = idx + 1)\n      begin\n        registerMem[idx] = 0;\n      end\n  end\n\n  always @(*) begin\n    if (regWrite == 1)\n      registerMem[writeRegister] = writeData;\n  end\n\n  always @(instr) begin\n    opcode = instr[31:26];\n     funct = instr[5:0];\n\n    regRs = instr[25:21];\n    regRt = instr[20:16];\n    regRd = instr[15:11];\n\n    immValue = { {16{instr[15]}}, instr[15:0] };\n\n    jumpDest = { {5{instr[25]}}, instr[25:0] };\n\n    signedBranch = { {16{instr[15]}}, instr[15:0] };\n    branchDest = pc + signedBranch;\n\n    regOut1 = registerMem[regRs];\n    regOut2 = registerMem[regRt];\n  end\n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_9663cc57", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule up_down_counter (\n    input clk,\n    input reset,\n    input enable,\n    input up_down,\n    output reg [3:0] count\n);\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            count <= 0;\n        end else if (enable) begin\n            if (up_down) begin\n                count <= count + 1;\n            end else if (count > 0) begin\n                count <= count - 1;\n            end\n        end\n    end\n    \nendmodule\nmodule shift_register (\n    input clk,\n    input reset,\n    input load,\n    input [3:0] data_in,\n    output reg [3:0] data_out\n);\n    \n    reg [3:0] shift_reg;\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 0;\n        end else if (load) begin\n            shift_reg <= data_in;\n        end else begin\n            shift_reg <= {shift_reg[3:1], 1'b0};\n        end\n    end\n    \n    always@(*) begin\n        data_out <= shift_reg;\n    end\n    \nendmodule\nmodule top_module (\n    input clk,\n    input reset,\n    input up_down,\n    input load,\n    input [3:0] data_in,\n    output [3:0] data_out\n);\n    \n    reg enable;\n    wire [3:0] count;\n    \n    up_down_counter counter (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .up_down(up_down),\n        .count(count)\n    );\n    \n    shift_register shift_reg (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .data_in(count),\n        .data_out(data_out)\n    );\n    \n    always @(posedge clk) begin\n        enable <= !load;\n    end\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vga_core_748f1793", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule vga_core(\n                vga_clk, \n                rst, \n                addr,\n                v_active,\n                h_sync, \n                v_sync\n                );\n\n\tinput              \tvga_clk;                // 25MHz\n\tinput              \trst;\n\toutput     \t[18: 0] addr;                   // pixel Screen address, 640 (1024) x 480 (512)\n\toutput             \tv_active;               // read VRAM RAM (active_low)\n\toutput             \th_sync, v_sync;         // horizontal and vertical synchronization\n\n\t// h_count: VGA horizontal counter (0-799)\n\treg [9:0] h_count = 0; // VGA horizontal counter (0-799): pixels\n\talways @ (posedge vga_clk or posedge rst) begin\n\t\tif (rst) begin\n\t\t\th_count <= 10'h0;\n\t\tend else if (h_count == 10'd799) begin\n\t\t\th_count <= 10'h0;\n\t\tend else begin\n\t\t\th_count <= h_count + 10'h1;\n\t\tend\n\tend\n\n\t// v_count: VGA vertical counter (0-524)\n\treg [9:0] v_count = 0; // VGA vertical counter (0-524): lines\n\talways @ (posedge vga_clk or posedge rst) begin\n\t\tif (rst) begin\n\t\t\tv_count <= 10'h0;\n\t\tend else if (h_count == 10'd799) begin\n\t\t\tif (v_count == 10'd524) begin\n\t\t\t\tv_count <= 10'h0;\n\t\t\tend else begin\n\t\t\t\tv_count <= v_count + 10'h1;\n\t\t\tend\n\t\tend\n\tend\n\n\t// signal timing\n\twire h_sync \t\t= (h_count > 10'd95);          // 96 -> 799\n\twire v_sync \t\t= (v_count > 10'd1);           // 2 -> 524\n\twire v_active \t\t= (h_count > 10'd142) &&     // 143 -> 782\n\t\t\t\t\t\t  (h_count < 10'd783) &&     // 640 pixels\n\t\t\t\t\t\t  (v_count > 10'd34) &&      // 35 -> 514\n\t\t\t\t\t\t  (v_count < 10'd515);       // 480 lines\n\n\twire [ 9: 0] col   \t= h_count - 10'd143;    // pixel Screen addr col\n\twire [ 9: 0] row   \t= v_count - 10'd35;     // pixel Screen addr row\n\twire [18: 0] addr  \t= {row[ 8: 0], col};    // pixel Screen addr\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder_ff6c6e41", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule adder (\n    input [3:0] A,\n    input [3:0] B,\n    input sel,\n    output reg [3:0] C\n);\n\n    wire [3:0] sum;\n    wire carry;\n\n    assign sum = A + B;\n    assign carry = (A[3] & B[3]) | (A[3] & ~sum[3]) | (B[3] & ~sum[3]);\n\n    always @ (*) begin\n        C = sel ? ~{carry, sum} : {carry, sum};\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__104ab48d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [3:0] a, // 4-bit input A for the comparator\n    input [3:0] b, // 4-bit input B for the comparator\n    output reg out_func, // 1-bit output from the functional module\n    output [2:0] count // 3-bit output from the counter\n);\n\nreg [2:0] counter;\nwire equal;\n\ncomparator_4bit comp_inst (\n    .a(a),\n    .b(b),\n    .equal(equal)\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 3'b0;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (counter > b) begin\n        out_func <= 1'b1;\n    end else begin\n        out_func <= 1'b0;\n    end\nend\n\nassign count = counter;\n\nendmodule\n\nmodule comparator_4bit (\n    input [3:0] a,\n    input [3:0] b,\n    output reg equal\n);\n\nalways @(a, b) begin\n    if (a == b) begin\n        equal <= 1'b1;\n    end else begin\n        equal <= 1'b0;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_to_bcd_6584fb96", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_to_bcd(\n    input [7:0] binary,\n    output [11:0] bcd\n);\n\nreg [3:0] digit1;\nreg [3:0] digit2;\nreg [3:0] digit3;\n\nalways @ (binary) begin\n    if (binary >= 100) begin\n        digit1 = binary / 100;\n        digit2 = (binary % 100) / 10;\n        digit3 = binary % 10;\n    end else if (binary >= 10) begin\n        digit1 = 0;\n        digit2 = binary / 10;\n        digit3 = binary % 10;\n    end else begin\n        digit1 = 0;\n        digit2 = 0;\n        digit3 = binary;\n    end\nend\n\nassign bcd = {digit1, digit2, digit3};\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DemoInterconnect_jtag_axi_0_0_wr_status_flags_as_124a823f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule DemoInterconnect_jtag_axi_0_0_wr_status_flags_as\n   (out,\n    \\gic0.gc0.count_d1_reg[5] ,\n    s_dclk_o);\n  output out;\n  input \\gic0.gc0.count_d1_reg[5] ;\n  input s_dclk_o;\n\n  wire \\gic0.gc0.count_d1_reg[5] ;\n   wire ram_full_fb_i;\n   wire ram_full_i;\n  wire s_dclk_o;\n\n  assign out = ram_full_fb_i;\n   \n   \n   \n  FDRE #(\n    .INIT(1'b0)) \n    ram_full_fb_i_reg\n       (.C(s_dclk_o),\n        .CE(1'b1),\n        .D(\\gic0.gc0.count_d1_reg[5] ),\n        .Q(ram_full_fb_i),\n        .R(1'b0));\n   \n   \n   \n  FDRE #(\n    .INIT(1'b0)) \n    ram_full_i_reg\n       (.C(s_dclk_o),\n        .CE(1'b1),\n        .D(\\gic0.gc0.count_d1_reg[5] ),\n        .Q(ram_full_i),\n        .R(1'b0));\nendmodule\n\n \nmodule FDRE \n  #(parameter INIT = 0) \n  (Q, D, C, CE, R);\n  output Q;\n  input D, C, CE, R;\n  reg Q;\n\n  always @(posedge C) begin\n    if (R) begin\n      Q <= INIT;\n    end\n    else if (CE) begin\n      Q <= D;\n    end\n  end\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "RCB_FRL_LED_Clock_796216f4", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule RCB_FRL_LED_Clock(Test_Clock_in, LED_Clock_out, RST);\n    input Test_Clock_in;\n    output LED_Clock_out;\n    input RST;\n\n\treg[9:0] count1;\n\treg[9:0] count2;\n\treg[9:0] count3;\n\treg LED_Clock_out_reg;\n\t\n\tassign LED_Clock_out = LED_Clock_out_reg;\n\nalways @(posedge Test_Clock_in or posedge RST) begin\n\tif (RST) begin\n\t\tcount1 <= 1'b0;\n\t\tcount2 <= 1'b0;\n\t\tcount3 <= 1'b0;\n\t\tLED_Clock_out_reg <= 1'b0;\n\t\tend\n\telse begin\n\t\tif (count3 < 448) begin\n\t\t\tif (count2 < 1000) begin\n\t\t\t\tif (count1 < 1000) \n\t\t\t\t\tcount1 <= count1 + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tcount1 <= 1'b0;\n\t\t\t\t\t\tcount2 <= count2 + 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tcount2 <= 1'b0;\n\t\t\t\t\tcount3 <= count3 + 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\telse\t\t\t\t\n\t\t\tbegin\n\t\t\t\tcount3 <= 1'b0;\n\t\t\t\tLED_Clock_out_reg <= ~LED_Clock_out_reg;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n\nmodule RCB_FRL_LED_Clock_DIV(Test_Clock_in, LED_Clock_out, RST);\n    input Test_Clock_in;\n    output LED_Clock_out;\n    input RST;\n\n\treg[9:0] count1;\n\treg[9:0] count2;\n\treg[9:0] count3;\n\treg LED_Clock_out_reg;\n\t\n\tassign LED_Clock_out = LED_Clock_out_reg;\n\nalways @(posedge Test_Clock_in or posedge RST) begin\n\tif (RST) begin\n\t\tcount1 <= 1'b0;\n\t\tcount2 <= 1'b0;\n\t\tcount3 <= 1'b0;\n\t\tLED_Clock_out_reg <= 1'b0;\n\t\tend\n\telse begin\n\t\tif (count3 < 56) begin\n\t\t\tif (count2 < 1000) begin\n\t\t\t\tif (count1 < 1000) \n\t\t\t\t\tcount1 <= count1 + 1'b1;\n\t\t\t\telse\n\t\t\t\t\tbegin\n\t\t\t\t\t\tcount1 <= 1'b0;\n\t\t\t\t\t\tcount2 <= count2 + 1'b1;\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tbegin\n\t\t\t\t\tcount2 <= 1'b0;\n\t\t\t\t\tcount3 <= count3 + 1'b1;\n\t\t\t\tend\n\t\t\tend\n\t\telse\t\t\t\t\n\t\t\tbegin\n\t\t\t\tcount3 <= 1'b0;\n\t\t\t\tLED_Clock_out_reg <= ~LED_Clock_out_reg;\n\t\t\tend\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "prometheus_fx3_partial_718499a2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule prometheus_fx3_partial(\n\tinput  rst_n,\n        input  clk_100,\n        input  partial_mode_selected,\n        input  i_gpif_in_ch0_rdy_d,\n        input  i_gpif_out_ch0_rdy_d,\n        output o_gpif_we_n_partial_,\n\toutput o_gpif_pkt_end_n_partial_,\n        output [31:0] data_out_partial\n);\n\nreg [2:0]current_partial_state;\nreg [2:0]next_partial_state;\nparameter [2:0] partial_idle                      = 3'd0;\nparameter [2:0] partial_wait_flagb                = 3'd1;\nparameter [2:0] partial_write                     = 3'd2;\nparameter [2:0] partial_write_wr_delay            = 3'd3;\nparameter [2:0] partial_wait\t\t          = 3'd4;\n\n\nreg [3:0] strob_cnt;\nreg       strob; \nreg [3:0] short_pkt_cnt;\nreg [31:0]data_gen_partial;\nreg o_gpif_pkt_end_n_prtl_;\n\nassign o_gpif_we_n_partial_ = ((current_partial_state == partial_write) && (i_gpif_out_ch0_rdy_d == 1'b1)) ? 1'b0 : 1'b1;\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tshort_pkt_cnt <= 4'd0;\n\tend else if(current_partial_state == partial_idle)begin\n\t\tshort_pkt_cnt <= 4'd0;\n\tend else if((current_partial_state == partial_write))begin\n\t\tshort_pkt_cnt <= short_pkt_cnt + 1'b1;\n\tend\t\nend\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tstrob_cnt <= 4'd0;\n\tend else if(current_partial_state == partial_idle)begin\n\t\tstrob_cnt <= 4'd0;\n\tend else if(current_partial_state == partial_wait)begin\n\t\tstrob_cnt <= strob_cnt + 1'b1;\n\tend\t\nend\n\nalways@(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin\n\t\tstrob <= 1'b0;\n\tend else if((current_partial_state == partial_wait) && (strob_cnt == 4'b0111)) begin\n\t\tstrob <= !strob;\n\tend\nend\n\nalways@(*)begin\n\tif((partial_mode_selected) & (strob == 1'b1) & (short_pkt_cnt == 4'b1111))begin\n\t\to_gpif_pkt_end_n_prtl_ = 1'b0;\n\tend else begin\n\t\to_gpif_pkt_end_n_prtl_ = 1'b1;\n\tend\nend\t\n\nassign o_gpif_pkt_end_n_partial_ = o_gpif_pkt_end_n_prtl_;\n\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tcurrent_partial_state <= partial_idle;\n\tend else begin\n\t\tcurrent_partial_state <= next_partial_state;\n\tend\t\nend\n\nalways @(*)begin\n\tnext_partial_state = current_partial_state;\n\tcase(current_partial_state)\n\tpartial_idle:begin\n\t\tif((partial_mode_selected) & (i_gpif_in_ch0_rdy_d == 1'b1))begin\n\t\t\tnext_partial_state = partial_wait_flagb; \n\t\tend else begin\n\t\t\tnext_partial_state = partial_idle;\n\t\tend\t\n\tend\n\tpartial_wait_flagb :begin\n\t\tif (i_gpif_out_ch0_rdy_d == 1'b1)begin\n\t\t\tnext_partial_state = partial_write; \n\t\tend else begin\n\t\t\tnext_partial_state = partial_wait_flagb; \n\t\tend\n\tend\n\tpartial_write:begin\n\t\tif((i_gpif_out_ch0_rdy_d == 1'b0) | ((strob == 1'b1) & (short_pkt_cnt == 4'b1111)))begin\n\t\t\tnext_partial_state = partial_write_wr_delay;\n\t\tend else begin\n\t\t \tnext_partial_state = partial_write;\n\t\tend\n\tend\n        partial_write_wr_delay:begin\n\t\tnext_partial_state = partial_wait;\n\tend\n\tpartial_wait:begin\n\t\tif(strob_cnt == 4'b0111)begin\n\t\t\tnext_partial_state = partial_idle;\n\t\tend else begin\n\t\t\tnext_partial_state = partial_wait;\n\t\tend\n\tend\t\n\tendcase\nend\n\n\nalways @(posedge clk_100, negedge rst_n)begin\n\tif(!rst_n)begin \n\t\tdata_gen_partial <= 32'd0;\n\tend else if((o_gpif_we_n_partial_ == 1'b0) & (partial_mode_selected)) begin\n\t\tdata_gen_partial <= data_gen_partial + 1;\n\tend else if (!partial_mode_selected) begin\n\t\tdata_gen_partial <= 32'd0;\n\tend\t\nend\n\nassign data_out_partial = data_gen_partial;\n\nendmodule\n\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "max_value_0105be0e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule max_value (input [7:0] A, B, C, D, output reg [15:0] out);\n\nreg [7:0] max_val;\n\nalways @ (A, B, C, D) begin\n    max_val = A > B ? A : B;\n    max_val = max_val > C ? max_val : C;\n    max_val = max_val > D ? max_val : D;\n    out = {max_val, 8'b0};\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__and2_aa76f330", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_lp__and2 (\n    X   ,\n    A   ,\n    B   ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    // Module ports\n    output X   ;\n    input  A   ;\n    input  B   ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    // Local signals\n    wire and0_out_X       ;\n\n    //                                 Name         Output             Other arguments\n    and                                and0        (and0_out_X       , A, B                  );\n    buf                                buf0        (X                , and0_out_X     );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sync_counter_bf3ba698", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sync_counter(\n    input rst,\n    input clk,\n    output reg [3:0] count\n);\n\n    always @(posedge clk) begin\n        if(rst) begin\n            count <= 4'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "processing_system7_v5_3_aw_atc #_fe06d774", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule processing_system7_v5_3_aw_atc #\n  (\n   parameter         C_FAMILY                         = \"rtl\", \n                       parameter integer C_AXI_ID_WIDTH                   = 4, \n                       parameter integer C_AXI_ADDR_WIDTH                 = 32, \n                       parameter integer C_AXI_AWUSER_WIDTH               = 1,\n                       parameter integer C_FIFO_DEPTH_LOG                 = 4\n   )\n  (\n   input  wire                                  ARESET,\n   input  wire                                  ACLK,\n\n   output reg                                   cmd_w_valid,\n   output wire                                  cmd_w_check,\n   output wire [C_AXI_ID_WIDTH-1:0]             cmd_w_id,\n   input  wire                                  cmd_w_ready,\n   input  wire [C_FIFO_DEPTH_LOG-1:0]           cmd_b_addr,\n   input  wire                                  cmd_b_ready,\n   \n   input  wire [C_AXI_ID_WIDTH-1:0]             S_AXI_AWID,\n   input  wire [C_AXI_ADDR_WIDTH-1:0]           S_AXI_AWADDR,\n   input  wire [4-1:0]                          S_AXI_AWLEN,\n   input  wire [3-1:0]                          S_AXI_AWSIZE,\n   input  wire [2-1:0]                          S_AXI_AWBURST,\n   input  wire [2-1:0]                          S_AXI_AWLOCK,\n   input  wire [4-1:0]                          S_AXI_AWCACHE,\n   input  wire [3-1:0]                          S_AXI_AWPROT,\n   input  wire [C_AXI_AWUSER_WIDTH-1:0]         S_AXI_AWUSER,\n   input  wire                                  S_AXI_AWVALID,\n   output wire                                  S_AXI_AWREADY,\n\n   output wire [C_AXI_ID_WIDTH-1:0]             M_AXI_AWID,\n   output wire [C_AXI_ADDR_WIDTH-1:0]           M_AXI_AWADDR,\n   output wire [4-1:0]                          M_AXI_AWLEN,\n   output wire [3-1:0]                          M_AXI_AWSIZE,\n   output wire [2-1:0]                          M_AXI_AWBURST,\n   output wire [2-1:0]                          M_AXI_AWLOCK,\n   output wire [4-1:0]                          M_AXI_AWCACHE,\n   output wire [3-1:0]                          M_AXI_AWPROT,\n   output wire [C_AXI_AWUSER_WIDTH-1:0]         M_AXI_AWUSER,\n   output wire                                  M_AXI_AWVALID,\n   input  wire                                  M_AXI_AWREADY\n   );\n  \n  \n  localparam [2-1:0] C_FIX_BURST         = 2'b00;\n  localparam [2-1:0] C_INCR_BURST        = 2'b01;\n  localparam [2-1:0] C_WRAP_BURST        = 2'b10;\n  \n  localparam [3-1:0] C_OPTIMIZED_SIZE    = 3'b011;\n  \n  localparam [4-1:0] C_OPTIMIZED_LEN     = 4'b0011;\n\n  localparam [4-1:0] C_NO_ADDR_OFFSET    = 5'b0;\n  \n  localparam C_FIFO_WIDTH                = C_AXI_ID_WIDTH + 1;\n  localparam C_FIFO_DEPTH                = 2 ** C_FIFO_DEPTH_LOG;\n    \n  \n  integer index;\n  \n  \n  wire                                access_is_incr;\n  wire                                access_is_wrap;\n  wire                                access_is_coherent;\n  wire                                access_optimized_size;\n  wire                                incr_addr_boundary;\n  wire                                incr_is_optimized;\n  wire                                wrap_is_optimized;\n  wire                                access_is_optimized;\n  \n  wire                                cmd_w_push;\n  reg                                 cmd_full;\n  reg  [C_FIFO_DEPTH_LOG-1:0]         addr_ptr;\n  wire [C_FIFO_DEPTH_LOG-1:0]         all_addr_ptr;\n  reg  [C_FIFO_WIDTH-1:0]             data_srl[C_FIFO_DEPTH-1:0];\n  \n  \n  assign access_is_incr         = ( S_AXI_AWBURST == C_INCR_BURST );\n  assign access_is_wrap         = ( S_AXI_AWBURST == C_WRAP_BURST );\n  \n  assign access_is_coherent     = ( S_AXI_AWUSER[0]  == 1'b1 ) &\n                                  ( S_AXI_AWCACHE[1] == 1'b1 );\n  \n  assign incr_addr_boundary     = ( S_AXI_AWADDR[4:0] == C_NO_ADDR_OFFSET );\n  \n  assign access_optimized_size  = ( S_AXI_AWSIZE == C_OPTIMIZED_SIZE ) & \n                                  ( S_AXI_AWLEN  == C_OPTIMIZED_LEN  );\n  \n  assign incr_is_optimized      = access_is_incr & access_is_coherent & access_optimized_size & incr_addr_boundary;\n  assign wrap_is_optimized      = access_is_wrap & access_is_coherent & access_optimized_size;\n  assign access_is_optimized    = ( incr_is_optimized | wrap_is_optimized );\n  \n  \n  assign cmd_w_push = S_AXI_AWVALID & M_AXI_AWREADY & ~cmd_full;\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      addr_ptr <= {C_FIFO_DEPTH_LOG{1'b1}};\n    end else begin\n      if ( cmd_w_push & ~cmd_w_ready ) begin\n        addr_ptr <= addr_ptr + 1;\n      end else if ( ~cmd_w_push & cmd_w_ready ) begin\n        addr_ptr <= addr_ptr - 1;\n      end\n    end\n  end\n  \n  assign all_addr_ptr = addr_ptr + cmd_b_addr + 2;\n  \n  always @ (posedge ACLK) begin\n    if (ARESET) begin\n      cmd_full    <= 1'b0;\n      cmd_w_valid <= 1'b0;\n    end else begin\n      if ( cmd_w_push & ~cmd_w_ready ) begin\n        cmd_w_valid <= 1'b1;\n      end else if ( ~cmd_w_push & cmd_w_ready ) begin\n        cmd_w_valid <= ( addr_ptr != 0 );\n      end\n      if ( cmd_w_push & ~cmd_b_ready ) begin\n        cmd_full    <= ( all_addr_ptr == C_FIFO_DEPTH-3 );\n      end else if ( ~cmd_w_push & cmd_b_ready ) begin\n        cmd_full    <= ( all_addr_ptr == C_FIFO_DEPTH-2 );\n      end\n    end\n  end\n  \n  always @ (posedge ACLK) begin\n    if ( cmd_w_push ) begin\n      for (index = 0; index < C_FIFO_DEPTH-1 ; index = index + 1) begin\n        data_srl[index+1] <= data_srl[index];\n      end\n      data_srl[0]   <= {access_is_optimized, S_AXI_AWID};\n    end\n  end\n  \n  assign {cmd_w_check, cmd_w_id} = data_srl[addr_ptr];\n  \n  \n  assign M_AXI_AWVALID   = S_AXI_AWVALID & ~cmd_full;\n  \n  assign S_AXI_AWREADY   = M_AXI_AWREADY & ~cmd_full;\n  \n  \n  assign M_AXI_AWID      = S_AXI_AWID; \n  assign M_AXI_AWADDR    = S_AXI_AWADDR;\n  assign M_AXI_AWLEN     = S_AXI_AWLEN;\n  assign M_AXI_AWSIZE    = S_AXI_AWSIZE;\n  assign M_AXI_AWBURST   = S_AXI_AWBURST;\n  assign M_AXI_AWLOCK    = S_AXI_AWLOCK;\n  assign M_AXI_AWCACHE   = S_AXI_AWCACHE;\n  assign M_AXI_AWPROT    = S_AXI_AWPROT;\n  assign M_AXI_AWUSER    = S_AXI_AWUSER;\n  \n  \nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_and_add_multiplier_11dbb2af", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_and_add_multiplier (\n    input clk,\n    input reset,\n    input [3:0] a, b,\n    output reg [7:0] product\n);\n\n    reg [2:0] i; // Declare 'i' as a 3-bit register\n\n    always @(posedge clk) begin\n        if (reset) begin\n            product <= 8'b0;\n        end else begin\n            for (i = 0; i < 4; i = i + 1) begin\n                if (b[i]) begin\n                    product <= product + (a << i);\n                end\n            end\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "three_input_gate_168490a7", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule three_input_gate (\n    Y,\n    A1,\n    A2,\n    B1\n);\n\n    output Y;\n    input A1;\n    input A2;\n    input B1;\n\n    wire A1_AND_A2;\n    wire B1_OR_A1_AND_A2;\n\n    assign A1_AND_A2 = A1 & A2;\n    assign B1_OR_A1_AND_A2 = B1 | A1_AND_A2;\n\n    assign Y = B1_OR_A1_AND_A2;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_counter_shifter_4b547551", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule up_down_counter_shifter (\n    input CLK,\n    input UP,\n    input DOWN,\n    input SHIFT,\n    input RST,\n    input [3:0] B,\n    output [3:0] Q,\n    output reg [3:0] RESULT\n);\n\nreg [3:0] counter;\n\nalways @(posedge CLK) begin\n    if (RST) begin\n        counter <= 4'b0;\n        RESULT <= 4'b0;\n    end else if (UP && !DOWN) begin\n        counter <= counter + 4'b1;\n    end else if (!UP && DOWN) begin\n        counter <= counter - 4'b1;\n    end else begin\n        counter <= counter;\n    end\n    \n    if (SHIFT) begin\n        RESULT <= counter << B;\n    end else begin\n        RESULT <= counter;\n    end\nend\n\nassign Q = counter;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "up_down_shift_4681f912", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule up_down_shift(\n    input [3:0] LOAD,\n    input UP_DOWN,\n    input CLK,\n    input RESET,\n    input [3:0] D,\n    output reg [3:0] OUT\n);\n\nreg [3:0] up_down_counter;\nreg [3:0] shift_register;\n\nalways @(posedge CLK) begin\n    if (RESET) begin\n        up_down_counter <= 4'b0;\n        shift_register <= 4'b0;\n        OUT <= 4'b0;\n    end\n    else if (LOAD) begin\n        up_down_counter <= LOAD;\n        shift_register <= D;\n        OUT <= up_down_counter + shift_register;\n    end\n    else begin\n        if (UP_DOWN) begin\n            up_down_counter <= up_down_counter + 1;\n        end\n        else begin\n            up_down_counter <= up_down_counter - 1;\n        end\n        shift_register <= {shift_register[2:0], D[0]};\n        OUT <= up_down_counter + shift_register;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dmem_mux3_e99d1b28", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dmem_mux3\n(\n    output reg [31:0] out0_addr_o,\n    output reg [31:0] out0_data_o,\n    input [31:0]      out0_data_i,\n    output reg [3:0]  out0_sel_o,\n    output reg        out0_we_o,\n    output reg        out0_stb_o,\n    output reg        out0_cyc_o,\n    output reg [2:0]  out0_cti_o,\n    input             out0_ack_i,\n    input             out0_stall_i,\n\n    output reg [31:0] out1_addr_o,\n    output reg [31:0] out1_data_o,\n    input [31:0]      out1_data_i,\n    output reg [3:0]  out1_sel_o,\n    output reg        out1_we_o,\n    output reg        out1_stb_o,\n    output reg        out1_cyc_o,\n    output reg [2:0]  out1_cti_o,\n    input             out1_ack_i,\n    input             out1_stall_i,\n\n    output reg [31:0] out2_addr_o,\n    output reg [31:0] out2_data_o,\n    input [31:0]      out2_data_i,\n    output reg [3:0]  out2_sel_o,\n    output reg        out2_we_o,\n    output reg        out2_stb_o,\n    output reg        out2_cyc_o,\n    output reg [2:0]  out2_cti_o,\n    input             out2_ack_i,\n    input             out2_stall_i,\n\n    input [31:0]      mem_addr_i,\n    input [31:0]      mem_data_i,\n    output reg[31:0]  mem_data_o,\n    input [3:0]       mem_sel_i,\n    input             mem_we_i,\n    input             mem_stb_i,\n    input             mem_cyc_i,\n    input [2:0]       mem_cti_i,\n    output reg        mem_ack_o,\n    output reg        mem_stall_o\n);\n\nparameter           ADDR_MUX_START      = 28;\n\nalways @ *\nbegin\n\n   out0_addr_o      = 32'h00000000;\n   out0_data_o      = 32'h00000000;\n   out0_sel_o       = 4'b0000;\n   out0_we_o        = 1'b0;\n   out0_stb_o       = 1'b0;\n   out0_cyc_o       = 1'b0;\n   out0_cti_o       = 3'b0;\n   out1_addr_o      = 32'h00000000;\n   out1_data_o      = 32'h00000000;\n   out1_sel_o       = 4'b0000;\n   out1_we_o        = 1'b0;\n   out1_stb_o       = 1'b0;\n   out1_cyc_o       = 1'b0;\n   out1_cti_o       = 3'b0;\n   out2_addr_o      = 32'h00000000;\n   out2_data_o      = 32'h00000000;\n   out2_sel_o       = 4'b0000;\n   out2_we_o        = 1'b0;\n   out2_stb_o       = 1'b0;\n   out2_cyc_o       = 1'b0;\n   out2_cti_o       = 3'b0;\n\n   case (mem_addr_i[ADDR_MUX_START+2-1:ADDR_MUX_START])\n\n   2'd0:\n   begin\n       out0_addr_o      = mem_addr_i;\n       out0_data_o      = mem_data_i;\n       out0_sel_o       = mem_sel_i;\n       out0_we_o        = mem_we_i;\n       out0_stb_o       = mem_stb_i;\n       out0_cyc_o       = mem_cyc_i;\n       out0_cti_o       = mem_cti_i;\n   end\n   2'd1:\n   begin\n       out1_addr_o      = mem_addr_i;\n       out1_data_o      = mem_data_i;\n       out1_sel_o       = mem_sel_i;\n       out1_we_o        = mem_we_i;\n       out1_stb_o       = mem_stb_i;\n       out1_cyc_o       = mem_cyc_i;\n       out1_cti_o       = mem_cti_i;\n   end\n   2'd2:\n   begin\n       out2_addr_o      = mem_addr_i;\n       out2_data_o      = mem_data_i;\n       out2_sel_o       = mem_sel_i;\n       out2_we_o        = mem_we_i;\n       out2_stb_o       = mem_stb_i;\n       out2_cyc_o       = mem_cyc_i;\n       out2_cti_o       = mem_cti_i;\n   end\n\n   default :\n      ;      \n   endcase\nend\n\nalways @ *\nbegin\n   case (mem_addr_i[ADDR_MUX_START+2-1:ADDR_MUX_START])\n\n    2'd0:\n    begin\n       mem_data_o   = out0_data_i;\n       mem_stall_o  = out0_stall_i;\n       mem_ack_o    = out0_ack_i;\n    end\n    2'd1:\n    begin\n       mem_data_o   = out1_data_i;\n       mem_stall_o  = out1_stall_i;\n       mem_ack_o    = out1_ack_i;\n    end\n    2'd2:\n    begin\n       mem_data_o   = out2_data_i;\n       mem_stall_o  = out2_stall_i;\n       mem_ack_o    = out2_ack_i;\n    end\n\n   default :\n   begin\n       mem_data_o   = 32'h00000000;\n       mem_stall_o  = 1'b0;\n       mem_ack_o    = 1'b0;\n   end\n   endcase\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_908e330e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule four_bit_adder (\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    input reset,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [3:0] xor1_out;\n    wire [3:0] xor2_out;\n    wire [3:0] and1_out;\n    wire [3:0] and2_out;\n    wire [3:0] and3_out;\n    wire [3:0] or1_out;\n    wire [3:0] or2_out;\n    wire [3:0] or3_out;\n    wire [3:0] or4_out;\n    wire [3:0] sum_out;\n    wire [3:0] carry_out;\n\n    assign xor1_out = A ^ B;\n    assign xor2_out = xor1_out ^ Cin;\n    assign and1_out = A & B;\n    assign and2_out = A & Cin;\n    assign and3_out = B & Cin;\n    assign or1_out = and1_out | and2_out;\n    assign or2_out = and1_out | and3_out;\n    assign or3_out = and2_out | and3_out;\n    assign or4_out = or1_out | or2_out | or3_out;\n    assign sum_out = xor2_out;\n    assign carry_out = or4_out;\n\n    assign Cout = carry_out[3];\n\n    reg [3:0] Sum;\n\n    always @ (posedge reset, posedge Cin) begin\n        if (reset) begin\n            Sum <= 0;\n        end else begin\n            Sum <= sum_out;\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "magnitude_903b7646", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule magnitude(Y0, Y1, Y2, Y3, mag1, mag2);\n\t\n\tinput [11:0] Y0, Y1, Y2, Y3;\n\toutput [11:0] mag1, mag2;\n\twire [11:0] max1, max2, min1, min2;\n\twire [11:0] Z0, Z1, Z2, Z3;\n\t\n\ttoPositive p1 (.in(Y0), .out(Z0));\n\ttoPositive p2 (.in(Y1), .out(Z1));\n\ttoPositive p3 (.in(Y2), .out(Z2));\n\ttoPositive p4 (.in(Y3), .out(Z3));\n\t\n\tmax m1 (.imagPart(Z1), .realPart(Z0), .maximun(max1));\n\tmax m2 (.imagPart(Z3), .realPart(Z2), .maximun(max2));\n\tmin m3 (.imagPart(Z1), .realPart(Z0), .minimum(min1));\n\tmin m4 (.imagPart(Z3), .realPart(Z2), .minimum(min2));\n\t\n\tassign mag1 = max1 + (min1 >> 2) - (max1 >> 4);\n\tassign mag2 = max2 + (min2 >> 2) - (max2 >> 4);\n\t\nendmodule\n\nmodule toPositive(\n\tinput [11:0] in,\n\toutput reg [11:0] out);\n\t\n\talways @ * begin\n\t\tif(in[11] == 1'b1)\n\t\t\tout = ~in + 12'b1;\n\t\telse\n\t\t\tout = in;\n\tend\nendmodule\n\nmodule max(\n\tinput [11:0] imagPart,\n\tinput [11:0] realPart,\n\toutput reg [11:0] maximun);\n\t\n\talways @ * begin\n\t\tif(imagPart > realPart)\n\t\t\tmaximun = imagPart;\n\t\telse\n\t\t\tmaximun = realPart;\n\tend\nendmodule\n\nmodule min(\n\tinput [11:0] imagPart,\n\tinput [11:0] realPart,\n\toutput reg [11:0] minimum);\n\t\n\talways @ * begin\n\t\tif(imagPart > realPart)\n\t\t\tminimum = realPart;\n\t\telse\n\t\t\tminimum = imagPart;\n\tend\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "signed_mult_shift_81ecc33b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule signed_mult_shift(\n    input signed [3:0] A,\n    input signed [3:0] B,\n    input [3:0] shift,\n    input dir,\n    output reg signed [15:0] out\n);\n\n    wire signed [7:0] mult_result;\n    wire [3:0] shift_amt;\n\n    // Signed multiplication module\n    signed_mult mult(\n        .A(A),\n        .B(B),\n        .out(mult_result)\n    );\n\n    // Determine shift amount based on direction input\n    assign shift_amt = (dir == 1'b1) ? shift : -shift;\n\n    // Instantiate the barrel shifter module\n    barrel_shifter shift_reg(\n        .in(mult_result),\n        .shift_amt(shift_amt),\n        .out(out)\n    );\n\nendmodule\nmodule signed_mult(\n    input signed [3:0] A,\n    input signed [3:0] B,\n    output reg signed [7:0] out\n);\n\n    wire [7:0] temp;\n    assign temp = A * B;\n    always @(*) begin\n        out = temp;\n    end\n\nendmodule\nmodule barrel_shifter(\n    input [7:0] in,\n    input [3:0] shift_amt,\n    output reg [15:0] out\n);\n\n    always @(*) begin\n        out = in << shift_amt;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "nios_altmemddr_0_ex_lfsr8_901a5da5", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule nios_altmemddr_0_ex_lfsr8 (\nclk, reset_n, enable, pause, load, data, ldata);\n\n   parameter seed  = 32;\n   input clk;\n   input reset_n;\n   input enable;\n   input pause;\n   input load;\n   output[8 - 1:0] data;\n   wire[8 - 1:0] data;\n   input[8 - 1:0] ldata;\n\n   reg[8 - 1:0] lfsr_data;\n\n   assign data = lfsr_data ;\n\n   always @(posedge clk or negedge reset_n)\n   begin\n      if (!reset_n)\n      begin\n         lfsr_data <= seed[7:0] ;\n      end\n      else\n      begin\n         if (!enable)\n         begin\n            lfsr_data <= seed[7:0];\n         end\n         else\n         begin\n            if (load)\n            begin\n               lfsr_data <= ldata ;\n            end\n            else\n            begin\n               if (!pause)\n               begin\n                  lfsr_data[0] <= lfsr_data[7] ;\n                  lfsr_data[1] <= lfsr_data[0] ;\n                  lfsr_data[2] <= lfsr_data[1] ^ lfsr_data[7] ;\n                  lfsr_data[3] <= lfsr_data[2] ^ lfsr_data[7] ;\n                  lfsr_data[4] <= lfsr_data[3] ^ lfsr_data[7] ;\n                  lfsr_data[5] <= lfsr_data[4] ;\n                  lfsr_data[6] <= lfsr_data[5] ;\n                  lfsr_data[7] <= lfsr_data[6] ;\n               end\n            end\n         end\n      end\n   end\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "binary_decoder_3to8_a5cfd204", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule binary_decoder_3to8 (\n    input [2:0] in,      // 3-bit input\n    output reg [7:0] out // 8-bit output\n);\n\n    always @(*) begin\n        // Initialize output to 0\n        out = 8'b00000000;\n\n        // Decode the input to one-hot output\n        case (in)\n            3'b000: out[0] = 1'b1;\n            3'b001: out[1] = 1'b1;\n            3'b010: out[2] = 1'b1;\n            3'b011: out[3] = 1'b1;\n            3'b100: out[4] = 1'b1;\n            3'b101: out[5] = 1'b1;\n            3'b110: out[6] = 1'b1;\n            3'b111: out[7] = 1'b1;\n            default: out = 8'b00000000; // Default case to handle unknown states\n        endcase\n    end\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_reset_1ac74fbc", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule dff_reset (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output [7:0] q\n);\n\nreg [7:0] q_reg;\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        q_reg <= 8'b0;\n    end else begin\n        q_reg <= d;\n    end\nend\n\nassign q = q_reg;\n\nendmodule\n\nmodule counter (\n    input clk,\n    input reset,\n    output reg [2:0] count\n);\n\nalways @(posedge clk, posedge reset) begin\n    if (reset) begin\n        count <= 3'b0;\n    end else begin\n        if (count == 3'b111) begin\n            count <= 3'b0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nend\n\nendmodule\n\nmodule and_module (\n    input [7:0] d,\n    input [2:0] count,\n    output [7:0] q\n);\n\nassign q = d & {3{count[2]}} & {3{count[1]}} & {3{count[0]}};\n\nendmodule\n\nmodule top_module (\n    input clk,\n    input reset,\n    input [7:0] d,\n    output [7:0] q\n);\n\nwire [2:0] count;\nwire [7:0] dff_out;\n\ndff_reset dff_inst (\n    .clk(clk),\n    .reset(count[2]),\n    .d(d),\n    .q(dff_out)\n);\n\ncounter counter_inst (\n    .clk(clk),\n    .reset(reset),\n    .count(count)\n);\n\nand_module and_inst (\n    .d(dff_out),\n    .count(count),\n    .q(q)\n);\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "signalinput_a0ac6f52", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule signalinput(\n    input [1:0] testmode,\n    input sysclk,\n    output sigin1\n);\n\nreg [20:0] state;\nreg [20:0] divide;\nreg sigin;\n\nassign sigin1 = sigin;\n\ninitial\nbegin\n    sigin = 0;\n    state = 21'b000000000000000000000;\n    divide = 21'b0_0000_0111_1101_0000_0000;\nend\n\nalways @(testmode)\nbegin\n    case(testmode[1:0])\n    2'b00: divide = 21'b0_0000_0111_1101_0000_0000;  // 3125Hz, divide by 32000\n    2'b01: divide = 21'b0_0000_0011_1110_1000_0000;  // 250Hz, divide by 400000\n    2'b10: divide = 21'b1_1110_1000_0100_1000_0000;  // 50Hz, divide by 2000000\n    2'b11: divide = 21'b0_0000_0001_1111_0100_0000;  // 12500Hz, divide by 8000\n    endcase\nend\n\nalways @(posedge sysclk)\nbegin\n    if(state == 0)\n        sigin = ~sigin;\n    state = state + 21'd2;\n    if(state == divide)\n        state = 0;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "axi_timer_ce8c251c", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule axi_timer\n    #(parameter WIDTH = 32, parameter TICK_RATE = 1)\n    (input clk, rst, enable, load,\n     input [WIDTH-1:0] value,\n     output [WIDTH-1:0] timer,\n     output reg done);\n\n    reg [WIDTH-1:0] load_value;\n    reg [WIDTH-1:0] count;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            count <= 0;\n            done <= 0;\n        end else if (enable) begin\n            if (load) begin\n                load_value <= value;\n                count <= load_value;\n                done <= 0;\n            end else if (count > 0) begin\n                count <= count - 1;\n                done <= 0;\n            end else begin\n                count <= load_value;\n                done <= 1;\n            end\n        end else begin\n            done <= 0;\n        end\n    end\n\n    assign timer = count;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_lp__a32o_1d834cec", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\nmodule sky130_fd_sc_lp__a32o (\n    X ,\n    A1,\n    A2,\n    A3,\n    B1,\n    B2\n);\n\n    output X ;\n    input  A1;\n    input  A2;\n    input  A3;\n    input  B1;\n    input  B2;\n\n    wire and0_out ;\n    wire and1_out ;\n    wire or0_out_X;\n\n    and and0 (and0_out , A3, A1, A2        );\n    and and1 (and1_out , B1, B2            );\n    or  or0  (or0_out_X, and1_out, and0_out);\n    buf buf0 (X        , or0_out_X         );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "i2c_control_9acdf4af", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\n\n\n\nmodule i2c_control\n(\n\tinput clk,\n\tinput reset,\n\t\n\tinput   [2:0]address,\n\tinput        write,\n\tinput  [31:0]writedata,\n\tinput        read,\n\toutput reg [31:0]readdata,\n\n\toutput reg go,\n\tinput full,\n\toutput reg [11:0]memd,\n\toutput memw,\n\tinput busy,\n\toutput tbm,\n\tinput [31:0]rda\n);\n\n\twire [9:0]i2c_data;\n\treg rdbff;\n\n\tassign memw = write & (address>=1) & (address<=5);\n\tassign i2c_data = {writedata[7:4], !writedata[4],\n\t              writedata[3:0], !writedata[0]};\n  always @(*)\n\tcase (address)\n\t\t3'd2: memd <= {2'b00, i2c_data};\n\t\t3'd3: memd <= {2'b10, i2c_data}; 3'd4: memd <= {2'b01, i2c_data}; 3'd5: memd <= {2'b11, i2c_data}; default: memd <= writedata[11:0];\n\tendcase\n\t\n\talways @(*)\n\tcase (address)\n\t\t3'd1:   readdata <= rda;\n\t\tdefault readdata <= {28'h1234_567, 1'b0, full, rdbff, busy || rda[31]};\n\tendcase\n\n\talways @(posedge clk or posedge reset)\n\tbegin\n\t\tif (reset)\n\t\tbegin\n\t\t  rdbff <= 0;\n\t\t  go    <= 0;\n    end\n\t\telse if (write && (address == 3'd0))\n\t\tbegin\n\t\t\trdbff <= writedata[1];\n\t\t\tgo    <= writedata[0];\n\t\tend\n\t\telse go <= 0;\n\tend\n\t\n\tassign tbm = rdbff;\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "full_adder_193e7bc0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule full_adder (A, B, Ci, S, Co);\n  input A, B, Ci;\n  output S, Co;\n  wire n1, n2, n3, n4, n5, n6, n7, n8, n9, n10, n11;\n\n  assign n11 = ~(A ^ B);\n  assign S = ~(Ci ^ n11);\n  assign n10 = ~(A & B & Ci);\n  assign n9 = ~(A & B);\n  assign Co = ~(n10 & n9);\n  assign n1 = ~(Ci & n11);\n  assign n2 = ~(B & n11);\n  assign n3 = ~(A & Ci);\n  assign n4 = ~(n1 & n2);\n  assign n5 = ~(n3 & n9);\n  assign n6 = ~(n3 & n2);\n  assign n7 = ~(n1 & n9);\n  assign n8 = ~(n6 & n7);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "eg_limiter_32582f63", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule eg_limiter(\n\tinput [6:0] lfo_mod,\n\tinput amsen,\n\tinput [1:0] ams,\n\tinput [6:0] tl,\n\tinput [9:0] eg_pure_in,\n\tinput ssg_inv,\n\toutput reg [9:0] eg_limited\n);\n\nreg [8:0] am_final;\nreg [11:0] sum_eg_tl;\nreg [11:0] sum_eg_tl_am;\nreg [5:0] am_inverted;\nreg [9:0] eg_pream;\n\nalways @(*) begin\n\tam_inverted = lfo_mod[6] ? ~lfo_mod[5:0] : lfo_mod[5:0];\nend\n\nalways @(*) begin\n\tcasez({amsen, ams})\n\t\tdefault: am_final = 9'd0;\n\t\t3'b1_01: am_final = {5'd0, am_inverted[5:2]};\n\t\t3'b1_10: am_final = {3'd0, am_inverted};\n\t\t3'b1_11: am_final = {2'd0, am_inverted, 1'b0};\n\tendcase\n\teg_pream = ssg_inv ? (10'h200 - eg_pure_in) : eg_pure_in;\n\tsum_eg_tl = {1'b0, tl, 3'd0} + {1'b0, eg_pream}; // leading zeros needed to compute correctly\n\tsum_eg_tl_am = sum_eg_tl + {3'd0, am_final};\nend\n\nalways @(*)\n\teg_limited = sum_eg_tl_am[11:10] == 2'd0 ? sum_eg_tl_am[9:0] : 10'h3ff;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "state_machine_e7120704", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule state_machine (\n  input clock,\n  input reset,\n  output reg [1:0] state_out,\n  output reg done\n);\n\n  parameter COUNT_TO_DONE = 3;\n\n  localparam IDLE = 2'b00;\n  localparam COUNT = 2'b01;\n  localparam DONE = 2'b10;\n\n  reg [1:0] state;\n\n  always @(posedge clock or negedge reset) begin\n    if (~reset) begin\n      state <= IDLE;\n      state_out <= IDLE;\n      done <= 0;\n    end\n    else begin\n      case (state)\n        IDLE: begin\n          if (clock) begin\n            state <= COUNT;\n            state_out <= COUNT;\n          end\n        end\n        COUNT: begin\n          if (clock) begin\n            if (state_out == COUNT_TO_DONE) begin\n              state <= DONE;\n              state_out <= DONE;\n              done <= 1;\n            end\n            else begin\n              state_out <= state_out + 1;\n            end\n          end\n        end\n        DONE: begin\n          if (clock) begin\n            done <= 1;\n          end\n        end\n      endcase\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_9941dd19", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder(\n    input [3:0] a,\n    input [3:0] b,\n    input enable,\n    output reg [3:0] sum\n);\n\nalways @ (a, b, enable)\nbegin\n    if(enable == 1'b1)\n        sum = a + b;\n    else\n        sum = 4'b0000;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "xor_module_fcb7417f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule xor_module(\n    input [3:0] a,\n    output [3:0] b\n);\n\n    // Define constant value\n    parameter [3:0] c = 4'b1011;\n\n    // Perform XOR operation between a and c\n    assign b = a ^ c;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "system_controller_4c735cf8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule system_controller(\n   clk_sys, reset_sys, locked,\n   clk_in, reset_in\n   );\n   input wire clk_in;\n   output wire clk_sys;\n   input  wire reset_in;\n   output wire reset_sys;   \n   output wire locked;\n   \n    \n   `ifdef XILINX\n   wire                         xclk_buf;\n   IBUFG xclk_ibufg(.I(clk_in), .O(xclk_buf));\n   wire                         locked;\n`else\n   assign locked = 1;\n   \n`endif\n   \n\n   reg [5:0]                    reset_count = 6'h0;\n   assign reset_sys = reset_in | ~locked | (|reset_count);   \n   \n   always @(posedge clk_in)\n     if (reset_in | ~locked) begin\n        reset_count <= 6'h1;        \n     end else begin\n        if (reset_count) begin\n           reset_count <= reset_count + 1;           \n        end\n     end\n   \n   `ifdef XILINX   \n   BUFG clk_bug (\n                 .O(clk_sys), .I(CLKFBOUT) );\n\n   clk_wiz_0 lab9_clocks\n     (\n      .clk_in1(xclk_buf),      .clk_out1(CLKFBOUT),     .reset(reset_in), .locked(locked));      `else assign clk_sys = clk_in;   \n   \n`endif endmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "multiply_complex #_9509568e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule multiply_complex #(parameter WIDTH = 32)\n  (\n    input wire clk,\n    input wire rst_n,\n    input wire signed [WIDTH-1:0] x,\n    input wire signed [WIDTH-1:0] y,\n    output reg signed [2*WIDTH-1:0] z\n  );\n\n  reg signed [2*WIDTH-1:0] temp_z;\n\n  always @ (posedge clk)\n  begin\n    if (~rst_n)\n    begin\n      temp_z <= 0;\n      z <= 0;\n    end\n    else\n    begin\n      temp_z <= x * y;\n      z <= temp_z >> WIDTH;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_9b15c05d", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator(\n    input [7:0] a,\n    input [7:0] b,\n    input [1:0] op,\n    output reg [7:0] result\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = a + b;\n        2'b01: result = a - b;\n        2'b10: result = a * b;\n        2'b11: result = a / b;\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "top__b444f542", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule top_module (\n    input clk,\n    input reset, // Synchronous active-high reset\n    input [2:0] input_data, // 3-bit input data\n    input control, // Control signal for the multiplexer\n    output reg [2:0] counter_out, // 3-bit output from the counter\n    output reg [2:0] xor_out // 3-bit output from the XOR module\n);\n\nreg [2:0] counter;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter <= 3'b000;\n    end\n    else if (counter == 3'b111) begin\n        counter <= 3'b000;\n    end\n    else begin\n        counter <= counter + 1;\n    end\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        xor_out <= 3'b000;\n    end\n    else begin\n        case (control)\n            1'b0: xor_out <= counter ^ input_data;\n            1'b1: xor_out <= counter_out ^ input_data;\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (reset) begin\n        counter_out <= 3'b000;\n    end\n    else begin\n        case (control)\n            1'b0: counter_out <= counter;\n            1'b1: counter_out <= counter_out;\n        endcase\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "DelayTest_c3de9d7e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule DelayTest(\n    input clk,\n    input reset,\n    input [3:0] data,\n    output reg [3:0] out1,\n    output reg [3:0] out2,\n    output reg [3:0] out3\n);\n\n  // Test different delays.\n  always @(posedge clk) begin\n    if (reset) begin\n      out1 <= 0;\n      out2 <= 0;\n      out3 <= 0;\n    end else begin\n      out1 <= data;\n      out2 <= out1;\n      out3 <= out2;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "mux4_88907058", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule mux4(input [3:0] in, input [1:0] sel, output reg out);\n\nalways @(*) begin\n    case(sel)\n        2'b00: out = in[0];\n        2'b01: out = in[1];\n        2'b10: out = in[2];\n        2'b11: out = in[3];\n    endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sd2_dac_a6f55e23", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule sd2_dac (\n\tinput \t\t\tclk,\t\t\tinput\t[15:0]\tldatasum,\tinput\t[15:0] \trdatasum,\toutput\treg \tleft=0,\t\toutput\treg \tright=0\t\t);\n\nlocalparam DW = 16;\nlocalparam CW = 2;\nlocalparam RW  = 4;\nlocalparam A1W = 2;\nlocalparam A2W = 5;\n\nwire [DW+2+0  -1:0] sd_l_er0, sd_r_er0;\nreg  [DW+2+0  -1:0] sd_l_er0_prev=0, sd_r_er0_prev=0;\nwire [DW+A1W+2-1:0] sd_l_aca1,  sd_r_aca1;\nwire [DW+A2W+2-1:0] sd_l_aca2,  sd_r_aca2;\nreg  [DW+A1W+2-1:0] sd_l_ac1=0, sd_r_ac1=0;\nreg  [DW+A2W+2-1:0] sd_l_ac2=0, sd_r_ac2=0;\nwire [DW+A2W+3-1:0] sd_l_quant, sd_r_quant;\n\nreg [24-1:0] seed1 = 24'h654321;\nreg [19-1:0] seed2 = 19'h12345;\nreg [24-1:0] seed_sum=0, seed_prev=0, seed_out=0;\nalways @ (posedge clk) begin\n  if (&seed1)\n    seed1 <= 24'h654321;\n  else\n    seed1 <= {seed1[22:0], ~(seed1[23] ^ seed1[22] ^ seed1[21] ^ seed1[16])};\nend\nalways @ (posedge clk) begin\n  if (&seed2)\n    seed2 <= 19'h12345;\n  else\n    seed2 <= {seed2[17:0], ~(seed2[18] ^ seed2[17] ^ seed2[16] ^ seed2[13] ^ seed2[0])};\nend\nalways @ (posedge clk) begin\n  seed_sum  <= seed1 + {5'b0, seed2};\n  seed_prev <= seed_sum;\n  seed_out  <= seed_sum - seed_prev;\nend\n\nlocalparam ID=4; reg  [ID+0-1:0] int_cnt = 0;\nalways @ (posedge clk) int_cnt <= int_cnt + 'd1;\n\nreg  [DW+0-1:0] ldata_cur=0, ldata_prev=0;\nreg  [DW+0-1:0] rdata_cur=0, rdata_prev=0;\nwire [DW+1-1:0] ldata_step, rdata_step;\nreg  [DW+ID-1:0] ldata_int=0, rdata_int=0;\nwire [DW+0-1:0] ldata_int_out, rdata_int_out;\nassign ldata_step = {ldata_cur[DW-1], ldata_cur} - {ldata_prev[DW-1], ldata_prev}; assign rdata_step = {rdata_cur[DW-1], rdata_cur} - {rdata_prev[DW-1], rdata_prev}; always @ (posedge clk) begin\n  if (~|int_cnt) begin\n    ldata_prev <= ldata_cur;\n    ldata_cur  <= ldatasum; rdata_prev <= rdata_cur;\n    rdata_cur  <= rdatasum; ldata_int  <= {ldata_cur[DW-1], ldata_cur, {ID{1'b0}}};\n    rdata_int  <= {rdata_cur[DW-1], rdata_cur, {ID{1'b0}}};\n  end else begin\n    ldata_int  <= ldata_int + {{ID{ldata_step[DW+1-1]}}, ldata_step};\n    rdata_int  <= rdata_int + {{ID{rdata_step[DW+1-1]}}, rdata_step};\n  end\nend\nassign ldata_int_out = ldata_int[DW+ID-1:ID];\nassign rdata_int_out = rdata_int[DW+ID-1:ID];\n\nwire [DW+2-1:0] ldata_gain, rdata_gain;\nassign ldata_gain = {ldata_int_out[DW-1], ldata_int_out, 1'b0} + {{(2){ldata_int_out[DW-1]}}, ldata_int_out};\nassign rdata_gain = {rdata_int_out[DW-1], rdata_int_out, 1'b0} + {{(2){rdata_int_out[DW-1]}}, rdata_int_out};\n\n\n\n\nassign sd_l_aca1 = {{(A1W){ldata_gain[DW+2-1]}}, ldata_gain} - {{(A1W){sd_l_er0[DW+2-1]}}, sd_l_er0} + sd_l_ac1;\nassign sd_r_aca1 = {{(A1W){rdata_gain[DW+2-1]}}, rdata_gain} - {{(A1W){sd_r_er0[DW+2-1]}}, sd_r_er0} + sd_r_ac1;\n\nassign sd_l_aca2 = {{(A2W-A1W){sd_l_aca1[DW+A1W+2-1]}}, sd_l_aca1} - {{(A2W){sd_l_er0[DW+2-1]}}, sd_l_er0} - {{(A2W+1){sd_l_er0_prev[DW+2-1]}}, sd_l_er0_prev[DW+2-1:1]} + sd_l_ac2;\nassign sd_r_aca2 = {{(A2W-A1W){sd_r_aca1[DW+A1W+2-1]}}, sd_r_aca1} - {{(A2W){sd_r_er0[DW+2-1]}}, sd_r_er0} - {{(A2W+1){sd_r_er0_prev[DW+2-1]}}, sd_r_er0_prev[DW+2-1:1]} + sd_r_ac2;\n\nalways @ (posedge clk) begin\n  sd_l_ac1 <= sd_l_aca1;\n  sd_r_ac1 <= sd_r_aca1;\n  sd_l_ac2 <= sd_l_aca2;\n  sd_r_ac2 <= sd_r_aca2;\nend\n\nassign sd_l_quant = {sd_l_ac2[DW+A2W+2-1], sd_l_ac2} + {{(DW+A2W+3-RW){seed_out[RW-1]}}, seed_out[RW-1:0]};\nassign sd_r_quant = {sd_r_ac2[DW+A2W+2-1], sd_r_ac2} + {{(DW+A2W+3-RW){seed_out[RW-1]}}, seed_out[RW-1:0]};\n\nassign sd_l_er0 = sd_l_quant[DW+A2W+3-1] ? {1'b1, {(DW+2-1){1'b0}}} : {1'b0, {(DW+2-1){1'b1}}};\nassign sd_r_er0 = sd_r_quant[DW+A2W+3-1] ? {1'b1, {(DW+2-1){1'b0}}} : {1'b0, {(DW+2-1){1'b1}}};\nalways @ (posedge clk) begin\n  sd_l_er0_prev <= (&sd_l_er0) ? sd_l_er0 : sd_l_er0+1;\n  sd_r_er0_prev <= (&sd_r_er0) ? sd_r_er0 : sd_r_er0+1;\nend\n\nalways @ (posedge clk) begin\n  left  <= (~|ldata_gain) ? ~left  : ~sd_l_er0[DW+2-1];\n  right <= (~|rdata_gain) ? ~right : ~sd_r_er0[DW+2-1];\nend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "four_bit_adder_6f6daa1e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule four_bit_adder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    input Clock,\n    output [3:0] Sum,\n    output Cout\n);\n\nreg [3:0] Sum;\nreg Cout;\n\nalways @(posedge Clock) begin\n    {Cout, Sum} = A + B + Cin;\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "state__7335ca8a", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule state_module ( g, p, g_prec, p_prec, g_out, p_out );\n  input g, p, g_prec, p_prec;\n  output g_out, p_out;\n  wire   n5, p_prec_inv;\n\n  // Inverting p_prec\n  not U4 ( p_prec_inv, p_prec);\n\n  // AND-OR-INVERT gate\n  and ( n5, p_prec_inv, g_prec);\n  or ( g_out, p, n5);\n\n  // AND gate\n  and ( p_out, p, p_prec);\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "div_top_cd7e5123", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule div_top(\n    clk,\n    reset,\n    ce,\n    din0,\n    din1,\n    dout);\n\nparameter ID = 32'd1;\nparameter NUM_STAGE = 32'd1;\nparameter din0_WIDTH = 32'd1;\nparameter din1_WIDTH = 32'd1;\nparameter dout_WIDTH = 32'd1;\n\ninput clk;\ninput reset;\ninput ce;\ninput[din0_WIDTH - 1:0] din0;\ninput[din1_WIDTH - 1:0] din1;\noutput[dout_WIDTH - 1:0] dout;\n\nwire[dout_WIDTH - 1:0] sig_remd;\n\ndiv #(\n.in0_WIDTH( din0_WIDTH ),\n.in1_WIDTH( din1_WIDTH ),\n.out_WIDTH( dout_WIDTH ))\ndiv_U(\n    .dividend( din0 ),\n    .divisor( din1 ),\n    .quot( dout ),\n    .remd( sig_remd ),\n    .clk( clk ),\n    .ce( ce ),\n    .reset( reset ));\n\nendmodule\nmodule div #(\nparameter in0_WIDTH = 32,\nparameter in1_WIDTH = 32,\nparameter out_WIDTH = 32)\n(\n    input [in0_WIDTH - 1:0] dividend,\n    input [in1_WIDTH - 1:0] divisor,\n    output reg [out_WIDTH - 1:0] quot,\n    output reg [out_WIDTH - 1:0] remd,\n    input clk,\n    input ce,\n    input reset);\n\n    reg [in0_WIDTH - 1:0] temp_dividend;\n    reg [in1_WIDTH - 1:0] temp_divisor;\n    reg [out_WIDTH - 1:0] temp_quot;\n    reg [out_WIDTH - 1:0] temp_remd;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            temp_dividend <= 0;\n            temp_divisor <= 0;\n            temp_quot <= 0;\n            temp_remd <= 0;\n        end else if (ce) begin\n            temp_dividend <= dividend;\n            temp_divisor <= divisor;\n            temp_quot <= quot;\n            temp_remd <= remd;\n\n            if (temp_divisor == 0) begin\n                temp_quot <= 0;\n                temp_remd <= temp_dividend;\n            end else begin\n                temp_quot <= temp_dividend / temp_divisor;\n                temp_remd <= temp_dividend % temp_divisor;\n            end\n        end\n    end\n\n    always @(*) begin\n        quot <= temp_quot;\n        remd <= temp_remd;\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "delay__a7f957b8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule delay_module (\n    input clk,\n    input reset,\n    input [3:0] in,\n    output reg [3:0] out\n);\n\nreg [3:0] delay_reg1;\nreg [3:0] delay_reg2;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        delay_reg1 <= 4'b0;\n        delay_reg2 <= 4'b0;\n        out <= 4'b0;\n    end else begin\n        delay_reg1 <= in;\n        delay_reg2 <= delay_reg1;\n        out <= delay_reg2;\n    end\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fmrv32im_axim_8ce45836", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule fmrv32im_axim\n  (\n   input         RST_N,\n   input         CLK,\n\n   output [0:0]  M_AXI_AWID,\n   output [31:0] M_AXI_AWADDR,\n   output [7:0]  M_AXI_AWLEN,\n   output [2:0]  M_AXI_AWSIZE,\n   output [1:0]  M_AXI_AWBURST,\n   output        M_AXI_AWLOCK,\n   output [3:0]  M_AXI_AWCACHE,\n   output [2:0]  M_AXI_AWPROT,\n   output [3:0]  M_AXI_AWQOS,\n   output [0:0]  M_AXI_AWUSER,\n   output        M_AXI_AWVALID,\n   input         M_AXI_AWREADY,\n\n   output [31:0] M_AXI_WDATA,\n   output [3:0]  M_AXI_WSTRB,\n   output        M_AXI_WLAST,\n   output [0:0]  M_AXI_WUSER,\n   output        M_AXI_WVALID,\n   input         M_AXI_WREADY,\n\n   input [0:0]   M_AXI_BID,\n   input [1:0]   M_AXI_BRESP,\n   input [0:0]   M_AXI_BUSER,\n   input         M_AXI_BVALID,\n   output        M_AXI_BREADY,\n\n   output [0:0]  M_AXI_ARID,\n   output [31:0] M_AXI_ARADDR,\n   output [7:0]  M_AXI_ARLEN,\n   output [2:0]  M_AXI_ARSIZE,\n   output [1:0]  M_AXI_ARBURST,\n   output [1:0]  M_AXI_ARLOCK,\n   output [3:0]  M_AXI_ARCACHE,\n   output [2:0]  M_AXI_ARPROT,\n   output [3:0]  M_AXI_ARQOS,\n   output [0:0]  M_AXI_ARUSER,\n   output        M_AXI_ARVALID,\n   input         M_AXI_ARREADY,\n\n   input [0:0]   M_AXI_RID,\n   input [31:0]  M_AXI_RDATA,\n   input [1:0]   M_AXI_RRESP,\n   input         M_AXI_RLAST,\n   input [0:0]   M_AXI_RUSER,\n   input         M_AXI_RVALID,\n   output        M_AXI_RREADY,\n\n   input         WR_REQ_START,\n   input [31:0]  WR_REQ_ADDR,\n   input [15:0]  WR_REQ_LEN,\n   output        WR_REQ_READY,\n   output [9:0]  WR_REQ_MEM_ADDR,\n   input [31:0]  WR_REQ_MEM_WDATA,\n\n   input         RD_REQ_START,\n   input [31:0]  RD_REQ_ADDR,\n   input [15:0]  RD_REQ_LEN,\n   output        RD_REQ_READY,\n   output        RD_REQ_MEM_WE,\n   output [9:0]  RD_REQ_MEM_ADDR,\n   output [31:0] RD_REQ_MEM_RDATA\n   );\n\n   localparam S_WR_REQ_IDLE  = 3'd0;\n   localparam S_WA_WAIT  = 3'd1;\n   localparam S_WA_START = 3'd2;\n   localparam S_WD_WAIT  = 3'd3;\n   localparam S_WD_PROC  = 3'd4;\n   localparam S_WR_REQ_WAIT  = 3'd5;\n\n   reg [2:0]     WR_REQ_state;\n   reg [31:0]    reg_WR_REQ_adrs;\n   reg [15:0]    reg_WR_REQ_len;\n   reg           reg_awvalid, reg_wvalid, reg_w_last;\n   reg [7:0]     reg_w_len;\n   reg [3:0]     reg_w_stb;\n   reg           reg_w_delay;\n   reg [31:0]    reg_w_data;\n   reg [13:0]    reg_wmem_addr;\n\n   always @(posedge CLK) begin\n      if(!RST_N) begin\n         WR_REQ_state            <= S_WR_REQ_IDLE;\n         reg_WR_REQ_adrs[31:0]   <= 32'd0;\n         reg_WR_REQ_len[15:0]    <= 16'd0;\n         reg_awvalid         <= 1'b0;\n         reg_wvalid          <= 1'b0;\n         reg_w_last          <= 1'b0;\n         reg_w_len[7:0]      <= 8'd0;\n         reg_w_stb[3:0]      <= 4'd0;\n         reg_wmem_addr       <= 13'd0;\n\t\t reg_w_data          <= 1'b0;\n\t\t reg_w_delay         <= 1'b0;\n      end else begin\n         case(WR_REQ_state)\n           S_WR_REQ_IDLE: begin\n              if(WR_REQ_START) begin\n                 WR_REQ_state          <= S_WA_START;\n                 reg_WR_REQ_adrs[31:0] <= WR_REQ_ADDR[31:0];\n                 reg_WR_REQ_len[15:0]  <= WR_REQ_LEN[15:0] -16'd1;\n              end\n              reg_awvalid         <= 1'b0;\n              reg_wvalid          <= 1'b0;\n              reg_w_last          <= 1'b0;\n              reg_w_len[7:0]      <= 8'd0;\n              reg_w_stb[3:0]      <= 4'd0;\n              reg_wmem_addr <= 13'd0;\n           end\n           S_WA_START: begin\n              WR_REQ_state            <= S_WD_WAIT;\n              reg_awvalid         <= 1'b1;\n              reg_WR_REQ_len[15:10]    <= reg_WR_REQ_len[15:10] - 6'd1;\n              if(reg_WR_REQ_len[15:10] != 6'd0) begin\n                 reg_w_len[7:0]  <= 8'hFF;\n                 reg_w_last      <= 1'b0;\n                 reg_w_stb[3:0]  <= 4'hF;\n              end else begin\n                 reg_w_len[7:0]  <= reg_WR_REQ_len[9:2];\n                 reg_w_last      <= 1'b1;\n                 reg_w_stb[3:0]  <= 4'hF;\n              end\n           end\n           S_WD_WAIT: begin\n              if(M_AXI_AWREADY) begin\n                 WR_REQ_state        <= S_WD_PROC;\n                 reg_awvalid     <= 1'b0;\n                 reg_wvalid      <= 1'b1;\n                 reg_wmem_addr  <= reg_wmem_addr +13'd1;\n              end\n           end\n           S_WD_PROC: begin\n              if(M_AXI_WREADY) begin\n                 if(reg_w_len[7:0] == 8'd0) begin\n                    WR_REQ_state        <= S_WR_REQ_WAIT;\n                    reg_wvalid      <= 1'b0;\n                    reg_w_stb[3:0]  <= 4'h0;\n                 end else begin\n                    reg_w_len[7:0]  <= reg_w_len[7:0] -8'd1;\n                    reg_wmem_addr  <= reg_wmem_addr +13'd1;\n                 end\n              end\n           end\n           S_WR_REQ_WAIT: begin\n              if(M_AXI_BVALID) begin\n                 if(reg_w_last) begin\n                    WR_REQ_state          <= S_WR_REQ_IDLE;\n                 end else begin\n                    WR_REQ_state          <= S_WA_START;\n                    reg_WR_REQ_adrs[31:0] <= reg_WR_REQ_adrs[31:0] + 32'd1024;\n                 end\n              end\n           end\n           default: begin\n              WR_REQ_state <= S_WR_REQ_IDLE;\n           end\n         endcase\n      end\n\n      reg_w_delay <= M_AXI_WREADY;\n      if((WR_REQ_state == S_WA_START) |\n         ((WR_REQ_state == S_WD_PROC) & reg_w_delay)) begin\n         reg_w_data <= WR_REQ_MEM_WDATA;\n      end\n   end\n\n   assign M_AXI_AWID         = 1'b0;\n   assign M_AXI_AWADDR[31:0] = reg_WR_REQ_adrs[31:0];\n   assign M_AXI_AWLEN[7:0]   = reg_w_len[7:0];\n   assign M_AXI_AWSIZE[2:0]  = 2'b010;\n   assign M_AXI_AWBURST[1:0] = 2'b01;\n   assign M_AXI_AWLOCK       = 1'b0;\n   assign M_AXI_AWCACHE[3:0] = 4'b0011;\n   assign M_AXI_AWPROT[2:0]  = 3'b000;\n   assign M_AXI_AWQOS[3:0]   = 4'b0000;\n   assign M_AXI_AWUSER[0]    = 1'b1;\n   assign M_AXI_AWVALID      = reg_awvalid;\n\nassign M_AXI_WDATA[31:0]  = (reg_w_delay)?WR_REQ_MEM_WDATA:reg_w_data;\n   assign M_AXI_WSTRB[3:0]   = (reg_wvalid)?reg_w_stb:4'h0;\n   assign M_AXI_WLAST        = (reg_w_len[7:0] == 8'd0)?1'b1:1'b0;\n   assign M_AXI_WUSER        = 1;\n   assign M_AXI_WVALID       = reg_wvalid;\n\n   assign M_AXI_BREADY       = (WR_REQ_state == S_WR_REQ_WAIT)?1'b1:1'b0;\n\n   assign WR_REQ_READY           = (WR_REQ_state == S_WR_REQ_IDLE)?1'b1:1'b0;\n   assign WR_REQ_MEM_ADDR        = reg_wmem_addr;\n\n   localparam S_RD_REQ_IDLE    = 3'd0;\n   localparam S_RS_REQUEST = 3'd1;\n   localparam S_RA_WAIT    = 3'd2;\n   localparam S_RA_START   = 3'd3;\n   localparam S_RD_REQ_WAIT    = 3'd4;\n   localparam S_RD_REQ_PROC    = 3'd5;\n\n   reg [2:0]   RD_REQ_state;\n   reg [31:0]  reg_RD_REQ_adrs;\n   reg [15:0]  reg_RD_REQ_len;\n   reg         reg_arvalid, reg_r_last;\n   reg [7:0]   reg_r_len;\n   reg [13:0]  reg_rmem_addr;\n\n   always @(posedge CLK or negedge RST_N) begin\n      if(!RST_N) begin\n         RD_REQ_state          <= S_RD_REQ_IDLE;\n         reg_RD_REQ_adrs[31:0] <= 32'd0;\n         reg_RD_REQ_len[15:0]  <= 16'd0;\n         reg_arvalid       <= 1'b0;\n         reg_r_len[7:0]    <= 8'd0;\n         reg_r_last        <= 1'b0;\n         reg_rmem_addr     <= 13'd0;\n      end else begin\n         case(RD_REQ_state)\n           S_RD_REQ_IDLE: begin\n              if(RD_REQ_START) begin\n                 RD_REQ_state          <= S_RA_START;\n                 reg_RD_REQ_adrs[31:0] <= RD_REQ_ADDR[31:0];\n                 reg_RD_REQ_len[15:0]  <= RD_REQ_LEN[15:0] -16'd1;\n              end\n              reg_arvalid     <= 1'b0;\n              reg_r_len[7:0]  <= 8'd0;\n              reg_rmem_addr   <= 13'd0;\n           end\n           S_RA_START: begin\n              RD_REQ_state          <= S_RD_REQ_WAIT;\n              reg_arvalid       <= 1'b1;\n              reg_RD_REQ_len[15:10] <= reg_RD_REQ_len[15:10] -6'd1;\n              if(reg_RD_REQ_len[15:10] != 16'd0) begin\n                 reg_r_last      <= 1'b0;\n                 reg_r_len[7:0]  <= 8'd255;\n              end else begin\n                 reg_r_last      <= 1'b1;\n                 reg_r_len[7:0]  <= reg_RD_REQ_len[9:2];\n              end\n           end\n           S_RD_REQ_WAIT: begin\n              if(M_AXI_ARREADY) begin\n                 RD_REQ_state        <= S_RD_REQ_PROC;\n                 reg_arvalid     <= 1'b0;\n              end\n           end\n           S_RD_REQ_PROC: begin\n              if(M_AXI_RVALID) begin\n                 reg_rmem_addr <= reg_rmem_addr +1;\n                 if(M_AXI_RLAST) begin\n                    if(reg_r_last) begin\n                       RD_REQ_state          <= S_RD_REQ_IDLE;\n                    end else begin\n                       RD_REQ_state          <= S_RA_START;\n                       reg_RD_REQ_adrs[31:0] <= reg_RD_REQ_adrs[31:0] + 32'd1024;\n                    end\n                 end else begin\n                    reg_r_len[7:0] <= reg_r_len[7:0] -8'd1;\n                 end\n              end\n           end\n         endcase\n      end\n   end\n\n   assign M_AXI_ARID         = 1'b0;\n   assign M_AXI_ARADDR[31:0] = reg_RD_REQ_adrs[31:0];\n   assign M_AXI_ARLEN[7:0]   = reg_r_len[7:0];\n   assign M_AXI_ARSIZE[2:0]  = 3'b010;\n   assign M_AXI_ARBURST[1:0] = 2'b01;\n   assign M_AXI_ARLOCK       = 1'b0;\n   assign M_AXI_ARCACHE[3:0] = 4'b0011;\n   assign M_AXI_ARPROT[2:0]  = 3'b000;\n   assign M_AXI_ARQOS[3:0]   = 4'b0000;\n   assign M_AXI_ARUSER[0]    = 1'b1;\n   assign M_AXI_ARVALID      = reg_arvalid;\n\n   assign M_AXI_RREADY       = 1'b1;\n\n   assign RD_REQ_READY           = (RD_REQ_state == S_RD_REQ_IDLE)?1'b1:1'b0;\n   assign RD_REQ_MEM_WE          = M_AXI_RVALID;\n   assign RD_REQ_MEM_ADDR        = reg_rmem_addr;\n   assign RD_REQ_MEM_RDATA        = M_AXI_RDATA[31:0];\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "vec_multiplier_d1243cd1", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule vec_multiplier (\n  input clk, rst,\n  input signed [7:0] vector1,\n  input signed [7:0] vector2,\n  output reg signed [15:0] product\n);\n\n  always @(posedge clk) begin\n    if (rst) begin\n      product <= 0;\n    end\n    else begin\n      product <= vector1 * vector2;\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "fourBitAdder_2460be75", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule fourBitAdder(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] Sum,\n    output Cout\n);\n\n    wire [4:0] temp_sum;\n\n    assign temp_sum = A + B + Cin;\n    assign Sum = temp_sum[3:0];\n    assign Cout = temp_sum[4];\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "sky130_fd_sc_hd__and2_1_e96a68f2", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule sky130_fd_sc_hd__and2_1 (\n    A,\n    B,\n    X\n);\n\n    input  A;\n    input  B;\n    output X;\n\n    wire _TECHMAP_FAIL_ = A && B;\n\n    assign X = _TECHMAP_FAIL_;\n\nendmodule\n\nmodule my_module (\n    Y   ,\n    A1  ,\n    A2  ,\n    B1  ,\n    B2  ,\n    VPWR,\n    VGND,\n    VPB ,\n    VNB\n);\n\n    output Y   ;\n    input  A1  ;\n    input  A2  ;\n    input  B1  ;\n    input  B2  ;\n    input  VPWR;\n    input  VGND;\n    input  VPB ;\n    input  VNB ;\n\n    sky130_fd_sc_hd__and2_1 base (\n        .A(A1),\n        .B(A2),\n        .X(Y)\n    );\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "dff_ram_7389af5e", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule dff_ram (\n    input clk,\n    input rst_n,\n    input [3:0] d,\n    input we,\n    input [7:0] waddr,\n    input re,\n    input [7:0] raddr,\n    output reg [3:0] q\n);\n\n    reg [3:0] ram [0:7];\n    reg [2:0] read_ptr;\n    reg [2:0] write_ptr;\n    reg [2:0] next_write_ptr;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            q <= 4'b0;\n            read_ptr <= 3'b0;\n            write_ptr <= 3'b0;\n            next_write_ptr <= 3'b0;\n        end else begin\n            if (we) begin\n                ram[waddr][3:0] <= d;\n                next_write_ptr <= write_ptr + 1;\n            end\n            write_ptr <= next_write_ptr;\n            if (re) begin\n                q <= ram[raddr][3:0] ^ q;\n                read_ptr <= read_ptr + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule xor_ram (\n    input clk,\n    input rst_n,\n    input [7:0] write_addr,\n    input [3:0] write_data,\n    input read_en,\n    input [7:0] read_addr,\n    output reg [7:0] final_output\n);\n\n    reg [3:0] dff_data;\n    wire [3:0] ram_data;\n    wire [7:0] read_ptr;\n    wire [7:0] write_ptr;\n\n    dff_ram dff_ram_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .d(dff_data),\n        .we(1'b1),\n        .waddr(write_addr),\n        .re(read_en),\n        .raddr(read_addr),\n        .q(ram_data)\n    );\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            final_output <= 8'b0;\n        end else begin\n            dff_data <= write_data;\n            final_output <= {ram_data, dff_data};\n        end\n    end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "uart_tx_0ce38646", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule uart_tx\n#(\n    parameter RTX_EXTERNAL_OVERRIDE = \"NO\"\n)\n(\n\tinput clk_i, rst_i,\n\n\tinput tx_start_i,\n\tinput [7:0] din_bi,\n\n\tinput locked_i,\n\tinput [28:0] bitperiod_i,\n\n\toutput reg tx_done_tick_o,\n\toutput reg tx_o\n);\n\nreg [7:0] \tdatabuf;\nreg [3:0] \tstate;\nreg [31:0] \tclk_counter;\nreg [2:0] \tbit_counter;\n\nlocalparam ST_IDLE \t\t= 8'h0;\nlocalparam ST_START \t= 8'h1;\nlocalparam ST_TX_DATA \t= 8'h2;\nlocalparam ST_STOP \t\t= 8'h3;\n\n\nalways @(posedge clk_i)\n\tbegin\n\tif (rst_i)\n\t\tbegin\n\t\tstate <= ST_IDLE;\n\t\tdatabuf <= 8'h0;\n\t\tclk_counter <= 32'h0;\n\t\ttx_o <= 1'b1;\n\t\ttx_done_tick_o <= 1'b0;\n\t\tend\n\telse \n\t\tbegin\n\t\t\n\t\t\n\t\tif (RTX_EXTERNAL_OVERRIDE == \"NO\") tx_done_tick_o <= 1'b0;\n\t\telse tx_done_tick_o <= 1'b1;\n\n\t\t\n\t\tcase (state)\n\n\t\t\tST_IDLE:\n\t\t\t\tbegin\n\t\t\t\ttx_o <= 1'b1;\n\t\t\t\tif ((tx_start_i == 1'b1) && (locked_i == 1'b1))\n\t\t\t\t\tbegin\n\t\t\t\t\ttx_o <= 1'b0;\n\t\t\t\t\tstate <= ST_START;\n\t\t\t\t\tdatabuf <= din_bi;\n\t\t\t\t\tclk_counter <= 32'h0;\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\tST_START:\n\t\t\t\tbegin\n\t\t\t\tclk_counter <= clk_counter + 32'h1;\n\t\t\t\tif (clk_counter == {3'h0, bitperiod_i})\n\t\t\t\t\tbegin\n\t\t\t\t\tstate <= ST_TX_DATA;\n\t\t\t\t\tclk_counter <= 32'h0;\n\t\t\t\t\tbit_counter <= 3'h0;\n\t\t\t\t\ttx_o <= databuf[0];\n\t\t\t\t\tdatabuf <= {1'b0, databuf[7:1]};\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\tST_TX_DATA:\n\t\t\t\tbegin\n\t\t\t\tclk_counter <= clk_counter + 32'h1;\n\t\t\t\tif (clk_counter == {3'h0, bitperiod_i})\n\t\t\t\t\tbegin\n\t\t\t\t\tclk_counter <= 32'h0;\n\t\t\t\t\tbit_counter <= bit_counter + 3'h1;\n\t\t\t\t\tif (bit_counter == 3'h7)\n\t\t\t\t\t\tbegin\n\t\t\t\t\t\ttx_o <= 1'b1;\n\t\t\t\t\t\tstate <= ST_STOP;\n\t\t\t\t\t\tend\n\t\t\t\t\telse \n\t\t\t\t\t\tbegin\n\t\t\t\t\t\ttx_o <= databuf[0];\n\t\t\t\t\t\tdatabuf <= {1'b0, databuf[7:1]};\n\t\t\t\t\t\tend\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\t\tST_STOP:\n\t\t\t\tbegin\n\t\t\t\tclk_counter <= clk_counter + 32'h1;\n\t\t\t\tif (clk_counter == {2'h0, bitperiod_i, 1'b0})\t\t// 2 * bit\n\t\t\t\t\tbegin\n\t\t\t\t\ttx_o <= 1'b1;\n\t\t\t\t\ttx_done_tick_o <= 1'b1;\n\t\t\t\t\tstate <= ST_IDLE;\n\t\t\t\t\tend\n\t\t\t\tend\n\n\t\tendcase\n\n\t\tend\n\tend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "calculator_8f7121c9", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule calculator (\n  input [7:0] A,\n  input [7:0] B,\n  input [1:0] op,\n  output reg [7:0] result\n);\n\nalways @(*) begin\n  case(op)\n    2'b00: result = A + B;\n    2'b01: result = A - B;\n    2'b10: result = A * B;\n    2'b11: result = A / B;\n  endcase\nend\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "pcie_core_gtp_pipe_rate #_35daa010", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\n\n\nmodule pcie_core_gtp_pipe_rate #\n(\n\n    parameter PCIE_SIM_SPEEDUP = \"FALSE\",                   parameter TXDATA_WAIT_MAX  = 4'd15                      )\n\n(\n\n    input               RATE_CLK,\n    input               RATE_RST_N,\n    input       [ 1:0]  RATE_RATE_IN,\n    input               RATE_DRP_DONE,\n    input               RATE_RXPMARESETDONE,\n    input               RATE_TXRATEDONE,\n    input               RATE_RXRATEDONE,\n    input               RATE_TXSYNC_DONE,\n    input               RATE_PHYSTATUS,\n    \n    output              RATE_PCLK_SEL,\n    output              RATE_DRP_START,\n    output              RATE_DRP_X16,\n    output      [ 2:0]  RATE_RATE_OUT,\n    output              RATE_TXSYNC_START,\n    output              RATE_DONE,\n    output              RATE_IDLE,\n    output      [ 4:0]  RATE_FSM\n\n);\n\n        reg         [ 1:0]  rate_in_reg1;\n    reg                 drp_done_reg1;\n    reg                 rxpmaresetdone_reg1;\n    reg                 txratedone_reg1;\n    reg                 rxratedone_reg1;\n    reg                 phystatus_reg1;\n    reg                 txsync_done_reg1;\n    \n    reg         [ 1:0]  rate_in_reg2;\n    reg                 drp_done_reg2;\n    reg                 rxpmaresetdone_reg2;\n    reg                 txratedone_reg2;\n    reg                 rxratedone_reg2;\n    reg                 phystatus_reg2;\n    reg                 txsync_done_reg2;\n    \n    wire        [ 2:0]  rate;\n    reg         [ 3:0]  txdata_wait_cnt = 4'd0;\n    reg                 txratedone      = 1'd0;\n    reg                 rxratedone      = 1'd0;\n    reg                 phystatus       = 1'd0;\n    reg                 ratedone        = 1'd0;\n    \n    reg                 pclk_sel =  1'd0; \n    reg         [ 2:0]  rate_out =  3'd0; \n    reg         [ 3:0]  fsm      =  0;                 \n   \n    localparam          FSM_IDLE           = 0; \n    localparam          FSM_TXDATA_WAIT    = 1;           \n    localparam          FSM_PCLK_SEL       = 2; \n    localparam          FSM_DRP_X16_START  = 3;\n    localparam          FSM_DRP_X16_DONE   = 4;   \n    localparam          FSM_RATE_SEL       = 5;\n    localparam          FSM_RXPMARESETDONE = 6; \n    localparam          FSM_DRP_X20_START  = 7;\n    localparam          FSM_DRP_X20_DONE   = 8;   \n    localparam          FSM_RATE_DONE      = 9;\n    localparam          FSM_TXSYNC_START   = 10;\n    localparam          FSM_TXSYNC_DONE    = 11;             \n    localparam          FSM_DONE           = 12; always @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin    \n        rate_in_reg1        <= 2'd0;\n        drp_done_reg1       <= 1'd0;\n        rxpmaresetdone_reg1 <= 1'd0;\n        txratedone_reg1     <= 1'd0;\n        rxratedone_reg1     <= 1'd0;\n        phystatus_reg1      <= 1'd0;\n        txsync_done_reg1    <= 1'd0;\n        rate_in_reg2        <= 2'd0;\n        drp_done_reg2       <= 1'd0;\n        rxpmaresetdone_reg2 <= 1'd0;\n        txratedone_reg2     <= 1'd0;\n        rxratedone_reg2     <= 1'd0;\n        phystatus_reg2      <= 1'd0;\n        txsync_done_reg2    <= 1'd0;\n        end\n    else\n        begin  \n        rate_in_reg1        <= RATE_RATE_IN;\n        drp_done_reg1       <= RATE_DRP_DONE;\n        rxpmaresetdone_reg1 <= RATE_RXPMARESETDONE;\n        txratedone_reg1     <= RATE_TXRATEDONE;\n        rxratedone_reg1     <= RATE_RXRATEDONE;\n        phystatus_reg1      <= RATE_PHYSTATUS;\n        txsync_done_reg1    <= RATE_TXSYNC_DONE;\n        rate_in_reg2        <= rate_in_reg1;\n        drp_done_reg2       <= drp_done_reg1;\n        rxpmaresetdone_reg2 <= rxpmaresetdone_reg1;\n        txratedone_reg2     <= txratedone_reg1;\n        rxratedone_reg2     <= rxratedone_reg1;\n        phystatus_reg2      <= phystatus_reg1;\n        txsync_done_reg2    <= txsync_done_reg1;   \n        end\n        \nend    \n\n\n\nassign rate = (rate_in_reg2 == 2'd1) ? 3'd1 : 3'd0;\n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        txdata_wait_cnt <= 4'd0;\n    else\n    \n        if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt < TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt + 4'd1;\n            \n        else if ((fsm == FSM_TXDATA_WAIT) && (txdata_wait_cnt == TXDATA_WAIT_MAX))\n            txdata_wait_cnt <= txdata_wait_cnt;\n            \n        else\n            txdata_wait_cnt <= 4'd0;\n        \nend \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin   \n        txratedone <= 1'd0;\n        rxratedone <= 1'd0; \n        phystatus  <= 1'd0;\n        ratedone   <= 1'd0;\n        end\n    else\n        begin  \n\n        if ((fsm == FSM_RATE_DONE) || (fsm == FSM_RXPMARESETDONE) || (fsm == FSM_DRP_X20_START) || (fsm == FSM_DRP_X20_DONE))\n        \n            begin\n            \n            if (txratedone_reg2)\n                txratedone <= 1'd1; \n            else\n                txratedone <= txratedone;\n \n            if (rxratedone_reg2)\n                rxratedone <= 1'd1; \n            else\n                rxratedone <= rxratedone;\n  \n            if (phystatus_reg2)\n                phystatus <= 1'd1; \n            else\n                phystatus <= phystatus;\n  \n            if (rxratedone && txratedone && phystatus)\n                ratedone <= 1'd1; \n            else\n                ratedone <= ratedone;\n  \n            end\n  \n        else \n        \n            begin\n            txratedone <= 1'd0;\n            rxratedone <= 1'd0;\n            phystatus  <= 1'd0;\n            ratedone   <= 1'd0;\n            end\n        \n        end\n        \nend    \n\n\n\nalways @ (posedge RATE_CLK)\nbegin\n\n    if (!RATE_RST_N)\n        begin\n        fsm      <= FSM_IDLE;\n        pclk_sel <= 1'd0; \n        rate_out <= 3'd0;                              \n        end\n    else\n        begin\n        \n        case (fsm)\n            \n        FSM_IDLE :\n        \n            begin\n            if (rate_in_reg2 != rate_in_reg1)\n                begin\n                fsm      <= FSM_TXDATA_WAIT;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            else\n                begin\n                fsm      <= FSM_IDLE;\n                pclk_sel <= pclk_sel;\n                rate_out <= rate_out;\n                end\n            end \n            \n        FSM_TXDATA_WAIT :\n        \n            begin\n            fsm      <= (txdata_wait_cnt == TXDATA_WAIT_MAX) ? FSM_PCLK_SEL : FSM_TXDATA_WAIT;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end \n\n        FSM_PCLK_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_SEL : FSM_DRP_X16_START;    \n            pclk_sel <= (rate_in_reg2 == 2'd1);\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X16_DONE : FSM_DRP_X16_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X16_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_SEL : FSM_DRP_X16_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n\n        FSM_RATE_SEL :\n        \n            begin\n            fsm      <= (PCIE_SIM_SPEEDUP == \"TRUE\") ? FSM_RATE_DONE : FSM_RXPMARESETDONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate;                               end    \n            \n        FSM_RXPMARESETDONE :\n        \n            begin\n            fsm      <= (!rxpmaresetdone_reg2) ? FSM_DRP_X20_START : FSM_RXPMARESETDONE;  \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end  \n            \n        FSM_DRP_X20_START :\n            \n            begin\n            fsm      <= (!drp_done_reg2) ? FSM_DRP_X20_DONE : FSM_DRP_X20_START;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_DRP_X20_DONE :\n        \n            begin  \n            fsm      <= drp_done_reg2 ? FSM_RATE_DONE : FSM_DRP_X20_DONE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_RATE_DONE :\n        \n            begin\n            if (ratedone) \n                fsm <= FSM_TXSYNC_START;\n            else      \n                fsm <= FSM_RATE_DONE;\n            \n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end      \n            \n        FSM_TXSYNC_START:\n        \n            begin\n            fsm      <= (!txsync_done_reg2 ? FSM_TXSYNC_DONE : FSM_TXSYNC_START);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n            \n        FSM_TXSYNC_DONE:\n        \n            begin\n            fsm      <= (txsync_done_reg2 ? FSM_DONE : FSM_TXSYNC_DONE);\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end        \n\n        FSM_DONE :  \n          \n            begin  \n            fsm      <= FSM_IDLE;\n            pclk_sel <= pclk_sel;\n            rate_out <= rate_out;\n            end\n               \n        default :\n        \n            begin\n            fsm      <= FSM_IDLE;\n            pclk_sel <= 1'd0; \n            rate_out <= 3'd0;  \n            end\n\n        endcase\n        \n        end\n        \nend \n\n\n\nassign RATE_PCLK_SEL     = pclk_sel;\nassign RATE_DRP_START    = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X20_START); \nassign RATE_DRP_X16      = (fsm == FSM_DRP_X16_START) || (fsm == FSM_DRP_X16_DONE);\nassign RATE_RATE_OUT     = rate_out;\nassign RATE_TXSYNC_START = (fsm == FSM_TXSYNC_START);\nassign RATE_DONE         = (fsm == FSM_DONE);\nassign RATE_IDLE         = (fsm == FSM_IDLE);\nassign RATE_FSM          = {1'd0, fsm};   \n\n\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "Counter7SD_a69c8d33", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule Counter7SD(\n  clock,\n  reset,\n  pause,\n  reverse,\n  data\n  );\ninput             clock;\ninput             reset;\ninput             pause;\ninput             reverse;\noutput reg [6:0]  data;\n       reg [6:0]  temp_data;\nparameter ZERO  = 7'b1111110; parameter ONE   = 7'b0110000; parameter TWO   = 7'b1101101; parameter THREE = 7'b1101101; parameter FOUR  = 7'b0110011; parameter FIVE  = 7'b1011011; parameter SIX   = 7'b1011011; parameter SEVEN = 7'b1110000; parameter EIGHT = 7'b1111111; parameter NINE  = 7'b1111011; \n\nparameter PAUSE = 7'b1100111; parameter HOLD  = 7'b0110111; always @ ( posedge clock ) begin\n  if (pause==0)\n    data <= PAUSE;\n  else\n    data <= temp_data;\n  case(reset)\n    0: temp_data <= HOLD;\n    1: case (pause)\n              0: temp_data <= temp_data;\n        default: case (temp_data)\n                  HOLD:   case (reverse)\n                                  0: temp_data <= ZERO;\n                            default: temp_data <= NINE;\n                          endcase\n                  ZERO:   case (reverse)\n                                  0: temp_data <= ONE;\n                            default: temp_data <= NINE;\n                          endcase\n                  ONE:    case (reverse)\n                                  0: temp_data <= TWO;\n                            default: temp_data <= ZERO;\n                          endcase\n                  TWO:    case (reverse)\n                                  0: temp_data <= THREE;\n                            default: temp_data <= ONE;\n                          endcase\n                  THREE:  case (reverse)\n                                  0: temp_data <= FOUR;\n                            default: temp_data <= TWO;\n                          endcase\n                  FOUR:   case (reverse)\n                                  0: temp_data <= FIVE;\n                            default: temp_data <= THREE;\n                          endcase\n                  FIVE:   case (reverse)\n                                  0: temp_data <= SIX;\n                            default: temp_data <= FOUR;\n                          endcase\n                  SIX:     case (reverse)\n                                  0: temp_data <= SEVEN;\n                            default: temp_data <= FIVE;\n                          endcase\n                  SEVEN:  case (reverse)\n                                  0: temp_data <= EIGHT;\n                            default: temp_data <= SIX;\n                          endcase\n                  EIGHT:  case (reverse)\n                                  0: temp_data <= NINE;\n                            default: temp_data <= SEVEN;\n                          endcase\n                  NINE:   case (reverse)\n                                  0: temp_data <= ZERO;\n                            default: temp_data <= EIGHT;\n                          endcase\n                  default:temp_data <= HOLD;\n                endcase\n       endcase\n  endcase\nend\nendmodule "}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "D_FlipFlop_8b2e6b0f", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule D_FlipFlop (\n  output reg Q,\n  input D,\n  input CLK,\n  input RST\n);\n\n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      Q <= 1'b0;\n    end else begin\n      Q <= D;\n    end\n  end\n\nendmodule\nmodule full_adder (\n  output S,\n  output C_out,\n  input A,\n  input B,\n  input C_in\n);\n\n  wire w1;\n  wire w2;\n\n  assign w1 = A ^ B;\n  assign w2 = A & B;\n\n  wire [0:0] CLK = 1'b0;\n  wire [0:0] RST = 1'b0;\n  wire [0:0] Q;\n\n  D_FlipFlop dffp1(\n    .Q(C_out),\n    .D(w2),\n    .CLK(CLK),\n    .RST(RST)\n  );\n\n  assign S = w1 ^ C_in;\nendmodule\nmodule ripple_adder (\n  output [3:0] Sum,\n  output Cout,\n  input [3:0] A,\n  input [3:0] B,\n  input Cin\n);\n\n  wire [3:0] s;\n  wire [3:0] c;\n\n  full_adder fa0(\n    .S(s[0]),\n    .C_out(c[0]),\n    .A(A[0]),\n    .B(B[0]),\n    .C_in(Cin)\n  );\n\n  full_adder fa1(\n    .S(s[1]),\n    .C_out(c[1]),\n    .A(A[1]),\n    .B(B[1]),\n    .C_in(c[0])\n  );\n\n  full_adder fa2(\n    .S(s[2]),\n    .C_out(c[2]),\n    .A(A[2]),\n    .B(B[2]),\n    .C_in(c[1])\n  );\n\n  full_adder fa3(\n    .S(s[3]),\n    .C_out(Cout),\n    .A(A[3]),\n    .B(B[3]),\n    .C_in(c[2])\n  );\n\n  assign Sum = s;\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ff_inv_c3e5744b", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule ff_inv (\n\tinput clk,\n\tinput reset,\n\tinput [255:0] rx_a,\n\tinput [255:0] rx_p,\n\n\toutput reg tx_done,\n\toutput reg [255:0] tx_a\n);\n\n\treg [255:0] u, v, x, y;\n\treg x_carry, y_carry;\n\n\twire u_even = u[0] == 1'b0;\n\twire v_even = v[0] == 1'b0;\n\twire [256:0] u_minus_v = {1'b0, u} - {1'b0, v};\n\twire [256:0] v_minus_u = {1'b0, v} - {1'b0, u};\n\treg [256:0] x_adder, y_adder;\n\n\n\talways @ (*)\n\tbegin\n\t\tif (x_carry || y_carry)\n\t\tbegin\n\t\t\tx_adder = x + rx_p;\n\t\t\ty_adder = y + rx_p;\n\t\tend\n\t\telse if (u_even || v_even)\n\t\tbegin\n\t\t\tx_adder = x + rx_p;\n\t\t\ty_adder = y + rx_p;\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tx_adder = x - y;\n\t\t\ty_adder = y - x;\n\t\tend\n\tend\n\n\n\talways @ (posedge clk)\n\tbegin\n\t\tif (u == 256'd1 && !tx_done)\n\t\tbegin\n\t\t\ttx_done <= 1'b1;\n\t\t\ttx_a <= x;\n\t\tend\n\t\telse if (v == 256'd1 && !tx_done)\n\t\tbegin\n\t\t\ttx_done <= 1'b1;\n\t\t\ttx_a <= y;\n\t\tend\n\n\t\tif (x_carry || y_carry)\n\t\tbegin\n\t\t\tx <= x_carry ? x_adder[255:0] : x;\n\t\t\ty <= y_carry ? y_adder[255:0] : y;\n\t\t\tx_carry <= 1'b0;\n\t\t\ty_carry <= 1'b0;\n\t\tend\n\t\telse if (u_even || v_even)\n\t\tbegin\n\t\t\tif (u_even)\n\t\t\tbegin\n\t\t\t\tu <= u >> 1;\n\t\t\t\tif (x[0] == 1'b0)\n\t\t\t\t\tx <= x >> 1;\n\t\t\t\telse\n\t\t\t\t\tx <= x_adder[256:1];\n\t\t\tend\n\n\t\t\tif (v_even)\n\t\t\tbegin\n\t\t\t\tv <= v >> 1;\n\t\t\t\tif (y[0] == 1'b0)\n\t\t\t\t\ty <= y >> 1;\n\t\t\t\telse\n\t\t\t\t\ty <= y_adder[256:1];\n\t\t\tend\n\t\tend\n\t\telse\n\t\tbegin\n\t\t\tif (u_minus_v[256] == 1'b0)\tbegin\n\t\t\t\tu <= u_minus_v;\n\t\t\t\tx <= x_adder[255:0];\n\t\t\t\tx_carry <= x_adder[256];\n\t\t\tend\n\t\t\telse\n\t\t\tbegin\n\t\t\t\tv <= v_minus_u;\n\t\t\t\ty <= y_adder[255:0];\n\t\t\t\ty_carry <= y_adder[256];\n\t\t\tend\n\t\tend\n\n\t\tif (reset)\n\t\tbegin\n\t\t\tu <= rx_a;\n\t\t\tv <= rx_p;\n\t\t\tx <= 256'd1;\n\t\t\ty <= 256'd0;\n\t\t\tx_carry <= 1'b0;\n\t\t\ty_carry <= 1'b0;\n\t\t\ttx_done <= 1'b0;\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adler_checksum_a7ce9e67", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adler_checksum (\n  input clk,\n  input reset,\n  input [7:0] data_in,\n  input [31:0] data_len,\n  output reg [15:0] checksum,\n  output reg valid\n);\n\n  // Define constants\n  parameter PRIME = 65521;\n  parameter BLOCK_SIZE = 16;\n\n  // Define state machine states\n  localparam IDLE = 0;\n  localparam PROCESSING = 1;\n  localparam CHECKSUM = 2;\n\n  // Define state machine variables\n  reg [31:0] byte_count;\n  reg [15:0] rolling_sum;\n  reg [15:0] block_sum;\n  reg [1:0] state;\n\n  // Define internal signals\n  reg [7:0] data_in_reg;\n  reg [15:0] checksum_reg;\n\n  // Register input data on clock edge\n  always @(posedge clk) begin\n    if (reset) begin\n      data_in_reg <= 0;\n    end else begin\n      data_in_reg <= data_in;\n    end\n  end\n\n  // State machine\n  always @(posedge clk) begin\n    if (reset) begin\n      state <= IDLE;\n      byte_count <= 0;\n      rolling_sum <= 1;\n      block_sum <= 0;\n      checksum <= 0;\n      valid <= 0;\n    end else begin\n      case (state)\n        IDLE: begin\n          // Wait for data to be valid\n          if (data_len > 0) begin\n            state <= PROCESSING;\n          end\n        end\n        PROCESSING: begin\n          // Add byte to rolling sum\n          rolling_sum <= (rolling_sum + data_in_reg) % PRIME;\n          block_sum <= (block_sum + data_in_reg) % PRIME;\n          byte_count <= byte_count + 1;\n\n          // Check if block is complete\n          if (byte_count == BLOCK_SIZE || byte_count == data_len) begin\n            state <= CHECKSUM;\n          end\n        end\n        CHECKSUM: begin\n          // Calculate final checksum\n          checksum_reg <= (block_sum << 16) + rolling_sum;\n          if (checksum_reg == checksum) begin\n            valid <= 1;\n          end else begin\n            valid <= 0;\n          end\n\n          // Reset state machine\n          byte_count <= 0;\n          rolling_sum <= 1;\n          block_sum <= 0;\n          checksum <= checksum_reg;\n          state <= IDLE;\n        end\n      endcase\n    end\n  end\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "adder16_c9bc0e02", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule adder16(\n    input [15:0] a,\n    input [15:0] b,\n    input cin,\n    output [15:0] sum,\n    output cout\n);\n\n    wire [15:0] carry;\n    \n    assign carry[0] = cin;\n    genvar i;\n    generate\n        for (i = 1; i < 16; i = i + 1) begin\n            full_adder fa(\n                .a(a[i]),\n                .b(b[i]),\n                .cin(carry[i-1]),\n                .sum(sum[i]),\n                .cout(carry[i])\n            );\n        end\n    endgenerate\n    \n    assign sum[0] = a[0] ^ b[0] ^ cin;\n    assign cout = carry[15];\n    \nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n    \nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "rw_manager_lfsr36_08b57ba8", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\n\nmodule rw_manager_lfsr36(\n\tclk, \n\tnrst, \n\tena, \n\tword\n);\n\n\tinput clk;\n\tinput nrst;\n\tinput ena;\n\toutput reg [35:0] word;\n\n\talways @(posedge clk or negedge nrst) begin\n\t\tif(~nrst) begin\n\t\t\tword <= 36'hF0F0AA55;\n\t\tend\n\t\telse if(ena) begin\n\t\t\tword[35] <= word[0];\n\t\t\tword[34] <= word[35];\n\t\t\tword[33] <= word[34];\n\t\t\tword[32] <= word[33];\n\t\t\tword[31] <= word[32];\n\t\t\tword[30] <= word[31];\n\t\t\tword[29] <= word[30];\n\t\t\tword[28] <= word[29];\n\t\t\tword[27] <= word[28];\n\t\t\tword[26] <= word[27];\n\t\t\tword[25] <= word[26];\n\t\t\tword[24] <= word[25] ^ word[0];\n\t\t\tword[23] <= word[24];\n\t\t\tword[22] <= word[23];\n\t\t\tword[21] <= word[22];\n\t\t\tword[20] <= word[21];\n\t\t\tword[19] <= word[20];\n\t\t\tword[18] <= word[19];\n\t\t\tword[17] <= word[18];\n\t\t\tword[16] <= word[17];\n\t\t\tword[15] <= word[16];\n\t\t\tword[14] <= word[15];\n\t\t\tword[13] <= word[14];\n\t\t\tword[12] <= word[13];\n\t\t\tword[11] <= word[12];\n\t\t\tword[10] <= word[11];\n\t\t\tword[9] <= word[10];\n\t\t\tword[8] <= word[9];\n\t\t\tword[7] <= word[8];\n\t\t\tword[6] <= word[7];\n\t\t\tword[5] <= word[6];\n\t\t\tword[4] <= word[5];\n\t\t\tword[3] <= word[4];\n\t\t\tword[2] <= word[3];\n\t\t\tword[1] <= word[2];\n\t\t\tword[0] <= word[1];\n\t\tend\n\tend\n\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "johnson_counter_de568d38", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule johnson_counter (\n    input wire clk,\n    input wire rst_n,\n    output reg [7:0] out_vec\n);\n\nreg [7:0] state;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (~rst_n) begin\n        state <= 8'b00000000;\n    end else begin\n        state <= {state[6:0], state[7]};\n    end\nend\n\nalways @* begin\n    case(state)\n        8'b00000000: out_vec = 8'b00000000;\n        8'b10000000: out_vec = 8'b10000000;\n        8'b11000000: out_vec = 8'b11000000;\n        8'b11100000: out_vec = 8'b11100000;\n        8'b11110000: out_vec = 8'b11110000;\n        8'b01111000: out_vec = 8'b01111000;\n        8'b00111100: out_vec = 8'b00111100;\n        8'b00011110: out_vec = 8'b00011110;\n        8'b00001111: out_vec = 8'b00001111;\n        default: out_vec = 8'b00000000;\n    endcase\nend\n\nendmodule\nmodule binary_number_module (\n    input wire [3:0] in_vec,\n    output reg [3:0] out_vec,\n    output reg msb_out,\n    output reg mid_out,\n    output reg lsb_out\n);\n\nwire [3:0] temp_vec;\n\nassign temp_vec = in_vec;\n\nalways @* begin\n    out_vec = temp_vec;\n    msb_out = temp_vec[3];\n    mid_out = temp_vec[2];\n    lsb_out = temp_vec[1];\nend\n\nendmodule\nmodule functional_module (\n    input wire [7:0] in_vec_1,\n    input wire [3:0] in_vec_2,\n    output reg [7:0] out_vec\n);\n\nalways @* begin\n    out_vec = in_vec_1 | {4'b0000, in_vec_2};\nend\n\nendmodule\nmodule top_module ( \n    input wire clk, \n    input wire rst_n, \n    input wire [3:0] in_vec, \n    output wire [7:0] out_vec, \n    output wire msb_out, \n    output wire mid_out, \n    output wire lsb_out \n);\n\nwire [7:0] jc_out;\nwire [3:0] bn_out;\nwire bn_msb_out;\nwire bn_mid_out;\nwire bn_lsb_out;\n\njohnson_counter jc_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .out_vec(jc_out)\n);\n\nbinary_number_module bn_inst (\n    .in_vec(in_vec),\n    .out_vec(bn_out),\n    .msb_out(bn_msb_out),\n    .mid_out(bn_mid_out),\n    .lsb_out(bn_lsb_out)\n);\n\nfunctional_module fm_inst (\n    .in_vec_1(jc_out),\n    .in_vec_2(bn_out),\n    .out_vec(out_vec)\n);\n\nassign msb_out = bn_msb_out;\nassign mid_out = bn_mid_out;\nassign lsb_out = bn_lsb_out;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "shift_register_f795ea84", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\nmodule shift_register (\n    input        clk,\n    input        reset,\n    input  [7:0] data_in,\n    output [7:0] data_out\n);\n\n    reg [7:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 8'b0;\n        end else begin\n            shift_reg <= {shift_reg[6:0], data_in};\n        end\n    end\n\n    assign data_out = shift_reg;\n\nendmodule"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
{"custom_id": "ham_15_11_decoder_a60860a0", "method": "POST", "url": "/v1/responses", "body": {"model": "gpt-5", "input": [{"role": "system", "content": "You are a verification engineer expert in SystemVerilog Assertions."}, {"role": "user", "content": "You are a verification engineer. \nGenerate SVA assertions for the following verilog module.\nMake sure it has full coverage and checks all important\nsignals and functions, but make sure it is also concise. We\nmostly care about quality over quantity and also mostly care\nabout SVA, not DUT or testbench code, the SVA is the most\nimportant part of what you generate.:\n\n\nmodule ham_15_11_decoder (c,q);\n\toutput [10:0] q;\n\treg [10:0] q;\n\t\n\t\n\tinput [14:0] c;\n\t\n\t\n\treg [3:0] pb;\n\treg [3:0] s;\n\treg [3:0] temp;\n\treg [14:0] inputs;\n\t\n\talways @(c or q)\n\tbegin\n\t\n\t\t\n\t\tpb[0]=c[2]^c[4]^c[6]^c[8]^c[10]^c[12]^c[14];\n\t\tpb[1]=c[2]^c[5]^c[6]^c[9]^c[10]^c[13]^c[14];\n\t\tpb[2]=c[4]^c[5]^c[6]^c[11]^c[12]^c[13]^c[14];\n\t\tpb[3]=c[8]^c[9]^c[10]^c[11]^c[12]^c[13]^c[14];\ns[0] = c[0]^pb[0];\n\t\ts[1] = c[1]^pb[1];\n\t\ts[2] = c[3]^pb[2];\n\t\ts[3] = c[7]^pb[3];\n\t\n\t\tinputs=c;\n\t\n\t\t\t\n\t\t\n\t\ttemp=s[0]*1;\n\t\ttemp=temp+s[1]*2;\n\t\ttemp=temp+s[2]*4;\n\t\ttemp=temp+s[3]*8-1;\n\t\tinputs[temp]=c[temp]^1;\n\t\t\n\t\t\n\t\tq[0]=inputs[2];\n\t\tq[1]=inputs[4];\n\t\tq[2]=inputs[5];\n\t\tq[3]=inputs[6];\n\t\tq[4]=inputs[8];\n\t\tq[5]=inputs[9];\n\t\tq[6]=inputs[10];\n\t\tq[7]=inputs[11];\n\t\tq[8]=inputs[12];\n\t\tq[9]=inputs[13];\n\t\tq[10]=inputs[14];\n\n\tend\n\t\n\t\nendmodule\n\n\n\n\n\n\n\n\nmodule ham_decoder (cc,qq);\n\tinput [14:0] cc;\n\toutput [10:0] qq;\n\tham_15_11_decoder hdec (cc,qq);\nendmodule\n"}], "reasoning": {"effort": "medium"}, "text": {"verbosity": "low"}}}
