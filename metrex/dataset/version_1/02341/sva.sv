// SVA checkers for the provided DUTs.
// Combinational modules are checked using an event clock generated by @*.
// Bind these checkers to the DUTs without modifying the RTL.

////////////////////////////////////////////////////////////
// bitwise_or_logical_or checker
////////////////////////////////////////////////////////////
module bitwise_or_logical_or_sva (
  input [2:0] a,
  input [2:0] b,
  input [2:0] out_or_bitwise,
  input       out_or_logical,
  input [5:0] out_not
);
  event comb_ev;
  always @* -> comb_ev;

  // Outputs must be fully determined when inputs are known
  assert property (@(comb_ev) !$isunknown({a,b}) |-> !$isunknown({out_or_bitwise,out_or_logical,out_not}));

  // Functional equivalence
  assert property (@(comb_ev) !$isunknown({a,b}) |-> (out_or_bitwise === (a | b)));
  assert property (@(comb_ev) !$isunknown({a,b}) |-> (out_or_logical === ((a!=3'b000) || (b!=3'b000))));
  assert property (@(comb_ev) !$isunknown({a,b}) |-> (out_not === ~{a,b}));

  // Cross-consistency: logical OR equals reduction of bitwise OR
  assert property (@(comb_ev) !$isunknown({a,b}) |-> (out_or_logical === (|out_or_bitwise)));

  // Basic covers
  cover property (@(comb_ev) a==3'b000 && b==3'b000 && out_or_logical==1'b0);
  cover property (@(comb_ev) a!=3'b000 && b==3'b000 && out_or_logical==1'b1);
  cover property (@(comb_ev) a==3'b000 && b!=3'b000 && out_or_logical==1'b1);
  cover property (@(comb_ev) a==3'b111 && b==3'b111 && out_or_bitwise==3'b111 && out_not==6'b000000);
endmodule

bind bitwise_or_logical_or bitwise_or_logical_or_sva bitwise_or_logical_or_sva_b (.*);

////////////////////////////////////////////////////////////
// and_or_xor checker
////////////////////////////////////////////////////////////
module and_or_xor_sva (
  input [99:0] in,
  input        out_and,
  input        out_or,
  input        out_xor
);
  event comb_ev;
  always @* -> comb_ev;

  function automatic bit pair_and_reduction (input [99:0] v);
    bit res; integer i; begin
      res = 1'b1;
      for (i=0; i<50; i++) res &= (v[i*2] & v[i*2+1]);
      return res;
    end
  endfunction

  function automatic bit pair_or_reduction (input [99:0] v);
    bit res; integer i; begin
      res = 1'b0;
      for (i=0; i<50; i++) res |= (v[i*2] | v[i*2+1]);
      return res;
    end
  endfunction

  function automatic bit adj_parity (input [99:0] v);
    bit res; integer i; begin
      res = 1'b0;
      for (i=0; i<99; i++) res ^= (v[i] ^ v[i+1]);
      return res;
    end
  endfunction

  // Outputs must be fully determined when inputs are known
  assert property (@(comb_ev) !$isunknown(in) |-> !$isunknown({out_and,out_or,out_xor}));

  // Functional checks against the spec
  assert property (@(comb_ev) !$isunknown(in) |-> (out_and === pair_and_reduction(in)));
  assert property (@(comb_ev) !$isunknown(in) |-> (out_or  === pair_or_reduction(in)));
  assert property (@(comb_ev) !$isunknown(in) |-> (out_xor === adj_parity(in)));

  // Mathematical identity of the XOR chain: parity collapses to in[0] ^ in[99]
  assert property (@(comb_ev) !$isunknown(in) |-> (out_xor === (in[0] ^ in[99])));

  // Sanity implications
  assert property (@(comb_ev) out_and |-> out_or);            // if all pairs AND to 1, at least one OR is 1
  assert property (@(comb_ev) out_and |-> (&in));             // out_and implies all inputs are 1
  assert property (@(comb_ev) !out_or |-> (in == '0));        // no pair had a 1 => all inputs are 0

  // Covers
  cover property (@(comb_ev) in=='0 && out_and==0 && out_or==0 && out_xor==0);
  cover property (@(comb_ev) &in    && out_and==1 && out_or==1);
  cover property (@(comb_ev) (in[0]^in[99])==0 && out_xor==0);
  cover property (@(comb_ev) (in[0]^in[99])==1 && out_xor==1);
endmodule

bind and_or_xor and_or_xor_sva and_or_xor_sva_b (.*);

////////////////////////////////////////////////////////////
// top_module checker (final_output relationship)
////////////////////////////////////////////////////////////
module top_module_sva (
  input [2:0] out_or_bitwise,
  input [2:0] final_output,
  input [2:0] a,
  input [2:0] b,
  input [99:0] in
);
  event comb_ev;
  // Trigger on any relevant input to this combinational path
  always @* -> comb_ev;

  // final_output equals doubling of out_or_bitwise (mod 3-bit)
  assert property (@(comb_ev) !$isunknown(out_or_bitwise) |-> (final_output === (out_or_bitwise + out_or_bitwise)));

  // Equivalent structural check: shift-left by 1 within 3 bits
  assert property (@(comb_ev) !$isunknown(out_or_bitwise) |-> (final_output === {out_or_bitwise[1:0],1'b0}));

  // final_output must be known when source is known
  assert property (@(comb_ev) !$isunknown(out_or_bitwise) |-> !$isunknown(final_output));

  // Coverage: exercise wrap and non-wrap cases
  cover property (@(comb_ev) out_or_bitwise==3'b100 && final_output==3'b000); // overflow drop
  cover property (@(comb_ev) out_or_bitwise==3'b011 && final_output==3'b110);
endmodule

bind top_module top_module_sva top_module_sva_b (.*);