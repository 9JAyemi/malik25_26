{"id": "00000", "version": "version_1", "verilog_file": "module.v", "sva_file": "properties.sv", "created_at": "2025-11-11T13:56:15.227133", "source": "preexisting_generated", "model_used": null, "module_name": "binary_counter", "original_dataset": null, "prompt_hash": null, "validation": {"syntax_check": true, "compiles_with_sv_linter": false, "num_assertions": 2}, "judging": {"status": "unjudged", "llm_scores": [], "aggregate_score": null, "accepted": null}, "verilog_code": "module binary_counter(\n  input clk,\n  input [3:0] reset,\n  input [3:0] enable,\n  output reg [3:0] count\n);\n\nalways @(posedge clk) begin\n  if (reset == 4'b1111) begin\n    count <= 4'b0000;\n  end else if (enable == 4'b1111) begin\n    count <= count + 1;\n    if (count == 4'b1111) begin\n      count <= 4'b0000;\n    end\n  end\nend\n\nendmodule", "sva_code": "// SVA for binary_counter\nmodule binary_counter_sva (\n  input logic        clk,\n  input logic [3:0]  reset,\n  input logic [3:0]  enable,\n  input logic [3:0]  count\n);\n\n  default clocking cb @(posedge clk); endclocking\n\n  // Sanity: no X/Z on key signals at sampling\n  assert property (!$isunknown({reset, enable, count})))\n    else $error(\"X/Z detected on reset/enable/count\");\n\n  // Single concise next-state functional check (reset has priority)\n  // Next count equals:\n  //   0                    if reset==4'hF\n  //   count+1 (no wrap)    if enable==4'hF and count!=4'hF\n  //   0                    if enable==4'hF and count==4'hF (wrap)\n  //   hold                 otherwise\n  property p_next_state;\n    $past(1'b1) |->\n      count ==\n        ( $past(reset)==4'hF ? 4'h0 :\n          ( $past(enable)==4'hF\n              ? ( $past(count)==4'hF ? 4'h0 : ($past(count)+4'h1) )\n              : $past(count) )\n        );\n  endproperty\n  assert property (p_next_state)\n    else $error(\"Next-state mismatch for count\");\n\n  // Coverage: reset behavior, increment, wrap, and hold\n  cover property (reset==4'hF); // reset seen\n  cover property ($past(1'b1) && $past(reset)==4'hF && count==4'h0); // reset effect\n  cover property ($past(1'b1) && $past(reset)!=4'hF && $past(enable)==4'hF &&\n                  count == ($past(count)+4'h1)); // increment\n  cover property ($past(1'b1) && $past(reset)!=4'hF && $past(enable)==4'hF &&\n                  $past(count)==4'hF && count==4'h0); // wrap-around\n  cover property ($past(1'b1) && $past(reset)!=4'hF && $past(enable)!=4'hF &&\n                  count==$past(count)); // hold when disabled\n\nendmodule\n\n// Bind example:\n// bind binary_counter binary_counter_sva sva(.clk(clk), .reset(reset), .enable(enable), .count(count));"}
{"id": "00001", "version": "version_1", "verilog_file": "module.v", "sva_file": "properties.sv", "created_at": "2025-11-11T13:56:15.228127", "source": "preexisting_generated", "model_used": null, "module_name": "binary_to_gray_converter", "original_dataset": null, "prompt_hash": null, "validation": {"syntax_check": true, "compiles_with_sv_linter": false, "num_assertions": 6}, "judging": {"status": "unjudged", "llm_scores": [], "aggregate_score": null, "accepted": null}, "verilog_code": "module binary_to_gray_converter (\n  input [2:0] binary,\n  output reg [2:0] gray\n);\n\n  always @(*) begin\n    gray[0] = binary[0] ^ binary[1];\n    gray[1] = binary[1] ^ binary[2];\n    gray[2] = binary[2];\n  end\n\nendmodule\n", "sva_code": "// SVA checker for binary_to_gray_converter\nmodule binary_to_gray_converter_sva (\n  input  logic [2:0] binary,\n  input  logic [2:0] gray\n);\n\n  // Event to sample on any combinational change\n  event comb_ev; always @* -> comb_ev;\n\n  // Expected mapping\n  let exp_gray = {binary[2], (binary[1]^binary[2]), (binary[0]^binary[1])};\n\n  // Functional correctness (concurrent, sampled on any change)\n  assert property (@comb_ev gray === exp_gray)\n    else $error(\"Gray mapping mismatch: bin=%b gray=%b exp=%b\", binary, gray, exp_gray);\n\n  // Bitwise checks (redundant but pinpoint issues)\n  assert property (@comb_ev gray[2] === binary[2])\n    else $error(\"gray[2]!=binary[2]\");\n  assert property (@comb_ev gray[1] === (binary[1]^binary[2]))\n    else $error(\"gray[1]!=b1^b2\");\n  assert property (@comb_ev gray[0] === (binary[0]^binary[1]))\n    else $error(\"gray[0]!=b0^b1\");\n\n  // 4-state behavior: known input must yield fully known output; any X/Z in input must reflect in output\n  assert property (@comb_ev (!$isunknown(binary)) |-> (!$isunknown(gray)))\n    else $error(\"Output has X/Z while input is fully known\");\n  assert property (@comb_ev $isunknown(binary) |-> $isunknown(gray))\n    else $error(\"X/Z in input did not propagate to output\");\n\n  // Coverage: hit all input/output pairs\n  cover property (@comb_ev (binary==3'b000 && gray==3'b000));\n  cover property (@comb_ev (binary==3'b001 && gray==3'b001));\n  cover property (@comb_ev (binary==3'b010 && gray==3'b011));\n  cover property (@comb_ev (binary==3'b011 && gray==3'b010));\n  cover property (@comb_ev (binary==3'b100 && gray==3'b110));\n  cover property (@comb_ev (binary==3'b101 && gray==3'b111));\n  cover property (@comb_ev (binary==3'b110 && gray==3'b101));\n  cover property (@comb_ev (binary==3'b111 && gray==3'b100));\n\n  // Coverage: all Gray codes seen\n  cover property (@comb_ev (gray inside {3'b000,3'b001,3'b011,3'b010,3'b110,3'b111,3'b101,3'b100}));\n\n  // Coverage: X/Z propagation observed\n  cover property (@comb_ev ($isunknown(binary) && $isunknown(gray)));\n\nendmodule\n\n// Bind into DUT\nbind binary_to_gray_converter binary_to_gray_converter_sva sva_i(.binary(binary), .gray(gray));"}
{"id": "00002", "version": "version_1", "verilog_file": "module.v", "sva_file": "properties.sv", "created_at": "2025-11-11T13:56:15.229276", "source": "preexisting_generated", "model_used": null, "module_name": "counter_4bit", "original_dataset": null, "prompt_hash": null, "validation": {"syntax_check": true, "compiles_with_sv_linter": false, "num_assertions": 11}, "judging": {"status": "unjudged", "llm_scores": [], "aggregate_score": null, "accepted": null}, "verilog_code": "module counter_4bit(\n  input clk,\n  input rst,\n  output reg [3:0] count\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else begin\n      count <= count + 1;\n    end\n  end\n\nendmodule", "sva_code": "// SVA for counter_4bit\n// Bind this module to the DUT instance/type as shown at the bottom.\n\nmodule counter_4bit_sva (\n  input logic       clk,\n  input logic       rst,\n  input logic [3:0] count\n);\n\n  default clocking cb @(posedge clk); endclocking\n\n  // Track when $past() is valid on the clock\n  logic past_valid;\n  initial past_valid = 1'b0;\n  always @(posedge clk) past_valid <= 1'b1;\n\n  // 1) No X/Z on sampled output\n  a_no_x: assert property ( !$isunknown(count) );\n\n  // 2) Asynchronous reset drives count to 0 immediately at rst posedge\n  //    (##0 moves sampling after the DUT's nonblocking updates)\n  a_async_immediate_zero: assert property (@(posedge rst) ##0 (! $isunknown(count) && count == 4'h0));\n\n  // 3) While rst is asserted at a clock edge, output must be 0\n  a_reset_holds_zero: assert property ( rst |-> count == 4'h0 );\n\n  // 4) If rst stays asserted across consecutive clocks, count remains stable at 0\n  a_reset_stable: assert property ( rst && $past(rst) |-> (count == 4'h0 && $stable(count)) );\n\n  // 5) Increment by 1 modulo 16 on every non-reset clock\n  a_inc_mod16: assert property (\n    disable iff (rst || !past_valid)\n    $unsigned(count) == ($unsigned($past(count)) + 1) % 16\n  );\n\n  // 6) Explicit rollover: F -> 0 on next non-reset clock\n  a_rollover: assert property (\n    disable iff (rst || !past_valid)\n    ($past(count) == 4'hF) |-> (count == 4'h0)\n  );\n\n  // 7) First non-reset cycle after deassertion produces 1 (since reset value is 0)\n  a_first_after_reset_is_one: assert property (\n    disable iff (!past_valid)\n    $past(rst) && !rst |-> count == 4'h1\n  );\n\n  // Coverage\n\n  // C1) See a reset followed by deassertion and first count of 1\n  c_reset_to_run: cover property ( $rose(rst) ##1 !rst ##1 (count == 4'h1) );\n\n  // C2) See a rollover event\n  c_rollover: cover property ( disable iff (rst || !past_valid) ($past(count) == 4'hF && count == 4'h0) );\n\n  // C3) See 16 consecutive valid increments (full-span run without reset)\n  sequence s_inc_mod16;\n    $unsigned(count) == ($unsigned($past(count)) + 1) % 16;\n  endsequence\n  c_16_steps: cover property ( disable iff (rst || !past_valid) s_inc_mod16 [*16] );\n\nendmodule\n\n// Bind to the DUT (type bind shown; instance bind also acceptable)\n// Ensure this is compiled after the DUT.\nbind counter_4bit counter_4bit_sva u_counter_4bit_sva (.clk(clk), .rst(rst), .count(count));"}
{"id": "00003", "version": "version_1", "verilog_file": "module.v", "sva_file": "properties.sv", "created_at": "2025-11-11T13:56:15.230618", "source": "preexisting_generated", "model_used": null, "module_name": "four_bit_adder", "original_dataset": null, "prompt_hash": null, "validation": {"syntax_check": true, "compiles_with_sv_linter": false, "num_assertions": 2}, "judging": {"status": "unjudged", "llm_scores": [], "aggregate_score": null, "accepted": null}, "verilog_code": "\nmodule four_bit_adder(\n  input [3:0] A,\n  input [3:0] B,\n  input Cin,\n  output [3:0] S,\n  output Cout\n);\n\nwire [3:0] xor1, xor2, xor3;\nwire and1, and2, and3, and4, or1, or2;\n\n// Calculate the XORs\nassign xor1 = A ^ B;\nassign xor2 = {A[1:0],1'b0} ^ {B[1:0],1'b0} ^ Cin;\nassign xor3 = {A[2:0],1'b0} ^ {B[2:0],1'b0} ^ {Cin,1'b0};\n\n// Calculate the ANDs\nassign and1 = A[0] & B[0];\nassign and2 = A[1] & B[1];\nassign and3 = A[2] & B[2];\nassign and4 = A[3] & B[3];\n\n// Calculate the ORs\nassign or1 = and1 | and2 | and3;\nassign or2 = and2 & and3 | and1 & and3 | and1 & and2;\n\n// Calculate the sum and carry-out\nassign S = {xor3[2:0], xor2[1:0], xor1[0]};\nassign Cout = or1 | or2;\n\nendmodule\n", "sva_code": "// SVA checker for four_bit_adder\n// Bind this module to the DUT and drive clk/rst_n from TB.\n\nmodule four_bit_adder_sva (\n  input  logic        clk,\n  input  logic        rst_n,\n  input  logic [3:0]  A,\n  input  logic [3:0]  B,\n  input  logic        Cin,\n  input  logic [3:0]  S,\n  input  logic        Cout\n);\n  default clocking cb @(posedge clk); endclocking\n  default disable iff (!rst_n);\n\n  // Golden 5-bit sum (includes carry-out bit)\n  let sum5 = ({1'b0,A} + {1'b0,B} + Cin);\n\n  // Functional correctness: packed {Cout,S} equals golden sum\n  property p_add_correct;\n    !$isunknown({A,B,Cin}) |-> (!$isunknown({S,Cout}) && {Cout,S} == sum5);\n  endproperty\n  assert property (p_add_correct)\n    else $error(\"four_bit_adder mismatch: A=%0h B=%0h Cin=%0b got {C,S}=%0h exp=%0h\",\n                A, B, Cin, {Cout,S}, sum5);\n\n  // Sanity: outputs must be 0/1 when inputs are 0/1\n  assert property ( !$isunknown({A,B,Cin}) |-> !$isunknown({S,Cout}) )\n    else $error(\"four_bit_adder X/Z on outputs with clean inputs\");\n\n  // Key functional covers (exercise edges, carry, extremes)\n  cover property (Cin == 0);\n  cover property (Cin == 1);\n  cover property (Cout == 0);\n  cover property (Cout == 1);\n\n  cover property (sum5 == 5'h00);  // 0+0+0\n  cover property (sum5 == 5'h10);  // carry-only case (e.g., 8+8+0)\n  cover property (sum5 == 5'h1F);  // 15+15+1\n\n  // Specific interesting vectors\n  cover property ({A,B,Cin} == {4'h0,4'h0,1'b0});\n  cover property ({A,B,Cin} == {4'hF,4'hF,1'b1});\n  // Full propagate through all bits (carry ripples from bit0 to Cout)\n  cover property (Cin==0 && (A[0]&B[0]) && (A[1]^B[1]) && (A[2]^B[2]) && (A[3]^B[3]) && Cout);\n\nendmodule\n\n// Example bind (put in TB):\n// bind four_bit_adder four_bit_adder_sva u_sva (.*);  // if clk,rst_n are in scope\n// or explicitly connect:\n// bind four_bit_adder four_bit_adder_sva u_sva (.clk(tb_clk), .rst_n(tb_rst_n),\n//                                               .A(A), .B(B), .Cin(Cin), .S(S), .Cout(Cout));"}
{"id": "00004", "version": "version_1", "verilog_file": "module.v", "sva_file": "properties.sv", "created_at": "2025-11-11T13:56:15.231816", "source": "preexisting_generated", "model_used": null, "module_name": "shift_left_2", "original_dataset": null, "prompt_hash": null, "validation": {"syntax_check": true, "compiles_with_sv_linter": false, "num_assertions": 7}, "judging": {"status": "unjudged", "llm_scores": [], "aggregate_score": null, "accepted": null}, "verilog_code": "module shift_left_2 (\n    input [3:0] A,\n    output [3:0] X\n);\n\n    wire [3:0] shifted_left;\n    \n    // Shift left by 2 bits using bitwise logic gates\n    assign shifted_left[3] = A[1] & A[0];\n    assign shifted_left[2] = A[0] & (~A[1]);\n    assign shifted_left[1] = (~A[2]) & (~A[1]);\n    assign shifted_left[0] = (~A[3]) & (~A[2]);\n    \n    // Assign output\n    assign X = shifted_left;\n    \nendmodule", "sva_code": "// SVA checker for shift_left_2\nmodule shift_left_2_sva (\n  input  logic       clk,\n  input  logic [3:0] A,\n  input  logic [3:0] X\n);\n  default clocking cb @(posedge clk); endclocking\n\n  // Functional equivalence (when inputs are known)\n  a_func: assert property (!$isunknown(A) |-> (X == {A[1:0], 2'b00} && !$isunknown(X)));\n\n  // Bit-level constraints (redundant but pinpoint failures)\n  a_low_zero: assert property (X[1:0] == 2'b00);\n  a_map3:     assert property (X[3] == A[1]);\n  a_map2:     assert property (X[2] == A[0]);\n\n  // Independence: upper input bits must not affect output\n  a_upper_indep: assert property ($stable(A[1:0]) && $changed(A[3:2]) |-> $stable(X));\n\n  // Toggle coupling: changes in A[1:0] reflect on X[3:2]\n  a_tog3: assert property ($changed(A[1]) |-> $changed(X[3]));\n  a_tog2: assert property ($changed(A[0]) |-> $changed(X[2]));\n\n  // Functional coverage: exercise all result classes\n  c_00: cover property (A[1:0]==2'b00 && X==4'b0000);\n  c_01: cover property (A[1:0]==2'b01 && X==4'b0100);\n  c_10: cover property (A[1:0]==2'b10 && X==4'b1000);\n  c_11: cover property (A[1:0]==2'b11 && X==4'b1100);\nendmodule\n\n// Example bind (hook clk to any free-running TB clock):\n// bind shift_left_2 shift_left_2_sva u_shift_left_2_sva (.clk(tb_clk), .A(A), .X(X));"}
{"id": "00005", "version": "version_1", "verilog_file": "module.v", "sva_file": "properties.sv", "created_at": "2025-11-11T13:56:15.232961", "source": "preexisting_generated", "model_used": null, "module_name": "top_", "original_dataset": null, "prompt_hash": null, "validation": {"syntax_check": true, "compiles_with_sv_linter": false, "num_assertions": 23}, "judging": {"status": "unjudged", "llm_scores": [], "aggregate_score": null, "accepted": null}, "verilog_code": "module top_module (\n    input clk,\n    input reset,  // Synchronous active-high reset\n    input [7:0] a,\n    input [7:0] b,\n    input [3:0] data,\n    input select,\n    output [7:0] s,\n    output overflow\n);\n\n    // Convert 2's complement numbers to sign-magnitude format\n    wire [7:0] a_mag = (a[7] == 1) ? {1'b0, ~a[6:0] + 1} : a;\n    wire [7:0] b_mag = (b[7] == 1) ? {1'b0, ~b[6:0] + 1} : b;\n\n    // Adder module\n    wire [8:0] adder_out;\n    wire adder_overflow;\n    carry_select_adder adder_inst (\n        .a(a_mag),\n        .b(b_mag),\n        .cin(1'b0),\n        .s(adder_out),\n        .cout(),\n        .overflow(adder_overflow)\n    );\n\n    // Shift register module\n    wire [3:0] shift_out;\n    shift_register shift_inst (\n        .clk(clk),\n        .reset(reset),\n        .data(data),\n        .enable(1'b1),\n        .load(1'b0),\n        .shift_left(select),\n        .q(shift_out)\n    );\n\n    // Output selection logic\n    assign s = (select == 1'b0) ? adder_out[7:0] : {4'b0, shift_out};\n    assign overflow = adder_overflow;\n\nendmodule\n\n// 8-bit carry-select adder module\nmodule carry_select_adder (\n    input [7:0] a,\n    input [7:0] b,\n    input cin,\n    output [8:0] s,\n    output cout,\n    output overflow\n);\n\n    wire [7:0] p = a + b;\n    wire [7:0] g = a & b;\n    wire [7:0] u = p + (g << 1);\n    wire [7:0] v = p - (g << 1);\n\n    assign s = (cin == 1'b0) ? u : v;\n    assign cout = (g[6] | (g[5] & cin));\n    assign overflow = (a[7] == b[7] && s[7] != a[7]);\n\nendmodule\n\n// 4-bit shift register module\nmodule shift_register (\n    input clk,\n    input reset,  // Asynchronous active-high reset\n    input [3:0] data,\n    input enable,\n    input load,\n    input shift_left,\n    output [3:0] q\n);\n\n    reg [3:0] q_reg;\n\n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            q_reg <= 4'b0;\n        end else if (enable) begin\n            if (load) begin\n                q_reg <= data;\n            end else if (shift_left) begin\n                q_reg <= {q_reg[2:0], 1'b0};\n            end else begin\n                q_reg <= {1'b0, q_reg[3:1]};\n            end\n        end\n    end\n\n    assign q = q_reg;\n\nendmodule", "sva_code": "// SVA for this design. Bind these to the DUT files.\n\n// Top-level checks\nmodule top_module_sva;\n  default clocking cb @(posedge clk); endclocking\n\n  // Sign-magnitude conversion checks\n  a_mag_pos: assert property (a[7]==0 |-> a_mag == a);\n  a_mag_neg: assert property (a[7]==1 |-> (a_mag[7]==0 && a_mag[6:0] == (~a[6:0] + 1)));\n\n  b_mag_pos: assert property (b[7]==0 |-> b_mag == b);\n  b_mag_neg: assert property (b[7]==1 |-> (b_mag[7]==0 && b_mag[6:0] == (~b[6:0] + 1)));\n\n  // Output selection and tie-offs\n  cin_tied_low: assert property (adder_inst.cin == 1'b0);\n  ovf_wire:     assert property (overflow == adder_overflow);\n  sel_add:      assert property (select==0 |-> s == adder_out[7:0]);\n  sel_shift:    assert property (select==1 |-> (s == {4'b0, shift_out} && s[7:4]==4'b0));\n\n  // Shift register interface constants from top\n  en_const:   assert property (shift_inst.enable == 1'b1);\n  load_const: assert property (shift_inst.load   == 1'b0);\n\n  // Shift behavior (active-low reset from shift_register)\n  left_shift:  assert property (disable iff (!reset)  select && shift_inst.enable && !shift_inst.load |=> shift_out == {$past(shift_out)[2:0],1'b0});\n  right_shift: assert property (disable iff (!reset) !select && shift_inst.enable && !shift_inst.load |=> shift_out == {1'b0,$past(shift_out)[3:1]});\n  hold_in_reset: assert property (@(posedge clk) !reset |-> shift_out == 4'b0);\n\n  // Basic functional coverage\n  cover_sel_01: cover property (select==0 ##1 select==1);\n  cover_sel_10: cover property (select==1 ##1 select==0);\n  cover_ovf:    cover property (overflow);\n  cover_a_neg:  cover property (a[7]);\n  cover_b_neg:  cover property (b[7]);\nendmodule\n\n// Adder-local checks (combinational)\nmodule carry_select_adder_sva;\n  // Core relation (using recomputed p/g to avoid hierarchy to internal wires)\n  always @* begin\n    assert ((cin==1'b0 && s == ((a+b) + ((a&b)<<1))) ||\n            (cin==1'b1 && s == ((a+b) - ((a&b)<<1))))\n      else $error(\"carry_select_adder: s mismatch\");\n    assert (cout == (((a&b)[6]) | ((a&b)[5] & cin)))\n      else $error(\"carry_select_adder: cout mismatch\");\n    assert (overflow == ((a[7]==b[7]) && (s[7] != a[7])))\n      else $error(\"carry_select_adder: overflow mismatch\");\n    assert (s[8] == 1'b0) // zero-extended assignment to 9-bit s\n      else $error(\"carry_select_adder: s[8] not zero\");\n  end\n\n  // Minimal coverage\n  cover_cin0: cover property (@(posedge $root.top_module.clk) cin==0);\n  cover_cin1: cover property (@(posedge $root.top_module.clk) cin==1);\n  cover_ovf:  cover property (@(posedge $root.top_module.clk) overflow);\nendmodule\n\n// Shift-register-local checks\nmodule shift_register_sva;\n  default clocking cb @(posedge clk); endclocking\n\n  // Asynchronous active-low reset behavior\n  async_reset_clears: assert property (@(negedge reset) ##[0:1] q == 4'b0);\n  while_in_reset:     assert property (!reset |-> q == 4'b0);\n\n  // One-cycle next-state behavior\n  hold_when_disabled:       assert property (disable iff (!reset) !enable |=> q == $past(q));\n  load_when_enabled:        assert property (disable iff (!reset)  enable && load |=> q == $past(data));\n  shift_left_when_enabled:  assert property (disable iff (!reset)  enable && !load && shift_left |=> q == {$past(q)[2:0],1'b0});\n  shift_right_when_enabled: assert property (disable iff (!reset)  enable && !load && !shift_left |=> q == {1'b0,$past(q)[3:1]});\n\n  // Coverage of key modes\n  cover_load:  cover property (disable iff (!reset) enable && load);\n  cover_lsh:   cover property (disable iff (!reset) enable && !load && shift_left);\n  cover_rsh:   cover property (disable iff (!reset) enable && !load && !shift_left);\n  cover_arst:  cover property (@(negedge reset) 1);\nendmodule\n\n// Binds\nbind top_module         top_module_sva        top_module_sva_i();\nbind carry_select_adder carry_select_adder_sva csa_sva_i();\nbind shift_register     shift_register_sva     sh_sva_i();"}
