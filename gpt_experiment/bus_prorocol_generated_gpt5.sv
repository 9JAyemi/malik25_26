// ------------------------------------------------------------
// Handshake checker for bus_protocol.sv (generated by GPT-5 using online version)
// ------------------------------------------------------------
module bus_protocol_chk #(
  parameter int unsigned MAX_LATENCY = 5  // bound for ack after valid
)(
  input  logic        clk,
  input  logic        reset,     // active-high sync/async as you prefer
  input  logic        dValid,
  input  logic        dAck,
  input  logic [7:0]  data
);

  // Default clocking / reset guard
  default clocking cb @(posedge clk); endclocking
  // Change to "disable iff (reset)" if your reset is synchronous
  `define DISABLE_RST disable iff (reset)

  // --------------------------
  // Sequences
  // --------------------------
  sequence s_waiting_for_ack;
    dValid && !dAck;
  endsequence

  sequence s_handshake;
    $rose(dValid) ##[1:$] dAck;
  endsequence

  // --------------------------
  // Assertions
  // --------------------------

  // A1: No spurious ack â€” ack implies valid high in the same cycle
  ap_ack_implies_valid: assert property (@cb `DISABLE_RST
    dAck |-> dValid
  ) else $error("ACK asserted when VALID is low.");

  // A2: VALID must remain asserted until ACK arrives
  ap_valid_until_ack: assert property (@cb `DISABLE_RST
    $rose(dValid) |-> dValid until_with dAck
  ) else $error("VALID deasserted before ACK.");

  // A3: DATA must remain stable while waiting for ACK
  ap_data_stable_wait: assert property (@cb `DISABLE_RST
    $rose(dValid) |-> $stable(data) until_with dAck
  ) else $error("DATA changed before ACK while VALID was high.");

  // A4: DATA must not be X/Z when VALID is high
  ap_no_xz_data_when_valid: assert property (@cb `DISABLE_RST
    dValid |-> !$isunknown(data)
  ) else $error("DATA has X/Z while VALID is high.");

  // A5: ACK must arrive within MAX_LATENCY cycles after VALID rises
  ap_ack_within_bound: assert property (@cb `DISABLE_RST
    $rose(dValid) |-> ##[1:MAX_LATENCY] dAck
  ) else $error("ACK
